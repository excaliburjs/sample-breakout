{"mappings":"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A,AAAA,SAAA,gBACA,CAAG,MAAH,EAAA,CACA,GAAA,AAAA,UAAA,OAAA,OAAA,OAAA,MACA,CACA,ICPA,EAAA,EAAA,CAAA,EAAA,IAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GCCA,EAAA,EAAA,AAAA,IACA,aAAA,OAAA,QAAA,OAAA,aACA,OAAA,eAAA,EAAA,OAAA,YAAA,CAAuD,MAAA,QAAA,GAEvD,OAAA,eAAA,EAAA,aAAA,CAAgD,MAAA,CAAA,CAAA,EAChD,E,I,E,C,E,A,C,K,E,E,E,C,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,G,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,G,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,E,I,I,E,I,I,E,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,G,I,I,E,I,I,E,I,I,E,I,I,G,I,I,E,I,I,E,I,I,E,I,I,G,I,I,C,G,IOFY,EECA,EIDA,EIYA,EMZA,EsCSA,EgBVA,EEUA,EAWA,EAOA,EC5BA,E0BiBA,EYjBA,EgBMA,EA0BA,EA4BA,EAoCA,EASA,ESfA,EErFA,EaQA,EAWA,EGTA,EShBA,EMEA,ECGA,ECmTA,EAsEA,EM/XA,ECEA,ECAA,ECAA,EK8CA,E,E,C,E,E,E,G,E,E,E,C,c,I,G,kB,I,G,wB,I,G,uB,I,G,oB,I,G,gB,I,G,kB,I,G,gB,I,G,kB,I,G,mB,I,G,W,I,E,iB,I,G,kB,I,G,U,I,G,e,I,G,c,I,G,iB,I,G,mB,I,G,oB,I,G,uB,I,G,Y,I,G,gB,I,G,U,I,G,mB,I,G,mB,I,G,c,I,G,e,I,G,c,I,G,gB,I,G,kB,I,G,kB,I,G,a,I,G,c,I,G,a,I,G,e,I,G,a,I,E,G,I,E,C,E,E,E,G,E,E,E,C,0B,I,G,wB,I,G,mB,I,E,G,I,E,C,E,E,E,G,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AA,WAAa,IAAI,EACa,CAEtC,IAAW,OAAX,CACE,OAAO,IAAI,CAAC,MACd,CAEA,IAAW,SAAX,CACE,OAAO,IAAI,CAAC,WAAW,MACzB,CAEO,MAAM,OAAN,QACL,AAAI,AAAgB,IAAhB,IAAI,CAAC,QACP,IAAI,CAAC,SACE,QAAQ,WAEV,IAAI,CAAC,WAAW,SACzB,CAEO,KAAK,EAAgB,CAAC,CAAtB,CACL,GAAI,AAAU,IAAV,GAGJ,KAAO,AAAU,IAAV,GAAe,AAA2B,IAA3B,IAAI,CAAC,WAAW,QACpC,IAAI,CAAC,WAAW,QAAQ,MACxB,GAEF,CAAA,IAAI,CAAC,QAAU,EACjB,CACD,CCtDM,IAAM,GAAa,SAE1B,G,C,I,E,I,E,I,E,I,E,I,E,I,E,I,I,E,E,G,C,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,I,E,E,I,E,E,G,C,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,I,E,E,G,C,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,G,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,G,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,E,I,I,E,E,G,C,E,IpTCA,MAAM,EAAO,IAAI,EAAO,CACtB,MAAO,IACP,OAAQ,GACV,GAOM,EAAS,IAAI,EAAM,CACvB,EAAG,IACH,EAAG,EAAK,WAAa,GACrB,MAAO,IACP,OAAQ,GAGR,MAAO,AAAA,EAAM,UACf,EAIA,CAAA,EAAO,KAAK,cAAgB,AAAA,EAAc,MAI1C,EAAK,IAAI,GAKT,EAAK,MAAM,SAAS,QAAQ,GAAG,OAAQ,AAAC,IACtC,EAAO,IAAI,EAAI,EAAI,SAAS,CAC9B,GAKA,MAAM,EAAO,IAAI,EAAM,CACrB,EAAG,IACH,EAAG,IAEH,OAAQ,GAER,MAAO,AAAA,EAAM,GACf,GAEM,EAAY,AAAA,EAAI,IAAK,KAC3B,WAAW,KAET,EAAK,IAAM,CACb,EAAG,KAIH,EAAK,KAAK,cAAgB,AAAA,EAAc,QAOxC,EAAK,IAAI,GAKT,EAAK,GAAG,aAAc,KAGhB,EAAK,IAAI,EAAI,EAAK,MAAQ,GAC5B,CAAA,EAAK,IAAI,EAAI,EAAU,CAAA,EAKrB,EAAK,IAAI,EAAI,EAAK,MAAQ,EAAI,EAAK,WACrC,CAAA,EAAK,IAAI,EAAI,AAAc,GAAd,EAAU,CADzB,EAMI,EAAK,IAAI,EAAI,EAAK,OAAS,GAC7B,CAAA,EAAK,IAAI,EAAI,EAAU,CAAA,CAE3B,GAaA,MAAM,EAAa,CAAC,AAAA,EAAM,OAAQ,AAAA,EAAM,OAAQ,AAAA,EAAM,OAAO,CAGvD,EAAa,EAAK,UANR,EAHA,GASwC,EAElD,EAAkB,EAAE,CAC1B,IAAK,IAAI,EAAI,EAAG,EARH,EAQa,IACxB,IAAK,IAAI,EAAI,EAAG,EAVF,EAUe,IAC3B,EAAO,KACL,IAAI,EAAM,CACR,EAAG,AAfK,GAeK,EAAK,CAAA,EAhBV,EAgBuB,EAhBvB,GAiBR,EAAG,AAfK,GAeK,AAAK,GAAL,EAjBL,GAkBR,MAAO,EACP,OATY,GAUZ,MAAO,CAAU,CAAC,EAAI,EAAW,OAAO,AAC1C,IAKN,EAAO,QAAQ,SAAU,CAAK,EAE5B,EAAM,KAAK,cAAgB,AAAA,EAAc,OAGzC,EAAK,IAAI,EACX,GAKA,IAAI,EAAY,CAAA,EAChB,EAAK,GAAG,iBAAkB,SAAU,CAAE,EAChC,EAAO,QAAQ,EAAG,OAAS,IAG7B,EAAG,MAAM,OAOX,IAAI,EAAe,EAAG,QAAQ,IAAI,YAI7B,IACH,EAAY,CAAA,EAER,KAAK,IAAI,EAAa,GAAK,KAAK,IAAI,EAAa,GACnD,EAAK,IAAI,GAAK,GAEd,EAAK,IAAI,GAAK,GAGpB,GAEA,EAAK,GAAG,eAAgB,KAEtB,EAAY,CAAA,CACd,GAMA,EAAK,GAAG,eAAgB,KACtB,MAAM,YACR,GAKA,EAAK","sources":["<anon>","src/main.ts","node_modules/excalibur/build/esm/excalibur.js","node_modules/excalibur/build/node_modules/core-js/es/array/sort.js","node_modules/excalibur/build/node_modules/core-js/es/object/keys.js","node_modules/excalibur/build/node_modules/core-js/internals/a-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/an-object.js","node_modules/excalibur/build/node_modules/core-js/internals/array-includes.js","node_modules/excalibur/build/node_modules/core-js/internals/array-method-is-strict.js","node_modules/excalibur/build/node_modules/core-js/internals/array-slice-simple.js","node_modules/excalibur/build/node_modules/core-js/internals/array-sort.js","node_modules/excalibur/build/node_modules/core-js/internals/classof-raw.js","node_modules/excalibur/build/node_modules/core-js/internals/classof.js","node_modules/excalibur/build/node_modules/core-js/internals/copy-constructor-properties.js","node_modules/excalibur/build/node_modules/core-js/internals/create-non-enumerable-property.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property.js","node_modules/excalibur/build/node_modules/core-js/internals/define-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/define-global-property.js","node_modules/excalibur/build/node_modules/core-js/internals/delete-property-or-throw.js","node_modules/excalibur/build/node_modules/core-js/internals/descriptors.js","node_modules/excalibur/build/node_modules/core-js/internals/document-create-element.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-ff-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-is-ie-or-edge.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-user-agent.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-v8-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-webkit-version.js","node_modules/excalibur/build/node_modules/core-js/internals/entry-unbind.js","node_modules/excalibur/build/node_modules/core-js/internals/enum-bug-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/export.js","node_modules/excalibur/build/node_modules/core-js/internals/fails.js","node_modules/excalibur/build/node_modules/core-js/internals/function-bind-native.js","node_modules/excalibur/build/node_modules/core-js/internals/function-call.js","node_modules/excalibur/build/node_modules/core-js/internals/function-name.js","node_modules/excalibur/build/node_modules/core-js/internals/function-uncurry-this.js","node_modules/excalibur/build/node_modules/core-js/internals/get-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/get-method.js","node_modules/excalibur/build/node_modules/core-js/internals/global.js","node_modules/excalibur/build/node_modules/core-js/internals/has-own-property.js","node_modules/excalibur/build/node_modules/core-js/internals/hidden-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/ie8-dom-define.js","node_modules/excalibur/build/node_modules/core-js/internals/indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/inspect-source.js","node_modules/excalibur/build/node_modules/core-js/internals/internal-state.js","node_modules/excalibur/build/node_modules/core-js/internals/is-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/is-forced.js","node_modules/excalibur/build/node_modules/core-js/internals/is-object.js","node_modules/excalibur/build/node_modules/core-js/internals/is-pure.js","node_modules/excalibur/build/node_modules/core-js/internals/is-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/length-of-array-like.js","node_modules/excalibur/build/node_modules/core-js/internals/make-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/math-trunc.js","node_modules/excalibur/build/node_modules/core-js/internals/native-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/native-weak-map.js","node_modules/excalibur/build/node_modules/core-js/internals/object-define-property.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-names.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-symbols.js","node_modules/excalibur/build/node_modules/core-js/internals/object-is-prototype-of.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys-internal.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/object-property-is-enumerable.js","node_modules/excalibur/build/node_modules/core-js/internals/ordinary-to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/own-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/path.js","node_modules/excalibur/build/node_modules/core-js/internals/require-object-coercible.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-key.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-store.js","node_modules/excalibur/build/node_modules/core-js/internals/shared.js","node_modules/excalibur/build/node_modules/core-js/internals/to-absolute-index.js","node_modules/excalibur/build/node_modules/core-js/internals/to-indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-integer-or-infinity.js","node_modules/excalibur/build/node_modules/core-js/internals/to-length.js","node_modules/excalibur/build/node_modules/core-js/internals/to-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/to-property-key.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string-tag-support.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/try-to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/uid.js","node_modules/excalibur/build/node_modules/core-js/internals/use-symbol-as-uid.js","node_modules/excalibur/build/node_modules/core-js/internals/v8-prototype-define-bug.js","node_modules/excalibur/build/node_modules/core-js/internals/well-known-symbol.js","node_modules/excalibur/build/node_modules/core-js/modules/es.array.sort.js","node_modules/excalibur/build/node_modules/core-js/modules/es.object.keys.js","node_modules/excalibur/build/esm/webpack:/Loader.css","node_modules/excalibur/build/esm/webpack:/Util/Toaster.css","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/api.js","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/sourceMaps.js","node_modules/excalibur/build/esm/webpack:/webpack/bootstrap","node_modules/excalibur/build/esm/webpack:/webpack/runtime/compat get default export","node_modules/excalibur/build/esm/webpack:/webpack/runtime/define property getters","node_modules/excalibur/build/esm/webpack:/webpack/runtime/global","node_modules/excalibur/build/esm/webpack:/webpack/runtime/hasOwnProperty shorthand","node_modules/excalibur/build/esm/webpack:/webpack/runtime/make namespace object","node_modules/excalibur/build/esm/webpack:/Polyfill.ts","node_modules/excalibur/build/esm/webpack:/Flags.ts","node_modules/excalibur/build/esm/webpack:/Id.ts","node_modules/excalibur/build/esm/webpack:/Math/Random.ts","node_modules/excalibur/build/esm/webpack:/Math/util.ts","node_modules/excalibur/build/esm/webpack:/Math/vector.ts","node_modules/excalibur/build/esm/webpack:/Util/Log.ts","node_modules/excalibur/build/esm/webpack:/Color.ts","node_modules/excalibur/build/esm/webpack:/Collision/Side.ts","node_modules/excalibur/build/esm/webpack:/Collision/BoundingBox.ts","node_modules/excalibur/build/esm/webpack:/Util/Future.ts","node_modules/excalibur/build/esm/webpack:/Util/Util.ts","node_modules/excalibur/build/esm/webpack:/Math/matrix.ts","node_modules/excalibur/build/esm/webpack:/Math/affine-matrix.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/transform-stack.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/state-stack.ts","node_modules/excalibur/build/esm/webpack:/Events.ts","node_modules/excalibur/build/esm/webpack:/EventDispatcher.ts","node_modules/excalibur/build/esm/webpack:/Resources/Resource.ts","node_modules/excalibur/build/esm/webpack:/Util/Watch.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Graphic.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Sprite.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Filtering.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/texture-loader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ImageSource.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteSheet.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteFont.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-font.png","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-text.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/render-source.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/render-target.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-adapter.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer/line-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer/line-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-util.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/vertex-buffer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/vertex-layout.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsDiagnostics.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer/line-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-pass-painter.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/quad-index-buffer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/image-renderer/image-renderer.frag.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/image-renderer/image-renderer.vert.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/image-renderer/image-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/rectangle-renderer/rectangle-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/circle-renderer/circle-renderer.frag.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/circle-renderer/circle-renderer.vert.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/circle-renderer/circle-renderer.ts","node_modules/excalibur/build/esm/webpack:/Util/Pool.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/draw-call.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContextWebGL.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts","node_modules/excalibur/build/esm/webpack:/Screen.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/AudioContext.ts","node_modules/excalibur/build/esm/webpack:/Util/WebAudio.ts","node_modules/excalibur/build/esm/webpack:/Class.ts","node_modules/excalibur/build/esm/webpack:/Util/DrawUtil.ts","node_modules/excalibur/build/esm/webpack:/Loader.logo.png","node_modules/excalibur/build/esm/webpack:/Graphics/Raster.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Canvas.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/AudioImplementation.ts","node_modules/excalibur/build/esm/webpack:/Util/StateMachine.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/WebAudioInstance.ts","node_modules/excalibur/build/esm/webpack:/Events/MediaEvents.ts","node_modules/excalibur/build/esm/webpack:/Util/Sound.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/Sound.ts","node_modules/excalibur/build/esm/webpack:/Loader.ts","node_modules/excalibur/build/esm/webpack:/Util/Detector.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionType.ts","node_modules/excalibur/build/esm/webpack:/Util/Decorators.ts","node_modules/excalibur/build/esm/webpack:/Collision/Physics.ts","node_modules/excalibur/build/esm/webpack:/Math/coord-plane.ts","node_modules/excalibur/build/esm/webpack:/Math/vector-view.ts","node_modules/excalibur/build/esm/webpack:/Math/watch-vector.ts","node_modules/excalibur/build/esm/webpack:/Math/transform.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Component.ts","node_modules/excalibur/build/esm/webpack:/Util/Observable.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/TransformComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/MotionComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroup.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/Pair.ts","node_modules/excalibur/build/esm/webpack:/Math/projection.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTree.ts","node_modules/excalibur/build/esm/webpack:/Math/ray.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTreeCollisionProcessor.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Collider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CompositeCollider.ts","node_modules/excalibur/build/esm/webpack:/Math/line-segment.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/ClosestLineJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CircleCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/CollisionContact.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/SeparatingAxis.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CollisionJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/EdgeCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/PolygonCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Shape.ts","node_modules/excalibur/build/esm/webpack:/Collision/ColliderComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/BodyComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Entity.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Rectangle.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Circle.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerComponent.ts","node_modules/excalibur/build/esm/webpack:/Util/EasingFunctions.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionQueue.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Repeat.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RepeatForever.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/RotationType.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/CallMethod.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/EaseTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/EaseBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Blink.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Fade.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Delay.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Die.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Follow.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Meet.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionContext.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/FontCommon.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Font.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Text.ts","node_modules/excalibur/build/esm/webpack:/Actor.ts","node_modules/excalibur/build/esm/webpack:/ScreenElement.ts","node_modules/excalibur/build/esm/webpack:/Timer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ParallaxComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/DebugGraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/TileMap/TileMap.ts","node_modules/excalibur/build/esm/webpack:/Camera.ts","node_modules/excalibur/build/esm/webpack:/Trigger.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/System.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/EntityManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Util.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Query.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/QueryManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/SystemManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/World.ts","node_modules/excalibur/build/esm/webpack:/Collision/Integrator.ts","node_modules/excalibur/build/esm/webpack:/Collision/MotionSystem.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ArcadeSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ContactConstraintPoint.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/RealisticSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionSystem.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Animation.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsGroup.ts","node_modules/excalibur/build/esm/webpack:/Configurable.ts","node_modules/excalibur/build/esm/webpack:/Particles.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsSystem.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugSystem.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerSystem.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsSystem.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricEntityComponent.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricEntitySystem.ts","node_modules/excalibur/build/esm/webpack:/Graphics/OffscreenSystem.ts","node_modules/excalibur/build/esm/webpack:/Scene.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ColorBlindnessMode.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/color-blind-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ScreenShader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ColorBlindnessPostProcessor.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugFlags.ts","node_modules/excalibur/build/esm/webpack:/Debug/Debug.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerScope.ts","node_modules/excalibur/build/esm/webpack:/Input/Keyboard.ts","node_modules/excalibur/build/esm/webpack:/Input/Gamepad.ts","node_modules/excalibur/build/esm/webpack:/Util/Browser.ts","node_modules/excalibur/build/esm/webpack:/Math/global-coordinates.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEvent.ts","node_modules/excalibur/build/esm/webpack:/Input/WheelEvent.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerAbstraction.ts","node_modules/excalibur/build/esm/webpack:/Input/WheelDeltaMode.ts","node_modules/excalibur/build/esm/webpack:/Input/NativePointerButton.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerButton.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerType.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEventReceiver.ts","node_modules/excalibur/build/esm/webpack:/Util/Fps.ts","node_modules/excalibur/build/esm/webpack:/Util/Clock.ts","node_modules/excalibur/build/esm/webpack:/Util/Toaster.ts","node_modules/excalibur/build/esm/webpack:/Engine.ts","node_modules/excalibur/build/esm/webpack:/Math/Index.ts","node_modules/excalibur/build/esm/webpack:/Debug/index.ts","node_modules/excalibur/build/esm/webpack:/Label.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricMap.ts","node_modules/excalibur/build/esm/webpack:/TileMap/index.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ActionSequence.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ParallelActions.ts","node_modules/excalibur/build/esm/webpack:/Actions/Index.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroupManager.ts","node_modules/excalibur/build/esm/webpack:/Collision/Index.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/LifecycleEvents.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/Index.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/Index.ts","node_modules/excalibur/build/esm/webpack:/Resources/Gif.ts","node_modules/excalibur/build/esm/webpack:/Resources/Index.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/index.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Line.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Polygon.ts","node_modules/excalibur/build/esm/webpack:/Graphics/index.ts","node_modules/excalibur/build/esm/webpack:/Input/Index.ts","node_modules/excalibur/build/esm/webpack:/Util/Index.ts","node_modules/excalibur/build/esm/webpack:/Util/Semaphore.ts","node_modules/excalibur/build/esm/webpack:/index.ts"],"sourcesContent":["/*!\n * excalibur - 0.27.0 - 2022-7-8\n * https://github.com/excaliburjs/Excalibur\n * Copyright (c) 2022 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>\n * Licensed BSD-2-Clause\n * @preserve\n */ /******/ var $2c23f148d58cd887$var$__webpack_modules__ = {\n    /***/ 4662: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        __webpack_require__(3430);\n        var entryUnbind = __webpack_require__(8791);\n        module.exports = entryUnbind(\"Array\", \"sort\");\n    /***/ },\n    /***/ 8343: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        __webpack_require__(4769);\n        var path = __webpack_require__(9276);\n        module.exports = path.Object.keys;\n    /***/ },\n    /***/ 7111: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var isCallable = __webpack_require__(6733);\n        var tryToString = __webpack_require__(9821);\n        var $TypeError = TypeError;\n        // `Assert: IsCallable(argument) is true`\n        module.exports = function(argument) {\n            if (isCallable(argument)) return argument;\n            throw $TypeError(tryToString(argument) + \" is not a function\");\n        };\n    /***/ },\n    /***/ 1176: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var isObject = __webpack_require__(5052);\n        var $String = String;\n        var $TypeError = TypeError;\n        // `Assert: Type(argument) is Object`\n        module.exports = function(argument) {\n            if (isObject(argument)) return argument;\n            throw $TypeError($String(argument) + \" is not an object\");\n        };\n    /***/ },\n    /***/ 9540: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toIndexedObject = __webpack_require__(905);\n        var toAbsoluteIndex = __webpack_require__(3231);\n        var lengthOfArrayLike = __webpack_require__(9646);\n        // `Array.prototype.{ indexOf, includes }` methods implementation\n        var createMethod = function(IS_INCLUDES) {\n            return function($this, el, fromIndex) {\n                var O = toIndexedObject($this);\n                var length = lengthOfArrayLike(O);\n                var index = toAbsoluteIndex(fromIndex, length);\n                var value;\n                // Array#includes uses SameValueZero equality algorithm\n                // eslint-disable-next-line no-self-compare -- NaN check\n                if (IS_INCLUDES && el != el) while(length > index){\n                    value = O[index++];\n                    // eslint-disable-next-line no-self-compare -- NaN check\n                    if (value != value) return true;\n                // Array#indexOf ignores holes, Array#includes - not\n                }\n                else for(; length > index; index++){\n                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                }\n                return !IS_INCLUDES && -1;\n            };\n        };\n        module.exports = {\n            // `Array.prototype.includes` method\n            // https://tc39.es/ecma262/#sec-array.prototype.includes\n            includes: createMethod(true),\n            // `Array.prototype.indexOf` method\n            // https://tc39.es/ecma262/#sec-array.prototype.indexof\n            indexOf: createMethod(false)\n        };\n    /***/ },\n    /***/ 6038: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var fails = __webpack_require__(4229);\n        module.exports = function(METHOD_NAME, argument) {\n            var method = [][METHOD_NAME];\n            return !!method && fails(function() {\n                // eslint-disable-next-line no-useless-call -- required for testing\n                method.call(null, argument || function() {\n                    return 1;\n                }, 1);\n            });\n        };\n    /***/ },\n    /***/ 9794: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toAbsoluteIndex = __webpack_require__(3231);\n        var lengthOfArrayLike = __webpack_require__(9646);\n        var createProperty = __webpack_require__(2324);\n        var $Array = Array;\n        var max = Math.max;\n        module.exports = function(O, start, end) {\n            var length = lengthOfArrayLike(O);\n            var k = toAbsoluteIndex(start, length);\n            var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n            var result = $Array(max(fin - k, 0));\n            for(var n = 0; k < fin; k++, n++)createProperty(result, n, O[k]);\n            result.length = n;\n            return result;\n        };\n    /***/ },\n    /***/ 3867: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var arraySlice = __webpack_require__(9794);\n        var floor = Math.floor;\n        var mergeSort = function(array, comparefn) {\n            var length = array.length;\n            var middle = floor(length / 2);\n            return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);\n        };\n        var insertionSort = function(array, comparefn) {\n            var length = array.length;\n            var i = 1;\n            var element, j;\n            while(i < length){\n                j = i;\n                element = array[i];\n                while(j && comparefn(array[j - 1], element) > 0)array[j] = array[--j];\n                if (j !== i++) array[j] = element;\n            }\n            return array;\n        };\n        var merge = function(array, left, right, comparefn) {\n            var llength = left.length;\n            var rlength = right.length;\n            var lindex = 0;\n            var rindex = 0;\n            while(lindex < llength || rindex < rlength)array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];\n            return array;\n        };\n        module.exports = mergeSort;\n    /***/ },\n    /***/ 7079: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        var toString = uncurryThis({}.toString);\n        var stringSlice = uncurryThis(\"\".slice);\n        module.exports = function(it) {\n            return stringSlice(toString(it), 8, -1);\n        };\n    /***/ },\n    /***/ 1589: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var TO_STRING_TAG_SUPPORT = __webpack_require__(1601);\n        var isCallable = __webpack_require__(6733);\n        var classofRaw = __webpack_require__(7079);\n        var wellKnownSymbol = __webpack_require__(95);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $Object = Object;\n        // ES3 wrong here\n        var CORRECT_ARGUMENTS = classofRaw(function() {\n            return arguments;\n        }()) == \"Arguments\";\n        // fallback for IE11 Script Access Denied error\n        var tryGet = function(it, key) {\n            try {\n                return it[key];\n            } catch (error) {}\n        };\n        // getting tag from ES6+ `Object.prototype.toString`\n        module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n            var O, tag, result;\n            return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && isCallable(O.callee) ? \"Arguments\" : result;\n        };\n    /***/ },\n    /***/ 7081: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var hasOwn = __webpack_require__(8270);\n        var ownKeys = __webpack_require__(4826);\n        var getOwnPropertyDescriptorModule = __webpack_require__(7933);\n        var definePropertyModule = __webpack_require__(1787);\n        module.exports = function(target, source, exceptions) {\n            var keys = ownKeys(source);\n            var defineProperty = definePropertyModule.f;\n            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n            for(var i = 0; i < keys.length; i++){\n                var key = keys[i];\n                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n            }\n        };\n    /***/ },\n    /***/ 5762: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var DESCRIPTORS = __webpack_require__(7400);\n        var definePropertyModule = __webpack_require__(1787);\n        var createPropertyDescriptor = __webpack_require__(5358);\n        module.exports = DESCRIPTORS ? function(object, key, value) {\n            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n        } : function(object, key, value) {\n            object[key] = value;\n            return object;\n        };\n    /***/ },\n    /***/ 5358: /***/ (module)=>{\n        module.exports = function(bitmap, value) {\n            return {\n                enumerable: !(bitmap & 1),\n                configurable: !(bitmap & 2),\n                writable: !(bitmap & 4),\n                value: value\n            };\n        };\n    /***/ },\n    /***/ 2324: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toPropertyKey = __webpack_require__(9310);\n        var definePropertyModule = __webpack_require__(1787);\n        var createPropertyDescriptor = __webpack_require__(5358);\n        module.exports = function(object, key, value) {\n            var propertyKey = toPropertyKey(key);\n            if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n            else object[propertyKey] = value;\n        };\n    /***/ },\n    /***/ 4768: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var isCallable = __webpack_require__(6733);\n        var definePropertyModule = __webpack_require__(1787);\n        var makeBuiltIn = __webpack_require__(6039);\n        var defineGlobalProperty = __webpack_require__(8400);\n        module.exports = function(O, key, value, options) {\n            if (!options) options = {};\n            var simple = options.enumerable;\n            var name = options.name !== undefined ? options.name : key;\n            if (isCallable(value)) makeBuiltIn(value, name, options);\n            if (options.global) {\n                if (simple) O[key] = value;\n                else defineGlobalProperty(key, value);\n            } else {\n                try {\n                    if (!options.unsafe) delete O[key];\n                    else if (O[key]) simple = true;\n                } catch (error) {}\n                if (simple) O[key] = value;\n                else definePropertyModule.f(O, key, {\n                    value: value,\n                    enumerable: false,\n                    configurable: !options.nonConfigurable,\n                    writable: !options.nonWritable\n                });\n            }\n            return O;\n        };\n    /***/ },\n    /***/ 8400: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        // eslint-disable-next-line es-x/no-object-defineproperty -- safe\n        var defineProperty = Object.defineProperty;\n        module.exports = function(key, value) {\n            try {\n                defineProperty(global, key, {\n                    value: value,\n                    configurable: true,\n                    writable: true\n                });\n            } catch (error) {\n                global[key] = value;\n            }\n            return value;\n        };\n    /***/ },\n    /***/ 9563: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var tryToString = __webpack_require__(9821);\n        var $TypeError = TypeError;\n        module.exports = function(O, P) {\n            if (!delete O[P]) throw $TypeError(\"Cannot delete property \" + tryToString(P) + \" of \" + tryToString(O));\n        };\n    /***/ },\n    /***/ 7400: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var fails = __webpack_require__(4229);\n        // Detect IE8's incomplete defineProperty implementation\n        module.exports = !fails(function() {\n            // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n            return Object.defineProperty({}, 1, {\n                get: function() {\n                    return 7;\n                }\n            })[1] != 7;\n        });\n    /***/ },\n    /***/ 2635: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var isObject = __webpack_require__(5052);\n        var document1 = global.document;\n        // typeof document.createElement is 'object' in old IE\n        var EXISTS = isObject(document1) && isObject(document1.createElement);\n        module.exports = function(it) {\n            return EXISTS ? document1.createElement(it) : {};\n        };\n    /***/ },\n    /***/ 2671: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var userAgent = __webpack_require__(598);\n        var firefox = userAgent.match(/firefox\\/(\\d+)/i);\n        module.exports = !!firefox && +firefox[1];\n    /***/ },\n    /***/ 8506: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var UA = __webpack_require__(598);\n        module.exports = /MSIE|Trident/.test(UA);\n    /***/ },\n    /***/ 598: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var getBuiltIn = __webpack_require__(1333);\n        module.exports = getBuiltIn(\"navigator\", \"userAgent\") || \"\";\n    /***/ },\n    /***/ 6358: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var userAgent = __webpack_require__(598);\n        var process = global.process;\n        var Deno = global.Deno;\n        var versions = process && process.versions || Deno && Deno.version;\n        var v8 = versions && versions.v8;\n        var match, version;\n        if (v8) {\n            match = v8.split(\".\");\n            // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n            // but their correct versions are not interesting for us\n            version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n        }\n        // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n        // so check `userAgent` even if `.v8` exists, but 0\n        if (!version && userAgent) {\n            match = userAgent.match(/Edge\\/(\\d+)/);\n            if (!match || match[1] >= 74) {\n                match = userAgent.match(/Chrome\\/(\\d+)/);\n                if (match) version = +match[1];\n            }\n        }\n        module.exports = version;\n    /***/ },\n    /***/ 9811: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var userAgent = __webpack_require__(598);\n        var webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n        module.exports = !!webkit && +webkit[1];\n    /***/ },\n    /***/ 8791: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var uncurryThis = __webpack_require__(5968);\n        module.exports = function(CONSTRUCTOR, METHOD) {\n            return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);\n        };\n    /***/ },\n    /***/ 3837: /***/ (module)=>{\n        // IE8- don't enum bug keys\n        module.exports = [\n            \"constructor\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"toLocaleString\",\n            \"toString\",\n            \"valueOf\"\n        ];\n    /***/ },\n    /***/ 3103: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var getOwnPropertyDescriptor = __webpack_require__(7933).f;\n        var createNonEnumerableProperty = __webpack_require__(5762);\n        var defineBuiltIn = __webpack_require__(4768);\n        var defineGlobalProperty = __webpack_require__(8400);\n        var copyConstructorProperties = __webpack_require__(7081);\n        var isForced = __webpack_require__(6541);\n        /*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ module.exports = function(options, source) {\n            var TARGET = options.target;\n            var GLOBAL = options.global;\n            var STATIC = options.stat;\n            var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n            if (GLOBAL) target = global;\n            else if (STATIC) target = global[TARGET] || defineGlobalProperty(TARGET, {});\n            else target = (global[TARGET] || {}).prototype;\n            if (target) for(key in source){\n                sourceProperty = source[key];\n                if (options.dontCallGetSet) {\n                    descriptor = getOwnPropertyDescriptor(target, key);\n                    targetProperty = descriptor && descriptor.value;\n                } else targetProperty = target[key];\n                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                // contained in target\n                if (!FORCED && targetProperty !== undefined) {\n                    if (typeof sourceProperty == typeof targetProperty) continue;\n                    copyConstructorProperties(sourceProperty, targetProperty);\n                }\n                // add a flag to not completely full polyfills\n                if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                defineBuiltIn(target, key, sourceProperty, options);\n            }\n        };\n    /***/ },\n    /***/ 4229: /***/ (module)=>{\n        module.exports = function(exec) {\n            try {\n                return !!exec();\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 7188: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var fails = __webpack_require__(4229);\n        module.exports = !fails(function() {\n            // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n            var test = (function() {}).bind();\n            // eslint-disable-next-line no-prototype-builtins -- safe\n            return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n        });\n    /***/ },\n    /***/ 266: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var NATIVE_BIND = __webpack_require__(7188);\n        var call = Function.prototype.call;\n        module.exports = NATIVE_BIND ? call.bind(call) : function() {\n            return call.apply(call, arguments);\n        };\n    /***/ },\n    /***/ 1805: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var DESCRIPTORS = __webpack_require__(7400);\n        var hasOwn = __webpack_require__(8270);\n        var FunctionPrototype = Function.prototype;\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n        var EXISTS = hasOwn(FunctionPrototype, \"name\");\n        // additional protection from minified / mangled / dropped function names\n        var PROPER = EXISTS && (function something() {}).name === \"something\";\n        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, \"name\").configurable);\n        module.exports = {\n            EXISTS: EXISTS,\n            PROPER: PROPER,\n            CONFIGURABLE: CONFIGURABLE\n        };\n    /***/ },\n    /***/ 5968: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var NATIVE_BIND = __webpack_require__(7188);\n        var FunctionPrototype = Function.prototype;\n        var bind = FunctionPrototype.bind;\n        var call = FunctionPrototype.call;\n        var uncurryThis = NATIVE_BIND && bind.bind(call, call);\n        module.exports = NATIVE_BIND ? function(fn) {\n            return fn && uncurryThis(fn);\n        } : function(fn) {\n            return fn && function() {\n                return call.apply(fn, arguments);\n            };\n        };\n    /***/ },\n    /***/ 1333: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var isCallable = __webpack_require__(6733);\n        var aFunction = function(argument) {\n            return isCallable(argument) ? argument : undefined;\n        };\n        module.exports = function(namespace, method) {\n            return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n        };\n    /***/ },\n    /***/ 5300: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var aCallable = __webpack_require__(7111);\n        // `GetMethod` abstract operation\n        // https://tc39.es/ecma262/#sec-getmethod\n        module.exports = function(V, P) {\n            var func = V[P];\n            return func == null ? undefined : aCallable(func);\n        };\n    /***/ },\n    /***/ 9859: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var check = function(it) {\n            return it && it.Math == Math && it;\n        };\n        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n        module.exports = // eslint-disable-next-line es-x/no-global-this -- safe\n        check(typeof globalThis == \"object\" && globalThis) || check(typeof window == \"object\" && window) || // eslint-disable-next-line no-restricted-globals -- safe\n        check(typeof self == \"object\" && self) || check(typeof __webpack_require__.g == \"object\" && __webpack_require__.g) || // eslint-disable-next-line no-new-func -- fallback\n        function() {\n            return this;\n        }() || Function(\"return this\")();\n    /***/ },\n    /***/ 8270: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        var toObject = __webpack_require__(2991);\n        var hasOwnProperty = uncurryThis({}.hasOwnProperty);\n        // `HasOwnProperty` abstract operation\n        // https://tc39.es/ecma262/#sec-hasownproperty\n        // eslint-disable-next-line es-x/no-object-hasown -- safe\n        module.exports = Object.hasOwn || function hasOwn(it, key) {\n            return hasOwnProperty(toObject(it), key);\n        };\n    /***/ },\n    /***/ 5977: /***/ (module)=>{\n        module.exports = {};\n    /***/ },\n    /***/ 4394: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var DESCRIPTORS = __webpack_require__(7400);\n        var fails = __webpack_require__(4229);\n        var createElement = __webpack_require__(2635);\n        // Thanks to IE8 for its funny defineProperty\n        module.exports = !DESCRIPTORS && !fails(function() {\n            // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n            return Object.defineProperty(createElement(\"div\"), \"a\", {\n                get: function() {\n                    return 7;\n                }\n            }).a != 7;\n        });\n    /***/ },\n    /***/ 9337: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        var fails = __webpack_require__(4229);\n        var classof = __webpack_require__(7079);\n        var $Object = Object;\n        var split = uncurryThis(\"\".split);\n        // fallback for non-array-like ES3 and non-enumerable old V8 strings\n        module.exports = fails(function() {\n            // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n            // eslint-disable-next-line no-prototype-builtins -- safe\n            return !$Object(\"z\").propertyIsEnumerable(0);\n        }) ? function(it) {\n            return classof(it) == \"String\" ? split(it, \"\") : $Object(it);\n        } : $Object;\n    /***/ },\n    /***/ 8511: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        var isCallable = __webpack_require__(6733);\n        var store = __webpack_require__(5353);\n        var functionToString = uncurryThis(Function.toString);\n        // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n        if (!isCallable(store.inspectSource)) store.inspectSource = function(it) {\n            return functionToString(it);\n        };\n        module.exports = store.inspectSource;\n    /***/ },\n    /***/ 6407: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var NATIVE_WEAK_MAP = __webpack_require__(8694);\n        var global = __webpack_require__(9859);\n        var uncurryThis = __webpack_require__(5968);\n        var isObject = __webpack_require__(5052);\n        var createNonEnumerableProperty = __webpack_require__(5762);\n        var hasOwn = __webpack_require__(8270);\n        var shared = __webpack_require__(5353);\n        var sharedKey = __webpack_require__(4399);\n        var hiddenKeys = __webpack_require__(5977);\n        var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n        var TypeError1 = global.TypeError;\n        var WeakMap1 = global.WeakMap;\n        var set, get, has;\n        var enforce = function(it) {\n            return has(it) ? get(it) : set(it, {});\n        };\n        var getterFor = function(TYPE) {\n            return function(it) {\n                var state;\n                if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError1(\"Incompatible receiver, \" + TYPE + \" required\");\n                return state;\n            };\n        };\n        if (NATIVE_WEAK_MAP || shared.state) {\n            var store = shared.state || (shared.state = new WeakMap1());\n            var wmget = uncurryThis(store.get);\n            var wmhas = uncurryThis(store.has);\n            var wmset = uncurryThis(store.set);\n            set = function(it, metadata) {\n                if (wmhas(store, it)) throw new TypeError1(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                wmset(store, it, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return wmget(store, it) || {};\n            };\n            has = function(it) {\n                return wmhas(store, it);\n            };\n        } else {\n            var STATE = sharedKey(\"state\");\n            hiddenKeys[STATE] = true;\n            set = function(it, metadata) {\n                if (hasOwn(it, STATE)) throw new TypeError1(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                createNonEnumerableProperty(it, STATE, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return hasOwn(it, STATE) ? it[STATE] : {};\n            };\n            has = function(it) {\n                return hasOwn(it, STATE);\n            };\n        }\n        module.exports = {\n            set: set,\n            get: get,\n            has: has,\n            enforce: enforce,\n            getterFor: getterFor\n        };\n    /***/ },\n    /***/ 6733: /***/ (module)=>{\n        // `IsCallable` abstract operation\n        // https://tc39.es/ecma262/#sec-iscallable\n        module.exports = function(argument) {\n            return typeof argument == \"function\";\n        };\n    /***/ },\n    /***/ 6541: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var fails = __webpack_require__(4229);\n        var isCallable = __webpack_require__(6733);\n        var replacement = /#|\\.prototype\\./;\n        var isForced = function(feature, detection) {\n            var value = data[normalize(feature)];\n            return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;\n        };\n        var normalize = isForced.normalize = function(string) {\n            return String(string).replace(replacement, \".\").toLowerCase();\n        };\n        var data = isForced.data = {};\n        var NATIVE = isForced.NATIVE = \"N\";\n        var POLYFILL = isForced.POLYFILL = \"P\";\n        module.exports = isForced;\n    /***/ },\n    /***/ 5052: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var isCallable = __webpack_require__(6733);\n        module.exports = function(it) {\n            return typeof it == \"object\" ? it !== null : isCallable(it);\n        };\n    /***/ },\n    /***/ 4231: /***/ (module)=>{\n        module.exports = false;\n    /***/ },\n    /***/ 9395: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var getBuiltIn = __webpack_require__(1333);\n        var isCallable = __webpack_require__(6733);\n        var isPrototypeOf = __webpack_require__(1321);\n        var USE_SYMBOL_AS_UID = __webpack_require__(6969);\n        var $Object = Object;\n        module.exports = USE_SYMBOL_AS_UID ? function(it) {\n            return typeof it == \"symbol\";\n        } : function(it) {\n            var $Symbol = getBuiltIn(\"Symbol\");\n            return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n        };\n    /***/ },\n    /***/ 9646: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toLength = __webpack_require__(4237);\n        // `LengthOfArrayLike` abstract operation\n        // https://tc39.es/ecma262/#sec-lengthofarraylike\n        module.exports = function(obj) {\n            return toLength(obj.length);\n        };\n    /***/ },\n    /***/ 6039: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var fails = __webpack_require__(4229);\n        var isCallable = __webpack_require__(6733);\n        var hasOwn = __webpack_require__(8270);\n        var DESCRIPTORS = __webpack_require__(7400);\n        var CONFIGURABLE_FUNCTION_NAME = __webpack_require__(1805).CONFIGURABLE;\n        var inspectSource = __webpack_require__(8511);\n        var InternalStateModule = __webpack_require__(6407);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        // eslint-disable-next-line es-x/no-object-defineproperty -- safe\n        var defineProperty = Object.defineProperty;\n        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {\n            return defineProperty(function() {}, \"length\", {\n                value: 8\n            }).length !== 8;\n        });\n        var TEMPLATE = String(String).split(\"String\");\n        var makeBuiltIn = module.exports = function(value, name, options) {\n            if (String(name).slice(0, 7) === \"Symbol(\") name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n            if (options && options.getter) name = \"get \" + name;\n            if (options && options.setter) name = \"set \" + name;\n            if (!hasOwn(value, \"name\") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n                if (DESCRIPTORS) defineProperty(value, \"name\", {\n                    value: name,\n                    configurable: true\n                });\n                else value.name = name;\n            }\n            if (CONFIGURABLE_LENGTH && options && hasOwn(options, \"arity\") && value.length !== options.arity) defineProperty(value, \"length\", {\n                value: options.arity\n            });\n            try {\n                if (options && hasOwn(options, \"constructor\") && options.constructor) {\n                    if (DESCRIPTORS) defineProperty(value, \"prototype\", {\n                        writable: false\n                    });\n                } else if (value.prototype) value.prototype = undefined;\n            } catch (error) {}\n            var state = enforceInternalState(value);\n            if (!hasOwn(state, \"source\")) state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n            return value;\n        };\n        // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n        // eslint-disable-next-line no-extend-native -- required\n        Function.prototype.toString = makeBuiltIn(function toString() {\n            return isCallable(this) && getInternalState(this).source || inspectSource(this);\n        }, \"toString\");\n    /***/ },\n    /***/ 917: /***/ (module)=>{\n        var ceil = Math.ceil;\n        var floor = Math.floor;\n        // `Math.trunc` method\n        // https://tc39.es/ecma262/#sec-math.trunc\n        // eslint-disable-next-line es-x/no-math-trunc -- safe\n        module.exports = Math.trunc || function trunc(x) {\n            var n = +x;\n            return (n > 0 ? floor : ceil)(n);\n        };\n    /***/ },\n    /***/ 3839: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        /* eslint-disable es-x/no-symbol -- required for testing */ var V8_VERSION = __webpack_require__(6358);\n        var fails = __webpack_require__(4229);\n        // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\n        module.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n            var symbol = Symbol();\n            // Chrome 38 Symbol has incorrect toString conversion\n            // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n            return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n            !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n        });\n    /***/ },\n    /***/ 8694: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var isCallable = __webpack_require__(6733);\n        var inspectSource = __webpack_require__(8511);\n        var WeakMap1 = global.WeakMap;\n        module.exports = isCallable(WeakMap1) && /native code/.test(inspectSource(WeakMap1));\n    /***/ },\n    /***/ 1787: /***/ (__unused_webpack_module, exports, __webpack_require__)=>{\n        var DESCRIPTORS = __webpack_require__(7400);\n        var IE8_DOM_DEFINE = __webpack_require__(4394);\n        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(7137);\n        var anObject = __webpack_require__(1176);\n        var toPropertyKey = __webpack_require__(9310);\n        var $TypeError = TypeError;\n        // eslint-disable-next-line es-x/no-object-defineproperty -- safe\n        var $defineProperty = Object.defineProperty;\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var ENUMERABLE = \"enumerable\";\n        var CONFIGURABLE = \"configurable\";\n        var WRITABLE = \"writable\";\n        // `Object.defineProperty` method\n        // https://tc39.es/ecma262/#sec-object.defineproperty\n        exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n                var current = $getOwnPropertyDescriptor(O, P);\n                if (current && current[WRITABLE]) {\n                    O[P] = Attributes.value;\n                    Attributes = {\n                        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n                        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                        writable: false\n                    };\n                }\n            }\n            return $defineProperty(O, P, Attributes);\n        } : $defineProperty : function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (IE8_DOM_DEFINE) try {\n                return $defineProperty(O, P, Attributes);\n            } catch (error) {}\n            if (\"get\" in Attributes || \"set\" in Attributes) throw $TypeError(\"Accessors not supported\");\n            if (\"value\" in Attributes) O[P] = Attributes.value;\n            return O;\n        };\n    /***/ },\n    /***/ 7933: /***/ (__unused_webpack_module, exports, __webpack_require__)=>{\n        var DESCRIPTORS = __webpack_require__(7400);\n        var call = __webpack_require__(266);\n        var propertyIsEnumerableModule = __webpack_require__(9195);\n        var createPropertyDescriptor = __webpack_require__(5358);\n        var toIndexedObject = __webpack_require__(905);\n        var toPropertyKey = __webpack_require__(9310);\n        var hasOwn = __webpack_require__(8270);\n        var IE8_DOM_DEFINE = __webpack_require__(4394);\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // `Object.getOwnPropertyDescriptor` method\n        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n        exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n            O = toIndexedObject(O);\n            P = toPropertyKey(P);\n            if (IE8_DOM_DEFINE) try {\n                return $getOwnPropertyDescriptor(O, P);\n            } catch (error) {}\n            if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n        };\n    /***/ },\n    /***/ 8151: /***/ (__unused_webpack_module, exports, __webpack_require__)=>{\n        var internalObjectKeys = __webpack_require__(140);\n        var enumBugKeys = __webpack_require__(3837);\n        var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n        // `Object.getOwnPropertyNames` method\n        // https://tc39.es/ecma262/#sec-object.getownpropertynames\n        // eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\n        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n            return internalObjectKeys(O, hiddenKeys);\n        };\n    /***/ },\n    /***/ 894: /***/ (__unused_webpack_module, exports)=>{\n        // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\n        exports.f = Object.getOwnPropertySymbols;\n    /***/ },\n    /***/ 1321: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        module.exports = uncurryThis({}.isPrototypeOf);\n    /***/ },\n    /***/ 140: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        var hasOwn = __webpack_require__(8270);\n        var toIndexedObject = __webpack_require__(905);\n        var indexOf = __webpack_require__(9540).indexOf;\n        var hiddenKeys = __webpack_require__(5977);\n        var push = uncurryThis([].push);\n        module.exports = function(object, names) {\n            var O = toIndexedObject(object);\n            var i = 0;\n            var result = [];\n            var key;\n            for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n            // Don't enum bug & hidden keys\n            while(names.length > i)if (hasOwn(O, key = names[i++])) ~indexOf(result, key) || push(result, key);\n            return result;\n        };\n    /***/ },\n    /***/ 5632: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var internalObjectKeys = __webpack_require__(140);\n        var enumBugKeys = __webpack_require__(3837);\n        // `Object.keys` method\n        // https://tc39.es/ecma262/#sec-object.keys\n        // eslint-disable-next-line es-x/no-object-keys -- safe\n        module.exports = Object.keys || function keys(O) {\n            return internalObjectKeys(O, enumBugKeys);\n        };\n    /***/ },\n    /***/ 9195: /***/ (__unused_webpack_module, exports)=>{\n        var $propertyIsEnumerable = {}.propertyIsEnumerable;\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // Nashorn ~ JDK8 bug\n        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n            1: 2\n        }, 1);\n        // `Object.prototype.propertyIsEnumerable` method implementation\n        // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n        exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n            var descriptor = getOwnPropertyDescriptor(this, V);\n            return !!descriptor && descriptor.enumerable;\n        } : $propertyIsEnumerable;\n    /***/ },\n    /***/ 2914: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var call = __webpack_require__(266);\n        var isCallable = __webpack_require__(6733);\n        var isObject = __webpack_require__(5052);\n        var $TypeError = TypeError;\n        // `OrdinaryToPrimitive` abstract operation\n        // https://tc39.es/ecma262/#sec-ordinarytoprimitive\n        module.exports = function(input, pref) {\n            var fn, val;\n            if (pref === \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n            if (pref !== \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            throw $TypeError(\"Can't convert object to primitive value\");\n        };\n    /***/ },\n    /***/ 4826: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var getBuiltIn = __webpack_require__(1333);\n        var uncurryThis = __webpack_require__(5968);\n        var getOwnPropertyNamesModule = __webpack_require__(8151);\n        var getOwnPropertySymbolsModule = __webpack_require__(894);\n        var anObject = __webpack_require__(1176);\n        var concat = uncurryThis([].concat);\n        // all object keys, includes non-enumerable and symbols\n        module.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n            var keys = getOwnPropertyNamesModule.f(anObject(it));\n            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n            return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n        };\n    /***/ },\n    /***/ 9276: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        module.exports = global;\n    /***/ },\n    /***/ 8885: /***/ (module)=>{\n        var $TypeError = TypeError;\n        // `RequireObjectCoercible` abstract operation\n        // https://tc39.es/ecma262/#sec-requireobjectcoercible\n        module.exports = function(it) {\n            if (it == undefined) throw $TypeError(\"Can't call method on \" + it);\n            return it;\n        };\n    /***/ },\n    /***/ 4399: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var shared = __webpack_require__(3036);\n        var uid = __webpack_require__(1441);\n        var keys = shared(\"keys\");\n        module.exports = function(key) {\n            return keys[key] || (keys[key] = uid(key));\n        };\n    /***/ },\n    /***/ 5353: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var defineGlobalProperty = __webpack_require__(8400);\n        var SHARED = \"__core-js_shared__\";\n        var store = global[SHARED] || defineGlobalProperty(SHARED, {});\n        module.exports = store;\n    /***/ },\n    /***/ 3036: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var IS_PURE = __webpack_require__(4231);\n        var store = __webpack_require__(5353);\n        (module.exports = function(key, value) {\n            return store[key] || (store[key] = value !== undefined ? value : {});\n        })(\"versions\", []).push({\n            version: \"3.23.3\",\n            mode: IS_PURE ? \"pure\" : \"global\",\n            copyright: \"\\xa9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n            license: \"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE\",\n            source: \"https://github.com/zloirock/core-js\"\n        });\n    /***/ },\n    /***/ 3231: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toIntegerOrInfinity = __webpack_require__(3329);\n        var max = Math.max;\n        var min = Math.min;\n        // Helper for a popular repeating case of the spec:\n        // Let integer be ? ToInteger(index).\n        // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n        module.exports = function(index, length) {\n            var integer = toIntegerOrInfinity(index);\n            return integer < 0 ? max(integer + length, 0) : min(integer, length);\n        };\n    /***/ },\n    /***/ 905: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        // toObject with fallback for non-array-like ES3 strings\n        var IndexedObject = __webpack_require__(9337);\n        var requireObjectCoercible = __webpack_require__(8885);\n        module.exports = function(it) {\n            return IndexedObject(requireObjectCoercible(it));\n        };\n    /***/ },\n    /***/ 3329: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var trunc = __webpack_require__(917);\n        // `ToIntegerOrInfinity` abstract operation\n        // https://tc39.es/ecma262/#sec-tointegerorinfinity\n        module.exports = function(argument) {\n            var number = +argument;\n            // eslint-disable-next-line no-self-compare -- NaN check\n            return number !== number || number === 0 ? 0 : trunc(number);\n        };\n    /***/ },\n    /***/ 4237: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toIntegerOrInfinity = __webpack_require__(3329);\n        var min = Math.min;\n        // `ToLength` abstract operation\n        // https://tc39.es/ecma262/#sec-tolength\n        module.exports = function(argument) {\n            return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n        };\n    /***/ },\n    /***/ 2991: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var requireObjectCoercible = __webpack_require__(8885);\n        var $Object = Object;\n        // `ToObject` abstract operation\n        // https://tc39.es/ecma262/#sec-toobject\n        module.exports = function(argument) {\n            return $Object(requireObjectCoercible(argument));\n        };\n    /***/ },\n    /***/ 2066: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var call = __webpack_require__(266);\n        var isObject = __webpack_require__(5052);\n        var isSymbol = __webpack_require__(9395);\n        var getMethod = __webpack_require__(5300);\n        var ordinaryToPrimitive = __webpack_require__(2914);\n        var wellKnownSymbol = __webpack_require__(95);\n        var $TypeError = TypeError;\n        var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n        // `ToPrimitive` abstract operation\n        // https://tc39.es/ecma262/#sec-toprimitive\n        module.exports = function(input, pref) {\n            if (!isObject(input) || isSymbol(input)) return input;\n            var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n            var result;\n            if (exoticToPrim) {\n                if (pref === undefined) pref = \"default\";\n                result = call(exoticToPrim, input, pref);\n                if (!isObject(result) || isSymbol(result)) return result;\n                throw $TypeError(\"Can't convert object to primitive value\");\n            }\n            if (pref === undefined) pref = \"number\";\n            return ordinaryToPrimitive(input, pref);\n        };\n    /***/ },\n    /***/ 9310: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var toPrimitive = __webpack_require__(2066);\n        var isSymbol = __webpack_require__(9395);\n        // `ToPropertyKey` abstract operation\n        // https://tc39.es/ecma262/#sec-topropertykey\n        module.exports = function(argument) {\n            var key = toPrimitive(argument, \"string\");\n            return isSymbol(key) ? key : key + \"\";\n        };\n    /***/ },\n    /***/ 1601: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var wellKnownSymbol = __webpack_require__(95);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var test = {};\n        test[TO_STRING_TAG] = \"z\";\n        module.exports = String(test) === \"[object z]\";\n    /***/ },\n    /***/ 3326: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var classof = __webpack_require__(1589);\n        var $String = String;\n        module.exports = function(argument) {\n            if (classof(argument) === \"Symbol\") throw TypeError(\"Cannot convert a Symbol value to a string\");\n            return $String(argument);\n        };\n    /***/ },\n    /***/ 9821: /***/ (module)=>{\n        var $String = String;\n        module.exports = function(argument) {\n            try {\n                return $String(argument);\n            } catch (error) {\n                return \"Object\";\n            }\n        };\n    /***/ },\n    /***/ 1441: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var uncurryThis = __webpack_require__(5968);\n        var id = 0;\n        var postfix = Math.random();\n        var toString = uncurryThis(1.0.toString);\n        module.exports = function(key) {\n            return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString(++id + postfix, 36);\n        };\n    /***/ },\n    /***/ 6969: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        /* eslint-disable es-x/no-symbol -- required for testing */ var NATIVE_SYMBOL = __webpack_require__(3839);\n        module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n    /***/ },\n    /***/ 7137: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var DESCRIPTORS = __webpack_require__(7400);\n        var fails = __webpack_require__(4229);\n        // V8 ~ Chrome 36-\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3334\n        module.exports = DESCRIPTORS && fails(function() {\n            // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n            return Object.defineProperty(function() {}, \"prototype\", {\n                value: 42,\n                writable: false\n            }).prototype != 42;\n        });\n    /***/ },\n    /***/ 95: /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n        var global = __webpack_require__(9859);\n        var shared = __webpack_require__(3036);\n        var hasOwn = __webpack_require__(8270);\n        var uid = __webpack_require__(1441);\n        var NATIVE_SYMBOL = __webpack_require__(3839);\n        var USE_SYMBOL_AS_UID = __webpack_require__(6969);\n        var WellKnownSymbolsStore = shared(\"wks\");\n        var Symbol1 = global.Symbol;\n        var symbolFor = Symbol1 && Symbol1[\"for\"];\n        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;\n        module.exports = function(name) {\n            if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n                var description = \"Symbol.\" + name;\n                if (NATIVE_SYMBOL && hasOwn(Symbol1, name)) WellKnownSymbolsStore[name] = Symbol1[name];\n                else if (USE_SYMBOL_AS_UID && symbolFor) WellKnownSymbolsStore[name] = symbolFor(description);\n                else WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n            }\n            return WellKnownSymbolsStore[name];\n        };\n    /***/ },\n    /***/ 3430: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__)=>{\n        var $ = __webpack_require__(3103);\n        var uncurryThis = __webpack_require__(5968);\n        var aCallable = __webpack_require__(7111);\n        var toObject = __webpack_require__(2991);\n        var lengthOfArrayLike = __webpack_require__(9646);\n        var deletePropertyOrThrow = __webpack_require__(9563);\n        var toString = __webpack_require__(3326);\n        var fails = __webpack_require__(4229);\n        var internalSort = __webpack_require__(3867);\n        var arrayMethodIsStrict = __webpack_require__(6038);\n        var FF = __webpack_require__(2671);\n        var IE_OR_EDGE = __webpack_require__(8506);\n        var V8 = __webpack_require__(6358);\n        var WEBKIT = __webpack_require__(9811);\n        var test = [];\n        var un$Sort = uncurryThis(test.sort);\n        var push = uncurryThis(test.push);\n        // IE8-\n        var FAILS_ON_UNDEFINED = fails(function() {\n            test.sort(undefined);\n        });\n        // V8 bug\n        var FAILS_ON_NULL = fails(function() {\n            test.sort(null);\n        });\n        // Old WebKit\n        var STRICT_METHOD = arrayMethodIsStrict(\"sort\");\n        var STABLE_SORT = !fails(function() {\n            // feature detection can be too slow, so check engines versions\n            if (V8) return V8 < 70;\n            if (FF && FF > 3) return;\n            if (IE_OR_EDGE) return true;\n            if (WEBKIT) return WEBKIT < 603;\n            var result = \"\";\n            var code, chr, value, index;\n            // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n            for(code = 65; code < 76; code++){\n                chr = String.fromCharCode(code);\n                switch(code){\n                    case 66:\n                    case 69:\n                    case 70:\n                    case 72:\n                        value = 3;\n                        break;\n                    case 68:\n                    case 71:\n                        value = 4;\n                        break;\n                    default:\n                        value = 2;\n                }\n                for(index = 0; index < 47; index++)test.push({\n                    k: chr + index,\n                    v: value\n                });\n            }\n            test.sort(function(a, b) {\n                return b.v - a.v;\n            });\n            for(index = 0; index < test.length; index++){\n                chr = test[index].k.charAt(0);\n                if (result.charAt(result.length - 1) !== chr) result += chr;\n            }\n            return result !== \"DGBEFHACIJK\";\n        });\n        var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n        var getSortCompare = function(comparefn) {\n            return function(x, y) {\n                if (y === undefined) return -1;\n                if (x === undefined) return 1;\n                if (comparefn !== undefined) return +comparefn(x, y) || 0;\n                return toString(x) > toString(y) ? 1 : -1;\n            };\n        };\n        // `Array.prototype.sort` method\n        // https://tc39.es/ecma262/#sec-array.prototype.sort\n        $({\n            target: \"Array\",\n            proto: true,\n            forced: FORCED\n        }, {\n            sort: function sort(comparefn) {\n                if (comparefn !== undefined) aCallable(comparefn);\n                var array = toObject(this);\n                if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n                var items = [];\n                var arrayLength = lengthOfArrayLike(array);\n                var itemsLength, index;\n                for(index = 0; index < arrayLength; index++)if (index in array) push(items, array[index]);\n                internalSort(items, getSortCompare(comparefn));\n                itemsLength = items.length;\n                index = 0;\n                while(index < itemsLength)array[index] = items[index++];\n                while(index < arrayLength)deletePropertyOrThrow(array, index++);\n                return array;\n            }\n        });\n    /***/ },\n    /***/ 4769: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__)=>{\n        var $ = __webpack_require__(3103);\n        var toObject = __webpack_require__(2991);\n        var nativeKeys = __webpack_require__(5632);\n        var fails = __webpack_require__(4229);\n        var FAILS_ON_PRIMITIVES = fails(function() {\n            nativeKeys(1);\n        });\n        // `Object.keys` method\n        // https://tc39.es/ecma262/#sec-object.keys\n        $({\n            target: \"Object\",\n            stat: true,\n            forced: FAILS_ON_PRIMITIVES\n        }, {\n            keys: function keys(it) {\n                return nativeKeys(toObject(it));\n            }\n        });\n    /***/ },\n    /***/ 1388: /***/ (module, __webpack_exports__, __webpack_require__)=>{\n        /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n            /* harmony export */ \"Z\": ()=>__WEBPACK_DEFAULT_EXPORT__\n        });\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n        // Imports\n        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());\n        // Module\n        ___CSS_LOADER_EXPORT___.push([\n            module.id,\n            \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\",\n            \"\",\n            {\n                \"version\": 3,\n                \"sources\": [\n                    \"webpack://./Loader.css\"\n                ],\n                \"names\": [],\n                \"mappings\": \"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF\",\n                \"sourcesContent\": [\n                    \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\"\n                ],\n                \"sourceRoot\": \"\"\n            }\n        ]);\n        // Exports\n        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;\n    /***/ },\n    /***/ 7379: /***/ (module, __webpack_exports__, __webpack_require__)=>{\n        /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n            /* harmony export */ \"Z\": ()=>__WEBPACK_DEFAULT_EXPORT__\n        });\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);\n        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n        // Imports\n        var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());\n        // Module\n        ___CSS_LOADER_EXPORT___.push([\n            module.id,\n            \"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\",\n            \"\",\n            {\n                \"version\": 3,\n                \"sources\": [\n                    \"webpack://./Util/Toaster.css\"\n                ],\n                \"names\": [],\n                \"mappings\": \";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB\",\n                \"sourcesContent\": [\n                    \"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\"\n                ],\n                \"sourceRoot\": \"\"\n            }\n        ]);\n        // Exports\n        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;\n    /***/ },\n    /***/ 2609: /***/ (module)=>{\n        /*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ module.exports = function(cssWithMappingToString) {\n            var list = []; // return the list of modules as css string\n            list.toString = function toString() {\n                return this.map(function(item) {\n                    var content = \"\";\n                    var needLayer = typeof item[5] !== \"undefined\";\n                    if (item[4]) content += \"@supports (\".concat(item[4], \") {\");\n                    if (item[2]) content += \"@media \".concat(item[2], \" {\");\n                    if (needLayer) content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n                    content += cssWithMappingToString(item);\n                    if (needLayer) content += \"}\";\n                    if (item[2]) content += \"}\";\n                    if (item[4]) content += \"}\";\n                    return content;\n                }).join(\"\");\n            }; // import a list of modules into the list\n            list.i = function i(modules, media, dedupe, supports, layer) {\n                if (typeof modules === \"string\") modules = [\n                    [\n                        null,\n                        modules,\n                        undefined\n                    ]\n                ];\n                var alreadyImportedModules = {};\n                if (dedupe) for(var k = 0; k < this.length; k++){\n                    var id = this[k][0];\n                    if (id != null) alreadyImportedModules[id] = true;\n                }\n                for(var _k = 0; _k < modules.length; _k++){\n                    var item = [].concat(modules[_k]);\n                    if (dedupe && alreadyImportedModules[item[0]]) continue;\n                    if (typeof layer !== \"undefined\") {\n                        if (typeof item[5] === \"undefined\") item[5] = layer;\n                        else {\n                            item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n                            item[5] = layer;\n                        }\n                    }\n                    if (media) {\n                        if (!item[2]) item[2] = media;\n                        else {\n                            item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n                            item[2] = media;\n                        }\n                    }\n                    if (supports) {\n                        if (!item[4]) item[4] = \"\".concat(supports);\n                        else {\n                            item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n                            item[4] = supports;\n                        }\n                    }\n                    list.push(item);\n                }\n            };\n            return list;\n        };\n    /***/ },\n    /***/ 272: /***/ (module)=>{\n        module.exports = function(item) {\n            var content = item[1];\n            var cssMapping = item[3];\n            if (!cssMapping) return content;\n            if (typeof btoa === \"function\") {\n                var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n                var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n                var sourceMapping = \"/*# \".concat(data, \" */\");\n                var sourceURLs = cssMapping.sources.map(function(source) {\n                    return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n                });\n                return [\n                    content\n                ].concat(sourceURLs).concat([\n                    sourceMapping\n                ]).join(\"\\n\");\n            }\n            return [\n                content\n            ].join(\"\\n\");\n        };\n    /***/ }\n};\n/************************************************************************/ /******/ // The module cache\n/******/ var $2c23f148d58cd887$var$__webpack_module_cache__ = {};\n/******/ /******/ // The require function\n/******/ function $2c23f148d58cd887$var$__webpack_require__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/ var cachedModule = $2c23f148d58cd887$var$__webpack_module_cache__[moduleId];\n    /******/ if (cachedModule !== undefined) /******/ return cachedModule.exports;\n    /******/ // Create a new module (and put it into the cache)\n    /******/ var module = $2c23f148d58cd887$var$__webpack_module_cache__[moduleId] = {\n        /******/ id: moduleId,\n        /******/ // no module.loaded needed\n        /******/ exports: {}\n    };\n    /******/ /******/ // Execute the module function\n    /******/ $2c23f148d58cd887$var$__webpack_modules__[moduleId](module, module.exports, $2c23f148d58cd887$var$__webpack_require__);\n    /******/ /******/ // Return the exports of the module\n    /******/ return module.exports;\n/******/ }\n/******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/ $2c23f148d58cd887$var$__webpack_require__.n = (module)=>{\n        /******/ var getter = module && module.__esModule ? /******/ ()=>module[\"default\"] : /******/ ()=>module;\n        /******/ $2c23f148d58cd887$var$__webpack_require__.d(getter, {\n            a: getter\n        });\n        /******/ return getter;\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ $2c23f148d58cd887$var$__webpack_require__.d = (exports, definition)=>{\n        /******/ for(var key in definition)/******/ if ($2c23f148d58cd887$var$__webpack_require__.o(definition, key) && !$2c23f148d58cd887$var$__webpack_require__.o(exports, key)) /******/ Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key]\n        });\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/global */ /******/ (()=>{\n    /******/ $2c23f148d58cd887$var$__webpack_require__.g = function() {\n        /******/ if (typeof globalThis === \"object\") return globalThis;\n        /******/ try {\n            /******/ return this || new Function(\"return this\")();\n        /******/ } catch (e) {\n            /******/ if (typeof window === \"object\") return window;\n        /******/ }\n    /******/ }();\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ $2c23f148d58cd887$var$__webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{\n    /******/ // define __esModule on exports\n    /******/ $2c23f148d58cd887$var$__webpack_require__.r = (exports)=>{\n        /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n            value: \"Module\"\n        });\n        /******/ Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n    /******/ };\n/******/ })();\n/******/ /************************************************************************/ var $2c23f148d58cd887$var$__webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(()=>{\n    // EXPORTS\n    $2c23f148d58cd887$var$__webpack_require__.d($2c23f148d58cd887$var$__webpack_exports__, {\n        \"fWn\": ()=>/* reexport */ ActionContext,\n        \"Ia8\": ()=>/* reexport */ ActionQueue,\n        \"rqv\": ()=>/* reexport */ ActionSequence,\n        \"hLI\": ()=>/* reexport */ ActionsComponent,\n        \"yyv\": ()=>/* reexport */ ActionsSystem,\n        \"tX5\": ()=>/* reexport */ ActivateEvent,\n        \"vtX\": ()=>/* reexport */ Actor,\n        \"r7K\": ()=>/* reexport */ AddedComponent,\n        \"lCh\": ()=>/* reexport */ AddedEntity,\n        \"cE4\": ()=>/* reexport */ AffineMatrix,\n        \"fwF\": ()=>/* reexport */ Animation,\n        \"sce\": ()=>/* reexport */ AnimationDirection,\n        \"_c7\": ()=>/* reexport */ AnimationStrategy,\n        \"KUs\": ()=>/* reexport */ ArcadeSolver,\n        \"Ajp\": ()=>/* reexport */ AudioContextFactory,\n        \"RDh\": ()=>/* reexport */ Axis,\n        \"_H9\": ()=>/* reexport */ BaseAlign,\n        \"mxs\": ()=>/* reexport */ Blink,\n        \"OmD\": ()=>/* reexport */ BodyComponent,\n        \"kBf\": ()=>/* reexport */ BoundingBox,\n        \"C4F\": ()=>/* reexport */ BroadphaseStrategy,\n        \"NQt\": ()=>/* reexport */ BrowserComponent,\n        \"JjN\": ()=>/* reexport */ BrowserEvents,\n        \"V1s\": ()=>/* reexport */ Camera,\n        \"Xz7\": ()=>/* reexport */ Canvas,\n        \"Cdc\": ()=>/* reexport */ Circle,\n        \"FKn\": ()=>/* reexport */ CircleCollider,\n        \"wTW\": ()=>/* reexport */ Class,\n        \"SUY\": ()=>/* reexport */ Clock,\n        \"ab2\": ()=>/* reexport */ ClosestLine,\n        \"GfZ\": ()=>/* reexport */ ClosestLineJumpTable,\n        \"YMS\": ()=>/* reexport */ Collider,\n        \"oyv\": ()=>/* reexport */ ColliderComponent,\n        \"aUb\": ()=>/* reexport */ CollisionContact,\n        \"SdD\": ()=>/* reexport */ CollisionEndEvent,\n        \"JUv\": ()=>/* reexport */ CollisionGroup,\n        \"jEj\": ()=>/* reexport */ CollisionGroupManager,\n        \"TFq\": ()=>/* reexport */ CollisionJumpTable,\n        \"HDU\": ()=>/* reexport */ CollisionPostSolveEvent,\n        \"R_y\": ()=>/* reexport */ CollisionPreSolveEvent,\n        \"ydN\": ()=>/* reexport */ CollisionResolutionStrategy,\n        \"t50\": ()=>/* reexport */ CollisionStartEvent,\n        \"s$$\": ()=>/* reexport */ CollisionSystem,\n        \"v2G\": ()=>/* reexport */ CollisionType,\n        \"Ilk\": ()=>/* reexport */ Color,\n        \"s9i\": ()=>/* reexport */ ColorBlindFlags,\n        \"dxL\": ()=>/* reexport */ ColorBlindnessMode,\n        \"LLX\": ()=>/* reexport */ ColorBlindnessPostProcessor,\n        \"wA2\": ()=>/* reexport */ Component,\n        \"R_p\": ()=>/* reexport */ CompositeCollider,\n        \"IQ$\": ()=>/* reexport */ Configurable,\n        \"I5F\": ()=>/* reexport */ ConsoleAppender,\n        \"X8$\": ()=>/* reexport */ ContactConstraintPoint,\n        \"FR6\": ()=>/* reexport */ ContactEndEvent,\n        \"U8o\": ()=>/* reexport */ ContactStartEvent,\n        \"kbG\": ()=>/* reexport */ CoordPlane,\n        \"iS_\": ()=>/* reexport */ DeactivateEvent,\n        \"cGG\": ()=>/* reexport */ Debug,\n        \"RPN\": ()=>/* reexport */ DebugGraphicsComponent,\n        \"skb\": ()=>/* reexport */ DebugSystem,\n        \"SLU\": ()=>/* reexport */ DebugText,\n        \"RdJ\": ()=>/* reexport */ DegreeOfFreedom,\n        \"cNu\": ()=>/* reexport */ Delay,\n        \"gU7\": ()=>/* reexport */ Detector,\n        \"LSk\": ()=>/* reexport */ Die,\n        \"Nmp\": ()=>/* reexport */ Direction,\n        \"d1Y\": ()=>/* reexport */ DisplayMode,\n        \"xrL\": ()=>/* reexport */ DynamicTree,\n        \"sRW\": ()=>/* reexport */ DynamicTreeCollisionProcessor,\n        \"cmV\": ()=>/* binding */ EX_VERSION,\n        \"qWz\": ()=>/* reexport */ EaseBy,\n        \"N0Q\": ()=>/* reexport */ EaseTo,\n        \"q8b\": ()=>/* reexport */ EasingFunctions,\n        \"ynB\": ()=>/* reexport */ EdgeCollider,\n        \"jT9\": ()=>/* reexport */ ElasticToActorStrategy,\n        \"wAz\": ()=>/* reexport */ EmitterType,\n        \"D4V\": ()=>/* reexport */ Engine,\n        \"N6H\": ()=>/* reexport */ EnterTriggerEvent,\n        \"W1A\": ()=>/* reexport */ EnterViewPortEvent,\n        \"JHW\": ()=>/* reexport */ Entity,\n        \"v2K\": ()=>/* reexport */ EntityManager,\n        \"pBf\": ()=>/* reexport */ EventDispatcher,\n        \"GMl\": ()=>/* reexport */ EventTypes,\n        \"zW2\": ()=>/* reexport */ Events_namespaceObject,\n        \"B0K\": ()=>/* reexport */ ExResponse,\n        \"Nv7\": ()=>/* reexport */ ExcaliburGraphicsContext2DCanvas,\n        \"C_p\": ()=>/* reexport */ ExcaliburGraphicsContextWebGL,\n        \"iqw\": ()=>/* reexport */ ExcaliburWebGLContextAccessor,\n        \"MUA\": ()=>/* reexport */ ExitTriggerEvent,\n        \"xqU\": ()=>/* reexport */ ExitViewPortEvent,\n        \"pTp\": ()=>/* reexport */ Fade,\n        \"vUK\": ()=>/* reexport */ Flags,\n        \"j9l\": ()=>/* reexport */ Follow,\n        \"Zxw\": ()=>/* reexport */ Font,\n        \"Hdx\": ()=>/* reexport */ FontStyle,\n        \"Z$d\": ()=>/* reexport */ FontUnit,\n        \"iqV\": ()=>/* reexport */ FpsSampler,\n        \"o$7\": ()=>/* reexport */ FrameStats,\n        \"olM\": ()=>/* reexport */ Future,\n        \"Zm$\": ()=>/* reexport */ GameEvent,\n        \"$QH\": ()=>/* reexport */ GameStartEvent,\n        \"i78\": ()=>/* reexport */ GameStopEvent,\n        \"h6u\": ()=>/* reexport */ GamepadAxisEvent,\n        \"hts\": ()=>/* reexport */ GamepadButtonEvent,\n        \"j88\": ()=>/* reexport */ GamepadConnectEvent,\n        \"VME\": ()=>/* reexport */ GamepadDisconnectEvent,\n        \"nt\": ()=>/* reexport */ Gif,\n        \"Ukr\": ()=>/* reexport */ GlobalCoordinates,\n        \"zsu\": ()=>/* reexport */ Graphic,\n        \"oA6\": ()=>/* reexport */ GraphicsComponent,\n        \"TVh\": ()=>/* reexport */ GraphicsGroup,\n        \"TwZ\": ()=>/* reexport */ GraphicsLayer,\n        \"GTT\": ()=>/* reexport */ GraphicsLayers,\n        \"xxj\": ()=>/* reexport */ GraphicsSystem,\n        \"XdK\": ()=>/* reexport */ HiddenEvent,\n        \"Jmb\": ()=>/* reexport */ ImageFiltering,\n        \"cXo\": ()=>/* reexport */ ImageSource,\n        \"Dm5\": ()=>/* reexport */ InitializeEvent,\n        \"IIB\": ()=>/* reexport */ Input_Index_namespaceObject,\n        \"zI0\": ()=>/* reexport */ Integrator,\n        \"LYD\": ()=>/* reexport */ IsometricEntityComponent,\n        \"cEG\": ()=>/* reexport */ IsometricEntitySystem,\n        \"SEl\": ()=>/* reexport */ IsometricMap,\n        \"t9V\": ()=>/* reexport */ IsometricTile,\n        \"SKZ\": ()=>/* reexport */ KillEvent,\n        \"__J\": ()=>/* reexport */ Label,\n        \"RI$\": ()=>/* reexport */ LimitCameraBoundsStrategy,\n        \"x12\": ()=>/* reexport */ Line,\n        \"ccz\": ()=>/* reexport */ LineSegment,\n        \"aNw\": ()=>/* reexport */ Loader,\n        \"xwn\": ()=>/* reexport */ LockCameraToActorAxisStrategy,\n        \"dNK\": ()=>/* reexport */ LockCameraToActorStrategy,\n        \"ini\": ()=>/* reexport */ LogLevel,\n        \"YdH\": ()=>/* reexport */ Logger,\n        \"y3G\": ()=>/* reexport */ Matrix,\n        \"l57\": ()=>/* reexport */ MatrixLocations,\n        \"xn0\": ()=>/* reexport */ MediaEvent,\n        \"t2V\": ()=>/* reexport */ Meet,\n        \"uxB\": ()=>/* reexport */ MotionComponent,\n        \"cpd\": ()=>/* reexport */ MotionSystem,\n        \"fiy\": ()=>/* reexport */ MoveBy,\n        \"$XZ\": ()=>/* reexport */ MoveTo,\n        \"uqK\": ()=>/* reexport */ NativeSoundEvent,\n        \"STE\": ()=>/* reexport */ NativeSoundProcessedEvent,\n        \"y$z\": ()=>/* reexport */ Observable,\n        \"mAD\": ()=>/* reexport */ OffscreenSystem,\n        \"sOq\": ()=>/* reexport */ Pair,\n        \"hUw\": ()=>/* reexport */ ParallaxComponent,\n        \"_0G\": ()=>/* reexport */ ParallelActions,\n        \"Sqs\": ()=>/* reexport */ ParseGif,\n        \"hpZ\": ()=>/* reexport */ Particle,\n        \"Vol\": ()=>/* reexport */ ParticleEmitter,\n        \"wIZ\": ()=>/* reexport */ Physics,\n        \"cBi\": ()=>/* reexport */ PhysicsStats,\n        \"RFv\": ()=>/* reexport */ PointerComponent,\n        \"kfC\": ()=>/* reexport */ PointerSystem,\n        \"mgq\": ()=>/* reexport */ Polygon,\n        \"YVA\": ()=>/* reexport */ PolygonCollider,\n        \"Kgp\": ()=>/* reexport */ Pool,\n        \"HH$\": ()=>/* reexport */ PostCollisionEvent,\n        \"M_d\": ()=>/* reexport */ PostDebugDrawEvent,\n        \"rgh\": ()=>/* reexport */ PostDrawEvent,\n        \"Ra6\": ()=>/* reexport */ PostFrameEvent,\n        \"KhR\": ()=>/* reexport */ PostKillEvent,\n        \"BS5\": ()=>/* reexport */ PostUpdateEvent,\n        \"xhz\": ()=>/* reexport */ PreCollisionEvent,\n        \"xOq\": ()=>/* reexport */ PreDebugDrawEvent,\n        \"a9j\": ()=>/* reexport */ PreDrawEvent,\n        \"bHk\": ()=>/* reexport */ PreFrameEvent,\n        \"CgK\": ()=>/* reexport */ PreKillEvent,\n        \"cuY\": ()=>/* reexport */ PreUpdateEvent,\n        \"kvE\": ()=>/* reexport */ Projection,\n        \"SBu\": ()=>/* reexport */ QuadIndexBuffer,\n        \"AE_\": ()=>/* reexport */ Query,\n        \"ctO\": ()=>/* reexport */ QueryManager,\n        \"OLH\": ()=>/* reexport */ RadiusAroundActorStrategy,\n        \"kky\": ()=>/* reexport */ Random,\n        \"nSF\": ()=>/* reexport */ Raster,\n        \"zHn\": ()=>/* reexport */ Ray,\n        \"zwx\": ()=>/* reexport */ RealisticSolver,\n        \"AeJ\": ()=>/* reexport */ Rectangle,\n        \"hLz\": ()=>/* reexport */ RemovedComponent,\n        \"D9g\": ()=>/* reexport */ RemovedEntity,\n        \"wA\": ()=>/* reexport */ Repeat,\n        \"jhr\": ()=>/* reexport */ RepeatForever,\n        \"GVs\": ()=>/* reexport */ Resolution,\n        \"_zO\": ()=>/* reexport */ Resource,\n        \"w6$\": ()=>/* reexport */ RotateBy,\n        \"mhV\": ()=>/* reexport */ RotateTo,\n        \"MOD\": ()=>/* reexport */ RotationType,\n        \"kwd\": ()=>/* reexport */ ScaleBy,\n        \"Lmr\": ()=>/* reexport */ ScaleTo,\n        \"xsS\": ()=>/* reexport */ Scene,\n        \"lLr\": ()=>/* reexport */ Screen,\n        \"Z$r\": ()=>/* reexport */ ScreenAppender,\n        \"IXb\": ()=>/* reexport */ ScreenElement,\n        \"SGH\": ()=>/* reexport */ ScreenShader,\n        \"SMj\": ()=>/* reexport */ ScrollPreventionMode,\n        \"L34\": ()=>/* reexport */ Semaphore,\n        \"exe\": ()=>/* reexport */ Shader,\n        \"bnF\": ()=>/* reexport */ Shape,\n        \"MFA\": ()=>/* reexport */ Side,\n        \"$uU\": ()=>/* reexport */ Sound,\n        \"jyi\": ()=>/* reexport */ Sprite,\n        \"E03\": ()=>/* reexport */ SpriteFont,\n        \"V6q\": ()=>/* reexport */ SpriteSheet,\n        \"rg2\": ()=>/* reexport */ StandardClock,\n        \"DVW\": ()=>/* reexport */ StateMachine,\n        \"nVo\": ()=>/* reexport */ StrategyContainer,\n        \"F6N\": ()=>/* reexport */ Stream,\n        \"xP7\": ()=>/* reexport */ System,\n        \"Odq\": ()=>/* reexport */ SystemManager,\n        \"Zif\": ()=>/* reexport */ SystemType,\n        \"ZGJ\": ()=>/* reexport */ TagComponent,\n        \"MJk\": ()=>/* reexport */ TestClock,\n        \"xvT\": ()=>/* reexport */ Text,\n        \"PHM\": ()=>/* reexport */ TextAlign,\n        \"dpR\": ()=>/* reexport */ TextureLoader,\n        \"n9L\": ()=>/* reexport */ Tile,\n        \"KwO\": ()=>/* reexport */ TileMap,\n        \"B7y\": ()=>/* reexport */ Timer,\n        \"x7r\": ()=>/* reexport */ Toaster,\n        \"wx7\": ()=>/* reexport */ Transform,\n        \"Uvn\": ()=>/* reexport */ TransformComponent,\n        \"OFT\": ()=>/* reexport */ TreeNode,\n        \"xzN\": ()=>/* reexport */ Trigger,\n        \"M5Z\": ()=>/* reexport */ TwoPI,\n        \"ZrN\": ()=>/* reexport */ Util_Index_namespaceObject,\n        \"OWs\": ()=>/* reexport */ Vector,\n        \"dF9\": ()=>/* reexport */ VectorView,\n        \"oZy\": ()=>/* reexport */ VertexBuffer,\n        \"rD2\": ()=>/* reexport */ VertexLayout,\n        \"VHo\": ()=>/* reexport */ VisibleEvent,\n        \"ohE\": ()=>/* reexport */ WebAudio,\n        \"R$E\": ()=>/* reexport */ WebAudioInstance,\n        \"q3I\": ()=>/* reexport */ World,\n        \"Pab\": ()=>/* reexport */ canonicalizeAngle,\n        \"uZ5\": ()=>/* reexport */ clamp,\n        \"McK\": ()=>/* reexport */ createId,\n        \"F9c\": ()=>/* reexport */ frac,\n        \"k0b\": ()=>/* reexport */ hasGraphicsTick,\n        \"hnT\": ()=>/* reexport */ hasOnInitialize,\n        \"RSJ\": ()=>/* reexport */ hasOnPostUpdate,\n        \"Mku\": ()=>/* reexport */ hasOnPreUpdate,\n        \"h90\": ()=>/* reexport */ hasPostDraw,\n        \"rms\": ()=>/* reexport */ hasPreDraw,\n        \"ErP\": ()=>/* reexport */ has_initialize,\n        \"aVg\": ()=>/* reexport */ has_postupdate,\n        \"lPc\": ()=>/* reexport */ has_preupdate,\n        \"Z8E\": ()=>/* reexport */ isAddedComponent,\n        \"_N2\": ()=>/* reexport */ isAddedSystemEntity,\n        \"yFn\": ()=>/* reexport */ isRemoveSystemEntity,\n        \"lNv\": ()=>/* reexport */ isRemovedComponent,\n        \"cu9\": ()=>/* reexport */ isScreenElement,\n        \"MZQ\": ()=>/* reexport */ maxMessages,\n        \"FUM\": ()=>/* reexport */ obsolete,\n        \"BxR\": ()=>/* reexport */ pixelSnapEpsilon,\n        \"vdf\": ()=>/* reexport */ randomInRange,\n        \"iaL\": ()=>/* reexport */ randomIntInRange,\n        \"w6H\": ()=>/* reexport */ range,\n        \"Q4c\": ()=>/* reexport */ resetObsoleteCounter,\n        \"Xxe\": ()=>/* reexport */ sign,\n        \"Uxb\": ()=>/* reexport */ toDegrees,\n        \"Yr5\": ()=>/* reexport */ toRadians,\n        \"Bhw\": ()=>/* reexport */ vec,\n        \"yOA\": ()=>/* reexport */ webgl_util_namespaceObject\n    });\n    // NAMESPACE OBJECT: ./Events.ts\n    var Events_namespaceObject = {};\n    $2c23f148d58cd887$var$__webpack_require__.r(Events_namespaceObject);\n    $2c23f148d58cd887$var$__webpack_require__.d(Events_namespaceObject, {\n        \"ActivateEvent\": ()=>ActivateEvent,\n        \"CollisionEndEvent\": ()=>CollisionEndEvent,\n        \"CollisionPostSolveEvent\": ()=>CollisionPostSolveEvent,\n        \"CollisionPreSolveEvent\": ()=>CollisionPreSolveEvent,\n        \"CollisionStartEvent\": ()=>CollisionStartEvent,\n        \"ContactEndEvent\": ()=>ContactEndEvent,\n        \"ContactStartEvent\": ()=>ContactStartEvent,\n        \"DeactivateEvent\": ()=>DeactivateEvent,\n        \"EnterTriggerEvent\": ()=>EnterTriggerEvent,\n        \"EnterViewPortEvent\": ()=>EnterViewPortEvent,\n        \"EventTypes\": ()=>EventTypes,\n        \"ExitTriggerEvent\": ()=>ExitTriggerEvent,\n        \"ExitViewPortEvent\": ()=>ExitViewPortEvent,\n        \"GameEvent\": ()=>GameEvent,\n        \"GameStartEvent\": ()=>GameStartEvent,\n        \"GameStopEvent\": ()=>GameStopEvent,\n        \"GamepadAxisEvent\": ()=>GamepadAxisEvent,\n        \"GamepadButtonEvent\": ()=>GamepadButtonEvent,\n        \"GamepadConnectEvent\": ()=>GamepadConnectEvent,\n        \"GamepadDisconnectEvent\": ()=>GamepadDisconnectEvent,\n        \"HiddenEvent\": ()=>HiddenEvent,\n        \"InitializeEvent\": ()=>InitializeEvent,\n        \"KillEvent\": ()=>KillEvent,\n        \"PostCollisionEvent\": ()=>PostCollisionEvent,\n        \"PostDebugDrawEvent\": ()=>PostDebugDrawEvent,\n        \"PostDrawEvent\": ()=>PostDrawEvent,\n        \"PostFrameEvent\": ()=>PostFrameEvent,\n        \"PostKillEvent\": ()=>PostKillEvent,\n        \"PostUpdateEvent\": ()=>PostUpdateEvent,\n        \"PreCollisionEvent\": ()=>PreCollisionEvent,\n        \"PreDebugDrawEvent\": ()=>PreDebugDrawEvent,\n        \"PreDrawEvent\": ()=>PreDrawEvent,\n        \"PreFrameEvent\": ()=>PreFrameEvent,\n        \"PreKillEvent\": ()=>PreKillEvent,\n        \"PreUpdateEvent\": ()=>PreUpdateEvent,\n        \"VisibleEvent\": ()=>VisibleEvent\n    });\n    // NAMESPACE OBJECT: ./Graphics/Context/webgl-util.ts\n    var webgl_util_namespaceObject = {};\n    $2c23f148d58cd887$var$__webpack_require__.r(webgl_util_namespaceObject);\n    $2c23f148d58cd887$var$__webpack_require__.d(webgl_util_namespaceObject, {\n        \"getAttributeComponentSize\": ()=>getAttributeComponentSize,\n        \"getAttributePointerType\": ()=>getAttributePointerType,\n        \"getGlTypeSizeBytes\": ()=>getGlTypeSizeBytes\n    });\n    // NAMESPACE OBJECT: ./Util/DrawUtil.ts\n    var DrawUtil_namespaceObject = {};\n    $2c23f148d58cd887$var$__webpack_require__.r(DrawUtil_namespaceObject);\n    $2c23f148d58cd887$var$__webpack_require__.d(DrawUtil_namespaceObject, {\n        \"circle\": ()=>circle,\n        \"line\": ()=>line,\n        \"point\": ()=>point,\n        \"roundRect\": ()=>roundRect,\n        \"vector\": ()=>vector\n    });\n    // NAMESPACE OBJECT: ./Input/Index.ts\n    var Input_Index_namespaceObject = {};\n    $2c23f148d58cd887$var$__webpack_require__.r(Input_Index_namespaceObject);\n    $2c23f148d58cd887$var$__webpack_require__.d(Input_Index_namespaceObject, {\n        \"Axes\": ()=>Axes,\n        \"Buttons\": ()=>Buttons,\n        \"Gamepad\": ()=>Gamepad,\n        \"Gamepads\": ()=>Gamepads,\n        \"KeyEvent\": ()=>KeyEvent,\n        \"Keyboard\": ()=>Keyboard,\n        \"Keys\": ()=>Keys,\n        \"NativePointerButton\": ()=>NativePointerButton,\n        \"PointerButton\": ()=>PointerButton,\n        \"PointerComponent\": ()=>PointerComponent,\n        \"PointerEvent\": ()=>PointerEvent,\n        \"PointerEventReceiver\": ()=>PointerEventReceiver,\n        \"PointerScope\": ()=>PointerScope,\n        \"PointerSystem\": ()=>PointerSystem,\n        \"PointerType\": ()=>PointerType,\n        \"WheelDeltaMode\": ()=>WheelDeltaMode,\n        \"WheelEvent\": ()=>WheelEvent\n    });\n    // NAMESPACE OBJECT: ./Util/Index.ts\n    var Util_Index_namespaceObject = {};\n    $2c23f148d58cd887$var$__webpack_require__.r(Util_Index_namespaceObject);\n    $2c23f148d58cd887$var$__webpack_require__.d(Util_Index_namespaceObject, {\n        \"ConsoleAppender\": ()=>ConsoleAppender,\n        \"DrawUtil\": ()=>DrawUtil_namespaceObject,\n        \"EasingFunctions\": ()=>EasingFunctions,\n        \"LogLevel\": ()=>LogLevel,\n        \"Logger\": ()=>Logger,\n        \"Observable\": ()=>Observable,\n        \"ScreenAppender\": ()=>ScreenAppender,\n        \"addItemToArray\": ()=>addItemToArray,\n        \"contains\": ()=>contains,\n        \"delay\": ()=>delay,\n        \"fail\": ()=>fail,\n        \"getPosition\": ()=>getPosition,\n        \"removeItemFromArray\": ()=>removeItemFromArray\n    });\n    // EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js\n    var sort = $2c23f148d58cd887$var$__webpack_require__(4662);\n    // EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js\n    var keys = $2c23f148d58cd887$var$__webpack_require__(8343);\n    /**\r\n * Polyfill adding function\r\n */ function polyfill() {\n        /* istanbul ignore next */ if (typeof window === \"undefined\") window = {\n            audioContext: function() {\n                return;\n            }\n        };\n        /* istanbul ignore next */ if (typeof window !== \"undefined\" && !window.requestAnimationFrame) window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {\n            window.setInterval(callback, 1000 / 60);\n        };\n        /* istanbul ignore next */ if (typeof window !== \"undefined\" && !window.cancelAnimationFrame) window.cancelAnimationFrame = window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function() {\n            return;\n        };\n        /* istanbul ignore next */ if (typeof window !== \"undefined\" && !window.AudioContext) {\n            if (window.webkitAudioContext) {\n                const ctx = window.webkitAudioContext;\n                const replaceMe = ctx.prototype.decodeAudioData;\n                window.webkitAudioContext.prototype.decodeAudioData = function(arrayBuffer) {\n                    return new Promise((resolve, reject)=>{\n                        replaceMe.call(this, arrayBuffer, resolve, reject);\n                    });\n                };\n            }\n            window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;\n        }\n        /* istanbul ignore next */ if (typeof window !== \"undefined\" && !window.devicePixelRatio) window.devicePixelRatio = window.devicePixelRatio || 1;\n    }\n    /**\r\n * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**\r\n * after which they are frozen and are read-only.\r\n *\r\n * Flags are used to enable experimental or preview features in Excalibur.\r\n */ class Flags {\n        /**\r\n     * Force excalibur to load the Canvas 2D graphics context fallback\r\n     *\r\n     * @warning not all features of excalibur are supported in the Canvas 2D fallback\r\n     */ static useCanvasGraphicsContext() {\n            Flags.enable(\"use-canvas-context\");\n        }\n        /**\r\n     * Freeze all flag modifications making them readonly\r\n     */ static freeze() {\n            Flags._FROZEN = true;\n        }\n        /**\r\n     * Resets internal flag state, not meant to be called by users. Only used for testing.\r\n     *\r\n     * Calling this in your game is UNSUPPORTED\r\n     * @internal\r\n     */ static _reset() {\n            Flags._FROZEN = false;\n            Flags._FLAGS = {};\n        }\n        /**\r\n     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n     * @param flagName\r\n     */ static enable(flagName) {\n            if (this._FROZEN) throw Error(\"Feature flags can only be enabled before Engine constructor time\");\n            Flags._FLAGS[flagName] = true;\n        }\n        /**\r\n     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n     * @param flagName\r\n     */ static disable(flagName) {\n            if (this._FROZEN) throw Error(\"Feature flags can only be disabled before Engine constructor time\");\n            Flags._FLAGS[flagName] = false;\n        }\n        /**\r\n     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned\r\n     * @param flagName\r\n     */ static isEnabled(flagName) {\n            return !!Flags._FLAGS[flagName];\n        }\n        /**\r\n     * Show a list of currently known flags\r\n     */ static show() {\n            return Object.keys(Flags._FLAGS);\n        }\n    }\n    Flags._FROZEN = false;\n    Flags._FLAGS = {};\n    /**\r\n * Create a branded ID type from a number\r\n */ function createId(type, value) {\n        return {\n            type: type,\n            value: value\n        };\n    }\n    /**\r\n * @module\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n */ /**\r\n * 32-bit mask\r\n */ const BITMASK32 = 0xffffffff;\n    /**\r\n * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n * of numbers each time it is called.\r\n * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n *\r\n * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n */ class Random {\n        /**\r\n     * If no seed is specified, the Date.now() is used\r\n     */ constructor(seed){\n            this.seed = seed;\n            // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\n            this._lowerMask = 0x7fffffff; // 31 bits same as _r\n            this._upperMask = 0x80000000; // 34 high bits\n            // Word size, 64 bits\n            this._w = 32;\n            // Degree of recurrence\n            this._n = 624;\n            // Middle word, an offset used in the recurrence defining the series x, 1<=m<n\n            this._m = 397;\n            // coefficients of teh rational normal form twist matrix\n            this._a = 0x9908b0df;\n            // tempering bit shifts and masks\n            this._u = 11;\n            this._s = 7;\n            this._b = 0x9d2c5680;\n            this._t = 15;\n            this._c = 0xefc60000;\n            this._l = 18;\n            this._f = 1812433253;\n            this._mt = new Array(this._n);\n            // need to mask to support higher bit machines\n            this._mt[0] = (seed || Date.now()) >>> 0;\n            for(let i = 1; i < this._n; i++){\n                const s = this._mt[i - 1] ^ this._mt[i - 1] >>> this._w - 2;\n                // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits\n                this._mt[i] = (this._f * ((s & 0xffff0000) >>> 16) << 16) + this._f * (s & 0xffff) + i >>> 0;\n            }\n            this._index = this._n;\n        }\n        /**\r\n     * Apply the twist\r\n     */ _twist() {\n            const mag01 = [\n                0x0,\n                this._a\n            ];\n            let y = 0, i = 0;\n            for(; i < this._n - this._m; i++){\n                y = this._mt[i] & this._upperMask | this._mt[i + 1] & this._lowerMask;\n                this._mt[i] = this._mt[i + this._m] ^ y >>> 1 ^ mag01[y & 0x1] & BITMASK32;\n            }\n            for(; i < this._n - 1; i++){\n                y = this._mt[i] & this._upperMask | this._mt[i + 1] & this._lowerMask;\n                this._mt[i] = this._mt[i + (this._m - this._n)] ^ y >>> 1 ^ mag01[y & 0x1] & BITMASK32;\n            }\n            y = this._mt[this._n - 1] & this._upperMask | this._mt[0] & this._lowerMask;\n            this._mt[this._n - 1] = this._mt[this._m - 1] ^ y >>> 1 ^ mag01[y & 0x1] & BITMASK32;\n            this._index = 0;\n        }\n        /**\r\n     * Return next 32 bit integer number in sequence\r\n     */ nextInt() {\n            if (this._index >= this._n) this._twist();\n            let y = this._mt[this._index++];\n            y ^= y >>> this._u;\n            y ^= y << this._s & this._b;\n            y ^= y << this._t & this._c;\n            y ^= y >>> this._l;\n            return y >>> 0;\n        }\n        /**\r\n     * Return a random floating point number between [0, 1)\r\n     */ next() {\n            return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\n        }\n        /**\r\n     * Return a random floating point in range [min, max) min is included, max is not included\r\n     */ floating(min, max) {\n            return (max - min) * this.next() + min;\n        }\n        /**\r\n     * Return a random integer in range [min, max] min is included, max is included.\r\n     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n     */ integer(min, max) {\n            return Math.floor((max - min + 1) * this.next() + min);\n        }\n        /**\r\n     * Returns true or false randomly with 50/50 odds by default.\r\n     * By default the likelihood of returning a true is .5 (50%).\r\n     * @param likelihood takes values between [0, 1]\r\n     */ bool(likelihood = 0.5) {\n            return this.next() <= likelihood;\n        }\n        /**\r\n     * Returns one element from an array at random\r\n     */ pickOne(array) {\n            return array[this.integer(0, array.length - 1)];\n        }\n        /**\r\n     * Returns a new array random picking elements from the original\r\n     * @param array Original array to pick from\r\n     * @param numPicks can be any positive number\r\n     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n     * just that it is possible)\r\n     */ pickSet(array, numPicks, allowDuplicates = false) {\n            if (allowDuplicates) return this._pickSetWithDuplicates(array, numPicks);\n            else return this._pickSetWithoutDuplicates(array, numPicks);\n        }\n        /**\r\n     * Returns a new array randomly picking elements in the original (not reused)\r\n     * @param array Array to pick elements out of\r\n     * @param numPicks must be less than or equal to the number of elements in the array.\r\n     */ _pickSetWithoutDuplicates(array, numPicks) {\n            if (numPicks > array.length || numPicks < 0) throw new Error(\"Invalid number of elements to pick, must pick a value 0 < n <= length\");\n            if (numPicks === array.length) return array;\n            const result = new Array(numPicks);\n            let currentPick = 0;\n            const tempArray = array.slice(0);\n            while(currentPick < numPicks){\n                const index = this.integer(0, tempArray.length - 1);\n                result[currentPick++] = tempArray[index];\n                tempArray.splice(index, 1);\n            }\n            return result;\n        }\n        /**\r\n     * Returns a new array random picking elements from the original allowing duplicates\r\n     * @param array Array to pick elements out of\r\n     * @param numPicks can be any positive number\r\n     */ _pickSetWithDuplicates(array, numPicks) {\n            // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\n            if (numPicks < 0) throw new Error(\"Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT\");\n            const result = new Array(numPicks);\n            for(let i = 0; i < numPicks; i++)result[i] = this.pickOne(array);\n            return result;\n        }\n        /**\r\n     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n     */ shuffle(array) {\n            const tempArray = array.slice(0);\n            let swap = null;\n            for(let i = 0; i < tempArray.length - 2; i++){\n                const randomIndex = this.integer(i, tempArray.length - 1);\n                swap = tempArray[i];\n                tempArray[i] = tempArray[randomIndex];\n                tempArray[randomIndex] = swap;\n            }\n            return tempArray;\n        }\n        /**\r\n     * Generate a list of random integer numbers\r\n     * @param length the length of the final array\r\n     * @param min the minimum integer number to generate inclusive\r\n     * @param max the maximum integer number to generate inclusive\r\n     */ range(length, min, max) {\n            const result = new Array(length);\n            for(let i = 0; i < length; i++)result[i] = this.integer(min, max);\n            return result;\n        }\n        /**\r\n     * Returns the result of a d4 dice roll\r\n     */ d4() {\n            return this.integer(1, 4);\n        }\n        /**\r\n     * Returns the result of a d6 dice roll\r\n     */ d6() {\n            return this.integer(1, 6);\n        }\n        /**\r\n     * Returns the result of a d8 dice roll\r\n     */ d8() {\n            return this.integer(1, 8);\n        }\n        /**\r\n     * Returns the result of a d10 dice roll\r\n     */ d10() {\n            return this.integer(1, 10);\n        }\n        /**\r\n     * Returns the result of a d12 dice roll\r\n     */ d12() {\n            return this.integer(1, 12);\n        }\n        /**\r\n     * Returns the result of a d20 dice roll\r\n     */ d20() {\n            return this.integer(1, 20);\n        }\n    }\n    /**\r\n * Two PI constant\r\n */ const TwoPI = Math.PI * 2;\n    /**\r\n * Returns the fractional part of a number\r\n * @param x\r\n */ function frac(x) {\n        if (x >= 0) return x - Math.floor(x);\n        else return x - Math.ceil(x);\n    }\n    /**\r\n * Returns the sign of a number, if 0 returns 0\r\n */ function sign(val) {\n        if (val === 0) return 0;\n        return val < 0 ? -1 : 1;\n    }\n    /**\r\n * Clamps a value between a min and max inclusive\r\n */ function clamp(val, min, max) {\n        return Math.min(Math.max(min, val), max);\n    }\n    /**\r\n * Convert an angle to be the equivalent in the range [0, 2PI]\r\n */ function canonicalizeAngle(angle) {\n        let tmpAngle = angle;\n        if (angle > TwoPI) while(tmpAngle > TwoPI)tmpAngle -= TwoPI;\n        if (angle < 0) while(tmpAngle < 0)tmpAngle += TwoPI;\n        return tmpAngle;\n    }\n    /**\r\n * Convert radians to degrees\r\n */ function toDegrees(radians) {\n        return 180 / Math.PI * radians;\n    }\n    /**\r\n * Convert degrees to radians\r\n */ function toRadians(degrees) {\n        return degrees / 180 * Math.PI;\n    }\n    /**\r\n * Generate a range of numbers\r\n * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]\r\n * @param from inclusive\r\n * @param to inclusive\r\n */ const range = (from, to)=>Array.from(new Array(to - from + 1), (_x, i)=>i + from);\n    /**\r\n * Find a random floating point number in range\r\n */ function randomInRange(min, max, random = new Random()) {\n        return random ? random.floating(min, max) : min + Math.random() * (max - min);\n    }\n    /**\r\n * Find a random integer in a range\r\n */ function randomIntInRange(min, max, random = new Random()) {\n        return random ? random.integer(min, max) : Math.round(randomInRange(min, max));\n    }\n    /**\r\n * A 2D vector on a plane.\r\n */ class Vector {\n        /**\r\n     * @param x  X component of the Vector\r\n     * @param y  Y component of the Vector\r\n     */ constructor(x, y){\n            this._x = 0;\n            this._y = 0;\n            this._x = x;\n            this._y = y;\n        }\n        /**\r\n     * A (0, 0) vector\r\n     */ static get Zero() {\n            return new Vector(0, 0);\n        }\n        /**\r\n     * A (1, 1) vector\r\n     */ static get One() {\n            return new Vector(1, 1);\n        }\n        /**\r\n     * A (0.5, 0.5) vector\r\n     */ static get Half() {\n            return new Vector(0.5, 0.5);\n        }\n        /**\r\n     * A unit vector pointing up (0, -1)\r\n     */ static get Up() {\n            return new Vector(0, -1);\n        }\n        /**\r\n     * A unit vector pointing down (0, 1)\r\n     */ static get Down() {\n            return new Vector(0, 1);\n        }\n        /**\r\n     * A unit vector pointing left (-1, 0)\r\n     */ static get Left() {\n            return new Vector(-1, 0);\n        }\n        /**\r\n     * A unit vector pointing right (1, 0)\r\n     */ static get Right() {\n            return new Vector(1, 0);\n        }\n        /**\r\n     * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n     * @param angle The angle to generate the vector\r\n     */ static fromAngle(angle) {\n            return new Vector(Math.cos(angle), Math.sin(angle));\n        }\n        /**\r\n     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n     */ static isValid(vec) {\n            if (vec === null || vec === undefined) return false;\n            if (isNaN(vec.x) || isNaN(vec.y)) return false;\n            if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) return false;\n            return true;\n        }\n        /**\r\n     * Calculates distance between two Vectors\r\n     * @param vec1\r\n     * @param vec2\r\n     */ static distance(vec1, vec2) {\n            return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\n        }\n        static min(vec1, vec2) {\n            return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));\n        }\n        static max(vec1, vec2) {\n            return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));\n        }\n        /**\r\n     * Get the x component of the vector\r\n     */ get x() {\n            return this._x;\n        }\n        /**\r\n     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n     */ set x(val) {\n            this._x = val;\n        }\n        /**\r\n     * Get the y component of the vector\r\n     */ get y() {\n            return this._y;\n        }\n        /**\r\n     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n     */ set y(val) {\n            this._y = val;\n        }\n        /**\r\n     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n     *\r\n     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**\r\n     */ setTo(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        /**\r\n     * Compares this point against another and tests for equality\r\n     * @param vector The other point to compare to\r\n     * @param tolerance Amount of euclidean distance off we are willing to tolerate\r\n     */ equals(vector, tolerance = 0.001) {\n            return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\n        }\n        /**\r\n     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n     * @param v  The other vector. Leave blank to use origin vector.\r\n     */ distance(v) {\n            if (!v) return Math.sqrt(this.x * this.x + this.y * this.y);\n            const deltaX = this.x - v.x;\n            const deltaY = this.y - v.y;\n            return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        }\n        squareDistance(v) {\n            if (!v) v = Vector.Zero;\n            const deltaX = this.x - v.x;\n            const deltaY = this.y - v.y;\n            return deltaX * deltaX + deltaY * deltaY;\n        }\n        /**\r\n     * Clamps the current vector's magnitude mutating it\r\n     * @param magnitude\r\n     */ clampMagnitude(magnitude) {\n            const size = this.size;\n            const newSize = clamp(size, 0, magnitude);\n            this.size = newSize;\n            return this;\n        }\n        /**\r\n     * The size (magnitude) of the Vector\r\n     */ get size() {\n            return this.distance();\n        }\n        /**\r\n     * Setting the size mutates the current vector\r\n     *\r\n     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**\r\n     */ set size(newLength) {\n            const v = this.normalize().scale(newLength);\n            this.setTo(v.x, v.y);\n        }\n        /**\r\n     * Normalizes a vector to have a magnitude of 1.\r\n     */ normalize() {\n            const d = this.distance();\n            if (d > 0) return new Vector(this.x / d, this.y / d);\n            else return new Vector(0, 1);\n        }\n        /**\r\n     * Returns the average (midpoint) between the current point and the specified\r\n     */ average(vec) {\n            return this.add(vec).scale(0.5);\n        }\n        scale(sizeOrScale, dest) {\n            const result = dest || new Vector(0, 0);\n            if (sizeOrScale instanceof Vector) {\n                result.x = this.x * sizeOrScale.x;\n                result.y = this.y * sizeOrScale.y;\n            } else {\n                result.x = this.x * sizeOrScale;\n                result.y = this.y * sizeOrScale;\n            }\n            return result;\n        }\n        /**\r\n     * Adds one vector to another\r\n     * @param v The vector to add\r\n     * @param dest Optionally copy the result into a provided vector\r\n     */ add(v, dest) {\n            if (dest) {\n                dest.x = this.x + v.x;\n                dest.y = this.y + v.y;\n                return dest;\n            }\n            return new Vector(this.x + v.x, this.y + v.y);\n        }\n        /**\r\n     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B\r\n     * @param v The vector to subtract\r\n     */ sub(v) {\n            return new Vector(this.x - v.x, this.y - v.y);\n        }\n        /**\r\n     * Adds one vector to this one modifying the original\r\n     * @param v The vector to add\r\n     * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n     */ addEqual(v) {\n            this.setTo(this.x + v.x, this.y + v.y);\n            return this;\n        }\n        /**\r\n     * Subtracts a vector from this one modifying the original\r\n     * @param v The vector to subtract\r\n     * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n     */ subEqual(v) {\n            this.setTo(this.x - v.x, this.y - v.y);\n            return this;\n        }\n        /**\r\n     * Scales this vector by a factor of size and modifies the original\r\n     * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n     */ scaleEqual(size) {\n            this.setTo(this.x * size, this.y * size);\n            return this;\n        }\n        /**\r\n     * Performs a dot product with another vector\r\n     * @param v  The vector to dot\r\n     */ dot(v) {\n            return this.x * v.x + this.y * v.y;\n        }\n        cross(v) {\n            if (v instanceof Vector) return this.x * v.y - this.y * v.x;\n            else if (typeof v === \"number\") return new Vector(v * this.y, -v * this.x);\n        }\n        static cross(num, vec) {\n            return new Vector(-num * vec.y, num * vec.x);\n        }\n        /**\r\n     * Returns the perpendicular vector to this one\r\n     */ perpendicular() {\n            return new Vector(this.y, -this.x);\n        }\n        /**\r\n     * Returns the normal vector to this one, same as the perpendicular of length 1\r\n     */ normal() {\n            return this.perpendicular().normalize();\n        }\n        /**\r\n     * Negate the current vector\r\n     */ negate() {\n            return this.scale(-1);\n        }\n        /**\r\n     * Returns the angle of this vector.\r\n     */ toAngle() {\n            return Math.atan2(this.y, this.x);\n        }\n        /**\r\n     * Rotates the current vector around a point by a certain number of\r\n     * degrees in radians\r\n     */ rotate(angle, anchor) {\n            if (!anchor) anchor = new Vector(0, 0);\n            const sinAngle = Math.sin(angle);\n            const cosAngle = Math.cos(angle);\n            const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\n            const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\n            return new Vector(x, y);\n        }\n        /**\r\n     * Creates new vector that has the same values as the previous.\r\n     */ clone(dest) {\n            const v = dest !== null && dest !== void 0 ? dest : new Vector(0, 0);\n            v.x = this.x;\n            v.y = this.y;\n            return v;\n        }\n        /**\r\n     * Returns a string representation of the vector.\r\n     */ toString(fixed) {\n            if (fixed) return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;\n            return `(${this.x}, ${this.y})`;\n        }\n    }\n    /**\r\n * Shorthand for creating new Vectors - returns a new Vector instance with the\r\n * provided X and Y components.\r\n *\r\n * @param x  X component of the Vector\r\n * @param y  Y component of the Vector\r\n */ function vec(x, y) {\n        return new Vector(x, y);\n    }\n    /* eslint-disable no-console */ /**\r\n * Logging level that Excalibur will tag\r\n */ var LogLevel;\n    (function(LogLevel) {\n        LogLevel[LogLevel[\"Debug\"] = 0] = \"Debug\";\n        LogLevel[LogLevel[\"Info\"] = 1] = \"Info\";\n        LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n        LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n        LogLevel[LogLevel[\"Fatal\"] = 4] = \"Fatal\";\n    })(LogLevel || (LogLevel = {}));\n    /**\r\n * Static singleton that represents the logging facility for Excalibur.\r\n * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n * Derive from [[Appender]] to create your own logging appenders.\r\n */ class Logger {\n        constructor(){\n            this._appenders = [];\n            /**\r\n         * Gets or sets the default logging level. Excalibur will only log\r\n         * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n         */ this.defaultLevel = LogLevel.Info;\n            if (Logger._INSTANCE) throw new Error(\"Logger is a singleton\");\n            Logger._INSTANCE = this;\n            // Default console appender\n            Logger._INSTANCE.addAppender(new ConsoleAppender());\n            return Logger._INSTANCE;\n        }\n        /**\r\n     * Gets the current static instance of Logger\r\n     */ static getInstance() {\n            if (Logger._INSTANCE == null) Logger._INSTANCE = new Logger();\n            return Logger._INSTANCE;\n        }\n        /**\r\n     * Adds a new [[Appender]] to the list of appenders to write to\r\n     */ addAppender(appender) {\n            this._appenders.push(appender);\n        }\n        /**\r\n     * Clears all appenders from the logger\r\n     */ clearAppenders() {\n            this._appenders.length = 0;\n        }\n        /**\r\n     * Logs a message at a given LogLevel\r\n     * @param level  The LogLevel`to log the message at\r\n     * @param args   An array of arguments to write to an appender\r\n     */ _log(level, args) {\n            if (level == null) level = this.defaultLevel;\n            const len = this._appenders.length;\n            for(let i = 0; i < len; i++)if (level >= this.defaultLevel) this._appenders[i].log(level, args);\n        }\n        /**\r\n     * Writes a log message at the [[LogLevel.Debug]] level\r\n     * @param args  Accepts any number of arguments\r\n     */ debug(...args) {\n            this._log(LogLevel.Debug, args);\n        }\n        /**\r\n     * Writes a log message at the [[LogLevel.Info]] level\r\n     * @param args  Accepts any number of arguments\r\n     */ info(...args) {\n            this._log(LogLevel.Info, args);\n        }\n        /**\r\n     * Writes a log message at the [[LogLevel.Warn]] level\r\n     * @param args  Accepts any number of arguments\r\n     */ warn(...args) {\n            this._log(LogLevel.Warn, args);\n        }\n        /**\r\n     * Writes a log message at the [[LogLevel.Error]] level\r\n     * @param args  Accepts any number of arguments\r\n     */ error(...args) {\n            this._log(LogLevel.Error, args);\n        }\n        /**\r\n     * Writes a log message at the [[LogLevel.Fatal]] level\r\n     * @param args  Accepts any number of arguments\r\n     */ fatal(...args) {\n            this._log(LogLevel.Fatal, args);\n        }\n    }\n    Logger._INSTANCE = null;\n    /**\r\n * Console appender for browsers (i.e. `console.log`)\r\n */ class ConsoleAppender {\n        /**\r\n     * Logs a message at the given [[LogLevel]]\r\n     * @param level  Level to log at\r\n     * @param args   Arguments to log\r\n     */ log(level, args) {\n            // Check for console support\n            if (!console && !console.log && console.warn && console.error) // todo maybe do something better than nothing\n            return;\n            // Create a new console args array\n            const consoleArgs = [];\n            consoleArgs.unshift.apply(consoleArgs, args);\n            consoleArgs.unshift(\"[\" + LogLevel[level] + \"] : \");\n            if (level < LogLevel.Warn) {\n                // Call .log for Debug/Info\n                if (console.log.apply) // this is required on some older browsers that don't support apply on console.log :(\n                console.log.apply(console, consoleArgs);\n                else console.log(consoleArgs.join(\" \"));\n            } else if (level < LogLevel.Error) {\n                // Call .warn for Warn\n                if (console.warn.apply) console.warn.apply(console, consoleArgs);\n                else console.warn(consoleArgs.join(\" \"));\n            } else // Call .error for Error/Fatal\n            if (console.error.apply) console.error.apply(console, consoleArgs);\n            else console.error(consoleArgs.join(\" \"));\n        }\n    }\n    /**\r\n * On-screen (canvas) appender\r\n */ class ScreenAppender {\n        /**\r\n     * @param width   Width of the screen appender in pixels\r\n     * @param height  Height of the screen appender in pixels\r\n     */ constructor(width, height){\n            // @todo Clean this up\n            this._messages = [];\n            this._canvas = document.createElement(\"canvas\");\n            this._canvas.width = width || window.innerWidth;\n            this._canvas.height = height || window.innerHeight;\n            this._canvas.style.position = \"absolute\";\n            // eslint-disable-next-line\n            this._ctx = this._canvas.getContext(\"2d\"); // eslint-disable-line\n            document.body.appendChild(this._canvas);\n        }\n        /**\r\n     * Logs a message at the given [[LogLevel]]\r\n     * @param level  Level to log at\r\n     * @param args   Arguments to log\r\n     */ log(level, args) {\n            const message = args.join(\",\");\n            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n            this._messages.unshift(\"[\" + LogLevel[level] + \"] : \" + message);\n            let pos = 10;\n            let opacity = 1.0;\n            for(let i = 0; i < this._messages.length; i++){\n                this._ctx.fillStyle = \"rgba(255,255,255,\" + opacity.toFixed(2) + \")\";\n                this._ctx.fillText(this._messages[i], 200, pos);\n                pos += 10;\n                opacity = opacity > 0 ? opacity - 0.05 : 0;\n            }\n        }\n    }\n    /**\r\n * Provides standard colors (e.g. [[Color.Black]])\r\n * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n */ class Color {\n        /**\r\n     * Creates a new instance of Color from an r, g, b, a\r\n     *\r\n     * @param r  The red component of color (0-255)\r\n     * @param g  The green component of color (0-255)\r\n     * @param b  The blue component of color (0-255)\r\n     * @param a  The alpha component of color (0-1.0)\r\n     */ constructor(r, g, b, a){\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a != null ? a : 1;\n        }\n        /**\r\n     * Creates a new instance of Color from an r, g, b, a\r\n     *\r\n     * @param r  The red component of color (0-255)\r\n     * @param g  The green component of color (0-255)\r\n     * @param b  The blue component of color (0-255)\r\n     * @param a  The alpha component of color (0-1.0)\r\n     */ static fromRGB(r, g, b, a) {\n            return new Color(r, g, b, a);\n        }\n        /**\r\n     * Creates a new instance of Color from a rgb string\r\n     *\r\n     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)\r\n     */ static fromRGBString(string) {\n            const rgbaRegEx = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/i;\n            let match = null;\n            if (match = string.match(rgbaRegEx)) {\n                const r = parseInt(match[1], 10);\n                const g = parseInt(match[2], 10);\n                const b = parseInt(match[3], 10);\n                let a = 1;\n                if (match[4]) a = parseFloat(match[4]);\n                return new Color(r, g, b, a);\n            } else throw new Error(\"Invalid rgb/a string: \" + string);\n        }\n        /**\r\n     * Creates a new instance of Color from a hex string\r\n     *\r\n     * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n     */ static fromHex(hex) {\n            const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\n            let match = null;\n            if (match = hex.match(hexRegEx)) {\n                const r = parseInt(match[1], 16);\n                const g = parseInt(match[2], 16);\n                const b = parseInt(match[3], 16);\n                let a = 1;\n                if (match[4]) a = parseInt(match[4], 16) / 255;\n                return new Color(r, g, b, a);\n            } else throw new Error(\"Invalid hex string: \" + hex);\n        }\n        /**\r\n     * Creates a new instance of Color from hsla values\r\n     *\r\n     * @param h  Hue is represented [0-1]\r\n     * @param s  Saturation is represented [0-1]\r\n     * @param l  Luminance is represented [0-1]\r\n     * @param a  Alpha is represented [0-1]\r\n     */ static fromHSL(h, s, l, a = 1.0) {\n            const temp = new HSLColor(h, s, l, a);\n            return temp.toRGBA();\n        }\n        /**\r\n     * Lightens the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to lighten by [0-1]\r\n     */ lighten(factor = 0.1) {\n            const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\n            temp.l += (1 - temp.l) * factor;\n            return temp.toRGBA();\n        }\n        /**\r\n     * Darkens the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to darken by [0-1]\r\n     */ darken(factor = 0.1) {\n            const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\n            temp.l -= temp.l * factor;\n            return temp.toRGBA();\n        }\n        /**\r\n     * Saturates the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to saturate by [0-1]\r\n     */ saturate(factor = 0.1) {\n            const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\n            temp.s += temp.s * factor;\n            return temp.toRGBA();\n        }\n        /**\r\n     * Desaturates the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to desaturate by [0-1]\r\n     */ desaturate(factor = 0.1) {\n            const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\n            temp.s -= temp.s * factor;\n            return temp.toRGBA();\n        }\n        /**\r\n     * Multiplies a color by another, results in a darker color\r\n     *\r\n     * @param color  The other color\r\n     */ multiply(color) {\n            const newR = color.r / 255 * this.r / 255 * 255;\n            const newG = color.g / 255 * this.g / 255 * 255;\n            const newB = color.b / 255 * this.b / 255 * 255;\n            const newA = color.a * this.a;\n            return new Color(newR, newG, newB, newA);\n        }\n        /**\r\n     * Screens a color by another, results in a lighter color\r\n     *\r\n     * @param color  The other color\r\n     */ screen(color) {\n            const color1 = color.invert();\n            const color2 = color.invert();\n            return color1.multiply(color2).invert();\n        }\n        /**\r\n     * Inverts the current color\r\n     */ invert() {\n            return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\n        }\n        /**\r\n     * Averages the current color with another\r\n     *\r\n     * @param color  The other color\r\n     */ average(color) {\n            const newR = (color.r + this.r) / 2;\n            const newG = (color.g + this.g) / 2;\n            const newB = (color.b + this.b) / 2;\n            const newA = (color.a + this.a) / 2;\n            return new Color(newR, newG, newB, newA);\n        }\n        equal(color) {\n            return this.toString() === color.toString();\n        }\n        /**\r\n     * Returns a CSS string representation of a color.\r\n     *\r\n     * @param format Color representation, accepts: rgb, hsl, or hex\r\n     */ toString(format = \"rgb\") {\n            switch(format){\n                case \"rgb\":\n                    return this.toRGBA();\n                case \"hsl\":\n                    return this.toHSLA();\n                case \"hex\":\n                    return this.toHex();\n                default:\n                    throw new Error(\"Invalid Color format\");\n            }\n        }\n        /**\r\n     * Returns Hex Value of a color component\r\n     * @param c color component\r\n     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n     */ _componentToHex(c) {\n            const hex = c.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        }\n        /**\r\n     * Return Hex representation of a color.\r\n     */ toHex() {\n            return \"#\" + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\n        }\n        /**\r\n     * Return RGBA representation of a color.\r\n     */ toRGBA() {\n            const result = String(this.r.toFixed(0)) + \", \" + String(this.g.toFixed(0)) + \", \" + String(this.b.toFixed(0));\n            if (this.a !== undefined || this.a !== null) return \"rgba(\" + result + \", \" + String(this.a) + \")\";\n            return \"rgb(\" + result + \")\";\n        }\n        /**\r\n     * Return HSLA representation of a color.\r\n     */ toHSLA() {\n            return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\n        }\n        /**\r\n     * Returns a CSS string representation of a color.\r\n     */ fillStyle() {\n            return this.toString();\n        }\n        /**\r\n     * Returns a clone of the current color.\r\n     */ clone() {\n            return new Color(this.r, this.g, this.b, this.a);\n        }\n        /**\r\n     * Black (#000000)\r\n     */ static get Black() {\n            return Color.fromHex(\"#000000\");\n        }\n        /**\r\n     * White (#FFFFFF)\r\n     */ static get White() {\n            return Color.fromHex(\"#FFFFFF\");\n        }\n        /**\r\n     * Gray (#808080)\r\n     */ static get Gray() {\n            return Color.fromHex(\"#808080\");\n        }\n        /**\r\n     * Light gray (#D3D3D3)\r\n     */ static get LightGray() {\n            return Color.fromHex(\"#D3D3D3\");\n        }\n        /**\r\n     * Dark gray (#A9A9A9)\r\n     */ static get DarkGray() {\n            return Color.fromHex(\"#A9A9A9\");\n        }\n        /**\r\n     * Yellow (#FFFF00)\r\n     */ static get Yellow() {\n            return Color.fromHex(\"#FFFF00\");\n        }\n        /**\r\n     * Orange (#FFA500)\r\n     */ static get Orange() {\n            return Color.fromHex(\"#FFA500\");\n        }\n        /**\r\n     * Red (#FF0000)\r\n     */ static get Red() {\n            return Color.fromHex(\"#FF0000\");\n        }\n        /**\r\n     * Vermilion (#FF5B31)\r\n     */ static get Vermilion() {\n            return Color.fromHex(\"#FF5B31\");\n        }\n        /**\r\n     * Rose (#FF007F)\r\n     */ static get Rose() {\n            return Color.fromHex(\"#FF007F\");\n        }\n        /**\r\n     * Magenta (#FF00FF)\r\n     */ static get Magenta() {\n            return Color.fromHex(\"#FF00FF\");\n        }\n        /**\r\n     * Violet (#7F00FF)\r\n     */ static get Violet() {\n            return Color.fromHex(\"#7F00FF\");\n        }\n        /**\r\n     * Blue (#0000FF)\r\n     */ static get Blue() {\n            return Color.fromHex(\"#0000FF\");\n        }\n        /**\r\n     * Azure (#007FFF)\r\n     */ static get Azure() {\n            return Color.fromHex(\"#007FFF\");\n        }\n        /**\r\n     * Cyan (#00FFFF)\r\n     */ static get Cyan() {\n            return Color.fromHex(\"#00FFFF\");\n        }\n        /**\r\n     * Viridian (#59978F)\r\n     */ static get Viridian() {\n            return Color.fromHex(\"#59978F\");\n        }\n        /**\r\n     * Green (#00FF00)\r\n     */ static get Green() {\n            return Color.fromHex(\"#00FF00\");\n        }\n        /**\r\n     * Chartreuse (#7FFF00)\r\n     */ static get Chartreuse() {\n            return Color.fromHex(\"#7FFF00\");\n        }\n        /**\r\n     * Transparent (#FFFFFF00)\r\n     */ static get Transparent() {\n            return Color.fromHex(\"#FFFFFF00\");\n        }\n        /**\r\n     * ExcaliburBlue (#176BAA)\r\n     */ static get ExcaliburBlue() {\n            return Color.fromHex(\"#176BAA\");\n        }\n    }\n    /**\r\n * Internal HSL Color representation\r\n *\r\n * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n */ class HSLColor {\n        constructor(h, s, l, a){\n            this.h = h;\n            this.s = s;\n            this.l = l;\n            this.a = a;\n        }\n        static hue2rgb(p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 0.5) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        }\n        static fromRGBA(r, g, b, a) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            const max = Math.max(r, g, b), min = Math.min(r, g, b);\n            let h, s;\n            const l = (max + min) / 2;\n            if (max === min) h = s = 0; // achromatic\n            else {\n                const d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return new HSLColor(h, s, l, a);\n        }\n        toRGBA() {\n            let r, g, b;\n            if (this.s === 0) r = g = b = this.l; // achromatic\n            else {\n                const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\n                const p = 2 * this.l - q;\n                r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\n                g = HSLColor.hue2rgb(p, q, this.h);\n                b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\n            }\n            return new Color(r * 255, g * 255, b * 255, this.a);\n        }\n        toString() {\n            const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);\n            return `hsla(${h}, ${s}, ${l}, ${a})`;\n        }\n    }\n    /**\r\n * An enum that describes the sides of an axis aligned box for collision\r\n */ var Side;\n    (function(Side) {\n        Side[\"None\"] = \"None\";\n        Side[\"Top\"] = \"Top\";\n        Side[\"Bottom\"] = \"Bottom\";\n        Side[\"Left\"] = \"Left\";\n        Side[\"Right\"] = \"Right\";\n    })(Side || (Side = {}));\n    (function(Side) {\n        /**\r\n     * Returns the opposite side from the current\r\n     */ function getOpposite(side) {\n            if (side === Side.Top) return Side.Bottom;\n            if (side === Side.Bottom) return Side.Top;\n            if (side === Side.Left) return Side.Right;\n            if (side === Side.Right) return Side.Left;\n            return Side.None;\n        }\n        Side.getOpposite = getOpposite;\n        /**\r\n     * Given a vector, return the Side most in that direction (via dot product)\r\n     */ function fromDirection(direction) {\n            const directions = [\n                Vector.Left,\n                Vector.Right,\n                Vector.Up,\n                Vector.Down\n            ];\n            const directionEnum = [\n                Side.Left,\n                Side.Right,\n                Side.Top,\n                Side.Bottom\n            ];\n            let max = -Number.MAX_VALUE;\n            let maxIndex = -1;\n            for(let i = 0; i < directions.length; i++)if (directions[i].dot(direction) > max) {\n                max = directions[i].dot(direction);\n                maxIndex = i;\n            }\n            return directionEnum[maxIndex];\n        }\n        Side.fromDirection = fromDirection;\n    })(Side || (Side = {}));\n    /**\r\n * Axis Aligned collision primitive for Excalibur.\r\n */ class BoundingBox {\n        /**\r\n     * Constructor allows passing of either an object with all coordinate components,\r\n     * or the coordinate components passed separately.\r\n     * @param leftOrOptions    Either x coordinate of the left edge or an options object\r\n     * containing the four coordinate components.\r\n     * @param top     y coordinate of the top edge\r\n     * @param right   x coordinate of the right edge\r\n     * @param bottom  y coordinate of the bottom edge\r\n     */ constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0){\n            if (typeof leftOrOptions === \"object\") {\n                this.left = leftOrOptions.left;\n                this.top = leftOrOptions.top;\n                this.right = leftOrOptions.right;\n                this.bottom = leftOrOptions.bottom;\n            } else if (typeof leftOrOptions === \"number\") {\n                this.left = leftOrOptions;\n                this.top = top;\n                this.right = right;\n                this.bottom = bottom;\n            }\n        }\n        /**\r\n     * Returns a new instance of [[BoundingBox]] that is a copy of the current instance\r\n     */ clone() {\n            return new BoundingBox(this.left, this.top, this.right, this.bottom);\n        }\n        /**\r\n     * Given bounding box A & B, returns the side relative to A when intersection is performed.\r\n     * @param intersection Intersection vector between 2 bounding boxes\r\n     */ static getSideFromIntersection(intersection) {\n            if (!intersection) return Side.None;\n            if (intersection) {\n                if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\n                    if (intersection.x < 0) return Side.Right;\n                    return Side.Left;\n                } else {\n                    if (intersection.y < 0) return Side.Bottom;\n                    return Side.Top;\n                }\n            }\n            return Side.None;\n        }\n        static fromPoints(points) {\n            let minX = Infinity;\n            let minY = Infinity;\n            let maxX = -Infinity;\n            let maxY = -Infinity;\n            for(let i = 0; i < points.length; i++){\n                if (points[i].x < minX) minX = points[i].x;\n                if (points[i].x > maxX) maxX = points[i].x;\n                if (points[i].y < minY) minY = points[i].y;\n                if (points[i].y > maxY) maxY = points[i].y;\n            }\n            return new BoundingBox(minX, minY, maxX, maxY);\n        }\n        static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {\n            return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);\n        }\n        /**\r\n     * Returns the calculated width of the bounding box\r\n     */ get width() {\n            return this.right - this.left;\n        }\n        /**\r\n     * Returns the calculated height of the bounding box\r\n     */ get height() {\n            return this.bottom - this.top;\n        }\n        /**\r\n     * Return whether the bounding box has zero dimensions in height,width or both\r\n     */ hasZeroDimensions() {\n            return this.width === 0 || this.height === 0;\n        }\n        /**\r\n     * Returns the center of the bounding box\r\n     */ get center() {\n            return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);\n        }\n        translate(pos) {\n            return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);\n        }\n        /**\r\n     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding\r\n     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.\r\n     */ rotate(angle, point = Vector.Zero) {\n            const points = this.getPoints().map((p)=>p.rotate(angle, point));\n            return BoundingBox.fromPoints(points);\n        }\n        /**\r\n     * Scale a bounding box by a scale factor, optionally provide a point\r\n     * @param scale\r\n     * @param point\r\n     */ scale(scale, point = Vector.Zero) {\n            const shifted = this.translate(point);\n            return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);\n        }\n        /**\r\n     * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box\r\n     * @param matrix\r\n     */ transform(matrix) {\n            // inlined these calculations to not use vectors would speed it up slightly\n            // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);\n            // const xa = matFirstColumn.scale(this.left);\n            const xa1 = matrix.data[0] * this.left;\n            const xa2 = matrix.data[1] * this.left;\n            // const xb = matFirstColumn.scale(this.right);\n            const xb1 = matrix.data[0] * this.right;\n            const xb2 = matrix.data[1] * this.right;\n            // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);\n            // const ya = matSecondColumn.scale(this.top);\n            const ya1 = matrix.data[2] * this.top;\n            const ya2 = matrix.data[3] * this.top;\n            // const yb = matSecondColumn.scale(this.bottom);\n            const yb1 = matrix.data[2] * this.bottom;\n            const yb2 = matrix.data[3] * this.bottom;\n            const matrixPos = matrix.getPosition();\n            // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);\n            // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);\n            const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;\n            const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;\n            const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;\n            const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;\n            return new BoundingBox({\n                left: left,\n                top: top,\n                right: right,\n                bottom: bottom //: bottomRight.y\n            });\n        }\n        /**\r\n     * Returns the perimeter of the bounding box\r\n     */ getPerimeter() {\n            const wx = this.width;\n            const wy = this.height;\n            return 2 * (wx + wy);\n        }\n        getPoints() {\n            const results = [];\n            results.push(new Vector(this.left, this.top));\n            results.push(new Vector(this.right, this.top));\n            results.push(new Vector(this.right, this.bottom));\n            results.push(new Vector(this.left, this.bottom));\n            return results;\n        }\n        /**\r\n     * Determines whether a ray intersects with a bounding box\r\n     */ rayCast(ray, farClipDistance = Infinity) {\n            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\n            let tmin = -Infinity;\n            let tmax = Infinity;\n            const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\n            const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\n            const tx1 = (this.left - ray.pos.x) * xinv;\n            const tx2 = (this.right - ray.pos.x) * xinv;\n            tmin = Math.min(tx1, tx2);\n            tmax = Math.max(tx1, tx2);\n            const ty1 = (this.top - ray.pos.y) * yinv;\n            const ty2 = (this.bottom - ray.pos.y) * yinv;\n            tmin = Math.max(tmin, Math.min(ty1, ty2));\n            tmax = Math.min(tmax, Math.max(ty1, ty2));\n            return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\n        }\n        rayCastTime(ray, farClipDistance = Infinity) {\n            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\n            let tmin = -Infinity;\n            let tmax = Infinity;\n            const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\n            const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\n            const tx1 = (this.left - ray.pos.x) * xinv;\n            const tx2 = (this.right - ray.pos.x) * xinv;\n            tmin = Math.min(tx1, tx2);\n            tmax = Math.max(tx1, tx2);\n            const ty1 = (this.top - ray.pos.y) * yinv;\n            const ty2 = (this.bottom - ray.pos.y) * yinv;\n            tmin = Math.max(tmin, Math.min(ty1, ty2));\n            tmax = Math.min(tmax, Math.max(ty1, ty2));\n            if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) return tmin;\n            return -1;\n        }\n        contains(val) {\n            if (val instanceof Vector) return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;\n            else if (val instanceof BoundingBox) {\n                if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) return true;\n                return false;\n            }\n            return false;\n        }\n        /**\r\n     * Combines this bounding box and another together returning a new bounding box\r\n     * @param other  The bounding box to combine\r\n     */ combine(other) {\n            const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));\n            return compositeBB;\n        }\n        get dimensions() {\n            return new Vector(this.width, this.height);\n        }\n        /**\r\n     * Returns true if the bounding boxes overlap.\r\n     * @param other\r\n     * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.\r\n     * This epsilon is useful in stable collision simulations.\r\n     */ overlaps(other, epsilon) {\n            const e = epsilon || 0;\n            if (other.hasZeroDimensions()) return this.contains(other);\n            if (this.hasZeroDimensions()) return other.contains(this);\n            const totalBoundingBox = this.combine(other);\n            return totalBoundingBox.width + e < other.width + this.width && totalBoundingBox.height + e < other.height + this.height;\n        }\n        /**\r\n     * Test wether this bounding box intersects with another returning\r\n     * the intersection vector that can be used to resolve the collision. If there\r\n     * is no intersection null is returned.\r\n     *\r\n     * @param other  Other [[BoundingBox]] to test intersection with\r\n     * @returns A Vector in the direction of the current BoundingBox, this <- other\r\n     */ intersect(other) {\n            const totalBoundingBox = this.combine(other);\n            // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision\n            if (totalBoundingBox.width < other.width + this.width && totalBoundingBox.height < other.height + this.height && !totalBoundingBox.dimensions.equals(other.dimensions) && !totalBoundingBox.dimensions.equals(this.dimensions)) {\n                // collision\n                let overlapX = 0;\n                // right edge is between the other's left and right edge\n                /**\r\n             *     +-this-+\r\n             *     |      |\r\n             *     |    +-other-+\r\n             *     +----|-+     |\r\n             *          |       |\r\n             *          +-------+\r\n             *         <---\r\n             *          ^ overlap\r\n             */ if (this.right >= other.left && this.right <= other.right) overlapX = other.left - this.right;\n                else overlapX = other.right - this.left;\n                let overlapY = 0;\n                // top edge is between the other's top and bottom edge\n                /**\r\n             *     +-other-+\r\n             *     |       |\r\n             *     |    +-this-+   | <- overlap\r\n             *     +----|--+   |   |\r\n             *          |      |  \\ /\r\n             *          +------+   '\r\n             */ if (this.top <= other.bottom && this.top >= other.top) overlapY = other.bottom - this.top;\n                else overlapY = other.top - this.bottom;\n                if (Math.abs(overlapX) < Math.abs(overlapY)) return new Vector(overlapX, 0);\n                else return new Vector(0, overlapY);\n            // Case of total containment of one bounding box by another\n            } else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {\n                let overlapX = 0;\n                // this is wider than the other\n                if (this.width - other.width >= 0) {\n                    // This right edge is closest to the others right edge\n                    if (this.right - other.right <= other.left - this.left) overlapX = other.left - this.right;\n                    else overlapX = other.right - this.left;\n                } else // This right edge is closest to the others right edge\n                if (other.right - this.right <= this.left - other.left) overlapX = this.left - other.right;\n                else overlapX = this.right - other.left;\n                let overlapY = 0;\n                // this is taller than other\n                if (this.height - other.height >= 0) {\n                    // The bottom edge is closest to the others bottom edge\n                    if (this.bottom - other.bottom <= other.top - this.top) overlapY = other.top - this.bottom;\n                    else overlapY = other.bottom - this.top;\n                } else // The bottom edge is closest to the others bottom edge\n                if (other.bottom - this.bottom <= this.top - other.top) overlapY = this.top - other.bottom;\n                else overlapY = this.bottom - other.top;\n                if (Math.abs(overlapX) < Math.abs(overlapY)) return new Vector(overlapX, 0);\n                else return new Vector(0, overlapY);\n            } else return null;\n        }\n        /**\r\n     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.\r\n     * @param bb The other actor to test\r\n     */ intersectWithSide(bb) {\n            const intersect = this.intersect(bb);\n            return BoundingBox.getSideFromIntersection(intersect);\n        }\n        /**\r\n     * Draw a debug bounding box\r\n     * @param ex\r\n     * @param color\r\n     */ draw(ex, color = Color.Yellow) {\n            ex.debug.drawRect(this.left, this.top, this.width, this.height, {\n                color: color\n            });\n        }\n    }\n    /**\r\n * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time\r\n */ class Future {\n        constructor(){\n            this._isCompleted = false;\n            this.promise = new Promise((resolve, reject)=>{\n                this._resolver = resolve;\n                this._rejecter = reject;\n            });\n        }\n        get isCompleted() {\n            return this._isCompleted;\n        }\n        resolve(value) {\n            if (this._isCompleted) return;\n            this._isCompleted = true;\n            this._resolver(value);\n        }\n        reject(error) {\n            if (this._isCompleted) return;\n            this._isCompleted = true;\n            this._rejecter(error);\n        }\n    }\n    /**\r\n * Find the screen position of an HTML element\r\n */ function getPosition(el) {\n        let oLeft = 0, oTop = 0;\n        const calcOffsetLeft = (parent)=>{\n            oLeft += parent.offsetLeft;\n            if (parent.offsetParent) calcOffsetLeft(parent.offsetParent);\n        };\n        const calcOffsetTop = (parent)=>{\n            oTop += parent.offsetTop;\n            if (parent.offsetParent) calcOffsetTop(parent.offsetParent);\n        };\n        calcOffsetLeft(el);\n        calcOffsetTop(el);\n        return new Vector(oLeft, oTop);\n    }\n    /**\r\n * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.\r\n * @deprecated Will be removed in v0.26.0\r\n */ function addItemToArray(item, array) {\n        if (array.indexOf(item) === -1) {\n            array.push(item);\n            return true;\n        }\n        return false;\n    }\n    /**\r\n * Remove an item from an list\r\n * @deprecated Will be removed in v0.26.0\r\n */ function removeItemFromArray(item, array) {\n        let index = -1;\n        if ((index = array.indexOf(item)) > -1) {\n            array.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\r\n * See if an array contains something\r\n */ function contains(array, obj) {\n        for(let i = 0; i < array.length; i++){\n            if (array[i] === obj) return true;\n        }\n        return false;\n    }\n    /**\r\n * Used for exhaustive checks at compile time\r\n */ function fail(message) {\n        throw new Error(message);\n    }\n    /**\r\n * Create a promise that resolves after a certain number of milliseconds\r\n *\r\n * It is strongly recommended you pass the excalibur clock so delays are bound to the\r\n * excalibur clock which would be unaffected by stop/pause.\r\n * @param milliseconds\r\n * @param clock\r\n */ function delay(milliseconds, clock) {\n        var _a;\n        const future = new Future();\n        const schedule = (_a = clock === null || clock === void 0 ? void 0 : clock.schedule.bind(clock)) !== null && _a !== void 0 ? _a : setTimeout;\n        schedule(()=>{\n            future.resolve();\n        }, milliseconds);\n        return future.promise;\n    }\n    var MatrixLocations;\n    (function(MatrixLocations) {\n        MatrixLocations[MatrixLocations[\"X\"] = 12] = \"X\";\n        MatrixLocations[MatrixLocations[\"Y\"] = 13] = \"Y\";\n    })(MatrixLocations || (MatrixLocations = {}));\n    /**\r\n * Excalibur Matrix helper for 4x4 matrices\r\n *\r\n * Useful for webgl 4x4 matrices\r\n */ class Matrix {\n        constructor(){\n            /**\r\n         *  4x4 matrix in column major order\r\n         *\r\n         * |         |         |          |          |\r\n         * | ------- | ------- | -------- | -------- |\r\n         * | data[0] | data[4] | data[8]  | data[12] |\r\n         * | data[1] | data[5] | data[9]  | data[13] |\r\n         * | data[2] | data[6] | data[10] | data[14] |\r\n         * | data[3] | data[7] | data[11] | data[15] |\r\n         *\r\n         */ this.data = new Float32Array(16);\n            this._scaleX = 1;\n            this._scaleSignX = 1;\n            this._scaleY = 1;\n            this._scaleSignY = 1;\n        }\n        /**\r\n     * Creates an orthographic (flat non-perspective) projection\r\n     * https://en.wikipedia.org/wiki/Orthographic_projection\r\n     * @param left\r\n     * @param right\r\n     * @param bottom\r\n     * @param top\r\n     * @param near\r\n     * @param far\r\n     */ static ortho(left, right, bottom, top, near, far) {\n            const mat = new Matrix();\n            mat.data[0] = 2 / (right - left);\n            mat.data[1] = 0;\n            mat.data[2] = 0;\n            mat.data[3] = 0;\n            mat.data[4] = 0;\n            mat.data[5] = 2 / (top - bottom);\n            mat.data[6] = 0;\n            mat.data[7] = 0;\n            mat.data[8] = 0;\n            mat.data[9] = 0;\n            mat.data[10] = -2 / (far - near);\n            mat.data[11] = 0;\n            mat.data[12] = -(right + left) / (right - left);\n            mat.data[13] = -(top + bottom) / (top - bottom);\n            mat.data[14] = -(far + near) / (far - near);\n            mat.data[15] = 1;\n            return mat;\n        }\n        /**\r\n     * Creates a new Matrix with the same data as the current 4x4\r\n     */ clone(dest) {\n            const mat = dest || new Matrix();\n            mat.data[0] = this.data[0];\n            mat.data[1] = this.data[1];\n            mat.data[2] = this.data[2];\n            mat.data[3] = this.data[3];\n            mat.data[4] = this.data[4];\n            mat.data[5] = this.data[5];\n            mat.data[6] = this.data[6];\n            mat.data[7] = this.data[7];\n            mat.data[8] = this.data[8];\n            mat.data[9] = this.data[9];\n            mat.data[10] = this.data[10];\n            mat.data[11] = this.data[11];\n            mat.data[12] = this.data[12];\n            mat.data[13] = this.data[13];\n            mat.data[14] = this.data[14];\n            mat.data[15] = this.data[15];\n            return mat;\n        }\n        /**\r\n     * Converts the current matrix into a DOMMatrix\r\n     *\r\n     * This is useful when working with the browser Canvas context\r\n     * @returns {DOMMatrix} DOMMatrix\r\n     */ toDOMMatrix() {\n            return new DOMMatrix([\n                ...this.data\n            ]);\n        }\n        static fromFloat32Array(data) {\n            const matrix = new Matrix();\n            matrix.data = data;\n            return matrix;\n        }\n        /**\r\n     * Creates a new identity matrix (a matrix that when applied does nothing)\r\n     */ static identity() {\n            const mat = new Matrix();\n            mat.data[0] = 1;\n            mat.data[1] = 0;\n            mat.data[2] = 0;\n            mat.data[3] = 0;\n            mat.data[4] = 0;\n            mat.data[5] = 1;\n            mat.data[6] = 0;\n            mat.data[7] = 0;\n            mat.data[8] = 0;\n            mat.data[9] = 0;\n            mat.data[10] = 1;\n            mat.data[11] = 0;\n            mat.data[12] = 0;\n            mat.data[13] = 0;\n            mat.data[14] = 0;\n            mat.data[15] = 1;\n            return mat;\n        }\n        /**\r\n     * Resets the current matrix to the identity matrix, mutating it\r\n     * @returns {Matrix} Current matrix as identity\r\n     */ reset() {\n            const mat = this;\n            mat.data[0] = 1;\n            mat.data[1] = 0;\n            mat.data[2] = 0;\n            mat.data[3] = 0;\n            mat.data[4] = 0;\n            mat.data[5] = 1;\n            mat.data[6] = 0;\n            mat.data[7] = 0;\n            mat.data[8] = 0;\n            mat.data[9] = 0;\n            mat.data[10] = 1;\n            mat.data[11] = 0;\n            mat.data[12] = 0;\n            mat.data[13] = 0;\n            mat.data[14] = 0;\n            mat.data[15] = 1;\n            return mat;\n        }\n        /**\r\n     * Creates a brand new translation matrix at the specified 3d point\r\n     * @param x\r\n     * @param y\r\n     */ static translation(x, y) {\n            const mat = Matrix.identity();\n            mat.data[12] = x;\n            mat.data[13] = y;\n            return mat;\n        }\n        /**\r\n     * Creates a brand new scaling matrix with the specified scaling factor\r\n     * @param sx\r\n     * @param sy\r\n     */ static scale(sx, sy) {\n            const mat = Matrix.identity();\n            mat.data[0] = sx;\n            mat.data[5] = sy;\n            mat.data[10] = 1;\n            mat.data[15] = 1;\n            return mat;\n        }\n        /**\r\n     * Creates a brand new rotation matrix with the specified angle\r\n     * @param angleRadians\r\n     */ static rotation(angleRadians) {\n            const mat = Matrix.identity();\n            mat.data[0] = Math.cos(angleRadians);\n            mat.data[4] = -Math.sin(angleRadians);\n            mat.data[1] = Math.sin(angleRadians);\n            mat.data[5] = Math.cos(angleRadians);\n            return mat;\n        }\n        multiply(vectorOrMatrix, dest) {\n            if (vectorOrMatrix instanceof Vector) {\n                const result = dest || new Vector(0, 0);\n                const vector = vectorOrMatrix;\n                // these shenanigans are to allow dest and vector to be the same instance\n                const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];\n                const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];\n                result.x = resultX;\n                result.y = resultY;\n                return result;\n            } else {\n                const result = dest || new Matrix();\n                const other = vectorOrMatrix;\n                const a11 = this.data[0];\n                const a21 = this.data[1];\n                const a31 = this.data[2];\n                const a41 = this.data[3];\n                const a12 = this.data[4];\n                const a22 = this.data[5];\n                const a32 = this.data[6];\n                const a42 = this.data[7];\n                const a13 = this.data[8];\n                const a23 = this.data[9];\n                const a33 = this.data[10];\n                const a43 = this.data[11];\n                const a14 = this.data[12];\n                const a24 = this.data[13];\n                const a34 = this.data[14];\n                const a44 = this.data[15];\n                const b11 = other.data[0];\n                const b21 = other.data[1];\n                const b31 = other.data[2];\n                const b41 = other.data[3];\n                const b12 = other.data[4];\n                const b22 = other.data[5];\n                const b32 = other.data[6];\n                const b42 = other.data[7];\n                const b13 = other.data[8];\n                const b23 = other.data[9];\n                const b33 = other.data[10];\n                const b43 = other.data[11];\n                const b14 = other.data[12];\n                const b24 = other.data[13];\n                const b34 = other.data[14];\n                const b44 = other.data[15];\n                result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n                result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n                result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n                result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n                result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n                result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n                result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n                result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n                result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n                result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n                result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n                result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n                result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n                result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n                result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n                result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n                const s = this.getScale();\n                result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\n                result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\n                return result;\n            }\n        }\n        /**\r\n     * Applies translation to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */ translate(x, y) {\n            const a11 = this.data[0];\n            const a21 = this.data[1];\n            const a31 = this.data[2];\n            const a41 = this.data[3];\n            const a12 = this.data[4];\n            const a22 = this.data[5];\n            const a32 = this.data[6];\n            const a42 = this.data[7];\n            const a13 = this.data[8];\n            const a23 = this.data[9];\n            const a33 = this.data[10];\n            const a43 = this.data[11];\n            const a14 = this.data[12];\n            const a24 = this.data[13];\n            const a34 = this.data[14];\n            const a44 = this.data[15];\n            // Doesn't change z\n            const z = 0;\n            const w = 1;\n            this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;\n            this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;\n            this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;\n            this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;\n            return this;\n        }\n        setPosition(x, y) {\n            this.data[12] = x;\n            this.data[13] = y;\n        }\n        getPosition() {\n            return vec(this.data[12], this.data[13]);\n        }\n        /**\r\n     * Applies rotation to the current matrix mutating it\r\n     * @param angle in Radians\r\n     */ rotate(angle) {\n            const a11 = this.data[0];\n            const a21 = this.data[1];\n            const a31 = this.data[2];\n            const a41 = this.data[3];\n            const a12 = this.data[4];\n            const a22 = this.data[5];\n            const a32 = this.data[6];\n            const a42 = this.data[7];\n            const sine = Math.sin(angle);\n            const cosine = Math.cos(angle);\n            this.data[0] = cosine * a11 + sine * a12;\n            this.data[1] = cosine * a21 + sine * a22;\n            this.data[2] = cosine * a31 + sine * a32;\n            this.data[3] = cosine * a41 + sine * a42;\n            this.data[4] = cosine * a12 - sine * a11;\n            this.data[5] = cosine * a22 - sine * a21;\n            this.data[6] = cosine * a32 - sine * a31;\n            this.data[7] = cosine * a42 - sine * a41;\n            return this;\n        }\n        /**\r\n     * Applies scaling to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */ scale(x, y) {\n            const a11 = this.data[0];\n            const a21 = this.data[1];\n            const a31 = this.data[2];\n            const a41 = this.data[3];\n            const a12 = this.data[4];\n            const a22 = this.data[5];\n            const a32 = this.data[6];\n            const a42 = this.data[7];\n            this.data[0] = a11 * x;\n            this.data[1] = a21 * x;\n            this.data[2] = a31 * x;\n            this.data[3] = a41 * x;\n            this.data[4] = a12 * y;\n            this.data[5] = a22 * y;\n            this.data[6] = a32 * y;\n            this.data[7] = a42 * y;\n            return this;\n        }\n        setRotation(angle) {\n            const currentScale = this.getScale();\n            const sine = Math.sin(angle);\n            const cosine = Math.cos(angle);\n            this.data[0] = cosine * currentScale.x;\n            this.data[1] = sine * currentScale.y;\n            this.data[4] = -sine * currentScale.x;\n            this.data[5] = cosine * currentScale.y;\n        }\n        getRotation() {\n            const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\n            return canonicalizeAngle(angle);\n        }\n        getScaleX() {\n            // absolute scale of the matrix (we lose sign so need to add it back)\n            const xscale = vec(this.data[0], this.data[4]).size;\n            return this._scaleSignX * xscale;\n        }\n        getScaleY() {\n            // absolute scale of the matrix (we lose sign so need to add it back)\n            const yscale = vec(this.data[1], this.data[5]).size;\n            return this._scaleSignY * yscale;\n        }\n        /**\r\n     * Get the scale of the matrix\r\n     */ getScale() {\n            return vec(this.getScaleX(), this.getScaleY());\n        }\n        setScaleX(val) {\n            if (this._scaleX === val) return;\n            this._scaleSignX = sign(val);\n            // negative scale acts like a 180 rotation, so flip\n            const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();\n            this.data[0] = xscale.x * val;\n            this.data[4] = xscale.y * val;\n            this._scaleX = val;\n        }\n        setScaleY(val) {\n            if (this._scaleY === val) return;\n            this._scaleSignY = sign(val);\n            // negative scale acts like a 180 rotation, so flip\n            const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();\n            this.data[1] = yscale.x * val;\n            this.data[5] = yscale.y * val;\n            this._scaleY = val;\n        }\n        setScale(scale) {\n            this.setScaleX(scale.x);\n            this.setScaleY(scale.y);\n        }\n        /**\r\n     * Determinant of the upper left 2x2 matrix\r\n     */ getBasisDeterminant() {\n            return this.data[0] * this.data[5] - this.data[1] * this.data[4];\n        }\n        /**\r\n     * Return the affine inverse, optionally store it in a target matrix.\r\n     *\r\n     * It's recommended you call .reset() the target unless you know what you're doing\r\n     * @param target\r\n     */ getAffineInverse(target) {\n            // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\n            // See https://www.mathsisfun.com/algebra/matrix-inverse.html\n            // Since we are actually only doing 2D transformations we can use this hack\n            // We don't actually use the 3rd or 4th dimension\n            const det = this.getBasisDeterminant();\n            const inverseDet = 1 / det; // todo zero check\n            const a = this.data[0];\n            const b = this.data[4];\n            const c = this.data[1];\n            const d = this.data[5];\n            const m = target || Matrix.identity();\n            // inverts rotation and scale\n            m.data[0] = d * inverseDet;\n            m.data[1] = -c * inverseDet;\n            m.data[4] = -b * inverseDet;\n            m.data[5] = a * inverseDet;\n            const tx = this.data[12];\n            const ty = this.data[13];\n            // invert translation\n            // transform translation into the matrix basis created by rot/scale\n            m.data[12] = -(tx * m.data[0] + ty * m.data[4]);\n            m.data[13] = -(tx * m.data[1] + ty * m.data[5]);\n            return m;\n        }\n        isIdentity() {\n            return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 0 && this.data[4] === 0 && this.data[5] === 1 && this.data[6] === 0 && this.data[7] === 0 && this.data[8] === 0 && this.data[9] === 0 && this.data[10] === 1 && this.data[11] === 0 && this.data[12] === 0 && this.data[13] === 0 && this.data[14] === 0 && this.data[15] === 1;\n        }\n        toString() {\n            return `\r\n[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]\r\n[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]\r\n[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]\r\n[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]\r\n`;\n        }\n    }\n    class AffineMatrix {\n        constructor(){\n            /**\r\n         * |         |         |          |\r\n         * | ------- | ------- | -------- |\r\n         * | data[0] | data[2] | data[4]  |\r\n         * | data[1] | data[3] | data[5]  |\r\n         * |   0     |    0    |    1     |\r\n         */ this.data = new Float64Array(6);\n            this._scale = new Float64Array([\n                1,\n                1\n            ]);\n            this._scaleSignX = 1;\n            this._scaleSignY = 1;\n        }\n        /**\r\n     * Converts the current matrix into a DOMMatrix\r\n     *\r\n     * This is useful when working with the browser Canvas context\r\n     * @returns {DOMMatrix} DOMMatrix\r\n     */ toDOMMatrix() {\n            return new DOMMatrix([\n                ...this.data\n            ]);\n        }\n        static identity() {\n            const mat = new AffineMatrix();\n            mat.data[0] = 1;\n            mat.data[1] = 0;\n            mat.data[2] = 0;\n            mat.data[3] = 1;\n            mat.data[4] = 0;\n            mat.data[5] = 0;\n            return mat;\n        }\n        /**\r\n     * Creates a brand new translation matrix at the specified 3d point\r\n     * @param x\r\n     * @param y\r\n     */ static translation(x, y) {\n            const mat = AffineMatrix.identity();\n            mat.data[4] = x;\n            mat.data[5] = y;\n            return mat;\n        }\n        /**\r\n     * Creates a brand new scaling matrix with the specified scaling factor\r\n     * @param sx\r\n     * @param sy\r\n     */ static scale(sx, sy) {\n            const mat = AffineMatrix.identity();\n            mat.data[0] = sx;\n            mat.data[3] = sy;\n            mat._scale[0] = sx;\n            mat._scale[1] = sy;\n            return mat;\n        }\n        /**\r\n     * Creates a brand new rotation matrix with the specified angle\r\n     * @param angleRadians\r\n     */ static rotation(angleRadians) {\n            const mat = AffineMatrix.identity();\n            mat.data[0] = Math.cos(angleRadians);\n            mat.data[1] = Math.sin(angleRadians);\n            mat.data[2] = -Math.sin(angleRadians);\n            mat.data[3] = Math.cos(angleRadians);\n            return mat;\n        }\n        setPosition(x, y) {\n            this.data[4] = x;\n            this.data[5] = y;\n        }\n        getPosition() {\n            return vec(this.data[4], this.data[5]);\n        }\n        /**\r\n     * Applies rotation to the current matrix mutating it\r\n     * @param angle in Radians\r\n     */ rotate(angle) {\n            const a11 = this.data[0];\n            const a21 = this.data[1];\n            const a12 = this.data[2];\n            const a22 = this.data[3];\n            const sine = Math.sin(angle);\n            const cosine = Math.cos(angle);\n            this.data[0] = cosine * a11 + sine * a12;\n            this.data[1] = cosine * a21 + sine * a22;\n            this.data[2] = cosine * a12 - sine * a11;\n            this.data[3] = cosine * a22 - sine * a21;\n            return this;\n        }\n        /**\r\n     * Applies translation to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */ translate(x, y) {\n            const a11 = this.data[0];\n            const a21 = this.data[1];\n            // const a31 = 0;\n            const a12 = this.data[2];\n            const a22 = this.data[3];\n            // const a32 = 0;\n            const a13 = this.data[4];\n            const a23 = this.data[5];\n            // const a33 = 1;\n            // Doesn't change z\n            this.data[4] = a11 * x + a12 * y + a13;\n            this.data[5] = a21 * x + a22 * y + a23;\n            return this;\n        }\n        /**\r\n     * Applies scaling to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */ scale(x, y) {\n            const a11 = this.data[0];\n            const a21 = this.data[1];\n            const a12 = this.data[2];\n            const a22 = this.data[3];\n            this.data[0] = a11 * x;\n            this.data[1] = a21 * x;\n            this.data[2] = a12 * y;\n            this.data[3] = a22 * y;\n            this._scale[0] = x;\n            this._scale[1] = y;\n            return this;\n        }\n        determinant() {\n            return this.data[0] * this.data[3] - this.data[1] * this.data[2];\n        }\n        /**\r\n     * Return the affine inverse, optionally store it in a target matrix.\r\n     *\r\n     * It's recommended you call .reset() the target unless you know what you're doing\r\n     * @param target\r\n     */ inverse(target) {\n            // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\n            // See https://www.mathsisfun.com/algebra/matrix-inverse.html\n            // Since we are actually only doing 2D transformations we can use this hack\n            // We don't actually use the 3rd or 4th dimension\n            const det = this.determinant();\n            const inverseDet = 1 / det; // TODO zero check\n            const a = this.data[0];\n            const b = this.data[2];\n            const c = this.data[1];\n            const d = this.data[3];\n            const m = target || AffineMatrix.identity();\n            // inverts rotation and scale\n            m.data[0] = d * inverseDet;\n            m.data[1] = -c * inverseDet;\n            m.data[2] = -b * inverseDet;\n            m.data[3] = a * inverseDet;\n            const tx = this.data[4];\n            const ty = this.data[5];\n            // invert translation\n            // transform translation into the matrix basis created by rot/scale\n            m.data[4] = -(tx * m.data[0] + ty * m.data[2]);\n            m.data[5] = -(tx * m.data[1] + ty * m.data[3]);\n            return m;\n        }\n        multiply(vectorOrMatrix, dest) {\n            if (vectorOrMatrix instanceof Vector) {\n                const result = dest || new Vector(0, 0);\n                const vector = vectorOrMatrix;\n                // these shenanigans are to allow dest and vector to be the same instance\n                const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];\n                const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];\n                result.x = resultX;\n                result.y = resultY;\n                return result;\n            } else {\n                const result = dest || new AffineMatrix();\n                const other = vectorOrMatrix;\n                const a11 = this.data[0];\n                const a21 = this.data[1];\n                //  const a31 = 0;\n                const a12 = this.data[2];\n                const a22 = this.data[3];\n                //  const a32 = 0;\n                const a13 = this.data[4];\n                const a23 = this.data[5];\n                //  const a33 = 1;\n                const b11 = other.data[0];\n                const b21 = other.data[1];\n                //  const b31 = 0;\n                const b12 = other.data[2];\n                const b22 = other.data[3];\n                //  const b32 = 0;\n                const b13 = other.data[4];\n                const b23 = other.data[5];\n                //  const b33 = 1;\n                result.data[0] = a11 * b11 + a12 * b21; // + a13 * b31; // zero\n                result.data[1] = a21 * b11 + a22 * b21; // + a23 * b31; // zero\n                result.data[2] = a11 * b12 + a12 * b22; // + a13 * b32; // zero\n                result.data[3] = a21 * b12 + a22 * b22; // + a23 * b32; // zero\n                result.data[4] = a11 * b13 + a12 * b23 + a13; // * b33; // one\n                result.data[5] = a21 * b13 + a22 * b23 + a23; // * b33; // one\n                const s = this.getScale();\n                result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\n                result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\n                return result;\n            }\n        }\n        to4x4() {\n            const mat = new Matrix();\n            mat.data[0] = this.data[0];\n            mat.data[1] = this.data[1];\n            mat.data[2] = 0;\n            mat.data[3] = 0;\n            mat.data[4] = this.data[2];\n            mat.data[5] = this.data[3];\n            mat.data[6] = 0;\n            mat.data[7] = 0;\n            mat.data[8] = 0;\n            mat.data[9] = 0;\n            mat.data[10] = 1;\n            mat.data[11] = 0;\n            mat.data[12] = this.data[4];\n            mat.data[13] = this.data[5];\n            mat.data[14] = 0;\n            mat.data[15] = 1;\n            return mat;\n        }\n        setRotation(angle) {\n            const currentScale = this.getScale();\n            const sine = Math.sin(angle);\n            const cosine = Math.cos(angle);\n            this.data[0] = cosine * currentScale.x;\n            this.data[1] = sine * currentScale.y;\n            this.data[2] = -sine * currentScale.x;\n            this.data[3] = cosine * currentScale.y;\n        }\n        getRotation() {\n            const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\n            return canonicalizeAngle(angle);\n        }\n        getScaleX() {\n            // absolute scale of the matrix (we lose sign so need to add it back)\n            const xscale = vec(this.data[0], this.data[2]).distance();\n            return this._scaleSignX * xscale;\n        }\n        getScaleY() {\n            // absolute scale of the matrix (we lose sign so need to add it back)\n            const yscale = vec(this.data[1], this.data[3]).distance();\n            return this._scaleSignY * yscale;\n        }\n        /**\r\n     * Get the scale of the matrix\r\n     */ getScale() {\n            return vec(this.getScaleX(), this.getScaleY());\n        }\n        setScaleX(val) {\n            if (val === this._scale[0]) return;\n            this._scaleSignX = sign(val);\n            // negative scale acts like a 180 rotation, so flip\n            const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();\n            this.data[0] = xscale.x * val;\n            this.data[2] = xscale.y * val;\n            this._scale[0] = val;\n        }\n        setScaleY(val) {\n            if (val === this._scale[1]) return;\n            this._scaleSignY = sign(val);\n            // negative scale acts like a 180 rotation, so flip\n            const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();\n            this.data[1] = yscale.x * val;\n            this.data[3] = yscale.y * val;\n            this._scale[1] = val;\n        }\n        setScale(scale) {\n            this.setScaleX(scale.x);\n            this.setScaleY(scale.y);\n        }\n        isIdentity() {\n            return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 1 && this.data[4] === 0 && this.data[5] === 0;\n        }\n        /**\r\n     * Resets the current matrix to the identity matrix, mutating it\r\n     * @returns {AffineMatrix} Current matrix as identity\r\n     */ reset() {\n            const mat = this;\n            mat.data[0] = 1;\n            mat.data[1] = 0;\n            mat.data[2] = 0;\n            mat.data[3] = 1;\n            mat.data[4] = 0;\n            mat.data[5] = 0;\n            return mat;\n        }\n        /**\r\n     * Creates a new Matrix with the same data as the current 4x4\r\n     */ clone(dest) {\n            const mat = dest || new AffineMatrix();\n            mat.data[0] = this.data[0];\n            mat.data[1] = this.data[1];\n            mat.data[2] = this.data[2];\n            mat.data[3] = this.data[3];\n            mat.data[4] = this.data[4];\n            mat.data[5] = this.data[5];\n            return mat;\n        }\n        toString() {\n            return `\r\n[${this.data[0]} ${this.data[2]} ${this.data[4]}]\r\n[${this.data[1]} ${this.data[3]} ${this.data[5]}]\r\n[0 0 1]\r\n`;\n        }\n    }\n    class TransformStack {\n        constructor(){\n            this._transforms = [];\n            this._currentTransform = AffineMatrix.identity();\n        }\n        save() {\n            this._transforms.push(this._currentTransform);\n            this._currentTransform = this._currentTransform.clone();\n        }\n        restore() {\n            this._currentTransform = this._transforms.pop();\n        }\n        translate(x, y) {\n            return this._currentTransform.translate(x, y);\n        }\n        rotate(angle) {\n            return this._currentTransform.rotate(angle);\n        }\n        scale(x, y) {\n            return this._currentTransform.scale(x, y);\n        }\n        set current(matrix) {\n            this._currentTransform = matrix;\n        }\n        get current() {\n            return this._currentTransform;\n        }\n    }\n    class StateStack {\n        constructor(){\n            this._states = [];\n            this._currentState = this._getDefaultState();\n        }\n        _getDefaultState() {\n            return {\n                opacity: 1,\n                z: 0,\n                tint: Color.White\n            };\n        }\n        _cloneState() {\n            return {\n                opacity: this._currentState.opacity,\n                z: this._currentState.z,\n                tint: this._currentState.tint.clone()\n            };\n        }\n        save() {\n            this._states.push(this._currentState);\n            this._currentState = this._cloneState();\n        }\n        restore() {\n            this._currentState = this._states.pop();\n        }\n        get current() {\n            return this._currentState;\n        }\n        set current(val) {\n            this._currentState = val;\n        }\n    }\n    var EventTypes;\n    (function(EventTypes) {\n        EventTypes[\"Kill\"] = \"kill\";\n        EventTypes[\"PreKill\"] = \"prekill\";\n        EventTypes[\"PostKill\"] = \"postkill\";\n        EventTypes[\"PreDraw\"] = \"predraw\";\n        EventTypes[\"PostDraw\"] = \"postdraw\";\n        EventTypes[\"PreDebugDraw\"] = \"predebugdraw\";\n        EventTypes[\"PostDebugDraw\"] = \"postdebugdraw\";\n        EventTypes[\"PreUpdate\"] = \"preupdate\";\n        EventTypes[\"PostUpdate\"] = \"postupdate\";\n        EventTypes[\"PreFrame\"] = \"preframe\";\n        EventTypes[\"PostFrame\"] = \"postframe\";\n        EventTypes[\"PreCollision\"] = \"precollision\";\n        EventTypes[\"CollisionStart\"] = \"collisionstart\";\n        EventTypes[\"CollisionEnd\"] = \"collisionend\";\n        EventTypes[\"PostCollision\"] = \"postcollision\";\n        EventTypes[\"Initialize\"] = \"initialize\";\n        EventTypes[\"Activate\"] = \"activate\";\n        EventTypes[\"Deactivate\"] = \"deactivate\";\n        EventTypes[\"ExitViewport\"] = \"exitviewport\";\n        EventTypes[\"EnterViewport\"] = \"enterviewport\";\n        EventTypes[\"ExitTrigger\"] = \"exit\";\n        EventTypes[\"EnterTrigger\"] = \"enter\";\n        EventTypes[\"Connect\"] = \"connect\";\n        EventTypes[\"Disconnect\"] = \"disconnect\";\n        EventTypes[\"Button\"] = \"button\";\n        EventTypes[\"Axis\"] = \"axis\";\n        EventTypes[\"Visible\"] = \"visible\";\n        EventTypes[\"Hidden\"] = \"hidden\";\n        EventTypes[\"Start\"] = \"start\";\n        EventTypes[\"Stop\"] = \"stop\";\n        EventTypes[\"PointerUp\"] = \"pointerup\";\n        EventTypes[\"PointerDown\"] = \"pointerdown\";\n        EventTypes[\"PointerMove\"] = \"pointermove\";\n        EventTypes[\"PointerEnter\"] = \"pointerenter\";\n        EventTypes[\"PointerLeave\"] = \"pointerleave\";\n        EventTypes[\"PointerCancel\"] = \"pointercancel\";\n        EventTypes[\"PointerWheel\"] = \"pointerwheel\";\n        EventTypes[\"Up\"] = \"up\";\n        EventTypes[\"Down\"] = \"down\";\n        EventTypes[\"Move\"] = \"move\";\n        EventTypes[\"Enter\"] = \"enter\";\n        EventTypes[\"Leave\"] = \"leave\";\n        EventTypes[\"Cancel\"] = \"cancel\";\n        EventTypes[\"Wheel\"] = \"wheel\";\n        EventTypes[\"Press\"] = \"press\";\n        EventTypes[\"Release\"] = \"release\";\n        EventTypes[\"Hold\"] = \"hold\";\n        EventTypes[\"PointerDragStart\"] = \"pointerdragstart\";\n        EventTypes[\"PointerDragEnd\"] = \"pointerdragend\";\n        EventTypes[\"PointerDragEnter\"] = \"pointerdragenter\";\n        EventTypes[\"PointerDragLeave\"] = \"pointerdragleave\";\n        EventTypes[\"PointerDragMove\"] = \"pointerdragmove\";\n    })(EventTypes || (EventTypes = {}));\n    /**\r\n * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\r\n * some events are unique to a type, others are not.\r\n *\r\n */ class GameEvent {\n        constructor(){\n            this._bubbles = true;\n        }\n        /**\r\n     * If set to false, prevents event from propagating to other actors. If true it will be propagated\r\n     * to all actors that apply.\r\n     */ get bubbles() {\n            return this._bubbles;\n        }\n        set bubbles(value) {\n            this._bubbles = value;\n        }\n        /**\r\n     * Prevents event from bubbling\r\n     */ stopPropagation() {\n            this.bubbles = false;\n        }\n    }\n    /**\r\n * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.\r\n */ class KillEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'prekill' event is emitted directly before an actor is killed.\r\n */ class PreKillEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'postkill' event is emitted directly after the actor is killed.\r\n */ class PostKillEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'start' event is emitted on engine when has started and is ready for interaction.\r\n */ class GameStartEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.\r\n */ class GameStopEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */ class PreDrawEvent extends GameEvent {\n        constructor(ctx, delta, target){\n            super();\n            this.ctx = ctx;\n            this.delta = delta;\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */ class PostDrawEvent extends GameEvent {\n        constructor(ctx, delta, target){\n            super();\n            this.ctx = ctx;\n            this.delta = delta;\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.\r\n */ class PreDebugDrawEvent extends GameEvent {\n        constructor(ctx, target){\n            super();\n            this.ctx = ctx;\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.\r\n */ class PostDebugDrawEvent extends GameEvent {\n        constructor(ctx, target){\n            super();\n            this.ctx = ctx;\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.\r\n */ class PreUpdateEvent extends GameEvent {\n        constructor(engine, delta, target){\n            super();\n            this.engine = engine;\n            this.delta = delta;\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.\r\n */ class PostUpdateEvent extends GameEvent {\n        constructor(engine, delta, target){\n            super();\n            this.engine = engine;\n            this.delta = delta;\n            this.target = target;\n        }\n    }\n    /**\r\n * The 'preframe' event is emitted on the engine, before the frame begins.\r\n */ class PreFrameEvent extends GameEvent {\n        constructor(engine, prevStats){\n            super();\n            this.engine = engine;\n            this.prevStats = prevStats;\n            this.target = engine;\n        }\n    }\n    /**\r\n * The 'postframe' event is emitted on the engine, after a frame ends.\r\n */ class PostFrameEvent extends GameEvent {\n        constructor(engine, stats){\n            super();\n            this.engine = engine;\n            this.stats = stats;\n            this.target = engine;\n        }\n    }\n    /**\r\n * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\r\n */ class GamepadConnectEvent extends GameEvent {\n        constructor(index, gamepad){\n            super();\n            this.index = index;\n            this.gamepad = gamepad;\n            this.target = gamepad;\n        }\n    }\n    /**\r\n * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\r\n */ class GamepadDisconnectEvent extends GameEvent {\n        constructor(index, gamepad){\n            super();\n            this.index = index;\n            this.gamepad = gamepad;\n            this.target = gamepad;\n        }\n    }\n    /**\r\n * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */ class GamepadButtonEvent extends GameEvent {\n        /**\r\n     * @param button  The Gamepad button\r\n     * @param value   A numeric value between 0 and 1\r\n     */ constructor(button, value, target){\n            super();\n            this.button = button;\n            this.value = value;\n            this.target = target;\n        }\n    }\n    /**\r\n * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */ class GamepadAxisEvent extends GameEvent {\n        /**\r\n     * @param axis  The Gamepad axis\r\n     * @param value A numeric value between -1 and 1\r\n     */ constructor(axis, value, target){\n            super();\n            this.axis = axis;\n            this.value = value;\n            this.target = target;\n        }\n    }\n    /**\r\n * Event received by the [[Engine]] when the browser window is visible on a screen.\r\n */ class VisibleEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * Event received by the [[Engine]] when the browser window is hidden from all screens.\r\n */ class HiddenEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\r\n */ class PreCollisionEvent extends GameEvent {\n        /**\r\n     * @param actor         The actor the event was thrown on\r\n     * @param other         The actor that will collided with the current actor\r\n     * @param side          The side that will be collided with the current actor\r\n     * @param intersection  Intersection vector\r\n     */ constructor(actor, other, side, intersection){\n            super();\n            this.other = other;\n            this.side = side;\n            this.intersection = intersection;\n            this.target = actor;\n        }\n    }\n    /**\r\n * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\r\n */ class PostCollisionEvent extends GameEvent {\n        /**\r\n     * @param actor         The actor the event was thrown on\r\n     * @param other         The actor that did collide with the current actor\r\n     * @param side          The side that did collide with the current actor\r\n     * @param intersection  Intersection vector\r\n     */ constructor(actor, other, side, intersection){\n            super();\n            this.other = other;\n            this.side = side;\n            this.intersection = intersection;\n            this.target = actor;\n        }\n        get actor() {\n            return this.target;\n        }\n        set actor(actor) {\n            this.target = actor;\n        }\n    }\n    class ContactStartEvent {\n        constructor(target, other, contact){\n            this.target = target;\n            this.other = other;\n            this.contact = contact;\n        }\n    }\n    class ContactEndEvent {\n        constructor(target, other){\n            this.target = target;\n            this.other = other;\n        }\n    }\n    class CollisionPreSolveEvent {\n        constructor(target, other, side, intersection, contact){\n            this.target = target;\n            this.other = other;\n            this.side = side;\n            this.intersection = intersection;\n            this.contact = contact;\n        }\n    }\n    class CollisionPostSolveEvent {\n        constructor(target, other, side, intersection, contact){\n            this.target = target;\n            this.other = other;\n            this.side = side;\n            this.intersection = intersection;\n            this.contact = contact;\n        }\n    }\n    /**\r\n * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\r\n */ class CollisionStartEvent extends GameEvent {\n        /**\r\n     *\r\n     * @param actor\r\n     * @param other\r\n     * @param contact\r\n     */ constructor(actor, other, contact){\n            super();\n            this.other = other;\n            this.contact = contact;\n            this.target = actor;\n        }\n        get actor() {\n            return this.target;\n        }\n        set actor(actor) {\n            this.target = actor;\n        }\n    }\n    /**\r\n * Event thrown when the [[Actor|actor]] is no longer colliding with another\r\n */ class CollisionEndEvent extends GameEvent {\n        /**\r\n     *\r\n     */ constructor(actor, other){\n            super();\n            this.other = other;\n            this.target = actor;\n        }\n        get actor() {\n            return this.target;\n        }\n        set actor(actor) {\n            this.target = actor;\n        }\n    }\n    /**\r\n * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\r\n */ class InitializeEvent extends GameEvent {\n        /**\r\n     * @param engine  The reference to the current engine\r\n     */ constructor(engine, target){\n            super();\n            this.engine = engine;\n            this.target = target;\n        }\n    }\n    /**\r\n * Event thrown on a [[Scene]] on activation\r\n */ class ActivateEvent extends GameEvent {\n        /**\r\n     * @param context  The context for the scene activation\r\n     */ constructor(context, target){\n            super();\n            this.context = context;\n            this.target = target;\n        }\n    }\n    /**\r\n * Event thrown on a [[Scene]] on deactivation\r\n */ class DeactivateEvent extends GameEvent {\n        /**\r\n     * @param context  The context for the scene deactivation\r\n     */ constructor(context, target){\n            super();\n            this.context = context;\n            this.target = target;\n        }\n    }\n    /**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */ class ExitViewPortEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    /**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */ class EnterViewPortEvent extends GameEvent {\n        constructor(target){\n            super();\n            this.target = target;\n        }\n    }\n    class EnterTriggerEvent extends GameEvent {\n        constructor(target, actor){\n            super();\n            this.target = target;\n            this.actor = actor;\n        }\n    }\n    class ExitTriggerEvent extends GameEvent {\n        constructor(target, actor){\n            super();\n            this.target = target;\n            this.actor = actor;\n        }\n    }\n    class EventDispatcher {\n        constructor(){\n            this._handlers = {};\n            this._wiredEventDispatchers = [];\n            this._deferedHandlerRemovals = [];\n        }\n        /**\r\n     * Clears any existing handlers or wired event dispatchers on this event dispatcher\r\n     */ clear() {\n            this._handlers = {};\n            this._wiredEventDispatchers = [];\n        }\n        _processDeferredHandlerRemovals() {\n            for (const eventHandler of this._deferedHandlerRemovals)this._removeHandler(eventHandler.name, eventHandler.handler);\n            this._deferedHandlerRemovals.length = 0;\n        }\n        /**\r\n     * Emits an event for target\r\n     * @param eventName  The name of the event to publish\r\n     * @param event      Optionally pass an event data object to the handler\r\n     */ emit(eventName, event) {\n            this._processDeferredHandlerRemovals();\n            if (!eventName) // key not mapped\n            return;\n            eventName = eventName.toLowerCase();\n            if (!event) event = new GameEvent();\n            let i, len;\n            if (this._handlers[eventName]) {\n                i = 0;\n                len = this._handlers[eventName].length;\n                for(i; i < len; i++)this._handlers[eventName][i](event);\n            }\n            i = 0;\n            len = this._wiredEventDispatchers.length;\n            for(i; i < len; i++)this._wiredEventDispatchers[i].emit(eventName, event);\n        }\n        /**\r\n     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n     * @param eventName  The name of the event to subscribe to\r\n     * @param handler    The handler callback to fire on this event\r\n     */ on(eventName, handler) {\n            this._processDeferredHandlerRemovals();\n            eventName = eventName.toLowerCase();\n            if (!this._handlers[eventName]) this._handlers[eventName] = [];\n            this._handlers[eventName].push(handler);\n        }\n        /**\r\n     * Unsubscribe an event handler(s) from an event. If a specific handler\r\n     * is specified for an event, only that handler will be unsubscribed.\r\n     * Otherwise all handlers will be unsubscribed for that event.\r\n     *\r\n     * @param eventName  The name of the event to unsubscribe\r\n     * @param handler    Optionally the specific handler to unsubscribe\r\n     */ off(eventName, handler) {\n            this._deferedHandlerRemovals.push({\n                name: eventName,\n                handler: handler\n            });\n        }\n        _removeHandler(eventName, handler) {\n            eventName = eventName.toLowerCase();\n            const eventHandlers = this._handlers[eventName];\n            if (eventHandlers) {\n                // if no explicit handler is give with the event name clear all handlers\n                if (!handler) this._handlers[eventName].length = 0;\n                else {\n                    const index = eventHandlers.indexOf(handler);\n                    if (index > -1) this._handlers[eventName].splice(index, 1);\n                }\n            }\n        }\n        /**\r\n     * Once listens to an event one time, then unsubscribes from that event\r\n     *\r\n     * @param eventName The name of the event to subscribe to once\r\n     * @param handler   The handler of the event that will be auto unsubscribed\r\n     */ once(eventName, handler) {\n            this._processDeferredHandlerRemovals();\n            const metaHandler = (event)=>{\n                const ev = event || new GameEvent();\n                this.off(eventName, metaHandler);\n                handler(ev);\n            };\n            this.on(eventName, metaHandler);\n        }\n        /**\r\n     * Wires this event dispatcher to also receive events from another\r\n     */ wire(eventDispatcher) {\n            eventDispatcher._wiredEventDispatchers.push(this);\n        }\n        /**\r\n     * Unwires this event dispatcher from another\r\n     */ unwire(eventDispatcher) {\n            const index = eventDispatcher._wiredEventDispatchers.indexOf(this);\n            if (index > -1) eventDispatcher._wiredEventDispatchers.splice(index, 1);\n        }\n    }\n    /**\r\n * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n */ class Resource {\n        /**\r\n     * @param path          Path to the remote resource\r\n     * @param responseType  The type to expect as a response: \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\n     * @param bustCache     Whether or not to cache-bust requests\r\n     */ constructor(path, responseType, bustCache = true){\n            this.path = path;\n            this.responseType = responseType;\n            this.bustCache = bustCache;\n            this.data = null;\n            this.logger = Logger.getInstance();\n            this.events = new EventDispatcher();\n        }\n        /**\r\n     * Returns true if the Resource is completely loaded and is ready\r\n     * to be drawn.\r\n     */ isLoaded() {\n            return this.data !== null;\n        }\n        _cacheBust(uri) {\n            const query = /\\?\\w*=\\w*/;\n            if (query.test(uri)) uri += \"&__=\" + Date.now();\n            else uri += \"?__=\" + Date.now();\n            return uri;\n        }\n        /**\r\n     * Begin loading the resource and returns a promise to be resolved on completion\r\n     */ load() {\n            return new Promise((resolve, reject)=>{\n                // Exit early if we already have data\n                if (this.data !== null) {\n                    this.logger.debug(\"Already have data for resource\", this.path);\n                    this.events.emit(\"complete\", this.data);\n                    resolve(this.data);\n                    return;\n                }\n                const request = new XMLHttpRequest();\n                request.open(\"GET\", this.bustCache ? this._cacheBust(this.path) : this.path, true);\n                request.responseType = this.responseType;\n                request.addEventListener(\"loadstart\", (e)=>this.events.emit(\"loadstart\", e));\n                request.addEventListener(\"progress\", (e)=>this.events.emit(\"progress\", e));\n                request.addEventListener(\"error\", (e)=>this.events.emit(\"error\", e));\n                request.addEventListener(\"load\", (e)=>this.events.emit(\"load\", e));\n                request.addEventListener(\"load\", ()=>{\n                    // XHR on file:// success status is 0, such as with PhantomJS\n                    if (request.status !== 0 && request.status !== 200) {\n                        this.logger.error(\"Failed to load resource \", this.path, \" server responded with error code\", request.status);\n                        this.events.emit(\"error\", request.response);\n                        reject(new Error(request.statusText));\n                        return;\n                    }\n                    this.data = request.response;\n                    this.events.emit(\"complete\", this.data);\n                    this.logger.debug(\"Completed loading resource\", this.path);\n                    resolve(this.data);\n                });\n                request.send();\n            });\n        }\n    }\n    /**\r\n * Watch an object with a proxy, only fires if property value is different\r\n */ function watch(type, change) {\n        if (!type) return type;\n        if (type.__isProxy === undefined) // expando hack to mark a proxy\n        return new Proxy(type, {\n            set: (obj, prop, value)=>{\n                // The default behavior to store the value\n                if (obj[prop] !== value) {\n                    obj[prop] = value;\n                    // Avoid watching private junk\n                    if (typeof prop === \"string\") {\n                        if (prop[0] !== \"_\") change(obj);\n                    }\n                }\n                // Indicate success\n                return true;\n            },\n            get: (obj, prop)=>{\n                if (prop !== \"__isProxy\") return obj[prop];\n                return true;\n            }\n        });\n        return type;\n    }\n    /**\r\n * Watch an object with a proxy, fires change on any property value change\r\n */ function watchAny(type, change) {\n        if (!type) return type;\n        if (type.__isProxy === undefined) // expando hack to mark a proxy\n        return new Proxy(type, {\n            set: (obj, prop, value)=>{\n                // The default behavior to store the value\n                obj[prop] = value;\n                // Avoid watching private junk\n                if (typeof prop === \"string\") {\n                    if (prop[0] !== \"_\") change(obj);\n                }\n                // Indicate success\n                return true;\n            },\n            get: (obj, prop)=>{\n                if (prop !== \"__isProxy\") return obj[prop];\n                return true;\n            }\n        });\n        return type;\n    }\n    /**\r\n * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].\r\n * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the\r\n * [[Graphic]] abstract class.\r\n *\r\n * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic\r\n * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]\r\n */ class Graphic {\n        constructor(options){\n            var _a, _b, _c, _d, _e, _f;\n            this.id = Graphic._ID++;\n            this.transform = AffineMatrix.identity();\n            this.tint = null;\n            this._transformStale = true;\n            /**\r\n         * Gets or sets wether to show debug information about the graphic\r\n         */ this.showDebug = false;\n            this._flipHorizontal = false;\n            this._flipVertical = false;\n            this._rotation = 0;\n            /**\r\n         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).\r\n         */ this.opacity = 1;\n            this._scale = Vector.One;\n            this._origin = null;\n            this._width = 0;\n            this._height = 0;\n            if (options) {\n                this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;\n                this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;\n                this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;\n                this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;\n                this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;\n                this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;\n            }\n        }\n        isStale() {\n            return this._transformStale;\n        }\n        /**\r\n     * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)\r\n     */ get flipHorizontal() {\n            return this._flipHorizontal;\n        }\n        set flipHorizontal(value) {\n            this._flipHorizontal = value;\n            this._transformStale = true;\n        }\n        /**\r\n     * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)\r\n     */ get flipVertical() {\n            return this._flipVertical;\n        }\n        set flipVertical(value) {\n            this._flipVertical = value;\n            this._transformStale = true;\n        }\n        /**\r\n     * Gets or sets the rotation of the graphic\r\n     */ get rotation() {\n            return this._rotation;\n        }\n        set rotation(value) {\n            this._rotation = value;\n            this._transformStale = true;\n        }\n        /**\r\n     * Gets or sets the scale of the graphic, this affects the width and\r\n     */ get scale() {\n            return this._scale;\n        }\n        set scale(value) {\n            this._scale = watch(value, ()=>{\n                this._transformStale = true;\n            });\n            this._transformStale = true;\n        }\n        /**\r\n     * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin\r\n     */ get origin() {\n            return this._origin;\n        }\n        set origin(value) {\n            this._origin = watch(value, ()=>{\n                this._transformStale = true;\n            });\n            this._transformStale = true;\n        }\n        cloneGraphicOptions() {\n            return {\n                origin: this.origin ? this.origin.clone() : null,\n                flipHorizontal: this.flipHorizontal,\n                flipVertical: this.flipVertical,\n                rotation: this.rotation,\n                opacity: this.opacity,\n                scale: this.scale ? this.scale.clone() : null\n            };\n        }\n        /**\r\n     * Gets or sets the width of the graphic (always positive)\r\n     */ get width() {\n            return Math.abs(this._width * this.scale.x);\n        }\n        /**\r\n     * Gets or sets the height of the graphic (always positive)\r\n     */ get height() {\n            return Math.abs(this._height * this.scale.y);\n        }\n        set width(value) {\n            this._width = value;\n            this._transformStale = true;\n        }\n        set height(value) {\n            this._height = value;\n            this._transformStale = true;\n        }\n        /**\r\n     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.\r\n     */ get localBounds() {\n            return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);\n        }\n        /**\r\n     * Draw the whole graphic to the context including transform\r\n     * @param ex The excalibur graphics context\r\n     * @param x\r\n     * @param y\r\n     */ draw(ex, x, y) {\n            this._preDraw(ex, x, y);\n            this._drawImage(ex, 0, 0);\n            this._postDraw(ex);\n        }\n        /**\r\n     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]\r\n     * @param ex\r\n     * @param x\r\n     * @param y\r\n     */ _preDraw(ex, x, y) {\n            ex.save();\n            ex.translate(x, y);\n            if (this._transformStale) {\n                this.transform.reset();\n                this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\n                this._rotate(this.transform);\n                this._flip(this.transform);\n                this._transformStale = false;\n            }\n            ex.multiply(this.transform);\n            // it is important to multiply alphas so graphics respect the current context\n            ex.opacity = ex.opacity * this.opacity;\n            if (this.tint) ex.tint = this.tint;\n        }\n        _rotate(ex) {\n            var _a;\n            const scaleDirX = this.scale.x > 0 ? 1 : -1;\n            const scaleDirY = this.scale.y > 0 ? 1 : -1;\n            const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);\n            ex.translate(origin.x, origin.y);\n            ex.rotate(this.rotation);\n            // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\n            ex.scale(scaleDirX, scaleDirY);\n            ex.translate(-origin.x, -origin.y);\n        }\n        _flip(ex) {\n            if (this.flipHorizontal) {\n                ex.translate(this.width / this.scale.x, 0);\n                ex.scale(-1, 1);\n            }\n            if (this.flipVertical) {\n                ex.translate(0, this.height / this.scale.y);\n                ex.scale(1, -1);\n            }\n        }\n        /**\r\n     * Apply any additional work after [[Graphic._drawImage]] and restore the context state.\r\n     * @param ex\r\n     */ _postDraw(ex) {\n            if (this.showDebug) ex.debug.drawRect(0, 0, this.width, this.height);\n            ex.restore();\n        }\n    }\n    Graphic._ID = 0;\n    class Sprite extends Graphic {\n        constructor(options){\n            var _a, _b;\n            super(options);\n            this._logger = Logger.getInstance();\n            this._dirty = true;\n            this._logNotLoadedWarning = false;\n            this.image = options.image;\n            const { width: width , height: height  } = options;\n            this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : {\n                x: 0,\n                y: 0,\n                width: width !== null && width !== void 0 ? width : 0,\n                height: height !== null && height !== void 0 ? height : 0\n            };\n            this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : {\n                width: width !== null && width !== void 0 ? width : 0,\n                height: height !== null && height !== void 0 ? height : 0\n            };\n            this._updateSpriteDimensions();\n            this.image.ready.then(()=>{\n                this._updateSpriteDimensions();\n            });\n        }\n        static from(image) {\n            return new Sprite({\n                image: image\n            });\n        }\n        get width() {\n            return Math.abs(this.destSize.width * this.scale.x);\n        }\n        get height() {\n            return Math.abs(this.destSize.height * this.scale.y);\n        }\n        set width(newWidth) {\n            newWidth /= Math.abs(this.scale.x);\n            this.destSize.width = newWidth;\n            super.width = Math.ceil(this.destSize.width);\n        }\n        set height(newHeight) {\n            newHeight /= Math.abs(this.scale.y);\n            this.destSize.height = newHeight;\n            super.height = Math.ceil(this.destSize.height);\n        }\n        _updateSpriteDimensions() {\n            var _a, _b, _c, _d, _e, _f;\n            const { width: nativeWidth , height: nativeHeight  } = this.image;\n            // This code uses || to avoid 0's\n            // If the source is not specified, use the native dimension\n            this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;\n            this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;\n            // If the destination is not specified, use the source if specified, then native\n            this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;\n            this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;\n            this.width = Math.ceil(this.destSize.width) * this.scale.x;\n            this.height = Math.ceil(this.destSize.height) * this.scale.y;\n        }\n        _preDraw(ex, x, y) {\n            if (this.image.isLoaded() && this._dirty) {\n                this._dirty = false;\n                this._updateSpriteDimensions();\n            }\n            super._preDraw(ex, x, y);\n        }\n        _drawImage(ex, x, y) {\n            if (this.image.isLoaded()) ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);\n            else {\n                if (!this._logNotLoadedWarning) this._logger.warn(`ImageSource ${this.image.path}` + ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\\n\\n` + `Read https://excaliburjs.com/docs/imagesource for more information.`);\n                this._logNotLoadedWarning = true;\n            }\n        }\n        clone() {\n            return new Sprite({\n                image: this.image,\n                sourceView: {\n                    ...this.sourceView\n                },\n                destSize: {\n                    ...this.destSize\n                },\n                ...this.cloneGraphicOptions()\n            });\n        }\n    }\n    /**\r\n * Describes the different image filtering modes\r\n */ var ImageFiltering;\n    (function(ImageFiltering) {\n        /**\r\n     * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.\r\n     *\r\n     * Useful for Pixel art aesthetics.\r\n     */ ImageFiltering[\"Pixel\"] = \"Pixel\";\n        /**\r\n     * Blended is useful when you have high resolution artwork and would like it blended and smoothed\r\n     */ ImageFiltering[\"Blended\"] = \"Blended\";\n    })(ImageFiltering || (ImageFiltering = {}));\n    /**\r\n * Manages loading image sources into webgl textures, a unique id is associated with all sources\r\n */ class TextureLoader {\n        static register(context) {\n            TextureLoader._GL = context;\n            TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);\n        }\n        /**\r\n     * Get the WebGL Texture from a source image\r\n     * @param image\r\n     */ static get(image) {\n            return TextureLoader._TEXTURE_MAP.get(image);\n        }\n        /**\r\n     * Returns whether a source image has been loaded as a texture\r\n     * @param image\r\n     */ static has(image) {\n            return TextureLoader._TEXTURE_MAP.has(image);\n        }\n        /**\r\n     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered\r\n     * @param image Source graphic\r\n     * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture\r\n     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed\r\n     */ static load(image, filtering, forceUpdate = false) {\n            // Ignore loading if webgl is not registered\n            const gl = TextureLoader._GL;\n            if (!gl) return null;\n            let tex = null;\n            // If reuse the texture if it's from the same source\n            if (TextureLoader.has(image)) tex = TextureLoader.get(image);\n            // Update existing webgl texture and return early\n            if (tex) {\n                if (forceUpdate) {\n                    gl.bindTexture(gl.TEXTURE_2D, tex);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n                }\n                return tex;\n            }\n            // No texture exists create a new one\n            tex = gl.createTexture();\n            TextureLoader.checkImageSizeSupportedAndLog(image);\n            gl.bindTexture(gl.TEXTURE_2D, tex);\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // NEAREST for pixel art, LINEAR for hi-res\n            const filterMode = filtering !== null && filtering !== void 0 ? filtering : TextureLoader.filtering;\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n            TextureLoader._TEXTURE_MAP.set(image, tex);\n            return tex;\n        }\n        static delete(image) {\n            // Ignore loading if webgl is not registered\n            const gl = TextureLoader._GL;\n            if (!gl) return null;\n            let tex = null;\n            if (TextureLoader.has(image)) {\n                tex = TextureLoader.get(image);\n                gl.deleteTexture(tex);\n            }\n        }\n        /**\r\n     * Takes an image and returns if it meets size criteria for hardware\r\n     * @param image\r\n     * @returns if the image will be supported at runtime\r\n     */ static checkImageSizeSupportedAndLog(image) {\n            var _a;\n            const originalSrc = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : \"internal canvas bitmap\";\n            if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {\n                TextureLoader._LOGGER.error(`The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of ` + `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image ` + `for excalibur to render properly.\\n\\nImages will likely render as black rectangles.\\n\\n` + `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\n                return false;\n            } else if (image.width > 4096 || image.height > 4096) // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits\n            TextureLoader._LOGGER.warn(`The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, ` + `it is recommended you resize images to a maximum (4096x4096).\\n\\n` + `Images will likely render as black rectangles on some mobile platforms.\\n\\n` + `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\n            return true;\n        }\n    }\n    TextureLoader._LOGGER = Logger.getInstance();\n    /**\r\n * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]\r\n */ TextureLoader.filtering = ImageFiltering.Blended;\n    TextureLoader._TEXTURE_MAP = new Map();\n    TextureLoader._MAX_TEXTURE_SIZE = 0;\n    class ImageSource {\n        /**\r\n     * The path to the image, can also be a data url like 'data:image/'\r\n     * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute\r\n     * @param bustCache {boolean} Should excalibur add a cache busting querystring?\r\n     * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]\r\n     */ constructor(path, bustCache = false, filtering){\n            this.path = path;\n            this._logger = Logger.getInstance();\n            /**\r\n         * Access to the underlying html image element\r\n         */ this.data = new Image();\n            this._readyFuture = new Future();\n            /**\r\n         * Promise the resolves when the image is loaded and ready for use, does not initiate loading\r\n         */ this.ready = this._readyFuture.promise;\n            this._resource = new Resource(path, \"blob\", bustCache);\n            this._filtering = filtering;\n            if (path.endsWith(\".svg\") || path.endsWith(\".gif\")) this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);\n        }\n        /**\r\n     * The original size of the source image in pixels\r\n     */ get width() {\n            return this.image.naturalWidth;\n        }\n        /**\r\n     * The original height of the source image in pixels\r\n     */ get height() {\n            return this.image.naturalHeight;\n        }\n        /**\r\n     * Returns true if the Texture is completely loaded and is ready\r\n     * to be drawn.\r\n     */ isLoaded() {\n            if (!this._src) // this boosts speed of access\n            this._src = this.data.src;\n            return !!this._src;\n        }\n        get image() {\n            return this.data;\n        }\n        /**\r\n     * Begins loading the image and returns a promise that resolves when the image is loaded\r\n     */ async load() {\n            if (this.isLoaded()) return this.data;\n            try {\n                // Load base64 or blob if needed\n                let url;\n                if (!this.path.includes(\"data:image/\")) {\n                    const blob = await this._resource.load();\n                    url = URL.createObjectURL(blob);\n                } else url = this.path;\n                // Decode the image\n                const image = new Image();\n                // Use Image.onload over Image.decode()\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7\n                // Otherwise chrome will throw still Image.decode() failures for large textures\n                const loadedFuture = new Future();\n                image.onload = ()=>loadedFuture.resolve();\n                image.src = url;\n                image.setAttribute(\"data-original-src\", this.path);\n                await loadedFuture.promise;\n                // Set results\n                this.data = image;\n            } catch (error) {\n                throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;\n            }\n            TextureLoader.load(this.data, this._filtering);\n            // todo emit complete\n            this._readyFuture.resolve(this.data);\n            return this.data;\n        }\n        /**\r\n     * Build a sprite from this ImageSource\r\n     */ toSprite() {\n            return Sprite.from(this);\n        }\n        /**\r\n     * Unload images from memory\r\n     */ unload() {\n            this.data = new Image();\n        }\n    }\n    /**\r\n * Represents a collection of sprites from a source image with some organization in a grid\r\n */ class SpriteSheet {\n        /**\r\n     * Build a new sprite sheet from a list of sprites\r\n     *\r\n     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n     * @param options\r\n     */ constructor(options){\n            this._logger = Logger.getInstance();\n            this.sprites = [];\n            const { sprites: sprites , rows: rows , columns: columns  } = options;\n            this.sprites = sprites;\n            this.rows = rows !== null && rows !== void 0 ? rows : 1;\n            this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;\n        }\n        /**\r\n     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left\r\n     * @param x\r\n     * @param y\r\n     */ getSprite(x, y) {\n            if (x >= this.columns || x < 0) {\n                this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);\n                return null;\n            }\n            if (y >= this.rows || y < 0) {\n                this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);\n                return null;\n            }\n            const spriteIndex = x + y * this.columns;\n            return this.sprites[spriteIndex];\n        }\n        /**\r\n     * Create a sprite sheet from a sparse set of [[SourceView]] rectangles\r\n     * @param options\r\n     */ static fromImageSourceWithSourceViews(options) {\n            const sprites = options.sourceViews.map((sourceView)=>{\n                return new Sprite({\n                    image: options.image,\n                    sourceView: sourceView\n                });\n            });\n            return new SpriteSheet({\n                sprites: sprites\n            });\n        }\n        /**\r\n     * Create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n     *\r\n     * Example:\r\n     * ```\r\n     * const spriteSheet = SpriteSheet.fromImageSource({\r\n     *   image: imageSource,\r\n     *   grid: {\r\n     *     rows: 5,\r\n     *     columns: 2,\r\n     *     spriteWidth: 32, // pixels\r\n     *     spriteHeight: 32 // pixels\r\n     *   },\r\n     *   // Optionally specify spacing\r\n     *   spacing: {\r\n     *     // pixels from the top left to start the sprite parsing\r\n     *     originOffset: {\r\n     *       x: 5,\r\n     *       y: 5\r\n     *     },\r\n     *     // pixels between each sprite while parsing\r\n     *     margin: {\r\n     *       x: 1,\r\n     *       y: 1\r\n     *     }\r\n     *   }\r\n     * })\r\n     * ```\r\n     *\r\n     * @param options\r\n     */ static fromImageSource(options) {\n            var _a;\n            const sprites = [];\n            options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};\n            const { image: image , grid: { rows: rows , columns: cols , spriteWidth: spriteWidth , spriteHeight: spriteHeight  } , spacing: { originOffset: originOffset , margin: margin  }  } = options;\n            const offsetDefaults = {\n                x: 0,\n                y: 0,\n                ...originOffset\n            };\n            const marginDefaults = {\n                x: 0,\n                y: 0,\n                ...margin\n            };\n            for(let x = 0; x < cols; x++)for(let y = 0; y < rows; y++)sprites[x + y * cols] = new Sprite({\n                image: image,\n                sourceView: {\n                    x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,\n                    y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,\n                    width: spriteWidth,\n                    height: spriteHeight\n                },\n                destSize: {\n                    height: spriteHeight,\n                    width: spriteWidth\n                }\n            });\n            return new SpriteSheet({\n                sprites: sprites,\n                rows: rows,\n                columns: cols\n            });\n        }\n    }\n    class SpriteFont extends Graphic {\n        constructor(options){\n            super(options);\n            this._text = \"\";\n            this.alphabet = \"\";\n            this.shadow = null;\n            this.caseInsensitive = false;\n            this.spacing = 0;\n            this._logger = Logger.getInstance();\n            this._alreadyWarnedAlphabet = false;\n            this._alreadyWarnedSpriteSheet = false;\n            const { alphabet: alphabet , spriteSheet: spriteSheet , caseInsensitive: caseInsensitive , spacing: spacing , shadow: shadow  } = options;\n            this.alphabet = alphabet;\n            this.spriteSheet = spriteSheet;\n            this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;\n            this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;\n            this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;\n        }\n        _getCharacterSprites(text) {\n            const results = [];\n            // handle case insensitive\n            const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;\n            const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;\n            // for each letter in text\n            for(let letterIndex = 0; letterIndex < textToRender.length; letterIndex++){\n                // find the sprite index in alphabet , if there is an error pick the first\n                const letter = textToRender[letterIndex];\n                let spriteIndex = alphabet.indexOf(letter);\n                if (spriteIndex === -1) {\n                    spriteIndex = 0;\n                    if (!this._alreadyWarnedAlphabet) {\n                        this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);\n                        this._logger.warn(\"There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.\");\n                        this._alreadyWarnedAlphabet = true;\n                    }\n                }\n                const letterSprite = this.spriteSheet.sprites[spriteIndex];\n                if (letterSprite) results.push(letterSprite);\n                else if (!this._alreadyWarnedSpriteSheet) {\n                    this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);\n                    this._logger.warn(\"There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.\");\n                    this._alreadyWarnedSpriteSheet = true;\n                }\n            }\n            return results;\n        }\n        measureText(text) {\n            const lines = text.split(\"\\n\");\n            const maxWidthLine = lines.reduce((a, b)=>{\n                return a.length > b.length ? a : b;\n            });\n            const sprites = this._getCharacterSprites(maxWidthLine);\n            let width = 0;\n            let height = 0;\n            for (const sprite of sprites){\n                width += sprite.width + this.spacing;\n                height = Math.max(height, sprite.height);\n            }\n            return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);\n        }\n        _drawImage(ex, x, y) {\n            let xCursor = 0;\n            let yCursor = 0;\n            let height = 0;\n            const lines = this._text.split(\"\\n\");\n            for (const line of lines){\n                for (const sprite of this._getCharacterSprites(line)){\n                    // draw it in the right spot and increase the cursor by sprite width\n                    sprite.draw(ex, x + xCursor, y + yCursor);\n                    xCursor += sprite.width + this.spacing;\n                    height = Math.max(height, sprite.height);\n                }\n                xCursor = 0;\n                yCursor += height;\n            }\n        }\n        render(ex, text, _color, x, y) {\n            // SpriteFont doesn't support _color, yet...\n            this._text = text;\n            const bounds = this.measureText(text);\n            this.width = bounds.width;\n            this.height = bounds.height;\n            if (this.shadow) {\n                ex.save();\n                ex.translate(this.shadow.offset.x, this.shadow.offset.y);\n                this.draw(ex, x, y);\n                ex.restore();\n            }\n            this.draw(ex, x, y);\n        }\n        clone() {\n            return new SpriteFont({\n                alphabet: this.alphabet,\n                spriteSheet: this.spriteSheet,\n                spacing: this.spacing\n            });\n        }\n    }\n    /* harmony default export */ const debug_font = \"data:image/png;base64,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\";\n    /**\r\n * Internal debugtext helper\r\n */ class DebugText {\n        constructor(){\n            /**\r\n         * base64 font\r\n         */ this.fontSheet = debug_font;\n            this.size = 16;\n            this.load();\n        }\n        load() {\n            this._imageSource = new ImageSource(this.fontSheet);\n            return this._imageSource.load().then(()=>{\n                this._spriteSheet = SpriteSheet.fromImageSource({\n                    image: this._imageSource,\n                    grid: {\n                        rows: 3,\n                        columns: 16,\n                        spriteWidth: 16,\n                        spriteHeight: 16\n                    }\n                });\n                this._spriteFont = new SpriteFont({\n                    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!'&.\\\"?-()+ \",\n                    caseInsensitive: true,\n                    spriteSheet: this._spriteSheet,\n                    spacing: -6\n                });\n            });\n        }\n        /**\r\n     * Writes debug text using the built in sprint font\r\n     * @param ctx\r\n     * @param text\r\n     * @param pos\r\n     */ write(ctx, text, pos) {\n            if (this._imageSource.isLoaded()) this._spriteFont.render(ctx, text, null, pos.x, pos.y);\n        }\n    }\n    class RenderSource {\n        constructor(_gl, _texture){\n            this._gl = _gl;\n            this._texture = _texture;\n        }\n        use() {\n            const gl = this._gl;\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, this._texture);\n        }\n        disable() {\n            const gl = this._gl;\n            gl.bindTexture(gl.TEXTURE_2D, null);\n        }\n    }\n    class RenderTarget {\n        constructor(options){\n            this.width = options.width;\n            this.height = options.height;\n            this._gl = options.gl;\n            this._setupFramebuffer();\n        }\n        setResolution(width, height) {\n            const gl = this._gl;\n            this.width = width;\n            this.height = height;\n            gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n        get frameBuffer() {\n            return this._frameBuffer;\n        }\n        get frameTexture() {\n            return this._frameTexture;\n        }\n        _setupFramebuffer() {\n            // Allocates frame buffer\n            const gl = this._gl;\n            this._frameTexture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            // set the filtering so we don't need mips\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // attach the texture as the first color attachment\n            const attachmentPoint = gl.COLOR_ATTACHMENT0;\n            // After this bind all draw calls will draw to this framebuffer texture\n            this._frameBuffer = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);\n            // Reset after initialized\n            this.disable();\n        }\n        toRenderSource() {\n            const source = new RenderSource(this._gl, this._frameTexture);\n            return source;\n        }\n        /**\r\n     * When called, all drawing gets redirected to this render target\r\n     */ use() {\n            const gl = this._gl;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n            // very important to set the viewport to the size of the framebuffer texture\n            gl.viewport(0, 0, this.width, this.height);\n        }\n        /**\r\n     * When called, all drawing is sent back to the canvas\r\n     */ disable() {\n            const gl = this._gl;\n            // passing null switches rendering back to the canvas\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n        }\n    }\n    /**\r\n * Must be accessed after Engine construction time to ensure the context has been created\r\n */ class ExcaliburWebGLContextAccessor {\n        static clear() {\n            ExcaliburWebGLContextAccessor._GL = null;\n        }\n        static register(gl) {\n            ExcaliburWebGLContextAccessor._GL = gl;\n        }\n        // current webgl context\n        static get gl() {\n            if (!ExcaliburWebGLContextAccessor._GL) throw Error(\"Attempted gl access before init\");\n            return ExcaliburWebGLContextAccessor._GL;\n        }\n    }\n    /* harmony default export */ const line_vertex = \"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\nout lowp vec4 v_color;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Passthrough the color\\r\\n   v_color = a_color;\\r\\n}\";\n    /* harmony default export */ const line_fragment = \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Color\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  fragColor = v_color;\\r\\n}\";\n    /**\r\n * Return the size of the GlType in bytes\r\n * @param gl\r\n * @param type\r\n */ function getGlTypeSizeBytes(gl, type) {\n        switch(type){\n            case gl.FLOAT:\n                return 4;\n            case gl.SHORT:\n                return 2;\n            case gl.UNSIGNED_SHORT:\n                return 2;\n            case gl.BYTE:\n                return 1;\n            case gl.UNSIGNED_BYTE:\n                return 1;\n            default:\n                return 1;\n        }\n    }\n    /**\r\n * Based on the type return the number of attribute components\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n * @param gl\r\n * @param type\r\n */ function getAttributeComponentSize(gl, type) {\n        switch(type){\n            case gl.LOW_FLOAT:\n            case gl.HIGH_FLOAT:\n            case gl.FLOAT:\n                return 1;\n            case gl.FLOAT_VEC2:\n                return 2;\n            case gl.FLOAT_VEC3:\n                return 3;\n            case gl.FLOAT_VEC4:\n                return 4;\n            case gl.BYTE:\n                return 1;\n            case gl.UNSIGNED_BYTE:\n                return 1;\n            case gl.UNSIGNED_SHORT:\n            case gl.SHORT:\n                return 1;\n            default:\n                return 1;\n        }\n    }\n    /**\r\n * Based on the attribute return the corresponding supported attrib pointer type\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n *\r\n * @param gl\r\n * @param type\r\n */ function getAttributePointerType(gl, type) {\n        switch(type){\n            case gl.LOW_FLOAT:\n            case gl.HIGH_FLOAT:\n            case gl.FLOAT:\n            case gl.FLOAT_VEC2:\n            case gl.FLOAT_VEC3:\n            case gl.FLOAT_VEC4:\n                return gl.FLOAT;\n            case gl.BYTE:\n                return gl.BYTE;\n            case gl.UNSIGNED_BYTE:\n                return gl.UNSIGNED_BYTE;\n            case gl.SHORT:\n                return gl.SHORT;\n            case gl.UNSIGNED_SHORT:\n                return gl.UNSIGNED_SHORT;\n            default:\n                return gl.FLOAT;\n        }\n    }\n    class Shader {\n        /**\r\n     * Create a shader program in excalibur\r\n     * @param options specify shader vertex and fragment source\r\n     */ constructor(options){\n            this._gl = ExcaliburWebGLContextAccessor.gl;\n            this.uniforms = {};\n            this.attributes = {};\n            this._compiled = false;\n            const { vertexSource: vertexSource , fragmentSource: fragmentSource  } = options;\n            this.vertexSource = vertexSource;\n            this.fragmentSource = fragmentSource;\n        }\n        get compiled() {\n            return this._compiled;\n        }\n        /**\r\n     * Binds the shader program\r\n     */ use() {\n            const gl = this._gl;\n            gl.useProgram(this.program);\n            Shader._ACTIVE_SHADER_INSTANCE = this;\n        }\n        isCurrentlyBound() {\n            return Shader._ACTIVE_SHADER_INSTANCE === this;\n        }\n        /**\r\n     * Compile the current shader against a webgl context\r\n     */ compile() {\n            const gl = this._gl;\n            const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);\n            const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);\n            this.program = this._createProgram(gl, vertexShader, fragmentShader);\n            const attributes = this.getAttributes();\n            for (const attribute of attributes)this.attributes[attribute.name] = attribute;\n            const uniforms = this.getUniforms();\n            for (const uniform of uniforms)this.uniforms[uniform.name] = uniform;\n            this._compiled = true;\n            return this.program;\n        }\n        getUniforms() {\n            const gl = this._gl;\n            const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n            const uniforms = [];\n            for(let i = 0; i < uniformCount; i++){\n                const uniform = gl.getActiveUniform(this.program, i);\n                const uniformLocation = gl.getUniformLocation(this.program, uniform.name);\n                uniforms.push({\n                    name: uniform.name,\n                    glType: uniform.type,\n                    location: uniformLocation\n                });\n            }\n            return uniforms;\n        }\n        getAttributes() {\n            const gl = this._gl;\n            const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\n            const attributes = [];\n            for(let i = 0; i < attributeCount; i++){\n                const attribute = gl.getActiveAttrib(this.program, i);\n                const attributeLocation = gl.getAttribLocation(this.program, attribute.name);\n                attributes.push({\n                    name: attribute.name,\n                    glType: getAttributePointerType(gl, attribute.type),\n                    size: getAttributeComponentSize(gl, attribute.type),\n                    location: attributeLocation,\n                    normalized: false\n                });\n            }\n            return attributes;\n        }\n        /**\r\n     * Set a texture in a gpu texture slot\r\n     * @param slotNumber\r\n     * @param texture\r\n     */ setTexture(slotNumber, texture) {\n            const gl = this._gl;\n            gl.activeTexture(gl.TEXTURE0 + slotNumber);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n        }\n        /**\r\n     * Set an integer uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformInt(name, value) {\n            this.setUniform(\"uniform1i\", name, ~~value);\n        }\n        /**\r\n     * Set an integer array uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformIntArray(name, value) {\n            this.setUniform(\"uniform1iv\", name, value);\n        }\n        /**\r\n     * Set a boolean uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformBoolean(name, value) {\n            this.setUniform(\"uniform1i\", name, value ? 1 : 0);\n        }\n        /**\r\n     * Set a float uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformFloat(name, value) {\n            this.setUniform(\"uniform1f\", name, value);\n        }\n        /**\r\n     * Set a float array uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformFloatArray(name, value) {\n            this.setUniform(\"uniform1fv\", name, value);\n        }\n        /**\r\n     * Set a [[Vector]] uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformFloatVector(name, value) {\n            this.setUniform(\"uniform2f\", name, value.x, value.y);\n        }\n        /**\r\n     * Set an [[Matrix]] uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */ setUniformMatrix(name, value) {\n            this.setUniform(\"uniformMatrix4fv\", name, false, value.data);\n        }\n        /**\r\n     * Set any available uniform type in webgl\r\n     *\r\n     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);\r\n     */ setUniform(uniformType, name, ...value) {\n            if (!this._compiled) throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);\n            if (!this.isCurrentlyBound()) throw Error(\"Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms\");\n            const gl = this._gl;\n            const location = gl.getUniformLocation(this.program, name);\n            if (location) {\n                const args = [\n                    location,\n                    ...value\n                ];\n                this._gl[uniformType].apply(this._gl, args);\n            } else throw Error(`Uniform ${uniformType}:${name} doesn\\'t exist or is not used in the shader source code,` + \" unused uniforms are optimized away by most browsers\");\n        }\n        _createProgram(gl, vertexShader, fragmentShader) {\n            const program = gl.createProgram();\n            if (program === null) throw Error(\"Could not create graphics shader program\");\n            // attach the shaders.\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            // link the program.\n            gl.linkProgram(program);\n            const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n            if (!success) throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);\n            return program;\n        }\n        _compileShader(gl, source, type) {\n            const typeName = gl.VERTEX_SHADER === type ? \"vertex\" : \"fragment\";\n            const shader = gl.createShader(type);\n            if (shader === null) throw Error(`Could not build shader: [${source}]`);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n            if (!success) {\n                const errorInfo = gl.getShaderInfoLog(shader);\n                throw Error(`Could not compile ${typeName} shader:\\n\\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);\n            }\n            return shader;\n        }\n        _processSourceForError(source, errorInfo) {\n            const lines = source.split(\"\\n\");\n            const errorLineStart = errorInfo.search(/\\d:\\d/);\n            const errorLineEnd = errorInfo.indexOf(\" \", errorLineStart);\n            const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(\":\").map((v)=>Number(v));\n            for(let i = 0; i < lines.length; i++)lines[i] = `${i + 1}: ${lines[i]}${error2 === i + 1 ? \" <----- ERROR!\" : \"\"}`;\n            return \"\\n\\nSource:\\n\" + lines.join(\"\\n\");\n        }\n    }\n    Shader._ACTIVE_SHADER_INSTANCE = null;\n    /**\r\n * Helper around vertex buffer to simplify creating and uploading geometry\r\n *\r\n * Under the hood uses Float32Array\r\n */ class VertexBuffer {\n        constructor(options){\n            this._gl = ExcaliburWebGLContextAccessor.gl;\n            /**\r\n         * If the vertices never change switching 'static' can be more efficient on the gpu\r\n         *\r\n         * Default is 'dynamic'\r\n         */ this.type = \"dynamic\";\n            const { size: size , type: type , data: data  } = options;\n            this.buffer = this._gl.createBuffer();\n            if (!data && !size) throw Error(\"Must either provide data or a size to the VertexBuffer\");\n            if (!data) this.bufferData = new Float32Array(size);\n            else this.bufferData = data;\n            this.type = type !== null && type !== void 0 ? type : this.type;\n            // Allocate buffer\n            const gl = this._gl;\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === \"static\" ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\n        }\n        /**\r\n     * Bind this vertex buffer\r\n     */ bind() {\n            const gl = this._gl;\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n        }\n        /**\r\n     * Upload vertex buffer geometry to the GPU\r\n     */ upload(count) {\n            const gl = this._gl;\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n            if (count) gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);\n            else // TODO always use bufferSubData? need to perf test it\n            gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === \"static\" ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\n        }\n    }\n    /**\r\n * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing\r\n * the memory layout for your vertices inside a particular buffer\r\n *\r\n * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.\r\n *\r\n * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you\r\n */ class VertexLayout {\n        constructor(options){\n            this._gl = ExcaliburWebGLContextAccessor.gl;\n            this._logger = Logger.getInstance();\n            this._layout = [];\n            this._attributes = [];\n            this._vertexTotalSizeBytes = 0;\n            const { shader: shader , vertexBuffer: vertexBuffer , attributes: attributes  } = options;\n            this._vertexBuffer = vertexBuffer;\n            this._attributes = attributes;\n            this._shader = shader;\n            this.initialize();\n        }\n        get vertexBuffer() {\n            return this._vertexBuffer;\n        }\n        get attributes() {\n            return this._attributes;\n        }\n        /**\r\n     * Total number of bytes that the vertex will take up\r\n     */ get totalVertexSizeBytes() {\n            return this._vertexTotalSizeBytes;\n        }\n        /**\r\n     * Layouts need shader locations and must be bound to a shader\r\n     */ initialize() {\n            if (!this._shader.compiled) throw Error(\"Shader not compiled, shader must be compiled before defining a vertex layout\");\n            this._layout.length = 0;\n            const shaderAttributes = this._shader.attributes;\n            for (const attribute of this._attributes){\n                const attrib = shaderAttributes[attribute[0]];\n                if (!attrib) throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}` + ` not found in the shader source code:\\n ${this._shader.vertexSource}`);\n                if (attrib.size !== attribute[1]) throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],` + ` doesnt match shader source size ${attrib.size}:\\n ${this._shader.vertexSource}`);\n                this._layout.push(attrib);\n            }\n            // calc size\n            let componentsPerVertex = 0;\n            for (const vertAttribute of this._layout){\n                const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);\n                this._vertexTotalSizeBytes += typeSize * vertAttribute.size;\n                componentsPerVertex += vertAttribute.size;\n            }\n            if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer` + ` (${this._vertexBuffer.bufferData.length})`);\n        }\n        /**\r\n     * Bind this layout with it's associated vertex buffer\r\n     *\r\n     * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout\r\n     */ use(uploadBuffer = false, count) {\n            const gl = this._gl;\n            if (!this._shader.isCurrentlyBound()) throw Error(\"Shader associated with this vertex layout is not active! Call shader.use() before layout.use()\");\n            this._vertexBuffer.bind();\n            if (uploadBuffer) this._vertexBuffer.upload(count);\n            let offset = 0;\n            // TODO switch to VAOs if the extension is\n            for (const vert of this._layout){\n                gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);\n                gl.enableVertexAttribArray(vert.location);\n                offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;\n            }\n        }\n    }\n    class GraphicsDiagnostics {\n        static clear() {\n            GraphicsDiagnostics.DrawCallCount = 0;\n            GraphicsDiagnostics.DrawnImagesCount = 0;\n        }\n    }\n    GraphicsDiagnostics.DrawCallCount = 0;\n    GraphicsDiagnostics.DrawnImagesCount = 0;\n    class LineRenderer {\n        constructor(){\n            this.type = \"ex.line\";\n            this.priority = 0;\n            this._maxLines = 10922;\n            this._vertexIndex = 0;\n            this._lineCount = 0;\n        }\n        initialize(gl, context) {\n            this._gl = gl;\n            this._context = context;\n            this._shader = new Shader({\n                vertexSource: line_vertex,\n                fragmentSource: line_fragment\n            });\n            this._shader.compile();\n            this._shader.use();\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            this._vertexBuffer = new VertexBuffer({\n                size: 12 * this._maxLines,\n                type: \"dynamic\"\n            });\n            this._layout = new VertexLayout({\n                vertexBuffer: this._vertexBuffer,\n                shader: this._shader,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_color\",\n                        4\n                    ]\n                ]\n            });\n        }\n        draw(start, end, color) {\n            // Force a render if the batch is full\n            if (this._isFull()) this.flush();\n            this._lineCount++;\n            const transform = this._context.getTransform();\n            const finalStart = transform.multiply(start);\n            const finalEnd = transform.multiply(end);\n            const vertexBuffer = this._vertexBuffer.bufferData;\n            // Start\n            vertexBuffer[this._vertexIndex++] = finalStart.x;\n            vertexBuffer[this._vertexIndex++] = finalStart.y;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            // End\n            vertexBuffer[this._vertexIndex++] = finalEnd.x;\n            vertexBuffer[this._vertexIndex++] = finalEnd.y;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n        }\n        _isFull() {\n            if (this._lineCount >= this._maxLines) return true;\n            return false;\n        }\n        hasPendingDraws() {\n            return this._lineCount !== 0;\n        }\n        flush() {\n            // nothing to draw early exit\n            if (this._lineCount === 0) return;\n            const gl = this._gl;\n            this._shader.use();\n            this._layout.use(true);\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line\n            GraphicsDiagnostics.DrawnImagesCount += this._lineCount;\n            GraphicsDiagnostics.DrawCallCount++;\n            // reset\n            this._vertexIndex = 0;\n            this._lineCount = 0;\n        }\n    }\n    /* harmony default export */ const point_vertex = \"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\nin float a_size;\\r\\nout lowp vec4 v_color;\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n  gl_PointSize = a_size * 2.0;\\r\\n  v_color = a_color;\\r\\n}\";\n    /* harmony default export */ const point_fragment = '#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  float r = 0.0, delta = 0.0, alpha = 1.0;\\r\\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\r\\n  r = dot(cxy, cxy);\\r\\n\\r\\n  delta = fwidth(r);\\r\\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\r\\n  // \"premultiply\" the color by alpha\\r\\n  vec4 color = v_color;\\r\\n  color.a = color.a * alpha;\\r\\n  color.rgb = color.rgb * color.a;\\r\\n  fragColor = color;\\r\\n}';\n    class PointRenderer {\n        constructor(){\n            this.type = \"ex.point\";\n            this.priority = 0;\n            this._maxPoints = 10922;\n            this._pointCount = 0;\n            this._vertexIndex = 0;\n        }\n        initialize(gl, context) {\n            this._gl = gl;\n            this._context = context;\n            this._shader = new Shader({\n                vertexSource: point_vertex,\n                fragmentSource: point_fragment\n            });\n            this._shader.compile();\n            this._shader.use();\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            this._buffer = new VertexBuffer({\n                size: 7 * this._maxPoints,\n                type: \"dynamic\"\n            });\n            this._layout = new VertexLayout({\n                shader: this._shader,\n                vertexBuffer: this._buffer,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_color\",\n                        4\n                    ],\n                    [\n                        \"a_size\",\n                        1\n                    ]\n                ]\n            });\n        }\n        draw(point, color, size) {\n            // Force a render if the batch is full\n            if (this._isFull()) this.flush();\n            this._pointCount++;\n            const transform = this._context.getTransform();\n            const opacity = this._context.opacity;\n            const snapToPixel = this._context.snapToPixel;\n            const finalPoint = transform.multiply(point);\n            if (snapToPixel) {\n                finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);\n                finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);\n            }\n            const vertexBuffer = this._buffer.bufferData;\n            vertexBuffer[this._vertexIndex++] = finalPoint.x;\n            vertexBuffer[this._vertexIndex++] = finalPoint.y;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a * opacity;\n            vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());\n        }\n        _isFull() {\n            if (this._pointCount >= this._maxPoints) return true;\n            return false;\n        }\n        hasPendingDraws() {\n            return this._pointCount !== 0;\n        }\n        flush() {\n            // nothing to draw early exit\n            if (this._pointCount === 0) return;\n            const gl = this._gl;\n            this._shader.use();\n            this._layout.use(true);\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            gl.drawArrays(gl.POINTS, 0, this._pointCount);\n            GraphicsDiagnostics.DrawnImagesCount += this._pointCount;\n            GraphicsDiagnostics.DrawCallCount++;\n            this._pointCount = 0;\n            this._vertexIndex = 0;\n        }\n    }\n    /* harmony default export */ const screen_vertex = \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n  // Pass the texcoord to the fragment shader.\\r\\n  v_texcoord = a_texcoord;\\r\\n}\";\n    /* harmony default export */ const screen_fragment = \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// The texture.\\r\\nuniform sampler2D u_texture;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   fragColor = texture(u_texture, v_texcoord);\\r\\n}\";\n    /**\r\n * This is responsible for painting the entire screen during the render passes\r\n */ class ScreenPassPainter {\n        constructor(gl){\n            this._gl = gl;\n            this._shader = new Shader({\n                vertexSource: screen_vertex,\n                fragmentSource: screen_fragment\n            });\n            this._shader.compile();\n            // Setup memory layout\n            this._buffer = new VertexBuffer({\n                type: \"static\",\n                // clip space quad + uv since we don't need a camera\n                data: new Float32Array([\n                    -1,\n                    -1,\n                    0,\n                    0,\n                    -1,\n                    1,\n                    0,\n                    1,\n                    1,\n                    -1,\n                    1,\n                    0,\n                    1,\n                    -1,\n                    1,\n                    0,\n                    -1,\n                    1,\n                    0,\n                    1,\n                    1,\n                    1,\n                    1,\n                    1\n                ])\n            });\n            this._layout = new VertexLayout({\n                shader: this._shader,\n                vertexBuffer: this._buffer,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_texcoord\",\n                        2\n                    ]\n                ]\n            });\n            this._buffer.upload();\n        }\n        renderWithPostProcessor(postprocessor) {\n            const gl = this._gl;\n            postprocessor.getShader().use();\n            postprocessor.getLayout().use();\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n        }\n        renderToScreen() {\n            const gl = this._gl;\n            this._shader.use();\n            this._layout.use();\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n        }\n    }\n    /**\r\n * Helper that defines and index buffer for quad geometry\r\n *\r\n * Index buffers allow you to save space in vertex buffers when you share vertices in geometry\r\n * it is almost always worth it in terms of performance to use an index buffer.\r\n */ class QuadIndexBuffer {\n        /**\r\n     * @param numberOfQuads Specify the max number of quads you want to draw\r\n     * @param useUint16 Optionally force a uint16 buffer\r\n     */ constructor(numberOfQuads, useUint16){\n            this._gl = ExcaliburWebGLContextAccessor.gl;\n            this._logger = Logger.getInstance();\n            const gl = this._gl;\n            this.buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\n            const totalVertices = numberOfQuads * 6;\n            if (!useUint16) this.bufferData = new Uint32Array(totalVertices);\n            else {\n                // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck\n                const maxUint16 = 65535;\n                const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads\n                this.bufferGlType = gl.UNSIGNED_SHORT;\n                this.bufferData = new Uint16Array(totalVertices);\n                // TODO Should we error if this happens?? maybe not might crash mid game\n                if (numberOfQuads > maxUint16Index) this._logger.warn(`Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);\n            }\n            let currentQuad = 0;\n            for(let i = 0; i < totalVertices; i += 6){\n                // first triangle\n                this.bufferData[i + 0] = currentQuad + 0;\n                this.bufferData[i + 1] = currentQuad + 1;\n                this.bufferData[i + 2] = currentQuad + 2;\n                // second triangle\n                this.bufferData[i + 3] = currentQuad + 2;\n                this.bufferData[i + 4] = currentQuad + 1;\n                this.bufferData[i + 5] = currentQuad + 3;\n                currentQuad += 4;\n            }\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\n        }\n        get size() {\n            return this.bufferData.length;\n        }\n        /**\r\n     * Upload data to the GPU\r\n     */ upload() {\n            const gl = this._gl;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\n        }\n        /**\r\n     * Bind this index buffer\r\n     */ bind() {\n            const gl = this._gl;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\n        }\n    }\n    /* harmony default export */ const image_renderer_frag = \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// Texture index\\r\\nin lowp float v_textureIndex;\\r\\n\\r\\n// Textures in the current draw\\r\\nuniform sampler2D u_textures[%%count%%];\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nin vec4 v_tint;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   // In order to support the most efficient sprite batching, we have multiple\\r\\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\\r\\n   // that do not apply to a particular sprite.\\r\\n\\r\\n   vec4 color = vec4(1.0, 0, 0, 1.0);\\r\\n\\r\\n   // GLSL is templated out to pick the right texture and set the vec4 color\\r\\n   %%texture_picker%%\\r\\n\\r\\n   color.rgb = color.rgb * v_opacity;\\r\\n   color.a = color.a * v_opacity;\\r\\n   fragColor = color * v_tint;\\r\\n}\";\n    /* harmony default export */ const image_renderer_vert = \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\n// Texture number\\r\\nin lowp float a_textureIndex;\\r\\nout lowp float v_textureIndex;\\r\\n\\r\\nin vec4 a_tint;\\r\\nout vec4 v_tint;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the UV coord to the fragment shader\\r\\n   v_texcoord = a_texcoord;\\r\\n   // Pass through the texture number to the fragment shader\\r\\n   v_textureIndex = a_textureIndex;\\r\\n   // Pass through the tint\\r\\n   v_tint = a_tint;\\r\\n}\";\n    class ImageRenderer {\n        constructor(){\n            this.type = \"ex.image\";\n            this.priority = 0;\n            this._maxImages = 10922; // max(uint16) / 6 verts\n            this._maxTextures = 0;\n            // Per flush vars\n            this._imageCount = 0;\n            this._textures = [];\n            this._vertexIndex = 0;\n        }\n        initialize(gl, context) {\n            this._gl = gl;\n            this._context = context;\n            // Transform shader source\n            // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...\n            this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);\n            const transformedFrag = this._transformFragmentSource(image_renderer_frag, this._maxTextures);\n            // Compile shader\n            this._shader = new Shader({\n                fragmentSource: transformedFrag,\n                vertexSource: image_renderer_vert\n            });\n            this._shader.compile();\n            // setup uniforms\n            this._shader.use();\n            this._shader.setUniformMatrix(\"u_matrix\", context.ortho);\n            // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]\n            this._shader.setUniformIntArray(\"u_textures\", [\n                ...Array(this._maxTextures)\n            ].map((_, i)=>i));\n            // Setup memory layout\n            this._buffer = new VertexBuffer({\n                size: 40 * this._maxImages,\n                type: \"dynamic\"\n            });\n            this._layout = new VertexLayout({\n                shader: this._shader,\n                vertexBuffer: this._buffer,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_opacity\",\n                        1\n                    ],\n                    [\n                        \"a_texcoord\",\n                        2\n                    ],\n                    [\n                        \"a_textureIndex\",\n                        1\n                    ],\n                    [\n                        \"a_tint\",\n                        4\n                    ]\n                ]\n            });\n            // Setup index buffer\n            this._quads = new QuadIndexBuffer(this._maxImages, true);\n        }\n        _transformFragmentSource(source, maxTextures) {\n            let newSource = source.replace(\"%%count%%\", maxTextures.toString());\n            let texturePickerBuilder = \"\";\n            for(let i = 0; i < maxTextures; i++){\n                if (i === 0) texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\\n`;\n                else texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\\n`;\n                texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\\n`;\n                texturePickerBuilder += `   }\\n`;\n            }\n            newSource = newSource.replace(\"%%texture_picker%%\", texturePickerBuilder);\n            return newSource;\n        }\n        _addImageAsTexture(image) {\n            const texture = TextureLoader.load(image);\n            if (this._textures.indexOf(texture) === -1) this._textures.push(texture);\n        }\n        _bindTextures(gl) {\n            // Bind textures in the correct order\n            for(let i = 0; i < this._maxTextures; i++){\n                gl.activeTexture(gl.TEXTURE0 + i);\n                gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);\n            }\n        }\n        _getTextureIdForImage(image) {\n            if (image) return this._textures.indexOf(TextureLoader.get(image));\n            return -1;\n        }\n        _isFull() {\n            if (this._imageCount >= this._maxImages) return true;\n            if (this._textures.length >= this._maxTextures) return true;\n            return false;\n        }\n        draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n            var _a, _b, _c, _d;\n            // Force a render if the batch is full\n            if (this._isFull()) this.flush();\n            this._imageCount++;\n            this._addImageAsTexture(image);\n            let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;\n            let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;\n            let view = [\n                0,\n                0,\n                (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0,\n                (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0\n            ];\n            let dest = [\n                sx !== null && sx !== void 0 ? sx : 1,\n                sy !== null && sy !== void 0 ? sy : 1\n            ];\n            // If destination is specified, update view and dest\n            if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {\n                view = [\n                    sx !== null && sx !== void 0 ? sx : 1,\n                    sy !== null && sy !== void 0 ? sy : 1,\n                    (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0,\n                    (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0\n                ];\n                dest = [\n                    dx,\n                    dy\n                ];\n                width = dwidth;\n                height = dheight;\n            }\n            sx = view[0];\n            sy = view[1];\n            const sw = view[2];\n            const sh = view[3];\n            // transform based on current context\n            const transform = this._context.getTransform();\n            const opacity = this._context.opacity;\n            const snapToPixel = this._context.snapToPixel;\n            let topLeft = vec(dest[0], dest[1]);\n            let topRight = vec(dest[0] + width, dest[1]);\n            let bottomLeft = vec(dest[0], dest[1] + height);\n            let bottomRight = vec(dest[0] + width, dest[1] + height);\n            topLeft = transform.multiply(topLeft);\n            topRight = transform.multiply(topRight);\n            bottomLeft = transform.multiply(bottomLeft);\n            bottomRight = transform.multiply(bottomRight);\n            if (snapToPixel) {\n                topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\n                topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\n                topRight.x = ~~(topRight.x + pixelSnapEpsilon);\n                topRight.y = ~~(topRight.y + pixelSnapEpsilon);\n                bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\n                bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\n                bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\n                bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\n            }\n            const tint = this._context.tint;\n            const textureId = this._getTextureIdForImage(image);\n            const imageWidth = image.width || width;\n            const imageHeight = image.height || height;\n            const uvx0 = sx / imageWidth;\n            const uvy0 = sy / imageHeight;\n            const uvx1 = (sx + sw - 0.01) / imageWidth;\n            const uvy1 = (sy + sh - 0.01) / imageHeight;\n            // update data\n            const vertexBuffer = this._layout.vertexBuffer.bufferData;\n            // (0, 0) - 0\n            vertexBuffer[this._vertexIndex++] = topLeft.x;\n            vertexBuffer[this._vertexIndex++] = topLeft.y;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = textureId;\n            vertexBuffer[this._vertexIndex++] = tint.r / 255;\n            vertexBuffer[this._vertexIndex++] = tint.g / 255;\n            vertexBuffer[this._vertexIndex++] = tint.b / 255;\n            vertexBuffer[this._vertexIndex++] = tint.a;\n            // (0, 1) - 1\n            vertexBuffer[this._vertexIndex++] = bottomLeft.x;\n            vertexBuffer[this._vertexIndex++] = bottomLeft.y;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = textureId;\n            vertexBuffer[this._vertexIndex++] = tint.r / 255;\n            vertexBuffer[this._vertexIndex++] = tint.g / 255;\n            vertexBuffer[this._vertexIndex++] = tint.b / 255;\n            vertexBuffer[this._vertexIndex++] = tint.a;\n            // (1, 0) - 2\n            vertexBuffer[this._vertexIndex++] = topRight.x;\n            vertexBuffer[this._vertexIndex++] = topRight.y;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = textureId;\n            vertexBuffer[this._vertexIndex++] = tint.r / 255;\n            vertexBuffer[this._vertexIndex++] = tint.g / 255;\n            vertexBuffer[this._vertexIndex++] = tint.b / 255;\n            vertexBuffer[this._vertexIndex++] = tint.a;\n            // (1, 1) - 3\n            vertexBuffer[this._vertexIndex++] = bottomRight.x;\n            vertexBuffer[this._vertexIndex++] = bottomRight.y;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = textureId;\n            vertexBuffer[this._vertexIndex++] = tint.r / 255;\n            vertexBuffer[this._vertexIndex++] = tint.g / 255;\n            vertexBuffer[this._vertexIndex++] = tint.b / 255;\n            vertexBuffer[this._vertexIndex++] = tint.a;\n        }\n        hasPendingDraws() {\n            return this._imageCount !== 0;\n        }\n        flush() {\n            // nothing to draw early exit\n            if (this._imageCount === 0) return;\n            const gl = this._gl;\n            // Bind the shader\n            this._shader.use();\n            // Bind the memory layout and upload data\n            this._layout.use(true, 40 * this._imageCount);\n            // Update ortho matrix uniform\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            // Bind textures to\n            this._bindTextures(gl);\n            // Bind index buffer\n            this._quads.bind();\n            // Draw all the quads\n            gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);\n            GraphicsDiagnostics.DrawnImagesCount += this._imageCount;\n            GraphicsDiagnostics.DrawCallCount++;\n            // Reset\n            this._imageCount = 0;\n            this._vertexIndex = 0;\n            this._textures.length = 0;\n        }\n    }\n    /* harmony default export */ const rectangle_renderer_frag = \"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\nin vec2 v_size; // in pixels\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness; // in pixels\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\\r\\n    vec2 uv = v_uv;\\r\\n    vec2 fragCoord = uv * v_size;\\r\\n    float maxX = v_size.x - v_strokeThickness;\\r\\n    float minX = v_strokeThickness;\\r\\n    float maxY = v_size.y - v_strokeThickness;\\r\\n    float minY = v_strokeThickness;\\r\\n\\r\\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\\r\\n        fragCoord.y < maxY && fragCoord.y > minY) {\\r\\n      fragColor = v_color;\\r\\n    } else {\\r\\n      fragColor = v_strokeColor;\\r\\n    }\\r\\n    fragColor.a *= v_opacity;\\r\\n    fragColor.rgb *= fragColor.a;\\r\\n\\r\\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\\r\\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\\r\\n\\r\\n    // float fHalfBorderDist      = 0.0;\\r\\n    // float fHalfBorderThickness = 0.0;\\r\\n\\r\\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \\r\\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \\r\\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else\\r\\n    // {\\r\\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\\r\\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\\r\\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\\r\\n        \\r\\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\\r\\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\\r\\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \\r\\n            \\r\\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\\r\\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\\r\\n    // }\\r\\n\\r\\n    // vec4 v4FromColor = v_strokeColor;\\r\\n    // v4FromColor.rgb *= v4FromColor.a;\\r\\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\\r\\n    // if (fHalfBorderDist < 0.0) {\\r\\n    //     v4ToColor = v_color;\\r\\n    //     v4ToColor.rgb *= v4ToColor.a;\\r\\n    // }\\r\\n\\r\\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\\r\\n\\r\\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\\r\\n    // gl_FragColor = finalColor;\\r\\n}\";\n    /* harmony default export */ const rectangle_renderer_vert = \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\nin vec2 a_size;\\r\\nout vec2 v_size;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through size\\r\\n   v_size = a_size;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\";\n    class RectangleRenderer {\n        constructor(){\n            this.type = \"ex.rectangle\";\n            this.priority = 0;\n            this._maxRectangles = 10922; // max(uint16) / 6 verts\n            this._rectangleCount = 0;\n            this._vertexIndex = 0;\n        }\n        initialize(gl, context) {\n            this._gl = gl;\n            this._context = context;\n            // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\n            this._shader = new Shader({\n                fragmentSource: rectangle_renderer_frag,\n                vertexSource: rectangle_renderer_vert\n            });\n            this._shader.compile();\n            // setup uniforms\n            this._shader.use();\n            this._shader.setUniformMatrix(\"u_matrix\", context.ortho);\n            this._buffer = new VertexBuffer({\n                size: 64 * this._maxRectangles,\n                type: \"dynamic\"\n            });\n            this._layout = new VertexLayout({\n                shader: this._shader,\n                vertexBuffer: this._buffer,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_uv\",\n                        2\n                    ],\n                    [\n                        \"a_size\",\n                        2\n                    ],\n                    [\n                        \"a_opacity\",\n                        1\n                    ],\n                    [\n                        \"a_color\",\n                        4\n                    ],\n                    [\n                        \"a_strokeColor\",\n                        4\n                    ],\n                    [\n                        \"a_strokeThickness\",\n                        1\n                    ]\n                ]\n            });\n            this._quads = new QuadIndexBuffer(this._maxRectangles, true);\n        }\n        _isFull() {\n            if (this._rectangleCount >= this._maxRectangles) return true;\n            return false;\n        }\n        draw(...args) {\n            if (args[0] instanceof Vector && args[1] instanceof Vector) this.drawLine.apply(this, args);\n            else this.drawRectangle.apply(this, args);\n        }\n        drawLine(start, end, color, thickness = 1) {\n            if (this._isFull()) this.flush();\n            this._rectangleCount++;\n            // transform based on current context\n            const transform = this._context.getTransform();\n            const opacity = this._context.opacity;\n            const snapToPixel = this._context.snapToPixel;\n            const dir = end.sub(start);\n            const length = dir.size;\n            const normal = dir.normalize().perpendicular();\n            const halfThick = thickness / 2;\n            /**\r\n         *    +---------------------^----------------------+\r\n         *    |                     | (normal)             |\r\n         *   (startx, starty)------------------>(endx, endy)\r\n         *    |                                            |\r\n         *    + -------------------------------------------+\r\n         */ const startTop = transform.multiply(normal.scale(halfThick).add(start));\n            const startBottom = transform.multiply(normal.scale(-halfThick).add(start));\n            const endTop = transform.multiply(normal.scale(halfThick).add(end));\n            const endBottom = transform.multiply(normal.scale(-halfThick).add(end));\n            if (snapToPixel) {\n                startTop.x = ~~(startTop.x + pixelSnapEpsilon);\n                startTop.y = ~~(startTop.y + pixelSnapEpsilon);\n                endTop.x = ~~(endTop.x + pixelSnapEpsilon);\n                endTop.y = ~~(endTop.y + pixelSnapEpsilon);\n                startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);\n                startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);\n                endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);\n                endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);\n            }\n            // TODO uv could be static vertex buffer\n            const uvx0 = 0;\n            const uvy0 = 0;\n            const uvx1 = 1;\n            const uvy1 = 1;\n            const stroke = Color.Transparent;\n            const strokeThickness = 0;\n            const width = 1;\n            // update data\n            const vertexBuffer = this._layout.vertexBuffer.bufferData;\n            // (0, 0) - 0\n            vertexBuffer[this._vertexIndex++] = startTop.x;\n            vertexBuffer[this._vertexIndex++] = startTop.y;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = length;\n            vertexBuffer[this._vertexIndex++] = thickness;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / width;\n            // (0, 1) - 1\n            vertexBuffer[this._vertexIndex++] = startBottom.x;\n            vertexBuffer[this._vertexIndex++] = startBottom.y;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = length;\n            vertexBuffer[this._vertexIndex++] = thickness;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / width;\n            // (1, 0) - 2\n            vertexBuffer[this._vertexIndex++] = endTop.x;\n            vertexBuffer[this._vertexIndex++] = endTop.y;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = length;\n            vertexBuffer[this._vertexIndex++] = thickness;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / width;\n            // (1, 1) - 3\n            vertexBuffer[this._vertexIndex++] = endBottom.x;\n            vertexBuffer[this._vertexIndex++] = endBottom.y;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = length;\n            vertexBuffer[this._vertexIndex++] = thickness;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / width;\n        }\n        drawRectangle(pos, width, height, color, stroke = Color.Transparent, strokeThickness = 0) {\n            if (this._isFull()) this.flush();\n            this._rectangleCount++;\n            // transform based on current context\n            const transform = this._context.getTransform();\n            const opacity = this._context.opacity;\n            const snapToPixel = this._context.snapToPixel;\n            const topLeft = transform.multiply(pos.add(vec(0, 0)));\n            const topRight = transform.multiply(pos.add(vec(width, 0)));\n            const bottomRight = transform.multiply(pos.add(vec(width, height)));\n            const bottomLeft = transform.multiply(pos.add(vec(0, height)));\n            if (snapToPixel) {\n                topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\n                topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\n                topRight.x = ~~(topRight.x + pixelSnapEpsilon);\n                topRight.y = ~~(topRight.y + pixelSnapEpsilon);\n                bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\n                bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\n                bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\n                bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\n            }\n            // TODO uv could be static vertex buffer\n            const uvx0 = 0;\n            const uvy0 = 0;\n            const uvx1 = 1;\n            const uvy1 = 1;\n            // update data\n            const vertexBuffer = this._layout.vertexBuffer.bufferData;\n            // (0, 0) - 0\n            vertexBuffer[this._vertexIndex++] = topLeft.x;\n            vertexBuffer[this._vertexIndex++] = topLeft.y;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = width;\n            vertexBuffer[this._vertexIndex++] = height;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness;\n            // (0, 1) - 1\n            vertexBuffer[this._vertexIndex++] = bottomLeft.x;\n            vertexBuffer[this._vertexIndex++] = bottomLeft.y;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = width;\n            vertexBuffer[this._vertexIndex++] = height;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness;\n            // (1, 0) - 2\n            vertexBuffer[this._vertexIndex++] = topRight.x;\n            vertexBuffer[this._vertexIndex++] = topRight.y;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = width;\n            vertexBuffer[this._vertexIndex++] = height;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness;\n            // (1, 1) - 3\n            vertexBuffer[this._vertexIndex++] = bottomRight.x;\n            vertexBuffer[this._vertexIndex++] = bottomRight.y;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = width;\n            vertexBuffer[this._vertexIndex++] = height;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness;\n        }\n        hasPendingDraws() {\n            return this._rectangleCount !== 0;\n        }\n        flush() {\n            // nothing to draw early exit\n            if (this._rectangleCount === 0) return;\n            const gl = this._gl;\n            // Bind the shader\n            this._shader.use();\n            // Bind the memory layout and upload data\n            this._layout.use(true);\n            // Update ortho matrix uniform\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            // Bind index buffer\n            this._quads.bind();\n            // Draw all the quads\n            gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);\n            GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;\n            GraphicsDiagnostics.DrawCallCount++;\n            // Reset\n            this._rectangleCount = 0;\n            this._vertexIndex = 0;\n        }\n    }\n    /* harmony default export */ const circle_renderer_frag = \"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness;\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  // make (0, 0) the center the uv \\r\\n  vec2 uv = v_uv * 2.0 - 1.0;\\r\\n\\r\\n  vec4 color = v_color;\\r\\n  vec4 strokeColor = v_strokeColor;\\r\\n\\r\\n  // circle border is at radius 1.0 \\r\\n  // dist is > 0 when inside the circle \\r\\n  float d = length(uv);\\r\\n  float dist = 1.0 - length(uv);\\r\\n\\r\\n  // Fade based on fwidth\\r\\n  float fade = fwidth(dot(uv, uv));\\r\\n\\r\\n  // if dist is greater than 0 step to 1;\\r\\n  // when we cross this 0 threshold add a smooth fade\\r\\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\\r\\n\\r\\n  // if dist is greater than the stroke thickness step to 1\\r\\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\\r\\n\\r\\n  strokeColor.a *= fill * stroke;\\r\\n  strokeColor.rgb *= strokeColor.a;\\r\\n\\r\\n  color.a *= fill * (1.0 - stroke);\\r\\n  color.rgb *= color.a;\\r\\n\\r\\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\\r\\n  finalColor.rgb = finalColor.rgb * v_opacity;\\r\\n  finalColor.a = finalColor.a * v_opacity;\\r\\n  fragColor = finalColor;\\r\\n}\";\n    /* harmony default export */ const circle_renderer_vert = \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\";\n    class CircleRenderer {\n        constructor(){\n            this.type = \"ex.circle\";\n            this.priority = 0;\n            this._maxCircles = 10922; // max(uint16) / 6 verts\n            this._circleCount = 0;\n            this._vertexIndex = 0;\n        }\n        initialize(gl, context) {\n            this._gl = gl;\n            this._context = context;\n            this._shader = new Shader({\n                fragmentSource: circle_renderer_frag,\n                vertexSource: circle_renderer_vert\n            });\n            this._shader.compile();\n            // setup uniforms\n            this._shader.use();\n            this._shader.setUniformMatrix(\"u_matrix\", context.ortho);\n            this._buffer = new VertexBuffer({\n                size: 56 * this._maxCircles,\n                type: \"dynamic\"\n            });\n            this._layout = new VertexLayout({\n                shader: this._shader,\n                vertexBuffer: this._buffer,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_uv\",\n                        2\n                    ],\n                    [\n                        \"a_opacity\",\n                        1\n                    ],\n                    [\n                        \"a_color\",\n                        4\n                    ],\n                    [\n                        \"a_strokeColor\",\n                        4\n                    ],\n                    [\n                        \"a_strokeThickness\",\n                        1\n                    ]\n                ]\n            });\n            this._quads = new QuadIndexBuffer(this._maxCircles, true);\n        }\n        _isFull() {\n            if (this._circleCount >= this._maxCircles) return true;\n            return false;\n        }\n        draw(pos, radius, color, stroke = Color.Transparent, strokeThickness = 0) {\n            if (this._isFull()) this.flush();\n            this._circleCount++;\n            // transform based on current context\n            const transform = this._context.getTransform();\n            const opacity = this._context.opacity;\n            const snapToPixel = this._context.snapToPixel;\n            const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));\n            const topRight = transform.multiply(pos.add(vec(radius, -radius)));\n            const bottomRight = transform.multiply(pos.add(vec(radius, radius)));\n            const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));\n            if (snapToPixel) {\n                topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\n                topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\n                topRight.x = ~~(topRight.x + pixelSnapEpsilon);\n                topRight.y = ~~(topRight.y + pixelSnapEpsilon);\n                bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\n                bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\n                bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\n                bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\n            }\n            // TODO UV could be static vertex buffer\n            const uvx0 = 0;\n            const uvy0 = 0;\n            const uvx1 = 1;\n            const uvy1 = 1;\n            // update data\n            const vertexBuffer = this._layout.vertexBuffer.bufferData;\n            // (0, 0) - 0\n            vertexBuffer[this._vertexIndex++] = topLeft.x;\n            vertexBuffer[this._vertexIndex++] = topLeft.y;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\n            // (0, 1) - 1\n            vertexBuffer[this._vertexIndex++] = bottomLeft.x;\n            vertexBuffer[this._vertexIndex++] = bottomLeft.y;\n            vertexBuffer[this._vertexIndex++] = uvx0;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\n            // (1, 0) - 2\n            vertexBuffer[this._vertexIndex++] = topRight.x;\n            vertexBuffer[this._vertexIndex++] = topRight.y;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy0;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\n            // (1, 1) - 3\n            vertexBuffer[this._vertexIndex++] = bottomRight.x;\n            vertexBuffer[this._vertexIndex++] = bottomRight.y;\n            vertexBuffer[this._vertexIndex++] = uvx1;\n            vertexBuffer[this._vertexIndex++] = uvy1;\n            vertexBuffer[this._vertexIndex++] = opacity;\n            vertexBuffer[this._vertexIndex++] = color.r / 255;\n            vertexBuffer[this._vertexIndex++] = color.g / 255;\n            vertexBuffer[this._vertexIndex++] = color.b / 255;\n            vertexBuffer[this._vertexIndex++] = color.a;\n            vertexBuffer[this._vertexIndex++] = stroke.r / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.g / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.b / 255;\n            vertexBuffer[this._vertexIndex++] = stroke.a;\n            vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\n        }\n        hasPendingDraws() {\n            return this._circleCount !== 0;\n        }\n        flush() {\n            // nothing to draw early exit\n            if (this._circleCount === 0) return;\n            const gl = this._gl;\n            // Bind the shader\n            this._shader.use();\n            // Bind the memory layout and upload data\n            this._layout.use(true);\n            // Update ortho matrix uniform\n            this._shader.setUniformMatrix(\"u_matrix\", this._context.ortho);\n            // Bind index buffer\n            this._quads.bind();\n            // Draw all the quads\n            gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);\n            GraphicsDiagnostics.DrawnImagesCount += this._circleCount;\n            GraphicsDiagnostics.DrawCallCount++;\n            // Reset\n            this._circleCount = 0;\n            this._vertexIndex = 0;\n        }\n    }\n    class Pool {\n        constructor(builder, recycler, maxObjects = 100){\n            this.builder = builder;\n            this.recycler = recycler;\n            this.maxObjects = maxObjects;\n            this.totalAllocations = 0;\n            this.index = 0;\n            this.objects = [];\n            this.disableWarnings = false;\n            this._logger = Logger.getInstance();\n        }\n        preallocate() {\n            for(let i = 0; i < this.maxObjects; i++)this.objects[i] = this.builder();\n        }\n        /**\r\n     * Use many instances out of the in the context and return all to the pool.\r\n     *\r\n     * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers\r\n     * @param context\r\n     */ using(context) {\n            const result = context(this);\n            if (result) return this.done(...result);\n            return this.done();\n        }\n        /**\r\n     * Use a single instance out of th pool and immediately return it to the pool\r\n     * @param context\r\n     */ borrow(context) {\n            const object = this.get();\n            context(object);\n            this.index--;\n        }\n        /**\r\n     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool\r\n     * @param args\r\n     */ get(...args) {\n            if (this.index === this.maxObjects) {\n                if (!this.disableWarnings) this._logger.warn(\"Max pooled objects reached, possible memory leak? Doubling\");\n                this.maxObjects = this.maxObjects * 2;\n            }\n            if (this.objects[this.index]) // Pool has an available object already constructed\n            return this.recycler(this.objects[this.index++], ...args);\n            else {\n                // New allocation\n                this.totalAllocations++;\n                const object = this.objects[this.index++] = this.builder(...args);\n                return object;\n            }\n        }\n        done(...objects) {\n            // All objects in pool now considered \"free\"\n            this.index = 0;\n            for (const object of objects){\n                const poolIndex = this.objects.indexOf(object);\n                // Build a new object to take the pool place\n                this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support\n                this.totalAllocations++;\n            }\n            return objects;\n        }\n    }\n    class DrawCall {\n        constructor(){\n            this.z = 0;\n            this.priority = 0;\n            this.transform = AffineMatrix.identity();\n            this.state = {\n                z: 0,\n                opacity: 1,\n                tint: Color.White\n            };\n        }\n    }\n    // renderers\n    const pixelSnapEpsilon = 0.0001;\n    class ExcaliburGraphicsContextWebGLDebug {\n        constructor(_webglCtx){\n            this._webglCtx = _webglCtx;\n            this._debugText = new DebugText();\n        }\n        /**\r\n     * Draw a debugging rectangle to the context\r\n     * @param x\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     */ drawRect(x, y, width, height, rectOptions = {\n            color: Color.Black\n        }) {\n            this.drawLine(vec(x, y), vec(x + width, y), {\n                ...rectOptions\n            });\n            this.drawLine(vec(x + width, y), vec(x + width, y + height), {\n                ...rectOptions\n            });\n            this.drawLine(vec(x + width, y + height), vec(x, y + height), {\n                ...rectOptions\n            });\n            this.drawLine(vec(x, y + height), vec(x, y), {\n                ...rectOptions\n            });\n        }\n        /**\r\n     * Draw a debugging line to the context\r\n     * @param start\r\n     * @param end\r\n     * @param lineOptions\r\n     */ drawLine(start, end, lineOptions = {\n            color: Color.Black\n        }) {\n            this._webglCtx.draw(\"ex.line\", start, end, lineOptions.color);\n        }\n        /**\r\n     * Draw a debugging point to the context\r\n     * @param point\r\n     * @param pointOptions\r\n     */ drawPoint(point, pointOptions = {\n            color: Color.Black,\n            size: 5\n        }) {\n            this._webglCtx.draw(\"ex.point\", point, pointOptions.color, pointOptions.size);\n        }\n        drawText(text, pos) {\n            this._debugText.write(this._webglCtx, text, pos);\n        }\n    }\n    class ExcaliburGraphicsContextWebGL {\n        constructor(options){\n            this._logger = Logger.getInstance();\n            this._renderers = new Map();\n            this._isDrawLifecycle = false;\n            this.useDrawSorting = true;\n            this._drawCallPool = new Pool(()=>new DrawCall(), (instance)=>{\n                instance.priority = 0;\n                instance.z = 0;\n                instance.renderer = undefined;\n                instance.args = undefined;\n                return instance;\n            }, 4000);\n            this._drawCalls = [];\n            // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process\n            this._postProcessTargets = [];\n            this._postprocessors = [];\n            this._transform = new TransformStack();\n            this._state = new StateStack();\n            this.snapToPixel = false;\n            this.smoothing = false;\n            this.backgroundColor = Color.ExcaliburBlue;\n            this._alreadyWarnedDrawLifecycle = false;\n            this.debug = new ExcaliburGraphicsContextWebGLDebug(this);\n            const { canvasElement: canvasElement , enableTransparency: enableTransparency , smoothing: smoothing , snapToPixel: snapToPixel , backgroundColor: backgroundColor , useDrawSorting: useDrawSorting  } = options;\n            this.__gl = canvasElement.getContext(\"webgl2\", {\n                antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,\n                premultipliedAlpha: false,\n                alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,\n                depth: true,\n                powerPreference: \"high-performance\"\n            });\n            if (!this.__gl) throw Error(\"Failed to retrieve webgl context from browser\");\n            ExcaliburWebGLContextAccessor.register(this.__gl);\n            TextureLoader.register(this.__gl);\n            this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;\n            this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;\n            this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;\n            this.useDrawSorting = useDrawSorting !== null && useDrawSorting !== void 0 ? useDrawSorting : this.useDrawSorting;\n            this._drawCallPool.disableWarnings = true;\n            this._drawCallPool.preallocate();\n            this._init();\n        }\n        get z() {\n            return this._state.current.z;\n        }\n        set z(value) {\n            this._state.current.z = value;\n        }\n        get opacity() {\n            return this._state.current.opacity;\n        }\n        set opacity(value) {\n            this._state.current.opacity = value;\n        }\n        get tint() {\n            return this._state.current.tint;\n        }\n        set tint(color) {\n            this._state.current.tint = color;\n        }\n        get width() {\n            return this.__gl.canvas.width;\n        }\n        get height() {\n            return this.__gl.canvas.height;\n        }\n        get ortho() {\n            return this._ortho;\n        }\n        /**\r\n     * Checks the underlying webgl implementation if the requested internal resolution is supported\r\n     * @param dim\r\n     */ checkIfResolutionSupported(dim) {\n            // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo\n            let supported = true;\n            if (dim.width > 4096 || dim.height > 4096) supported = false;\n            return supported;\n        }\n        _init() {\n            const gl = this.__gl;\n            // Setup viewport and view matrix\n            this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n            // Clear background\n            gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            // Enable alpha blending\n            // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/\n            gl.enable(gl.BLEND);\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            // Setup builtin renderers\n            this.register(new ImageRenderer());\n            this.register(new RectangleRenderer());\n            this.register(new CircleRenderer());\n            this.register(new PointRenderer());\n            this.register(new LineRenderer());\n            this._screenRenderer = new ScreenPassPainter(gl);\n            this._renderTarget = new RenderTarget({\n                gl: gl,\n                width: gl.canvas.width,\n                height: gl.canvas.height\n            });\n            this._postProcessTargets = [\n                new RenderTarget({\n                    gl: gl,\n                    width: gl.canvas.width,\n                    height: gl.canvas.height\n                }),\n                new RenderTarget({\n                    gl: gl,\n                    width: gl.canvas.width,\n                    height: gl.canvas.height\n                })\n            ];\n        }\n        register(renderer) {\n            this._renderers.set(renderer.type, renderer);\n            renderer.initialize(this.__gl, this);\n        }\n        get(rendererName) {\n            return this._renderers.get(rendererName);\n        }\n        _isCurrentRenderer(renderer) {\n            if (!this._currentRenderer || this._currentRenderer === renderer) return true;\n            return false;\n        }\n        beginDrawLifecycle() {\n            this._isDrawLifecycle = true;\n        }\n        endDrawLifecycle() {\n            this._isDrawLifecycle = false;\n        }\n        draw(rendererName, ...args) {\n            if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {\n                this._logger.warn(`Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\\n` + `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);\n                this._alreadyWarnedDrawLifecycle = true;\n            }\n            const renderer = this._renderers.get(rendererName);\n            if (renderer) {\n                if (this.useDrawSorting) {\n                    const drawCall = this._drawCallPool.get();\n                    drawCall.z = this._state.current.z;\n                    drawCall.priority = renderer.priority;\n                    drawCall.renderer = rendererName;\n                    this.getTransform().clone(drawCall.transform);\n                    drawCall.state.z = this._state.current.z;\n                    drawCall.state.opacity = this._state.current.opacity;\n                    drawCall.state.tint = this._state.current.tint;\n                    drawCall.args = args;\n                    this._drawCalls.push(drawCall);\n                } else {\n                    // Set the current renderer if not defined\n                    if (!this._currentRenderer) this._currentRenderer = renderer;\n                    if (!this._isCurrentRenderer(renderer)) // switching graphics means we must flush the previous\n                    this._currentRenderer.flush();\n                    // If we are still using the same renderer we can add to the current batch\n                    renderer.draw(...args);\n                    this._currentRenderer = renderer;\n                }\n            } else throw Error(`No renderer with name ${rendererName} has been registered`);\n        }\n        resetTransform() {\n            this._transform.current = AffineMatrix.identity();\n        }\n        updateViewport(resolution) {\n            const gl = this.__gl;\n            this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);\n            this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);\n            this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);\n            this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);\n        }\n        drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n            if (swidth === 0 || sheight === 0) return; // zero dimension dest exit early\n            else if (dwidth === 0 || dheight === 0) return; // zero dimension dest exit early\n            else if (image.width === 0 || image.height === 0) return; // zero dimension source exit early\n            if (!image) {\n                Logger.getInstance().warn(\"Cannot draw a null or undefined image\");\n                // tslint:disable-next-line: no-console\n                if (console.trace) // tslint:disable-next-line: no-console\n                console.trace();\n                return;\n            }\n            this.draw(\"ex.image\", image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\n        }\n        drawLine(start, end, color, thickness = 1) {\n            this.draw(\"ex.rectangle\", start, end, color, thickness);\n        }\n        drawRectangle(pos, width, height, color, stroke, strokeThickness) {\n            this.draw(\"ex.rectangle\", pos, width, height, color, stroke, strokeThickness);\n        }\n        drawCircle(pos, radius, color, stroke, thickness) {\n            this.draw(\"ex.circle\", pos, radius, color, stroke, thickness);\n        }\n        save() {\n            this._transform.save();\n            this._state.save();\n        }\n        restore() {\n            this._transform.restore();\n            this._state.restore();\n        }\n        translate(x, y) {\n            this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);\n        }\n        rotate(angle) {\n            this._transform.rotate(angle);\n        }\n        scale(x, y) {\n            this._transform.scale(x, y);\n        }\n        transform(matrix) {\n            this._transform.current = matrix;\n        }\n        getTransform() {\n            return this._transform.current;\n        }\n        multiply(m) {\n            this._transform.current.multiply(m, this._transform.current);\n        }\n        addPostProcessor(postprocessor) {\n            this._postprocessors.push(postprocessor);\n            postprocessor.initialize(this.__gl);\n        }\n        removePostProcessor(postprocessor) {\n            const index = this._postprocessors.indexOf(postprocessor);\n            if (index !== -1) this._postprocessors.splice(index, 1);\n        }\n        clearPostProcessors() {\n            this._postprocessors.length = 0;\n        }\n        clear() {\n            const gl = this.__gl;\n            this._renderTarget.use();\n            gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\n            // Clear the context with the newly set color. This is\n            // the function call that actually does the drawing.\n            gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        /**\r\n     * Flushes all batched rendering to the screen\r\n     */ flush() {\n            const gl = this.__gl;\n            // render target captures all draws and redirects to the render target\n            this._renderTarget.use();\n            if (this.useDrawSorting) {\n                // sort draw calls\n                // Find the original order of the first instance of the draw call\n                const originalSort = new Map();\n                for (const [name] of this._renderers){\n                    const firstIndex = this._drawCalls.findIndex((dc)=>dc.renderer === name);\n                    originalSort.set(name, firstIndex);\n                }\n                this._drawCalls.sort((a, b)=>{\n                    const zIndex = a.z - b.z;\n                    const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);\n                    const priority = a.priority - b.priority;\n                    if (zIndex === 0) {\n                        if (priority === 0) return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order\n                        return priority;\n                    }\n                    return zIndex;\n                });\n                const oldTransform = this._transform.current;\n                const oldState = this._state.current;\n                if (this._drawCalls.length) {\n                    let currentRendererName = this._drawCalls[0].renderer;\n                    let currentRenderer = this._renderers.get(currentRendererName);\n                    for(let i = 0; i < this._drawCalls.length; i++){\n                        // hydrate the state for renderers\n                        this._transform.current = this._drawCalls[i].transform;\n                        this._state.current = this._drawCalls[i].state;\n                        if (this._drawCalls[i].renderer !== currentRendererName) {\n                            // switching graphics renderer means we must flush the previous\n                            currentRenderer.flush();\n                            currentRendererName = this._drawCalls[i].renderer;\n                            currentRenderer = this._renderers.get(currentRendererName);\n                        }\n                        // If we are still using the same renderer we can add to the current batch\n                        currentRenderer.draw(...this._drawCalls[i].args);\n                    }\n                    if (currentRenderer.hasPendingDraws()) currentRenderer.flush();\n                }\n                // reset state\n                this._transform.current = oldTransform;\n                this._state.current = oldState;\n                // reclaim draw calls\n                this._drawCallPool.done();\n                this._drawCalls.length = 0;\n            } else {\n                // This is the final flush at the moment to draw any leftover pending draw\n                for (const renderer of this._renderers.values())if (renderer.hasPendingDraws()) renderer.flush();\n            }\n            this._renderTarget.disable();\n            // post process step\n            const source = this._renderTarget.toRenderSource();\n            source.use();\n            // flip flop render targets\n            for(let i = 0; i < this._postprocessors.length; i++){\n                this._postProcessTargets[i % 2].use();\n                this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);\n                this._postProcessTargets[i % 2].toRenderSource().use();\n            }\n            // passing null switches rendering back to the canvas\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            this._screenRenderer.renderToScreen();\n        }\n    }\n    const ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon = 0.0001;\n    class ExcaliburGraphicsContext2DCanvasDebug {\n        constructor(_ex){\n            this._ex = _ex;\n            this._debugText = new DebugText();\n        }\n        /**\r\n     * Draw a debug rectangle to the context\r\n     * @param x\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     */ drawRect(x, y, width, height) {\n            this._ex.__ctx.save();\n            this._ex.__ctx.strokeStyle = \"red\";\n            this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this._ex.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y, this._ex.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this._ex.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);\n            this._ex.__ctx.restore();\n        }\n        drawLine(start, end, lineOptions = {\n            color: Color.Black\n        }) {\n            this._ex.__ctx.save();\n            this._ex.__ctx.beginPath();\n            this._ex.__ctx.strokeStyle = lineOptions.color.toString();\n            this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this._ex.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);\n            this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this._ex.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);\n            this._ex.__ctx.lineWidth = 2;\n            this._ex.__ctx.stroke();\n            this._ex.__ctx.closePath();\n            this._ex.__ctx.restore();\n        }\n        drawPoint(point, pointOptions = {\n            color: Color.Black,\n            size: 5\n        }) {\n            this._ex.__ctx.save();\n            this._ex.__ctx.beginPath();\n            this._ex.__ctx.fillStyle = pointOptions.color.toString();\n            this._ex.__ctx.arc(this._ex.snapToPixel ? ~~(point.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.x, this._ex.snapToPixel ? ~~(point.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.y, pointOptions.size, 0, Math.PI * 2);\n            this._ex.__ctx.fill();\n            this._ex.__ctx.closePath();\n            this._ex.__ctx.restore();\n        }\n        drawText(text, pos) {\n            this._debugText.write(this._ex, text, pos);\n        }\n    }\n    class ExcaliburGraphicsContext2DCanvas {\n        constructor(options){\n            /**\r\n         * Unused in Canvas implementation\r\n         */ this.useDrawSorting = false;\n            /**\r\n         * Unused in Canvas implementation\r\n         */ this.z = 0;\n            this.backgroundColor = Color.ExcaliburBlue;\n            this._state = new StateStack();\n            this.snapToPixel = false;\n            this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);\n            const { canvasElement: canvasElement , enableTransparency: enableTransparency , snapToPixel: snapToPixel , smoothing: smoothing , backgroundColor: backgroundColor  } = options;\n            this.__ctx = canvasElement.getContext(\"2d\", {\n                alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true\n            });\n            this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;\n            this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;\n            this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;\n        }\n        get width() {\n            return this.__ctx.canvas.width;\n        }\n        get height() {\n            return this.__ctx.canvas.height;\n        }\n        get opacity() {\n            return this._state.current.opacity;\n        }\n        set opacity(value) {\n            this._state.current.opacity = value;\n        }\n        get tint() {\n            return this._state.current.tint;\n        }\n        set tint(color) {\n            this._state.current.tint = color;\n        }\n        get smoothing() {\n            return this.__ctx.imageSmoothingEnabled;\n        }\n        set smoothing(value) {\n            this.__ctx.imageSmoothingEnabled = value;\n        }\n        resetTransform() {\n            this.__ctx.resetTransform();\n        }\n        updateViewport(_resolution) {\n        // pass\n        }\n        drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n            if (swidth === 0 || sheight === 0) return; // zero dimension dest exit early\n            else if (dwidth === 0 || dheight === 0) return; // zero dimension dest exit early\n            else if (image.width === 0 || image.height === 0) return; // zero dimension source exit early\n            this.__ctx.globalAlpha = this.opacity;\n            const args = [\n                image,\n                sx,\n                sy,\n                swidth,\n                sheight,\n                dx,\n                dy,\n                dwidth,\n                dheight\n            ].filter((a)=>a !== undefined).map((a)=>typeof a === \"number\" && this.snapToPixel ? ~~a : a);\n            this.__ctx.drawImage.apply(this.__ctx, args);\n            GraphicsDiagnostics.DrawCallCount++;\n            GraphicsDiagnostics.DrawnImagesCount = 1;\n        }\n        drawLine(start, end, color, thickness = 1) {\n            this.__ctx.save();\n            this.__ctx.beginPath();\n            this.__ctx.strokeStyle = color.toString();\n            this.__ctx.moveTo(this.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);\n            this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);\n            this.__ctx.lineWidth = thickness;\n            this.__ctx.stroke();\n            this.__ctx.closePath();\n            this.__ctx.restore();\n        }\n        drawRectangle(pos, width, height, color) {\n            this.__ctx.save();\n            this.__ctx.fillStyle = color.toString();\n            this.__ctx.fillRect(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, this.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);\n            this.__ctx.restore();\n        }\n        drawCircle(pos, radius, color, stroke, thickness) {\n            this.__ctx.save();\n            this.__ctx.beginPath();\n            if (stroke) this.__ctx.strokeStyle = stroke.toString();\n            if (thickness) this.__ctx.lineWidth = thickness;\n            this.__ctx.fillStyle = color.toString();\n            this.__ctx.arc(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2);\n            this.__ctx.fill();\n            if (stroke) this.__ctx.stroke();\n            this.__ctx.closePath();\n            this.__ctx.restore();\n        }\n        /**\r\n     * Save the current state of the canvas to the stack (transforms and opacity)\r\n     */ save() {\n            this.__ctx.save();\n        }\n        /**\r\n     * Restore the state of the canvas from the stack\r\n     */ restore() {\n            this.__ctx.restore();\n        }\n        /**\r\n     * Translate the origin of the context by an x and y\r\n     * @param x\r\n     * @param y\r\n     */ translate(x, y) {\n            this.__ctx.translate(this.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y);\n        }\n        /**\r\n     * Rotate the context about the current origin\r\n     */ rotate(angle) {\n            this.__ctx.rotate(angle);\n        }\n        /**\r\n     * Scale the context by an x and y factor\r\n     * @param x\r\n     * @param y\r\n     */ scale(x, y) {\n            this.__ctx.scale(x, y);\n        }\n        getTransform() {\n            throw new Error(\"Not implemented\");\n        }\n        multiply(_m) {\n            this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));\n        }\n        addPostProcessor(_postprocessor) {\n        // pass\n        }\n        removePostProcessor(_postprocessor) {\n        // pass\n        }\n        clearPostProcessors() {\n        // pass\n        }\n        beginDrawLifecycle() {\n        // pass\n        }\n        endDrawLifecycle() {\n        // pass\n        }\n        clear() {\n            // Clear frame\n            this.__ctx.clearRect(0, 0, this.width, this.height);\n            this.__ctx.fillStyle = this.backgroundColor.toString();\n            this.__ctx.fillRect(0, 0, this.width, this.height);\n            GraphicsDiagnostics.clear();\n        }\n        /**\r\n     * Flushes the batched draw calls to the screen\r\n     */ flush() {\n        // pass\n        }\n    }\n    /**\r\n * Enum representing the different display modes available to Excalibur.\r\n */ var DisplayMode;\n    (function(DisplayMode) {\n        /**\r\n     * Default, use a specified resolution for the game. Like 800x600 pixels for example.\r\n     */ DisplayMode[\"Fixed\"] = \"Fixed\";\n        /**\r\n     * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.\r\n     * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n     * is guaranteed to be on screen.\r\n     */ DisplayMode[\"FitContainerAndFill\"] = \"FitContainerAndFill\";\n        /**\r\n     * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.\r\n     * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n     * is guaranteed to be on screen.\r\n     */ DisplayMode[\"FitScreenAndFill\"] = \"FitScreenAndFill\";\n        /**\r\n     * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n     * (letterbox) that would otherwise be present in [[FitContainer]].\r\n     *\r\n     * **warning** This will clip some drawable area from the user because of the zoom,\r\n     * use [[Screen.contentArea]] to know the safe to draw area.\r\n     */ DisplayMode[\"FitContainerAndZoom\"] = \"FitContainerAndZoom\";\n        /**\r\n     * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n     * (letterbox) that would otherwise be present in [[FitScreen]].\r\n     *\r\n     * **warning** This will clip some drawable area from the user because of the zoom,\r\n     * use [[Screen.contentArea]] to know the safe to draw area.\r\n     */ DisplayMode[\"FitScreenAndZoom\"] = \"FitScreenAndZoom\";\n        /**\r\n     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.\r\n     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.\r\n     *\r\n     * You may want to center your game here is an example\r\n     * ```html\r\n     * <!-- html -->\r\n     * <body>\r\n     * <main>\r\n     *   <canvas id=\"game\"></canvas>\r\n     * </main>\r\n     * </body>\r\n     * ```\r\n     *\r\n     * ```css\r\n     * // css\r\n     * main {\r\n     *   display: flex;\r\n     *   align-items: center;\r\n     *   justify-content: center;\r\n     *   height: 100%;\r\n     *   width: 100%;\r\n     * }\r\n     * ```\r\n     */ DisplayMode[\"FitScreen\"] = \"FitScreen\";\n        /**\r\n     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will\r\n     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]\r\n     */ DisplayMode[\"FillScreen\"] = \"FillScreen\";\n        /**\r\n     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.\r\n     */ DisplayMode[\"FitContainer\"] = \"FitContainer\";\n        /**\r\n     * Use the parent DOM container's css width/height for the game resolution dynamically\r\n     */ DisplayMode[\"FillContainer\"] = \"FillContainer\";\n    })(DisplayMode || (DisplayMode = {}));\n    /**\r\n * Convenience class for quick resolutions\r\n * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution\r\n */ class Resolution {\n        /* istanbul ignore next */ static get SVGA() {\n            return {\n                width: 800,\n                height: 600\n            };\n        }\n        /* istanbul ignore next */ static get Standard() {\n            return {\n                width: 1920,\n                height: 1080\n            };\n        }\n        /* istanbul ignore next */ static get Atari2600() {\n            return {\n                width: 160,\n                height: 192\n            };\n        }\n        /* istanbul ignore next */ static get GameBoy() {\n            return {\n                width: 160,\n                height: 144\n            };\n        }\n        /* istanbul ignore next */ static get GameBoyAdvance() {\n            return {\n                width: 240,\n                height: 160\n            };\n        }\n        /* istanbul ignore next */ static get NintendoDS() {\n            return {\n                width: 256,\n                height: 192\n            };\n        }\n        /* istanbul ignore next */ static get NES() {\n            return {\n                width: 256,\n                height: 224\n            };\n        }\n        /* istanbul ignore next */ static get SNES() {\n            return {\n                width: 256,\n                height: 244\n            };\n        }\n    }\n    /**\r\n * The Screen handles all aspects of interacting with the screen for Excalibur.\r\n */ class Screen {\n        constructor(options){\n            var _a, _b, _c;\n            this._antialiasing = true;\n            this._resolutionStack = [];\n            this._viewportStack = [];\n            this._pixelRatioOverride = null;\n            this._isFullScreen = false;\n            this._isDisposed = false;\n            this._logger = Logger.getInstance();\n            this._fullscreenChangeHandler = ()=>{\n                this._isFullScreen = !this._isFullScreen;\n                this._logger.debug(\"Fullscreen Change\", this._isFullScreen);\n            };\n            this._pixelRatioChangeHandler = ()=>{\n                this._logger.debug(\"Pixel Ratio Change\", window.devicePixelRatio);\n                this._listenForPixelRatio();\n                this._devicePixelRatio = this._calculateDevicePixelRatio();\n                this.applyResolutionAndViewport();\n            };\n            this._resizeHandler = ()=>{\n                const parent = this.parent;\n                this._logger.debug(\"View port resized\");\n                this._setResolutionAndViewportByDisplayMode(parent);\n                this.applyResolutionAndViewport();\n            };\n            // Asking the window.devicePixelRatio is expensive we do it once\n            this._devicePixelRatio = this._calculateDevicePixelRatio();\n            this._alreadyWarned = false;\n            this._contentArea = new BoundingBox();\n            this.viewport = options.viewport;\n            this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : {\n                ...this.viewport\n            };\n            this._contentResolution = this.resolution;\n            this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;\n            this._canvas = options.canvas;\n            this.graphicsContext = options.context;\n            this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;\n            this._browser = options.browser;\n            this._pixelRatioOverride = options.pixelRatio;\n            this._applyDisplayMode();\n            this._listenForPixelRatio();\n            this._canvas.addEventListener(\"fullscreenchange\", this._fullscreenChangeHandler);\n            this.applyResolutionAndViewport();\n        }\n        _listenForPixelRatio() {\n            if (this._mediaQueryList && !this._mediaQueryList.addEventListener) // Safari <=13.1 workaround, remove any existing handlers\n            this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\n            this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\n            // Safari <=13.1 workaround\n            if (this._mediaQueryList.addEventListener) this._mediaQueryList.addEventListener(\"change\", this._pixelRatioChangeHandler, {\n                once: true\n            });\n            else this._mediaQueryList.addListener(this._pixelRatioChangeHandler);\n        }\n        dispose() {\n            if (!this._isDisposed) {\n                // Clean up handlers\n                this._isDisposed = true;\n                this._browser.window.off(\"resize\", this._resizeHandler);\n                if (this._resizeObserver) this._resizeObserver.disconnect();\n                this.parent.removeEventListener(\"resize\", this._resizeHandler);\n                // Safari <=13.1 workaround\n                if (this._mediaQueryList.removeEventListener) this._mediaQueryList.removeEventListener(\"change\", this._pixelRatioChangeHandler);\n                else this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\n                this._canvas.removeEventListener(\"fullscreenchange\", this._fullscreenChangeHandler);\n            }\n        }\n        _calculateDevicePixelRatio() {\n            if (window.devicePixelRatio < 1) return 1;\n            const devicePixelRatio = window.devicePixelRatio || 1;\n            return devicePixelRatio;\n        }\n        get pixelRatio() {\n            if (this._pixelRatioOverride) return this._pixelRatioOverride;\n            return this._devicePixelRatio;\n        }\n        get isHiDpi() {\n            return this.pixelRatio !== 1;\n        }\n        get displayMode() {\n            return this._displayMode;\n        }\n        get canvas() {\n            return this._canvas;\n        }\n        get parent() {\n            switch(this.displayMode){\n                case DisplayMode.FillContainer:\n                case DisplayMode.FitContainer:\n                case DisplayMode.FitContainerAndFill:\n                case DisplayMode.FitContainerAndZoom:\n                    return this.canvas.parentElement || document.body;\n                default:\n                    return window;\n            }\n        }\n        get resolution() {\n            return this._resolution;\n        }\n        set resolution(resolution) {\n            this._resolution = resolution;\n        }\n        get viewport() {\n            if (this._viewport) return this._viewport;\n            return this._resolution;\n        }\n        set viewport(viewport) {\n            this._viewport = viewport;\n        }\n        get aspectRatio() {\n            return this._resolution.width / this._resolution.height;\n        }\n        get scaledWidth() {\n            return this._resolution.width * this.pixelRatio;\n        }\n        get scaledHeight() {\n            return this._resolution.height * this.pixelRatio;\n        }\n        setCurrentCamera(camera) {\n            this._camera = camera;\n        }\n        pushResolutionAndViewport() {\n            this._resolutionStack.push(this.resolution);\n            this._viewportStack.push(this.viewport);\n            this.resolution = {\n                ...this.resolution\n            };\n            this.viewport = {\n                ...this.viewport\n            };\n        }\n        peekViewport() {\n            return this._viewportStack[this._viewportStack.length - 1];\n        }\n        peekResolution() {\n            return this._resolutionStack[this._resolutionStack.length - 1];\n        }\n        popResolutionAndViewport() {\n            this.resolution = this._resolutionStack.pop();\n            this.viewport = this._viewportStack.pop();\n        }\n        applyResolutionAndViewport() {\n            this._canvas.width = this.scaledWidth;\n            this._canvas.height = this.scaledHeight;\n            if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\n                const supported = this.graphicsContext.checkIfResolutionSupported({\n                    width: this.scaledWidth,\n                    height: this.scaledHeight\n                });\n                if (!supported && !this._alreadyWarned) {\n                    this._alreadyWarned = true; // warn once\n                    this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` + \" are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.\" + \" Try reducing the resolution or disabling Hi DPI scaling to avoid this\" + \" (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).\");\n                }\n            }\n            if (this._antialiasing) this._canvas.style.imageRendering = \"auto\";\n            else {\n                this._canvas.style.imageRendering = \"pixelated\";\n                // Fall back to 'crisp-edges' if 'pixelated' is not supported\n                // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\n                if (this._canvas.style.imageRendering === \"\") this._canvas.style.imageRendering = \"crisp-edges\";\n            }\n            this._canvas.style.width = this.viewport.width + \"px\";\n            this._canvas.style.height = this.viewport.height + \"px\";\n            // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset\n            this.graphicsContext.updateViewport(this.resolution);\n            this.graphicsContext.resetTransform();\n            this.graphicsContext.smoothing = this._antialiasing;\n            if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);\n        }\n        get antialiasing() {\n            return this._antialiasing;\n        }\n        set antialiasing(isSmooth) {\n            this._antialiasing = isSmooth;\n            this.graphicsContext.smoothing = this._antialiasing;\n        }\n        /**\r\n     * Returns true if excalibur is fullscreen using the browser fullscreen api\r\n     */ get isFullScreen() {\n            return this._isFullScreen;\n        }\n        /**\r\n     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.\r\n     * For example, wire this to a user click handler.\r\n     *\r\n     * Optionally specify a target element id to go fullscreen, by default the game canvas is used\r\n     * @param elementId\r\n     */ goFullScreen(elementId) {\n            if (elementId) {\n                const maybeElement = document.getElementById(elementId);\n                if (maybeElement) return maybeElement.requestFullscreen();\n            }\n            return this._canvas.requestFullscreen();\n        }\n        /**\r\n     * Requests to exit fullscreen using the browser fullscreen api\r\n     */ exitFullScreen() {\n            return document.exitFullscreen();\n        }\n        /**\r\n     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to\r\n     * Excalibur screen space.\r\n     *\r\n     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n     * bottom right corner (resolutionX, resolutionY)\r\n     * @param point\r\n     */ pageToScreenCoordinates(point) {\n            let newX = point.x;\n            let newY = point.y;\n            if (!this._isFullScreen) {\n                newX -= getPosition(this._canvas).x;\n                newY -= getPosition(this._canvas).y;\n            }\n            // if fullscreen api on it centers with black bars\n            // we need to adjust the screen to world coordinates in this case\n            if (this._isFullScreen) {\n                if (window.innerWidth / this.aspectRatio < window.innerHeight) {\n                    const screenHeight = window.innerWidth / this.aspectRatio;\n                    const screenMarginY = (window.innerHeight - screenHeight) / 2;\n                    newY = (newY - screenMarginY) / screenHeight * this.viewport.height;\n                    newX = newX / window.innerWidth * this.viewport.width;\n                } else {\n                    const screenWidth = window.innerHeight * this.aspectRatio;\n                    const screenMarginX = (window.innerWidth - screenWidth) / 2;\n                    newX = (newX - screenMarginX) / screenWidth * this.viewport.width;\n                    newY = newY / window.innerHeight * this.viewport.height;\n                }\n            }\n            newX = newX / this.viewport.width * this.resolution.width;\n            newY = newY / this.viewport.height * this.resolution.height;\n            return new Vector(newX, newY);\n        }\n        /**\r\n     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,\r\n     * this is where html elements might live if you want to position them relative to Excalibur.\r\n     *\r\n     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n     * bottom right corner (resolutionX, resolutionY)\r\n     * @param point\r\n     */ screenToPageCoordinates(point) {\n            let newX = point.x;\n            let newY = point.y;\n            newX = newX / this.resolution.width * this.viewport.width;\n            newY = newY / this.resolution.height * this.viewport.height;\n            if (this._isFullScreen) {\n                if (window.innerWidth / this.aspectRatio < window.innerHeight) {\n                    const screenHeight = window.innerWidth / this.aspectRatio;\n                    const screenMarginY = (window.innerHeight - screenHeight) / 2;\n                    newY = newY / this.viewport.height * screenHeight + screenMarginY;\n                    newX = newX / this.viewport.width * window.innerWidth;\n                } else {\n                    const screenWidth = window.innerHeight * this.aspectRatio;\n                    const screenMarginX = (window.innerWidth - screenWidth) / 2;\n                    newX = newX / this.viewport.width * screenWidth + screenMarginX;\n                    newY = newY / this.viewport.height * window.innerHeight;\n                }\n            }\n            if (!this._isFullScreen) {\n                newX += getPosition(this._canvas).x;\n                newY += getPosition(this._canvas).y;\n            }\n            return new Vector(newX, newY);\n        }\n        /**\r\n     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.\r\n     *\r\n     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]\r\n     * and extends infinitely out relative from the [[Camera]].\r\n     * @param point  Screen coordinate to convert\r\n     */ screenToWorldCoordinates(point) {\n            // the only difference between screen & world is the camera transform\n            if (this._camera) return this._camera.inverse.multiply(point);\n            return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));\n        }\n        /**\r\n     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.\r\n     *\r\n     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.\r\n     * @param point  World coordinate to convert\r\n     */ worldToScreenCoordinates(point) {\n            if (this._camera) return this._camera.transform.multiply(point);\n            return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));\n        }\n        pageToWorldCoordinates(point) {\n            const screen = this.pageToScreenCoordinates(point);\n            return this.screenToWorldCoordinates(screen);\n        }\n        worldToPageCoordinates(point) {\n            const screen = this.worldToScreenCoordinates(point);\n            return this.screenToPageCoordinates(screen);\n        }\n        /**\r\n     * Returns a BoundingBox of the top left corner of the screen\r\n     * and the bottom right corner of the screen.\r\n     *\r\n     * World bounds are in world coordinates, useful for culling objects offscreen\r\n     */ getWorldBounds() {\n            const topLeft = this.screenToWorldCoordinates(Vector.Zero);\n            const right = topLeft.x + this.drawWidth;\n            const bottom = topLeft.y + this.drawHeight;\n            return new BoundingBox(topLeft.x, topLeft.y, right, bottom);\n        }\n        /**\r\n     * The width of the game canvas in pixels (physical width component of the\r\n     * resolution of the canvas element)\r\n     */ get canvasWidth() {\n            return this.canvas.width;\n        }\n        /**\r\n     * Returns half width of the game canvas in pixels (half physical width component)\r\n     */ get halfCanvasWidth() {\n            return this.canvas.width / 2;\n        }\n        /**\r\n     * The height of the game canvas in pixels, (physical height component of\r\n     * the resolution of the canvas element)\r\n     */ get canvasHeight() {\n            return this.canvas.height;\n        }\n        /**\r\n     * Returns half height of the game canvas in pixels (half physical height component)\r\n     */ get halfCanvasHeight() {\n            return this.canvas.height / 2;\n        }\n        /**\r\n     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get drawWidth() {\n            if (this._camera) return this.resolution.width / this._camera.zoom;\n            return this.resolution.width;\n        }\n        /**\r\n     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get halfDrawWidth() {\n            return this.drawWidth / 2;\n        }\n        /**\r\n     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get drawHeight() {\n            if (this._camera) return this.resolution.height / this._camera.zoom;\n            return this.resolution.height;\n        }\n        /**\r\n     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get halfDrawHeight() {\n            return this.drawHeight / 2;\n        }\n        /**\r\n     * Returns screen center coordinates including zoom and device pixel ratio.\r\n     */ get center() {\n            return vec(this.halfDrawWidth, this.halfDrawHeight);\n        }\n        /**\r\n     * Returns the content area in screen space where it is safe to place content\r\n     */ get contentArea() {\n            return this._contentArea;\n        }\n        _computeFit() {\n            document.body.style.margin = \"0px\";\n            document.body.style.overflow = \"hidden\";\n            const aspect = this.aspectRatio;\n            let adjustedWidth = 0;\n            let adjustedHeight = 0;\n            if (window.innerWidth / aspect < window.innerHeight) {\n                adjustedWidth = window.innerWidth;\n                adjustedHeight = window.innerWidth / aspect;\n            } else {\n                adjustedWidth = window.innerHeight * aspect;\n                adjustedHeight = window.innerHeight;\n            }\n            this.viewport = {\n                width: adjustedWidth,\n                height: adjustedHeight\n            };\n            this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\n        }\n        _computeFitScreenAndFill() {\n            document.body.style.margin = \"0px\";\n            document.body.style.overflow = \"hidden\";\n            const vw = window.innerWidth;\n            const vh = window.innerHeight;\n            this._computeFitAndFill(vw, vh);\n        }\n        _computeFitContainerAndFill() {\n            document.body.style.margin = \"0px\";\n            document.body.style.overflow = \"hidden\";\n            const parent = this.canvas.parentElement;\n            const vw = parent.clientWidth;\n            const vh = parent.clientHeight;\n            this._computeFitAndFill(vw, vh);\n        }\n        _computeFitAndFill(vw, vh) {\n            this.viewport = {\n                width: vw,\n                height: vh\n            };\n            // if the current screen aspectRatio is less than the original aspectRatio\n            if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {\n                // compute new resolution to match the original aspect ratio\n                this.resolution = {\n                    width: vw * this._contentResolution.width / vw,\n                    height: vw * this._contentResolution.width / vw * vh / vw\n                };\n                const clip = (this.resolution.height - this._contentResolution.height) / 2;\n                this._contentArea = new BoundingBox({\n                    top: clip,\n                    left: 0,\n                    right: this._contentResolution.width,\n                    bottom: this.resolution.height - clip\n                });\n            } else {\n                this.resolution = {\n                    width: vh * this._contentResolution.height / vh * vw / vh,\n                    height: vh * this._contentResolution.height / vh\n                };\n                const clip = (this.resolution.width - this._contentResolution.width) / 2;\n                this._contentArea = new BoundingBox({\n                    top: 0,\n                    left: clip,\n                    right: this.resolution.width - clip,\n                    bottom: this._contentResolution.height\n                });\n            }\n        }\n        _computeFitScreenAndZoom() {\n            document.body.style.margin = \"0px\";\n            document.body.style.overflow = \"hidden\";\n            this.canvas.style.position = \"absolute\";\n            const vw = window.innerWidth;\n            const vh = window.innerHeight;\n            this._computeFitAndZoom(vw, vh);\n        }\n        _computeFitContainerAndZoom() {\n            document.body.style.margin = \"0px\";\n            document.body.style.overflow = \"hidden\";\n            this.canvas.style.position = \"absolute\";\n            const parent = this.canvas.parentElement;\n            parent.style.position = \"relative\";\n            parent.style.overflow = \"hidden\";\n            const vw = parent.clientWidth;\n            const vh = parent.clientHeight;\n            this._computeFitAndZoom(vw, vh);\n        }\n        _computeFitAndZoom(vw, vh) {\n            const aspect = this.aspectRatio;\n            let adjustedWidth = 0;\n            let adjustedHeight = 0;\n            if (vw / aspect < vh) {\n                adjustedWidth = vw;\n                adjustedHeight = vw / aspect;\n            } else {\n                adjustedWidth = vh * aspect;\n                adjustedHeight = vh;\n            }\n            const scaleX = vw / adjustedWidth;\n            const scaleY = vh / adjustedHeight;\n            const maxScaleFactor = Math.max(scaleX, scaleY);\n            const zoomedWidth = adjustedWidth * maxScaleFactor;\n            const zoomedHeight = adjustedHeight * maxScaleFactor;\n            // Center zoomed dimension if bigger than the screen\n            if (zoomedWidth > vw) this.canvas.style.left = -(zoomedWidth - vw) / 2 + \"px\";\n            else this.canvas.style.left = \"\";\n            if (zoomedHeight > vh) this.canvas.style.top = -(zoomedHeight - vh) / 2 + \"px\";\n            else this.canvas.style.top = \"\";\n            this.viewport = {\n                width: zoomedWidth,\n                height: zoomedHeight\n            };\n            const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);\n            // return safe area\n            if (this.viewport.width > vw) {\n                const clip = (this.viewport.width - vw) / this.viewport.width * this.resolution.width;\n                bounds.top = 0;\n                bounds.left = clip / 2;\n                bounds.right = this.resolution.width - clip / 2;\n                bounds.bottom = this.resolution.height;\n            }\n            if (this.viewport.height > vh) {\n                const clip = (this.viewport.height - vh) / this.viewport.height * this.resolution.height;\n                bounds.top = clip / 2;\n                bounds.left = 0;\n                bounds.bottom = this.resolution.height - clip / 2;\n                bounds.right = this.resolution.width;\n            }\n            this._contentArea = bounds;\n        }\n        _computeFitContainer() {\n            const aspect = this.aspectRatio;\n            let adjustedWidth = 0;\n            let adjustedHeight = 0;\n            const parent = this.canvas.parentElement;\n            if (parent.clientWidth / aspect < parent.clientHeight) {\n                adjustedWidth = parent.clientWidth;\n                adjustedHeight = parent.clientWidth / aspect;\n            } else {\n                adjustedWidth = parent.clientHeight * aspect;\n                adjustedHeight = parent.clientHeight;\n            }\n            this.viewport = {\n                width: adjustedWidth,\n                height: adjustedHeight\n            };\n            this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\n        }\n        _applyDisplayMode() {\n            this._setResolutionAndViewportByDisplayMode(this.parent);\n            // watch resizing\n            if (this.parent instanceof Window) this._browser.window.on(\"resize\", this._resizeHandler);\n            else {\n                this._resizeObserver = new ResizeObserver(()=>{\n                    this._resizeHandler();\n                });\n                this._resizeObserver.observe(this.parent);\n            }\n            this.parent.addEventListener(\"resize\", this._resizeHandler);\n        }\n        /**\r\n     * Sets the resolution and viewport based on the selected display mode.\r\n     */ _setResolutionAndViewportByDisplayMode(parent) {\n            if (this.displayMode === DisplayMode.FillContainer) {\n                this.resolution = {\n                    width: parent.clientWidth,\n                    height: parent.clientHeight\n                };\n                this.viewport = this.resolution;\n            }\n            if (this.displayMode === DisplayMode.FillScreen) {\n                document.body.style.margin = \"0px\";\n                document.body.style.overflow = \"hidden\";\n                this.resolution = {\n                    width: parent.innerWidth,\n                    height: parent.innerHeight\n                };\n                this.viewport = this.resolution;\n            }\n            if (this.displayMode === DisplayMode.FitScreen) this._computeFit();\n            if (this.displayMode === DisplayMode.FitContainer) this._computeFitContainer();\n            if (this.displayMode === DisplayMode.FitScreenAndFill) this._computeFitScreenAndFill();\n            if (this.displayMode === DisplayMode.FitContainerAndFill) this._computeFitContainerAndFill();\n            if (this.displayMode === DisplayMode.FitScreenAndZoom) this._computeFitScreenAndZoom();\n            if (this.displayMode === DisplayMode.FitContainerAndZoom) this._computeFitContainerAndZoom();\n        }\n    }\n    /**\r\n * Internal class used to build instances of AudioContext\r\n */ /* istanbul ignore next */ class AudioContextFactory {\n        static create() {\n            if (!this._INSTANCE) {\n                if (window.AudioContext || window.webkitAudioContext) this._INSTANCE = new AudioContext();\n            }\n            return this._INSTANCE;\n        }\n    }\n    AudioContextFactory._INSTANCE = null;\n    /**\r\n * Patch for detecting legacy web audio in browsers\r\n * @internal\r\n * @param source\r\n */ function isLegacyWebAudioSource(source) {\n        return !!source.playbackState;\n    }\n    class WebAudio {\n        /**\r\n     * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n     * right after a user interaction event.\r\n     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n     */ static unlock() {\n            const promise = new Promise((resolve, reject)=>{\n                if (WebAudio._UNLOCKED || !AudioContextFactory.create()) return resolve(true);\n                const unlockTimeoutTimer = setTimeout(()=>{\n                    Logger.getInstance().warn(\"Excalibur was unable to unlock the audio context, audio probably will not play in this browser.\");\n                    resolve(false);\n                }, 200);\n                const audioContext = AudioContextFactory.create();\n                audioContext.resume().then(()=>{\n                    // create empty buffer and play it\n                    const buffer = audioContext.createBuffer(1, 1, 22050);\n                    const source = audioContext.createBufferSource();\n                    let ended = false;\n                    source.buffer = buffer;\n                    source.connect(audioContext.destination);\n                    source.onended = ()=>ended = true;\n                    source.start(0);\n                    // by checking the play state after some time, we know if we're really unlocked\n                    setTimeout(()=>{\n                        if (isLegacyWebAudioSource(source)) {\n                            if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) WebAudio._UNLOCKED = true;\n                        } else if (audioContext.currentTime > 0 || ended) WebAudio._UNLOCKED = true;\n                    }, 0);\n                    clearTimeout(unlockTimeoutTimer);\n                    resolve(true);\n                }, ()=>{\n                    reject();\n                });\n            });\n            return promise;\n        }\n        static isUnlocked() {\n            return this._UNLOCKED;\n        }\n    }\n    WebAudio._UNLOCKED = false;\n    /**\r\n * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n * and extending abilities for vanilla Javascript projects\r\n */ class Class {\n        constructor(){\n            this.eventDispatcher = new EventDispatcher();\n        }\n        /**\r\n     * Alias for `addEventListener`. You can listen for a variety of\r\n     * events off of the engine; see the events section below for a complete list.\r\n     * @param eventName  Name of the event to listen for\r\n     * @param handler    Event handler for the thrown event\r\n     */ on(eventName, handler) {\n            this.eventDispatcher.on(eventName, handler);\n        }\n        /**\r\n     * Alias for `removeEventListener`. If only the eventName is specified\r\n     * it will remove all handlers registered for that specific event. If the eventName\r\n     * and the handler instance are specified only that handler will be removed.\r\n     *\r\n     * @param eventName  Name of the event to listen for\r\n     * @param handler    Event handler for the thrown event\r\n     */ off(eventName, handler) {\n            this.eventDispatcher.off(eventName, handler);\n        }\n        /**\r\n     * Emits a new event\r\n     * @param eventName   Name of the event to emit\r\n     * @param eventObject Data associated with this event\r\n     */ emit(eventName, eventObject) {\n            this.eventDispatcher.emit(eventName, eventObject);\n        }\n        /**\r\n     * Once listens to an event one time, then unsubscribes from that event\r\n     *\r\n     * @param eventName The name of the event to subscribe to once\r\n     * @param handler   The handler of the event that will be auto unsubscribed\r\n     */ once(eventName, handler) {\n            this.eventDispatcher.once(eventName, handler);\n        }\n    }\n    /* istanbul ignore next */ /**\r\n * Draw a line on canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param color The color of the line\r\n * @param x1 The start x coordinate\r\n * @param y1 The start y coordinate\r\n * @param x2 The ending x coordinate\r\n * @param y2 The ending y coordinate\r\n * @param thickness The line thickness\r\n * @param cap The [[LineCapStyle]] (butt, round, or square)\r\n */ function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = \"butt\") {\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = thickness;\n        ctx.lineCap = cap;\n        ctx.strokeStyle = color.toString();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n    /* istanbul ignore next */ /**\r\n * Draw the vector as a point onto the canvas.\r\n */ function point(ctx, color = Color.Red, point) {\n        ctx.beginPath();\n        ctx.strokeStyle = color.toString();\n        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n        ctx.closePath();\n        ctx.stroke();\n    }\n    /**\r\n * Draw the vector as a line onto the canvas starting a origin point.\r\n */ /* istanbul ignore next */ /**\r\n *\r\n */ function vector(ctx, color, origin, vector, scale = 1.0) {\n        const c = color ? color.toString() : \"blue\";\n        const v = vector.scale(scale);\n        ctx.beginPath();\n        ctx.strokeStyle = c;\n        ctx.moveTo(origin.x, origin.y);\n        ctx.lineTo(origin.x + v.x, origin.y + v.y);\n        ctx.closePath();\n        ctx.stroke();\n    }\n    /**\r\n * Draw a round rectangle on a canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param x The top-left x coordinate\r\n * @param y The top-left y coordinate\r\n * @param width The width of the rectangle\r\n * @param height The height of the rectangle\r\n * @param radius The border radius of the rectangle\r\n * @param stroke The [[Color]] to stroke rectangle with\r\n * @param fill The [[Color]] to fill rectangle with\r\n */ function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {\n        let br;\n        if (typeof radius === \"number\") br = {\n            tl: radius,\n            tr: radius,\n            br: radius,\n            bl: radius\n        };\n        else {\n            const defaultRadius = {\n                tl: 0,\n                tr: 0,\n                br: 0,\n                bl: 0\n            };\n            for(const prop in defaultRadius)if (defaultRadius.hasOwnProperty(prop)) {\n                const side = prop;\n                br[side] = radius[side] || defaultRadius[side];\n            }\n        }\n        ctx.beginPath();\n        ctx.moveTo(x + br.tl, y);\n        ctx.lineTo(x + width - br.tr, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\n        ctx.lineTo(x + width, y + height - br.br);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\n        ctx.lineTo(x + br.bl, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\n        ctx.lineTo(x, y + br.tl);\n        ctx.quadraticCurveTo(x, y, x + br.tl, y);\n        ctx.closePath();\n        if (fill) {\n            ctx.fillStyle = fill.toString();\n            ctx.fill();\n        }\n        if (stroke) {\n            ctx.strokeStyle = stroke.toString();\n            ctx.stroke();\n        }\n    }\n    /**\r\n *\r\n */ function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2);\n        ctx.closePath();\n        if (fill) {\n            ctx.fillStyle = fill.toString();\n            ctx.fill();\n        }\n        if (stroke) {\n            ctx.strokeStyle = stroke.toString();\n            ctx.stroke();\n        }\n    }\n    /* harmony default export */ const Loader_logo = \"data:image/png;base64,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\";\n    // EXTERNAL MODULE: ./Loader.css\n    var Loader_0 = $2c23f148d58cd887$var$__webpack_require__(1388);\n    /**\r\n * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the\r\n * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.\r\n *\r\n * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.\r\n */ class Raster extends Graphic {\n        constructor(options){\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n            super(options);\n            this.filtering = null;\n            this.lineCap = \"butt\";\n            this.quality = 1;\n            this._dirty = true;\n            this._smoothing = false;\n            this._color = watch(Color.Black, ()=>this.flagDirty());\n            this._lineWidth = 1;\n            this._lineDash = [];\n            this._padding = 0;\n            if (options) {\n                this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;\n                this.color = (_b = options.color) !== null && _b !== void 0 ? _b : Color.Black;\n                this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;\n                this.smoothing = (_c = options.smoothing) !== null && _c !== void 0 ? _c : this.smoothing;\n                this.lineWidth = (_d = options.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;\n                this.lineDash = (_e = options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;\n                this.lineCap = (_f = options.lineCap) !== null && _f !== void 0 ? _f : this.lineCap;\n                this.padding = (_g = options.padding) !== null && _g !== void 0 ? _g : this.padding;\n                this.filtering = (_h = options.filtering) !== null && _h !== void 0 ? _h : this.filtering;\n            }\n            this._bitmap = document.createElement(\"canvas\");\n            // get the default canvas width/height as a fallback\n            const bitmapWidth = (_j = options === null || options === void 0 ? void 0 : options.width) !== null && _j !== void 0 ? _j : this._bitmap.width;\n            const bitmapHeight = (_k = options === null || options === void 0 ? void 0 : options.height) !== null && _k !== void 0 ? _k : this._bitmap.height;\n            this.width = bitmapWidth;\n            this.height = bitmapHeight;\n            const maybeCtx = this._bitmap.getContext(\"2d\");\n            if (!maybeCtx) /* istanbul ignore next */ throw new Error(\"Browser does not support 2d canvas drawing, cannot create Raster graphic\");\n            else this._ctx = maybeCtx;\n        }\n        cloneRasterOptions() {\n            return {\n                color: this.color ? this.color.clone() : null,\n                strokeColor: this.strokeColor ? this.strokeColor.clone() : null,\n                smoothing: this.smoothing,\n                lineWidth: this.lineWidth,\n                lineDash: this.lineDash,\n                lineCap: this.lineCap,\n                quality: this.quality,\n                padding: this.padding\n            };\n        }\n        /**\r\n     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized\r\n     */ get dirty() {\n            return this._dirty;\n        }\n        /**\r\n     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.\r\n     * This should be called any time the graphics state changes such that it affects the outputted drawing\r\n     */ flagDirty() {\n            this._dirty = true;\n        }\n        /**\r\n     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster\r\n     * to be flagged dirty causing a re-raster on the next draw.\r\n     *\r\n     * Any `padding`s or `quality` set will be factored into the width\r\n     */ get width() {\n            return Math.abs(this._getTotalWidth() * this.scale.x);\n        }\n        set width(value) {\n            value /= Math.abs(this.scale.x);\n            this._bitmap.width = value;\n            this._originalWidth = value;\n            this.flagDirty();\n        }\n        /**\r\n     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster\r\n     * to be flagged dirty causing a re-raster on the next draw.\r\n     *\r\n     * Any `padding` or `quality` set will be factored into the height\r\n     */ get height() {\n            return Math.abs(this._getTotalHeight() * this.scale.y);\n        }\n        set height(value) {\n            value /= Math.abs(this.scale.y);\n            this._bitmap.height = value;\n            this._originalHeight = value;\n            this.flagDirty();\n        }\n        _getTotalWidth() {\n            var _a;\n            return (((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2) * 1;\n        }\n        _getTotalHeight() {\n            var _a;\n            return (((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2) * 1;\n        }\n        /**\r\n     * Returns the local bounds of the Raster including the padding\r\n     */ get localBounds() {\n            return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);\n        }\n        /**\r\n     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster\r\n     * to be flagged dirty causing a re-raster on the next draw.\r\n     */ get smoothing() {\n            return this._smoothing;\n        }\n        set smoothing(value) {\n            this._smoothing = value;\n            this.flagDirty();\n        }\n        /**\r\n     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be\r\n     * flagged dirty causing a re-raster on the next draw.\r\n     */ get color() {\n            return this._color;\n        }\n        set color(value) {\n            this.flagDirty();\n            this._color = watch(value, ()=>this.flagDirty());\n        }\n        /**\r\n     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be\r\n     * flagged dirty causing a re-raster on the next draw.\r\n     */ get strokeColor() {\n            return this._strokeColor;\n        }\n        set strokeColor(value) {\n            this.flagDirty();\n            this._strokeColor = watch(value, ()=>this.flagDirty());\n        }\n        /**\r\n     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be\r\n     * flagged dirty causing a re-raster on the next draw.\r\n     */ get lineWidth() {\n            return this._lineWidth;\n        }\n        set lineWidth(value) {\n            this._lineWidth = value;\n            this.flagDirty();\n        }\n        get lineDash() {\n            return this._lineDash;\n        }\n        set lineDash(value) {\n            this._lineDash = value;\n            this.flagDirty();\n        }\n        get padding() {\n            return this._padding;\n        }\n        set padding(value) {\n            this._padding = value;\n            this.flagDirty();\n        }\n        /**\r\n     * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if\r\n     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call\r\n     */ rasterize() {\n            this._dirty = false;\n            this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());\n            this._ctx.save();\n            this._applyRasterProperties(this._ctx);\n            this.execute(this._ctx);\n            this._ctx.restore();\n            // The webgl texture needs to be updated if it exists after a raster cycle\n            TextureLoader.load(this._bitmap, this.filtering, true);\n        }\n        _applyRasterProperties(ctx) {\n            var _a, _b, _c;\n            this._bitmap.width = this._getTotalWidth() * this.quality;\n            this._bitmap.height = this._getTotalHeight() * this.quality;\n            ctx.scale(this.quality, this.quality);\n            ctx.translate(this.padding, this.padding);\n            ctx.imageSmoothingEnabled = this.smoothing;\n            ctx.lineWidth = this.lineWidth;\n            ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());\n            ctx.lineCap = this.lineCap;\n            ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();\n            ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();\n        }\n        _drawImage(ex, x, y) {\n            if (this._dirty) this.rasterize();\n            ex.scale(1 / this.quality, 1 / this.quality);\n            ex.drawImage(this._bitmap, x, y);\n        }\n    }\n    /**\r\n * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].\r\n *\r\n * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed\r\n * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.\r\n *\r\n * **Low performance API**\r\n */ class Canvas extends Raster {\n        constructor(_options){\n            super(_options);\n            this._options = _options;\n        }\n        /**\r\n     * Return the 2D graphics context of this canvas\r\n     */ get ctx() {\n            return this._ctx;\n        }\n        clone() {\n            return new Canvas({\n                ...this._options,\n                ...this.cloneGraphicOptions(),\n                ...this.cloneRasterOptions()\n            });\n        }\n        execute(ctx) {\n            var _a, _b;\n            if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) (_b = this._options) === null || _b === void 0 || _b.draw(ctx);\n            if (!this._options.cache) this.flagDirty();\n        }\n    }\n    class ExResponse {\n    }\n    ExResponse.type = {\n        any: \"\",\n        blob: \"blob\",\n        json: \"json\",\n        text: \"text\",\n        document: \"document\",\n        arraybuffer: \"arraybuffer\"\n    };\n    class StateMachine {\n        constructor(){\n            this.states = new Map();\n        }\n        get currentState() {\n            return this._currentState;\n        }\n        set currentState(state) {\n            this._currentState = state;\n        }\n        static create(machineDescription, data) {\n            const machine = new StateMachine();\n            machine.data = data;\n            for(const stateName in machineDescription.states)machine.states.set(stateName, {\n                name: stateName,\n                ...machineDescription.states[stateName]\n            });\n            // validate transitions are states\n            for (const state of machine.states.values())for (const transitionState of state.transitions){\n                if (transitionState === \"*\") continue;\n                if (!machine.states.has(transitionState)) throw Error(`Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`);\n            }\n            machine.currentState = machine.startState = machine.states.get(machineDescription.start);\n            return machine;\n        }\n        in(state) {\n            return this.currentState.name === state;\n        }\n        go(stateName, eventData) {\n            var _a, _b;\n            if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes(\"*\")) {\n                const potentialNewState = this.states.get(stateName);\n                if (this.currentState.onExit) {\n                    const canExit = (_a = this.currentState) === null || _a === void 0 ? void 0 : _a.onExit({\n                        to: potentialNewState.name,\n                        data: this.data\n                    });\n                    if (canExit === false) return false;\n                }\n                if (potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter) {\n                    const canEnter = potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter({\n                        from: this.currentState.name,\n                        eventData: eventData,\n                        data: this.data\n                    });\n                    if (canEnter === false) return false;\n                }\n                // console.log(`${this.currentState.name} => ${potentialNewState.name} (${eventData})`);\n                this.currentState = potentialNewState;\n                if ((_b = this.currentState) === null || _b === void 0 ? void 0 : _b.onState) this.currentState.onState();\n                return true;\n            }\n            return false;\n        }\n        update(elapsedMs) {\n            if (this.currentState.onUpdate) this.currentState.onUpdate(this.data, elapsedMs);\n        }\n        save(saveKey) {\n            localStorage.setItem(saveKey, JSON.stringify({\n                currentState: this.currentState.name,\n                data: this.data\n            }));\n        }\n        restore(saveKey) {\n            const state = JSON.parse(localStorage.getItem(saveKey));\n            this.currentState = this.states.get(state.currentState);\n            this.data = state.data;\n        }\n    }\n    /**\r\n * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n */ class WebAudioInstance {\n        constructor(_src){\n            this._src = _src;\n            this._audioContext = AudioContextFactory.create();\n            this._volumeNode = this._audioContext.createGain();\n            this._playingPromise = new Promise((resolve)=>{\n                this._playingResolve = resolve;\n            });\n            this._stateMachine = StateMachine.create({\n                start: \"STOPPED\",\n                states: {\n                    PLAYING: {\n                        onEnter: ({ data: data  })=>{\n                            // Buffer nodes are single use\n                            this._createNewBufferSource();\n                            this._handleEnd();\n                            this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);\n                            data.startedAt = this._audioContext.currentTime - data.pausedAt;\n                            data.pausedAt = 0;\n                        },\n                        onState: ()=>this._playStarted(),\n                        onExit: ({ to: to  })=>{\n                            // If you've exited early only resolve if explicitly STOPPED\n                            if (to === \"STOPPED\") this._playingResolve(true);\n                            // Whenever you're not playing... you stop!\n                            this._instance.onended = null; // disconnect the wired on-end handler\n                            this._instance.disconnect();\n                            this._instance.stop(0);\n                            this._instance = null;\n                        },\n                        transitions: [\n                            \"STOPPED\",\n                            \"PAUSED\",\n                            \"SEEK\"\n                        ]\n                    },\n                    SEEK: {\n                        onEnter: ({ eventData: position , data: data  })=>{\n                            data.pausedAt = (position !== null && position !== void 0 ? position : 0) / this._playbackRate;\n                            data.startedAt = 0;\n                        },\n                        transitions: [\n                            \"*\"\n                        ]\n                    },\n                    STOPPED: {\n                        onEnter: ({ data: data  })=>{\n                            data.pausedAt = 0;\n                            data.startedAt = 0;\n                            this._playingResolve(true);\n                        },\n                        transitions: [\n                            \"PLAYING\",\n                            \"PAUSED\",\n                            \"SEEK\"\n                        ]\n                    },\n                    PAUSED: {\n                        onEnter: ({ data: data  })=>{\n                            // Playback rate will be a scale factor of how fast/slow the audio is being played\n                            // default is 1.0\n                            // we need to invert it to get the time scale\n                            data.pausedAt = this._audioContext.currentTime - data.startedAt;\n                        },\n                        transitions: [\n                            \"PLAYING\",\n                            \"STOPPED\",\n                            \"SEEK\"\n                        ]\n                    }\n                }\n            }, {\n                startedAt: 0,\n                pausedAt: 0\n            });\n            this._volume = 1;\n            this._loop = false;\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\n            this._playStarted = ()=>{};\n            this._playbackRate = 1.0;\n            this._createNewBufferSource();\n        }\n        _createNewBufferSource() {\n            this._instance = this._audioContext.createBufferSource();\n            this._instance.buffer = this._src;\n            this._instance.loop = this.loop;\n            this._instance.playbackRate.value = this._playbackRate;\n            this._instance.connect(this._volumeNode);\n            this._volumeNode.connect(this._audioContext.destination);\n        }\n        _handleEnd() {\n            if (!this.loop) this._instance.onended = ()=>{\n                this._playingResolve(true);\n            };\n        }\n        set loop(value) {\n            this._loop = value;\n            if (this._instance) {\n                this._instance.loop = value;\n                if (!this.loop) this._instance.onended = ()=>{\n                    this._playingResolve(true);\n                };\n            }\n        }\n        get loop() {\n            return this._loop;\n        }\n        set volume(value) {\n            value = clamp(value, 0, 1.0);\n            this._volume = value;\n            if (this._stateMachine.in(\"PLAYING\") && this._volumeNode.gain.setTargetAtTime) // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime\n            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.\n            // This exponential ramp provides a more pleasant transition in gain\n            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);\n            else this._volumeNode.gain.value = value;\n        }\n        get volume() {\n            return this._volume;\n        }\n        /**\r\n     * Returns the set duration to play, otherwise returns the total duration if unset\r\n     */ get duration() {\n            var _a;\n            return (_a = this._duration) !== null && _a !== void 0 ? _a : this.getTotalPlaybackDuration();\n        }\n        /**\r\n     * Set the duration that this audio should play.\r\n     *\r\n     * Note: if you seek to a specific point the duration will start from that point, for example\r\n     *\r\n     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n     */ set duration(duration) {\n            this._duration = duration;\n        }\n        isPlaying() {\n            return this._stateMachine.in(\"PLAYING\");\n        }\n        isPaused() {\n            return this._stateMachine.in(\"PAUSED\") || this._stateMachine.in(\"SEEK\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        play(playStarted = ()=>{}) {\n            this._playStarted = playStarted;\n            this._stateMachine.go(\"PLAYING\");\n            return this._playingPromise;\n        }\n        pause() {\n            this._stateMachine.go(\"PAUSED\");\n        }\n        stop() {\n            this._stateMachine.go(\"STOPPED\");\n        }\n        seek(position) {\n            this._stateMachine.go(\"PAUSED\");\n            this._stateMachine.go(\"SEEK\", position);\n        }\n        getTotalPlaybackDuration() {\n            return this._src.duration;\n        }\n        getPlaybackPosition() {\n            const { pausedAt: pausedAt , startedAt: startedAt  } = this._stateMachine.data;\n            if (pausedAt) return pausedAt * this._playbackRate;\n            if (startedAt) return (this._audioContext.currentTime - startedAt) * this._playbackRate;\n            return 0;\n        }\n        set playbackRate(playbackRate) {\n            this._instance.playbackRate.value = this._playbackRate = playbackRate;\n        }\n        get playbackRate() {\n            return this._instance.playbackRate.value;\n        }\n    }\n    class MediaEvent extends GameEvent {\n        constructor(target, _name = \"MediaEvent\"){\n            super();\n            this.target = target;\n            this._name = _name;\n        }\n        /**\r\n     * Media event cannot bubble\r\n     */ set bubbles(_value) {\n        // stubbed\n        }\n        /**\r\n     * Media event cannot bubble\r\n     */ get bubbles() {\n            return false;\n        }\n        /**\r\n     * Media event cannot bubble, so they have no path\r\n     */ get _path() {\n            return null;\n        }\n        /**\r\n     * Media event cannot bubble, so they have no path\r\n     */ set _path(_val) {\n        // stubbed\n        }\n        /**\r\n     * Prevents event from bubbling\r\n     */ stopPropagation() {\n        /**\r\n         * Stub\r\n         */ }\n        /**\r\n     * Action, that calls when event happens\r\n     */ action() {\n        /**\r\n         * Stub\r\n         */ }\n        /**\r\n     * Propagate event further through event path\r\n     */ propagate() {\n        /**\r\n         * Stub\r\n         */ }\n        layPath(_actor) {\n        /**\r\n         * Stub\r\n         */ }\n    }\n    class NativeSoundEvent extends MediaEvent {\n        constructor(target, track){\n            super(target, \"NativeSoundEvent\");\n            this.track = track;\n        }\n    }\n    class NativeSoundProcessedEvent extends MediaEvent {\n        constructor(target, _processedData){\n            super(target, \"NativeSoundProcessedEvent\");\n            this._processedData = _processedData;\n            this.data = this._processedData;\n        }\n    }\n    /**\r\n * Whether or not the browser can play this file as HTML5 Audio\r\n */ function canPlayFile(file) {\n        try {\n            const a = new Audio();\n            const filetype = /.*\\.([A-Za-z0-9]+)$/;\n            const type = file.match(filetype)[1];\n            if (a.canPlayType(\"audio/\" + type)) return true;\n            else return false;\n        } catch (e) {\n            Logger.getInstance().warn(\"Cannot determine audio support, assuming no support for the Audio Tag\", e);\n            return false;\n        }\n    }\n    /**\r\n * The [[Sound]] object allows games built in Excalibur to load audio\r\n * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]\r\n * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n */ class Sound extends Class {\n        /**\r\n     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n     */ constructor(...paths){\n            super();\n            this.logger = Logger.getInstance();\n            this._loop = false;\n            this._volume = 1;\n            this._isStopped = false;\n            // private _isPaused = false;\n            this._tracks = [];\n            this._wasPlayingOnHidden = false;\n            this._playbackRate = 1.0;\n            this._audioContext = AudioContextFactory.create();\n            this._resource = new Resource(\"\", ExResponse.type.arraybuffer);\n            /**\r\n         * Chrome : MP3, WAV, Ogg\r\n         * Firefox : WAV, Ogg,\r\n         * IE : MP3, WAV coming soon\r\n         * Safari MP3, WAV, Ogg\r\n         */ for (const path of paths)if (canPlayFile(path)) {\n                this.path = path;\n                break;\n            }\n            if (!this.path) {\n                this.logger.warn(\"This browser does not support any of the audio files specified:\", paths.join(\", \"));\n                this.logger.warn(\"Attempting to use\", paths[0]);\n                this.path = paths[0]; // select the first specified\n            }\n        }\n        /**\r\n     * Indicates whether the clip should loop when complete\r\n     * @param value  Set the looping flag\r\n     */ set loop(value) {\n            this._loop = value;\n            for (const track of this._tracks)track.loop = this._loop;\n            this.logger.debug(\"Set loop for all instances of sound\", this.path, \"to\", this._loop);\n        }\n        get loop() {\n            return this._loop;\n        }\n        set volume(value) {\n            this._volume = value;\n            for (const track of this._tracks)track.volume = this._volume;\n            this.emit(\"volumechange\", new NativeSoundEvent(this));\n            this.logger.debug(\"Set loop for all instances of sound\", this.path, \"to\", this._volume);\n        }\n        get volume() {\n            return this._volume;\n        }\n        /**\r\n     * Get the duration that this audio should play. If unset the total natural playback duration will be used.\r\n     */ get duration() {\n            return this._duration;\n        }\n        /**\r\n     * Set the duration that this audio should play. If unset the total natural playback duration will be used.\r\n     *\r\n     * Note: if you seek to a specific point the duration will start from that point, for example\r\n     *\r\n     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n     */ set duration(duration) {\n            this._duration = duration;\n        }\n        /**\r\n     * Return array of Current AudioInstances playing or being paused\r\n     */ get instances() {\n            return this._tracks;\n        }\n        get path() {\n            return this._resource.path;\n        }\n        set path(val) {\n            this._resource.path = val;\n        }\n        isLoaded() {\n            return !!this.data;\n        }\n        async load() {\n            var _a, _b;\n            if (this.data) return this.data;\n            const arraybuffer = await this._resource.load();\n            const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));\n            this._duration = (_b = (_a = this._duration) !== null && _a !== void 0 ? _a : audiobuffer === null || audiobuffer === void 0 ? void 0 : audiobuffer.duration) !== null && _b !== void 0 ? _b : undefined;\n            this.emit(\"processed\", new NativeSoundProcessedEvent(this, audiobuffer));\n            return this.data = audiobuffer;\n        }\n        async decodeAudio(data) {\n            try {\n                return await this._audioContext.decodeAudioData(data.slice(0));\n            } catch (e) {\n                this.logger.error(\"Unable to decode  this browser may not fully support this format, or the file may be corrupt, if this is an mp3 try removing id3 tags and album art from the file.\");\n                return await Promise.reject();\n            }\n        }\n        wireEngine(engine) {\n            if (engine) {\n                this._engine = engine;\n                this._engine.on(\"hidden\", ()=>{\n                    if (engine.pauseAudioWhenHidden && this.isPlaying()) {\n                        this._wasPlayingOnHidden = true;\n                        this.pause();\n                    }\n                });\n                this._engine.on(\"visible\", ()=>{\n                    if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {\n                        this.play();\n                        this._wasPlayingOnHidden = false;\n                    }\n                });\n                this._engine.on(\"start\", ()=>{\n                    this._isStopped = false;\n                });\n                this._engine.on(\"stop\", ()=>{\n                    this.stop();\n                    this._isStopped = true;\n                });\n            }\n        }\n        /**\r\n     * Returns how many instances of the sound are currently playing\r\n     */ instanceCount() {\n            return this._tracks.length;\n        }\n        /**\r\n     * Whether or not the sound is playing right now\r\n     */ isPlaying() {\n            return this._tracks.some((t)=>t.isPlaying());\n        }\n        isPaused() {\n            return this._tracks.some((t)=>t.isPaused());\n        }\n        /**\r\n     * Play the sound, returns a promise that resolves when the sound is done playing\r\n     * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n     */ play(volume) {\n            if (!this.isLoaded()) {\n                this.logger.warn(\"Cannot start playing. Resource\", this.path, \"is not loaded yet\");\n                return Promise.resolve(true);\n            }\n            if (this._isStopped) {\n                this.logger.warn(\"Cannot start playing. Engine is in a stopped state.\");\n                return Promise.resolve(false);\n            }\n            this.volume = volume || this.volume;\n            if (this.isPaused()) return this._resumePlayback();\n            else return this._startPlayback();\n        }\n        /**\r\n     * Stop the sound, and do not rewind\r\n     */ pause() {\n            if (!this.isPlaying()) return;\n            for (const track of this._tracks)track.pause();\n            this.emit(\"pause\", new NativeSoundEvent(this));\n            this.logger.debug(\"Paused all instances of sound\", this.path);\n        }\n        /**\r\n     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.\r\n     */ stop() {\n            for (const track of this._tracks)track.stop();\n            this.emit(\"stop\", new NativeSoundEvent(this));\n            this._tracks.length = 0;\n            this.logger.debug(\"Stopped all instances of sound\", this.path);\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        set playbackRate(playbackRate) {\n            this._playbackRate = playbackRate;\n            this._tracks.forEach((t)=>{\n                t.playbackRate = this._playbackRate;\n            });\n        }\n        seek(position, trackId = 0) {\n            if (this._tracks.length === 0) this._getTrackInstance(this.data);\n            this._tracks[trackId].seek(position);\n        }\n        getTotalPlaybackDuration() {\n            return this.data.duration;\n        }\n        /**\r\n     * Return the current playback time of the playing track in seconds from the start.\r\n     *\r\n     * Optionally specify the track to query if multiple are playing at once.\r\n     * @param trackId\r\n     */ getPlaybackPosition(trackId = 0) {\n            if (this._tracks.length) return this._tracks[trackId].getPlaybackPosition();\n            return 0;\n        }\n        /**\r\n     * Get Id of provided AudioInstance in current trackList\r\n     * @param track [[Audio]] which Id is to be given\r\n     */ getTrackId(track) {\n            return this._tracks.indexOf(track);\n        }\n        async _resumePlayback() {\n            if (this.isPaused) {\n                const resumed = [];\n                // ensure we resume *current* tracks (if paused)\n                for (const track of this._tracks)resumed.push(track.play().then(()=>{\n                    this.emit(\"playbackend\", new NativeSoundEvent(this, track));\n                    this._tracks.splice(this.getTrackId(track), 1);\n                    return true;\n                }));\n                this.emit(\"resume\", new NativeSoundEvent(this));\n                this.logger.debug(\"Resuming paused instances for sound\", this.path, this._tracks);\n                // resolve when resumed tracks are done\n                await Promise.all(resumed);\n            }\n            return true;\n        }\n        /**\r\n     * Starts playback, returns a promise that resolves when playback is complete\r\n     */ async _startPlayback() {\n            const track = await this._getTrackInstance(this.data);\n            const complete = await track.play(()=>{\n                this.emit(\"playbackstart\", new NativeSoundEvent(this, track));\n                this.logger.debug(\"Playing new instance for sound\", this.path);\n            });\n            // when done, remove track\n            this.emit(\"playbackend\", new NativeSoundEvent(this, track));\n            this._tracks.splice(this.getTrackId(track), 1);\n            return complete;\n        }\n        _getTrackInstance(data) {\n            const newTrack = new WebAudioInstance(data);\n            newTrack.loop = this.loop;\n            newTrack.volume = this.volume;\n            newTrack.duration = this.duration;\n            newTrack.playbackRate = this._playbackRate;\n            this._tracks.push(newTrack);\n            return newTrack;\n        }\n    }\n    /**\r\n * Pre-loading assets\r\n *\r\n * The loader provides a mechanism to preload multiple resources at\r\n * one time. The loader must be passed to the engine in order to\r\n * trigger the loading progress bar.\r\n *\r\n * The [[Loader]] itself implements [[Loadable]] so you can load loaders.\r\n *\r\n * ## Example: Pre-loading resources for a game\r\n *\r\n * ```js\r\n * // create a loader\r\n * var loader = new ex.Loader();\r\n *\r\n * // create a resource dictionary (best practice is to keep a separate file)\r\n * var resources = {\r\n *   TextureGround: new ex.Texture(\"/images/textures/ground.png\"),\r\n *   SoundDeath: new ex.Sound(\"/sound/death.wav\", \"/sound/death.mp3\")\r\n * };\r\n *\r\n * // loop through dictionary and add to loader\r\n * for (var loadable in resources) {\r\n *   if (resources.hasOwnProperty(loadable)) {\r\n *     loader.addResource(resources[loadable]);\r\n *   }\r\n * }\r\n *\r\n * // start game\r\n * game.start(loader).then(function () {\r\n *   console.log(\"Game started!\");\r\n * });\r\n * ```\r\n *\r\n * ## Customize the Loader\r\n *\r\n * The loader can be customized to show different, text, logo, background color, and button.\r\n *\r\n * ```typescript\r\n * const loader = new ex.Loader([playerTexture]);\r\n *\r\n * // The loaders button text can simply modified using this\r\n * loader.playButtonText = 'Start the best game ever';\r\n *\r\n * // The logo can be changed by inserting a base64 image string here\r\n *\r\n * loader.logo = 'data:image/png;base64,iVBORw...';\r\n * loader.logoWidth = 15;\r\n * loader.logoHeight = 14;\r\n *\r\n * // The background color can be changed like so by supplying a valid CSS color string\r\n *\r\n * loader.backgroundColor = 'red'\r\n * loader.backgroundColor = '#176BAA'\r\n *\r\n * // To build a completely new button\r\n * loader.startButtonFactory = () => {\r\n *     let myButton = document.createElement('button');\r\n *     myButton.textContent = 'The best button';\r\n *     return myButton;\r\n * };\r\n *\r\n * engine.start(loader).then(() => {});\r\n * ```\r\n */ class Loader extends Class {\n        /**\r\n     * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n     */ constructor(loadables){\n            super();\n            this.canvas = new Canvas({\n                filtering: ImageFiltering.Blended,\n                smoothing: true,\n                cache: true,\n                draw: this.draw.bind(this)\n            });\n            this._resourceList = [];\n            this._index = 0;\n            this._playButtonShown = false;\n            this._resourceCount = 0;\n            this._numLoaded = 0;\n            this._progressCounts = {};\n            this._totalCounts = {};\n            // logo drawing stuff\n            // base64 string encoding of the excalibur logo (logo-white.png)\n            this.logo = Loader_logo;\n            this.logoWidth = 468;\n            this.logoHeight = 118;\n            /**\r\n         * Gets or sets the color of the loading bar, default is [[Color.White]]\r\n         */ this.loadingBarColor = Color.White;\n            /**\r\n         * Gets or sets the background color of the loader as a hex string\r\n         */ this.backgroundColor = \"#176BAA\";\n            this.suppressPlayButton = false;\n            /** Loads the css from Loader.css */ this._playButtonStyles = Loader_0 /* default.toString */ .Z.toString();\n            /**\r\n         * Get/set play button text\r\n         */ this.playButtonText = \"Play game\";\n            /**\r\n         * Return a html button element for excalibur to use as a play button\r\n         */ this.startButtonFactory = ()=>{\n                let buttonElement = document.getElementById(\"excalibur-play\");\n                if (!buttonElement) buttonElement = document.createElement(\"button\");\n                buttonElement.id = \"excalibur-play\";\n                buttonElement.textContent = this.playButtonText;\n                buttonElement.style.display = \"none\";\n                return buttonElement;\n            };\n            this._loadingFuture = new Future();\n            if (loadables) this.addResources(loadables);\n        }\n        get _image() {\n            if (!this._imageElement) {\n                this._imageElement = new Image();\n                this._imageElement.src = this.logo;\n            }\n            return this._imageElement;\n        }\n        get playButtonRootElement() {\n            return this._playButtonRootElement;\n        }\n        get playButtonElement() {\n            return this._playButtonElement;\n        }\n        get _playButton() {\n            const existingRoot = document.getElementById(\"excalibur-play-root\");\n            if (existingRoot) this._playButtonRootElement = existingRoot;\n            if (!this._playButtonRootElement) {\n                this._playButtonRootElement = document.createElement(\"div\");\n                this._playButtonRootElement.id = \"excalibur-play-root\";\n                this._playButtonRootElement.style.position = \"absolute\";\n                document.body.appendChild(this._playButtonRootElement);\n            }\n            if (!this._styleBlock) {\n                this._styleBlock = document.createElement(\"style\");\n                this._styleBlock.textContent = this._playButtonStyles;\n                document.head.appendChild(this._styleBlock);\n            }\n            if (!this._playButtonElement) {\n                this._playButtonElement = this.startButtonFactory();\n                this._playButtonRootElement.appendChild(this._playButtonElement);\n            }\n            return this._playButtonElement;\n        }\n        wireEngine(engine) {\n            this._engine = engine;\n            this.canvas.width = this._engine.canvas.width;\n            this.canvas.height = this._engine.canvas.height;\n        }\n        /**\r\n     * Add a resource to the loader to load\r\n     * @param loadable  Resource to add\r\n     */ addResource(loadable) {\n            const key = this._index++;\n            this._resourceList.push(loadable);\n            this._progressCounts[key] = 0;\n            this._totalCounts[key] = 1;\n            this._resourceCount++;\n        }\n        /**\r\n     * Add a list of resources to the loader to load\r\n     * @param loadables  The list of resources to load\r\n     */ addResources(loadables) {\n            let i = 0;\n            const len = loadables.length;\n            for(i; i < len; i++)this.addResource(loadables[i]);\n        }\n        /**\r\n     * Returns true if the loader has completely loaded all resources\r\n     */ isLoaded() {\n            return this._numLoaded === this._resourceCount;\n        }\n        /**\r\n     * Shows the play button and returns a promise that resolves when clicked\r\n     */ async showPlayButton() {\n            var _a, _b;\n            if (this.suppressPlayButton) {\n                this.hidePlayButton();\n                // Delay is to give the logo a chance to show, otherwise don't delay\n                await delay(500, (_a = this._engine) === null || _a === void 0 ? void 0 : _a.clock);\n            } else {\n                const resizeHandler = ()=>{\n                    this._positionPlayButton();\n                };\n                if ((_b = this._engine) === null || _b === void 0 ? void 0 : _b.browser) this._engine.browser.window.on(\"resize\", resizeHandler);\n                this._playButtonShown = true;\n                this._playButton.style.display = \"block\";\n                document.body.addEventListener(\"keyup\", (evt)=>{\n                    if (evt.key === \"Enter\") this._playButton.click();\n                });\n                this._positionPlayButton();\n                const playButtonClicked = new Promise((resolve)=>{\n                    const startButtonHandler = (e)=>{\n                        var _a;\n                        // We want to stop propagation to keep bubbling to the engine pointer handlers\n                        e.stopPropagation();\n                        // Hide Button after click\n                        this.hidePlayButton();\n                        if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) this._engine.browser.window.off(\"resize\", resizeHandler);\n                        resolve();\n                    };\n                    this._playButton.addEventListener(\"click\", startButtonHandler);\n                    this._playButton.addEventListener(\"touchend\", startButtonHandler);\n                    this._playButton.addEventListener(\"pointerup\", startButtonHandler);\n                });\n                return await playButtonClicked;\n            }\n        }\n        hidePlayButton() {\n            this._playButtonShown = false;\n            this._playButton.style.display = \"none\";\n        }\n        /**\r\n     * Clean up generated elements for the loader\r\n     */ dispose() {\n            if (this._playButtonRootElement.parentElement) {\n                this._playButtonRootElement.removeChild(this._playButtonElement);\n                document.body.removeChild(this._playButtonRootElement);\n                document.head.removeChild(this._styleBlock);\n                this._playButtonRootElement = null;\n                this._playButtonElement = null;\n                this._styleBlock = null;\n            }\n        }\n        update(_engine, _delta) {\n        // override me\n        }\n        areResourcesLoaded() {\n            return this._loadingFuture.promise;\n        }\n        /**\r\n     * Begin loading all of the supplied resources, returning a promise\r\n     * that resolves when loading of all is complete AND the user has clicked the \"Play button\"\r\n     */ async load() {\n            var _a, _b;\n            await ((_a = this._image) === null || _a === void 0 ? void 0 : _a.decode()); // decode logo if it exists\n            this.canvas.flagDirty();\n            await Promise.all(this._resourceList.map(async (r)=>{\n                await r.load().finally(()=>{\n                    // capture progress\n                    this._numLoaded++;\n                    this.canvas.flagDirty();\n                });\n            }));\n            // Wire all sound to the engine\n            for (const resource of this._resourceList)if (resource instanceof Sound) resource.wireEngine(this._engine);\n            this._loadingFuture.resolve();\n            // short delay in showing the button for aesthetics\n            await delay(200, (_b = this._engine) === null || _b === void 0 ? void 0 : _b.clock);\n            this.canvas.flagDirty();\n            await this.showPlayButton();\n            // Unlock browser AudioContext in after user gesture\n            // See: https://github.com/excaliburjs/Excalibur/issues/262\n            // See: https://github.com/excaliburjs/Excalibur/issues/1031\n            await WebAudio.unlock();\n            return this.data = this._resourceList;\n        }\n        markResourceComplete() {\n            this._numLoaded++;\n        }\n        /**\r\n     * Returns the progress of the loader as a number between [0, 1] inclusive.\r\n     */ get progress() {\n            return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;\n        }\n        _positionPlayButton() {\n            if (this._engine) {\n                const screenHeight = this._engine.screen.viewport.height;\n                const screenWidth = this._engine.screen.viewport.width;\n                if (this._playButtonRootElement) {\n                    const left = this._engine.canvas.offsetLeft;\n                    const top = this._engine.canvas.offsetTop;\n                    const buttonWidth = this._playButton.clientWidth;\n                    const buttonHeight = this._playButton.clientHeight;\n                    if (this.playButtonPosition) {\n                        this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;\n                        this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;\n                    } else {\n                        this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;\n                        this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;\n                    }\n                }\n            }\n        }\n        /**\r\n     * Loader draw function. Draws the default Excalibur loading screen.\r\n     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n     * to customize the drawing, or just override entire method.\r\n     */ draw(ctx) {\n            const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;\n            const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;\n            this._positionPlayButton();\n            ctx.fillStyle = this.backgroundColor;\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            let logoY = canvasHeight / 2;\n            const width = Math.min(this.logoWidth, canvasWidth * 0.75);\n            let logoX = canvasWidth / 2 - width / 2;\n            if (this.logoPosition) {\n                logoX = this.logoPosition.x;\n                logoY = this.logoPosition.y;\n            }\n            const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\n            const oldAntialias = this._engine.getAntialiasing();\n            this._engine.setAntialiasing(true);\n            if (!this.logoPosition) ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);\n            else ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);\n            // loading box\n            if (!this.suppressPlayButton && this._playButtonShown) {\n                this._engine.setAntialiasing(oldAntialias);\n                return;\n            }\n            let loadingX = logoX;\n            let loadingY = logoY;\n            if (this.loadingBarPosition) {\n                loadingX = this.loadingBarPosition.x;\n                loadingY = this.loadingBarPosition.y;\n            }\n            ctx.lineWidth = 2;\n            roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);\n            const progress = width * this.progress;\n            const margin = 5;\n            const progressWidth = progress - margin * 2;\n            const height = 20 - margin * 2;\n            roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);\n            this._engine.setAntialiasing(oldAntialias);\n        }\n    }\n    /**\r\n * This is the list of features that will be used to log the supported\r\n * features to the console when Detector.logBrowserFeatures() is called.\r\n */ const REPORTED_FEATURES = {\n        webgl: \"WebGL\",\n        webaudio: \"WebAudio\",\n        gamepadapi: \"Gamepad API\"\n    };\n    /**\r\n * Excalibur internal feature detection helper class\r\n */ class Detector {\n        constructor(){\n            this._features = null;\n            this.failedTests = [];\n            // critical browser features required for ex to run\n            this._criticalTests = {\n                // Test canvas/2d context support\n                canvasSupport: function() {\n                    const elem = document.createElement(\"canvas\");\n                    return !!(elem.getContext && elem.getContext(\"2d\"));\n                },\n                // Test array buffer support ex uses for downloading binary data\n                arrayBufferSupport: function() {\n                    const xhr = new XMLHttpRequest();\n                    xhr.open(\"GET\", \"/\");\n                    try {\n                        xhr.responseType = \"arraybuffer\";\n                    } catch (e) {\n                        return false;\n                    }\n                    return xhr.responseType === \"arraybuffer\";\n                },\n                // Test data urls ex uses for sprites\n                dataUrlSupport: function() {\n                    const canvas = document.createElement(\"canvas\");\n                    return canvas.toDataURL(\"image/png\").indexOf(\"data:image/png\") === 0;\n                },\n                // Test object url support for loading\n                objectUrlSupport: function() {\n                    return \"URL\" in window && \"revokeObjectURL\" in URL && \"createObjectURL\" in URL;\n                },\n                // RGBA support for colors\n                rgbaSupport: function() {\n                    const style = document.createElement(\"a\").style;\n                    style.cssText = \"background-color:rgba(150,255,150,.5)\";\n                    return (\"\" + style.backgroundColor).indexOf(\"rgba\") > -1;\n                }\n            };\n            // warnings excalibur performance will be degraded\n            this._warningTest = {\n                webAudioSupport: function() {\n                    return !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext);\n                },\n                webglSupport: function() {\n                    const elem = document.createElement(\"canvas\");\n                    return !!(elem.getContext && elem.getContext(\"webgl\"));\n                }\n            };\n            this._features = this._loadBrowserFeatures();\n        }\n        /**\r\n     * Returns a map of currently supported browser features. This method\r\n     * treats the features as a singleton and will only calculate feature\r\n     * support if it has not previously been done.\r\n     */ getBrowserFeatures() {\n            if (this._features === null) this._features = this._loadBrowserFeatures();\n            return this._features;\n        }\n        /**\r\n     * Report on non-critical browser support for debugging purposes.\r\n     * Use native browser console colors for visibility.\r\n     */ logBrowserFeatures() {\n            let msg = \"%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n\";\n            const args = [\n                \"font-weight: bold; color: navy\",\n                \"font-weight: normal; color: inherit\"\n            ];\n            const supported = this.getBrowserFeatures();\n            for (const feature of Object.keys(REPORTED_FEATURES)){\n                if (supported[feature]) {\n                    msg += \"(%c✓%c)\"; // (✓)\n                    args.push(\"font-weight: bold; color: green\");\n                    args.push(\"font-weight: normal; color: inherit\");\n                } else {\n                    msg += \"(%c✗%c)\"; // (✗)\n                    args.push(\"font-weight: bold; color: red\");\n                    args.push(\"font-weight: normal; color: inherit\");\n                }\n                msg += \" \" + REPORTED_FEATURES[feature] + \"\\n\";\n            }\n            args.unshift(msg);\n            // eslint-disable-next-line no-console\n            console.log.apply(console, args);\n        }\n        /**\r\n     * Executes several IIFE's to get a constant reference to supported\r\n     * features within the current execution context.\r\n     */ _loadBrowserFeatures() {\n            return {\n                // IIFE to check canvas support\n                canvas: (()=>{\n                    return this._criticalTests.canvasSupport();\n                })(),\n                // IIFE to check arraybuffer support\n                arraybuffer: (()=>{\n                    return this._criticalTests.arrayBufferSupport();\n                })(),\n                // IIFE to check dataurl support\n                dataurl: (()=>{\n                    return this._criticalTests.dataUrlSupport();\n                })(),\n                // IIFE to check objecturl support\n                objecturl: (()=>{\n                    return this._criticalTests.objectUrlSupport();\n                })(),\n                // IIFE to check rgba support\n                rgba: (()=>{\n                    return this._criticalTests.rgbaSupport();\n                })(),\n                // IIFE to check webaudio support\n                webaudio: (()=>{\n                    return this._warningTest.webAudioSupport();\n                })(),\n                // IIFE to check webgl support\n                webgl: (()=>{\n                    return this._warningTest.webglSupport();\n                })(),\n                // IIFE to check gamepadapi support\n                gamepadapi: (()=>{\n                    return !!navigator.getGamepads;\n                })()\n            };\n        }\n        test() {\n            // Critical test will for ex not to run\n            let failedCritical = false;\n            for(const test in this._criticalTests)if (!this._criticalTests[test].call(this)) {\n                this.failedTests.push(test);\n                Logger.getInstance().error(\"Critical browser feature missing, Excalibur requires:\", test);\n                failedCritical = true;\n            }\n            if (failedCritical) return false;\n            // Warning tests do not for ex to return false to compatibility\n            for(const warning in this._warningTest)if (!this._warningTest[warning]()) Logger.getInstance().warn(\"Warning browser feature missing, Excalibur will have reduced performance:\", warning);\n            return true;\n        }\n    }\n    /**\r\n * An enum that describes the types of collisions bodies can participate in\r\n */ var CollisionType;\n    (function(CollisionType) {\n        /**\r\n     * Bodies with the `PreventCollision` setting do not participate in any\r\n     * collisions and do not raise collision events.\r\n     */ CollisionType[\"PreventCollision\"] = \"PreventCollision\";\n        /**\r\n     * Bodies with the `Passive` setting only raise collision events, but are not\r\n     * influenced or moved by other bodies and do not influence or move other bodies.\r\n     * This is useful for use in trigger type behavior.\r\n     */ CollisionType[\"Passive\"] = \"Passive\";\n        /**\r\n     * Bodies with the `Active` setting raise collision events and participate\r\n     * in collisions with other bodies and will be push or moved by bodies sharing\r\n     * the `Active` or `Fixed` setting.\r\n     */ CollisionType[\"Active\"] = \"Active\";\n        /**\r\n     * Bodies with the `Fixed` setting raise collision events and participate in\r\n     * collisions with other bodies. Actors with the `Fixed` setting will not be\r\n     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed\r\n     * bodies as \"immovable/unstoppable\" objects. If two `Fixed` bodies meet they will\r\n     * not be pushed or moved by each other, they will not interact except to throw\r\n     * collision events.\r\n     */ CollisionType[\"Fixed\"] = \"Fixed\";\n    })(CollisionType || (CollisionType = {}));\n    const maxMessages = 5;\n    const obsoleteMessage = {};\n    const resetObsoleteCounter = ()=>{\n        for(const message in obsoleteMessage)obsoleteMessage[message] = 0;\n    };\n    const logMessage = (message, options)=>{\n        const suppressObsoleteMessages = Flags.isEnabled(\"suppress-obsolete-message\");\n        if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {\n            Logger.getInstance().warn(message);\n            // tslint:disable-next-line: no-console\n            if (console.trace && options.showStackTrace) // tslint:disable-next-line: no-console\n            console.trace();\n        }\n        obsoleteMessage[message]++;\n    };\n    /**\r\n * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n */ function obsolete(options) {\n        options = {\n            message: \"This feature will be removed in future versions of Excalibur.\",\n            alternateMethod: null,\n            showStackTrace: false,\n            ...options\n        };\n        return function(target, property, descriptor) {\n            if (descriptor && !(typeof descriptor.value === \"function\" || typeof descriptor.get === \"function\" || typeof descriptor.set === \"function\")) throw new SyntaxError(\"Only classes/functions/getters/setters can be marked as obsolete\");\n            const methodSignature = `${target.name || \"\"}${target.name && property ? \".\" : \"\"}${property ? property : \"\"}`;\n            const message = `${methodSignature} is marked obsolete: ${options.message}` + (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : \"\");\n            if (!obsoleteMessage[message]) obsoleteMessage[message] = 0;\n            // If descriptor is null it is a class\n            const method = descriptor ? {\n                ...descriptor\n            } : target;\n            if (!descriptor) {\n                // with es2015 classes we need to change our decoration tactic\n                class DecoratedClass extends method {\n                    constructor(...args){\n                        logMessage(message, options);\n                        super(...args);\n                    }\n                }\n                return DecoratedClass;\n            }\n            if (descriptor && descriptor.value) {\n                method.value = function() {\n                    logMessage(message, options);\n                    return descriptor.value.apply(this, arguments);\n                };\n                return method;\n            }\n            if (descriptor && descriptor.get) method.get = function() {\n                logMessage(message, options);\n                return descriptor.get.apply(this, arguments);\n            };\n            if (descriptor && descriptor.set) method.set = function() {\n                logMessage(message, options);\n                return descriptor.set.apply(this, arguments);\n            };\n            return method;\n        };\n    }\n    var __decorate = function(decorators, target, key, desc) {\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n        else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\n    };\n    /**\r\n * Possible collision resolution strategies\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things\r\n * like platformers or top down games.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */ var CollisionResolutionStrategy;\n    (function(CollisionResolutionStrategy) {\n        CollisionResolutionStrategy[\"Arcade\"] = \"arcade\";\n        CollisionResolutionStrategy[\"Realistic\"] = \"realistic\";\n    })(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));\n    /**\r\n * Possible broadphase collision pair identification strategies\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */ var BroadphaseStrategy;\n    (function(BroadphaseStrategy) {\n        BroadphaseStrategy[BroadphaseStrategy[\"DynamicAABBTree\"] = 0] = \"DynamicAABBTree\";\n    })(BroadphaseStrategy || (BroadphaseStrategy = {}));\n    /**\r\n * Possible numerical integrators for position and velocity\r\n */ var Integrator;\n    (function(Integrator) {\n        Integrator[Integrator[\"Euler\"] = 0] = \"Euler\";\n    })(Integrator || (Integrator = {}));\n    /**\r\n * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n */ /* istanbul ignore next */ class Physics {\n        static get gravity() {\n            return Physics.acc;\n        }\n        static set gravity(v) {\n            Physics.acc = v;\n        }\n        /**\r\n     * Configures Excalibur to use \"arcade\" physics. Arcade physics which performs simple axis aligned arcade style physics.\r\n     */ static useArcadePhysics() {\n            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\n        }\n        /**\r\n     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n     * simulated physical interactions.\r\n     */ static useRealisticPhysics() {\n            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;\n        }\n        static get dynamicTreeVelocityMultiplyer() {\n            return Physics.dynamicTreeVelocityMultiplier;\n        }\n        static set dynamicTreeVelocityMultiplyer(value) {\n            Physics.dynamicTreeVelocityMultiplier = value;\n        }\n    }\n    /**\r\n * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.\r\n * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.\r\n *\r\n * This is a great way to globally simulate effects like gravity.\r\n */ Physics.acc = new Vector(0, 0);\n    /**\r\n * Globally switches all Excalibur physics behavior on or off.\r\n */ Physics.enabled = true;\n    /**\r\n * Gets or sets the broadphase pair identification strategy.\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */ Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\n    /**\r\n * Gets or sets the global collision resolution strategy (narrowphase).\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */ Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\n    /**\r\n * The default mass to use if none is specified\r\n */ Physics.defaultMass = 10;\n    /**\r\n * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n */ Physics.integrator = Integrator.Euler;\n    /**\r\n * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);\r\n */ Physics.dynamicTreeVelocityMultiplier = 2;\n    /**\r\n * Pad RigidBody BoundingBox by a constant amount\r\n */ Physics.boundsPadding = 5;\n    /**\r\n * Number of position iterations (overlap) to run in the solver\r\n */ Physics.positionIterations = 3;\n    /**\r\n * Number of velocity iteration (response) to run in the solver\r\n */ Physics.velocityIterations = 8;\n    /**\r\n * Amount of overlap to tolerate in pixels\r\n */ Physics.slop = 1;\n    /**\r\n * Amount of positional overlap correction to apply each position iteration of the solver\r\n * O - meaning no correction, 1 - meaning correct all overlap\r\n */ Physics.steeringFactor = 0.2;\n    /**\r\n * Warm start set to true re-uses impulses from previous frames back in the solver\r\n */ Physics.warmStart = true;\n    /**\r\n * By default bodies do not sleep\r\n */ Physics.bodiesCanSleepByDefault = false;\n    /**\r\n * Surface epsilon is used to help deal with surface penetration\r\n */ Physics.surfaceEpsilon = 0.1;\n    Physics.sleepEpsilon = 0.07;\n    Physics.wakeThreshold = Physics.sleepEpsilon * 3;\n    Physics.sleepBias = 0.9;\n    /**\r\n * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n * bodies from tunneling through one another.\r\n */ Physics.checkForFastBodies = true;\n    /**\r\n * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n * Excalibur will always perform the fast body raycast regardless of speed.\r\n */ Physics.disableMinimumSpeedForFastBody = false;\n    __decorate([\n        obsolete({\n            message: \"Alias for incorrect spelling used in older versions, will be removed in v0.25.0\",\n            alternateMethod: \"dynamicTreeVelocityMultiplier\"\n        })\n    ], Physics, \"dynamicTreeVelocityMultiplyer\", null);\n    /**\r\n * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]\r\n */ var CoordPlane;\n    (function(CoordPlane) {\n        /**\r\n     * The world coordinate plane (default) represents world space, any entities drawn with world\r\n     * space move when the camera moves.\r\n     */ CoordPlane[\"World\"] = \"world\";\n        /**\r\n     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned\r\n     * to screen coordinates ignoring the camera.\r\n     */ CoordPlane[\"Screen\"] = \"screen\";\n    })(CoordPlane || (CoordPlane = {}));\n    class VectorView extends Vector {\n        constructor(options){\n            super(0, 0);\n            this._getX = options.getX;\n            this._getY = options.getY;\n            this._setX = options.setX;\n            this._setY = options.setY;\n        }\n        get x() {\n            return this._x = this._getX();\n        }\n        set x(val) {\n            this._setX(val);\n            this._x = val;\n        }\n        get y() {\n            return this._y = this._getY();\n        }\n        set y(val) {\n            this._setY(val);\n            this._y = val;\n        }\n    }\n    /**\r\n * Wraps a vector and watches for changes in the x/y, modifies the original vector.\r\n */ class WatchVector extends Vector {\n        constructor(original, change){\n            super(original.x, original.y);\n            this.original = original;\n            this.change = change;\n        }\n        get x() {\n            return this._x = this.original.x;\n        }\n        set x(newX) {\n            this.change(newX, this._y);\n            this._x = this.original.x = newX;\n        }\n        get y() {\n            return this._y = this.original.y;\n        }\n        set y(newY) {\n            this.change(this._x, newY);\n            this._y = this.original.y = newY;\n        }\n    }\n    class Transform {\n        constructor(){\n            this._parent = null;\n            this._children = [];\n            this._pos = vec(0, 0);\n            this._rotation = 0;\n            this._scale = vec(1, 1);\n            this._isDirty = false;\n            this._isInverseDirty = false;\n            this._matrix = AffineMatrix.identity();\n            this._inverse = AffineMatrix.identity();\n        }\n        get parent() {\n            return this._parent;\n        }\n        set parent(transform) {\n            if (this._parent) {\n                const index = this._parent._children.indexOf(this);\n                if (index > -1) this._parent._children.splice(index, 1);\n            }\n            this._parent = transform;\n            if (this._parent) this._parent._children.push(this);\n            this.flagDirty();\n        }\n        get children() {\n            return this._children;\n        }\n        set pos(v) {\n            if (!v.equals(this._pos)) {\n                this._pos.x = v.x;\n                this._pos.y = v.y;\n                this.flagDirty();\n            }\n        }\n        get pos() {\n            return new WatchVector(this._pos, (x, y)=>{\n                if (x !== this._pos.x || y !== this._pos.y) this.flagDirty();\n            });\n        }\n        set globalPos(v) {\n            let localPos = v.clone();\n            if (this.parent) localPos = this.parent.inverse.multiply(v);\n            if (!localPos.equals(this._pos)) {\n                this._pos = localPos;\n                this.flagDirty();\n            }\n        }\n        get globalPos() {\n            return new VectorView({\n                getX: ()=>this.matrix.data[4],\n                getY: ()=>this.matrix.data[5],\n                setX: (x)=>{\n                    if (this.parent) {\n                        const { x: newX  } = this.parent.inverse.multiply(vec(x, this.pos.y));\n                        this.pos.x = newX;\n                    } else this.pos.x = x;\n                    if (x !== this.matrix.data[4]) this.flagDirty();\n                },\n                setY: (y)=>{\n                    if (this.parent) {\n                        const { y: newY  } = this.parent.inverse.multiply(vec(this.pos.x, y));\n                        this.pos.y = newY;\n                    } else this.pos.y = y;\n                    if (y !== this.matrix.data[5]) this.flagDirty();\n                }\n            });\n        }\n        set rotation(rotation) {\n            const canonRotation = canonicalizeAngle(rotation);\n            if (canonRotation !== this._rotation) this.flagDirty();\n            this._rotation = canonRotation;\n        }\n        get rotation() {\n            return this._rotation;\n        }\n        set globalRotation(rotation) {\n            let inverseRotation = 0;\n            if (this.parent) inverseRotation = this.parent.globalRotation;\n            const canonRotation = canonicalizeAngle(rotation + inverseRotation);\n            if (canonRotation !== this._rotation) this.flagDirty();\n            this._rotation = canonRotation;\n        }\n        get globalRotation() {\n            if (this.parent) return this.matrix.getRotation();\n            return this.rotation;\n        }\n        set scale(v) {\n            if (!v.equals(this._scale)) {\n                this._scale.x = v.x;\n                this._scale.y = v.y;\n                this.flagDirty();\n            }\n        }\n        get scale() {\n            return new WatchVector(this._scale, (x, y)=>{\n                if (x !== this._scale.x || y !== this._scale.y) this.flagDirty();\n            });\n        }\n        set globalScale(v) {\n            let inverseScale = vec(1, 1);\n            if (this.parent) inverseScale = this.parent.globalScale;\n            this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));\n        }\n        get globalScale() {\n            return new VectorView({\n                getX: ()=>this.parent ? this.matrix.getScaleX() : this.scale.x,\n                getY: ()=>this.parent ? this.matrix.getScaleY() : this.scale.y,\n                setX: (x)=>{\n                    if (this.parent) {\n                        const globalScaleX = this.parent.globalScale.x;\n                        this.scale.x = x / globalScaleX;\n                    } else this.scale.x = x;\n                },\n                setY: (y)=>{\n                    if (this.parent) {\n                        const globalScaleY = this.parent.globalScale.y;\n                        this.scale.y = y / globalScaleY;\n                    } else this.scale.y = y;\n                }\n            });\n        }\n        get matrix() {\n            if (this._isDirty) {\n                if (this.parent === null) this._matrix = this._calculateMatrix();\n                else this._matrix = this.parent.matrix.multiply(this._calculateMatrix());\n                this._isDirty = false;\n            }\n            return this._matrix;\n        }\n        get inverse() {\n            if (this._isInverseDirty) {\n                this._inverse = this.matrix.inverse();\n                this._isInverseDirty = false;\n            }\n            return this._inverse;\n        }\n        _calculateMatrix() {\n            const matrix = AffineMatrix.identity().translate(this.pos.x, this.pos.y).rotate(this.rotation).scale(this.scale.x, this.scale.y);\n            return matrix;\n        }\n        flagDirty() {\n            this._isDirty = true;\n            this._isInverseDirty = true;\n            for(let i = 0; i < this._children.length; i++)this._children[i].flagDirty();\n        }\n        apply(point) {\n            return this.matrix.multiply(point);\n        }\n        applyInverse(point) {\n            return this.inverse.multiply(point);\n        }\n        setTransform(pos, rotation, scale) {\n            this._pos.x = pos.x;\n            this._pos.y = pos.y;\n            this._rotation = canonicalizeAngle(rotation);\n            this._scale.x = scale.x;\n            this._scale.y = scale.y;\n            this.flagDirty();\n        }\n        clone(dest) {\n            const target = dest !== null && dest !== void 0 ? dest : new Transform();\n            this._pos.clone(target._pos);\n            target._rotation = this._rotation;\n            this._scale.clone(target._scale);\n            target.flagDirty();\n        }\n    }\n    /**\r\n * Type guard to check if a component implements clone\r\n * @param x\r\n */ function hasClone(x) {\n        return !!(x === null || x === void 0 ? void 0 : x.clone);\n    }\n    /**\r\n * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses\r\n *\r\n * Implementations of Component must have a zero-arg constructor to support dependencies\r\n *\r\n * ```typescript\r\n * class MyComponent extends ex.Component<'my'> {\r\n *   public readonly type = 'my';\r\n *   // zero arg support required if you want to use component dependencies\r\n *   constructor(public optionalPos?: ex.Vector) {}\r\n * }\r\n * ```\r\n */ class Component {\n        constructor(){\n            /**\r\n         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]\r\n         */ this.owner = null;\n        }\n        /**\r\n     * Clones any properties on this component, if that property value has a `clone()` method it will be called\r\n     */ clone() {\n            const newComponent = new this.constructor();\n            for(const prop in this)if (this.hasOwnProperty(prop)) {\n                const val = this[prop];\n                if (hasClone(val) && prop !== \"owner\" && prop !== \"clone\") newComponent[prop] = val.clone();\n                else newComponent[prop] = val;\n            }\n            return newComponent;\n        }\n    }\n    /**\r\n * Tag components are a way of tagging a component with label and a simple value\r\n *\r\n * For example:\r\n *\r\n * ```typescript\r\n * const isOffscreen = new TagComponent('offscreen');\r\n * entity.addComponent(isOffscreen);\r\n * entity.tags.includes\r\n * ```\r\n */ class TagComponent extends Component {\n        constructor(type, value){\n            super();\n            this.type = type;\n            this.value = value;\n        }\n    }\n    /**\r\n * Simple Observable implementation\r\n * @template T is the typescript Type that defines the data being observed\r\n */ class Observable {\n        constructor(){\n            this.observers = [];\n            this.subscriptions = [];\n        }\n        /**\r\n     * Register an observer to listen to this observable\r\n     * @param observer\r\n     */ register(observer) {\n            this.observers.push(observer);\n        }\n        /**\r\n     * Register a callback to listen to this observable\r\n     * @param func\r\n     */ subscribe(func) {\n            this.subscriptions.push(func);\n        }\n        /**\r\n     * Remove an observer from the observable\r\n     * @param observer\r\n     */ unregister(observer) {\n            const i = this.observers.indexOf(observer);\n            if (i !== -1) this.observers.splice(i, 1);\n        }\n        /**\r\n     * Remove a callback that is listening to this observable\r\n     * @param func\r\n     */ unsubscribe(func) {\n            const i = this.subscriptions.indexOf(func);\n            if (i !== -1) this.subscriptions.splice(i, 1);\n        }\n        /**\r\n     * Broadcasts a message to all observers and callbacks\r\n     * @param message\r\n     */ notifyAll(message) {\n            const observersLength = this.observers.length;\n            for(let i = 0; i < observersLength; i++)this.observers[i].notify(message);\n            const subscriptionsLength = this.subscriptions.length;\n            for(let i = 0; i < subscriptionsLength; i++)this.subscriptions[i](message);\n        }\n        /**\r\n     * Removes all observers and callbacks\r\n     */ clear() {\n            this.observers.length = 0;\n            this.subscriptions.length = 0;\n        }\n    }\n    class TransformComponent extends Component {\n        constructor(){\n            super(...arguments);\n            this.type = \"ex.transform\";\n            this._transform = new Transform();\n            this._addChildTransform = (child)=>{\n                const childTxComponent = child.get(TransformComponent);\n                if (childTxComponent) childTxComponent._transform.parent = this._transform;\n            };\n            /**\r\n         * Observable that emits when the z index changes on this component\r\n         */ this.zIndexChanged$ = new Observable();\n            this._z = 0;\n            /**\r\n         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.\r\n         */ this.coordPlane = CoordPlane.World;\n        }\n        get() {\n            return this._transform;\n        }\n        onAdd(owner) {\n            for (const child of owner.children)this._addChildTransform(child);\n            owner.childrenAdded$.subscribe((child)=>this._addChildTransform(child));\n            owner.childrenRemoved$.subscribe((child)=>{\n                const childTxComponent = child.get(TransformComponent);\n                if (childTxComponent) childTxComponent._transform.parent = null;\n            });\n        }\n        onRemove(_previousOwner) {\n            this._transform.parent = null;\n        }\n        /**\r\n     * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n     * For example z=99 would be drawn on top of z=0.\r\n     */ get z() {\n            return this._z;\n        }\n        set z(val) {\n            const oldz = this._z;\n            this._z = val;\n            if (oldz !== val) this.zIndexChanged$.notifyAll(val);\n        }\n        get pos() {\n            return this._transform.pos;\n        }\n        set pos(v) {\n            this._transform.pos = v;\n        }\n        get globalPos() {\n            return this._transform.globalPos;\n        }\n        set globalPos(v) {\n            this._transform.globalPos = v;\n        }\n        get rotation() {\n            return this._transform.rotation;\n        }\n        set rotation(rotation) {\n            this._transform.rotation = rotation;\n        }\n        get globalRotation() {\n            return this._transform.globalRotation;\n        }\n        set globalRotation(rotation) {\n            this._transform.globalRotation = rotation;\n        }\n        get scale() {\n            return this._transform.scale;\n        }\n        set scale(v) {\n            this._transform.scale = v;\n        }\n        get globalScale() {\n            return this._transform.globalScale;\n        }\n        set globalScale(v) {\n            this._transform.globalScale = v;\n        }\n        applyInverse(v) {\n            return this._transform.applyInverse(v);\n        }\n        apply(v) {\n            return this._transform.apply(v);\n        }\n    }\n    class MotionComponent extends Component {\n        constructor(){\n            super(...arguments);\n            this.type = \"ex.motion\";\n            /**\r\n         * The velocity of an entity in pixels per second\r\n         */ this.vel = Vector.Zero;\n            /**\r\n         * The acceleration of entity in pixels per second^2\r\n         */ this.acc = Vector.Zero;\n            /**\r\n         * The scale rate of change in scale units per second\r\n         */ this.scaleFactor = Vector.Zero;\n            /**\r\n         * The angular velocity which is how quickly the entity is rotating in radians per second\r\n         */ this.angularVelocity = 0;\n            /**\r\n         * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n         */ this.torque = 0;\n            /**\r\n         * Inertia can be thought of as the resistance to motion\r\n         */ this.inertia = 1;\n        }\n    }\n    /**\r\n * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s\r\n *\r\n * For example:\r\n *\r\n * Players have collision group \"player\"\r\n *\r\n * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)\r\n *\r\n * Enemies have collision group \"enemy\"\r\n *\r\n * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)\r\n *\r\n * Blocks have collision group \"ground\"\r\n *\r\n * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)\r\n *\r\n * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide\r\n * with players and blocks.\r\n *\r\n * This is done with bitmasking, see the following pseudo-code\r\n *\r\n * PlayerGroup = `0b001`\r\n * PlayerGroupMask = `0b110`\r\n *\r\n * EnemyGroup = `0b010`\r\n * EnemyGroupMask = `0b101`\r\n *\r\n * BlockGroup = `0b100`\r\n * BlockGroupMask = `0b011`\r\n *\r\n * Should Players collide? No because the bitwise mask evaluates to 0\r\n * `(player1.group & player2.mask) === 0`\r\n * `(0b001 & 0b110) === 0`\r\n *\r\n * Should Players and Enemies collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & enemy1.mask) === 1`\r\n * `(0b001 & 0b101) === 1`\r\n *\r\n * Should Players and Blocks collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & blocks1.mask) === 1`\r\n * `(0b001 & 0b011) === 1`\r\n */ class CollisionGroup {\n        /**\r\n     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups\r\n     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.\r\n     * @param name Name of the collision group\r\n     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`\r\n     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`\r\n     */ constructor(name, category, mask){\n            this._name = name;\n            this._category = category;\n            this._mask = mask;\n        }\n        /**\r\n     * Get the name of the collision group\r\n     */ get name() {\n            return this._name;\n        }\n        /**\r\n     * Get the category of the collision group, a 32 bit number which should be a unique power of 2\r\n     */ get category() {\n            return this._category;\n        }\n        /**\r\n     * Get the mask for this collision group\r\n     */ get mask() {\n            return this._mask;\n        }\n        /**\r\n     * Evaluates whether 2 collision groups can collide\r\n     * @param other  CollisionGroup\r\n     */ canCollide(other) {\n            return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;\n        }\n        /**\r\n     * Inverts the collision group. For example, if before the group specified \"players\",\r\n     * inverting would specify all groups except players\r\n     * @returns CollisionGroup\r\n     */ invert() {\n            return new CollisionGroup(\"~(\" + this.name + \")\", ~this.category, ~this.mask);\n        }\n        /**\r\n     * Combine collision groups with each other. The new group includes all of the previous groups.\r\n     *\r\n     * @param collisionGroups\r\n     */ static combine(collisionGroups) {\n            const combinedName = collisionGroups.map((c)=>c.name).join(\"+\");\n            const combinedCategory = collisionGroups.reduce((current, g)=>g.category | current, 0);\n            const combinedMask = ~combinedCategory;\n            return new CollisionGroup(combinedName, combinedCategory, combinedMask);\n        }\n        /**\r\n     * Creates a collision group that collides with the listed groups\r\n     * @param collisionGroups\r\n     */ static collidesWith(collisionGroups) {\n            return CollisionGroup.combine(collisionGroups).invert();\n        }\n    }\n    /**\r\n * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,\r\n * it is the default collision group on colliders.\r\n */ CollisionGroup.All = new CollisionGroup(\"Collide with all groups\", -1, -1);\n    /**\r\n * Models a potential collision between 2 colliders\r\n */ class Pair {\n        constructor(colliderA, colliderB){\n            this.colliderA = colliderA;\n            this.colliderB = colliderB;\n            this.id = null;\n            this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\n        }\n        /**\r\n     * Returns whether a it is allowed for 2 colliders in a Pair to collide\r\n     * @param colliderA\r\n     * @param colliderB\r\n     */ static canCollide(colliderA, colliderB) {\n            var _a, _b;\n            const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n            const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n            // Prevent self collision\n            if (colliderA.id === colliderB.id) return false;\n            // Colliders with the same owner do not collide (composite colliders)\n            if (colliderA.owner && colliderB.owner && colliderA.owner.id === colliderB.owner.id) return false;\n            // if the pair has a member with zero dimension don't collide\n            if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) return false;\n            // Body's needed for collision in the current state\n            // TODO can we collide without a body?\n            if (!bodyA || !bodyB) return false;\n            // If both are in the same collision group short circuit\n            if (!bodyA.group.canCollide(bodyB.group)) return false;\n            // if both are fixed short circuit\n            if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) return false;\n            // if the either is prevent collision short circuit\n            if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) return false;\n            // if either is dead short circuit\n            if (!bodyA.active || !bodyB.active) return false;\n            return true;\n        }\n        /**\r\n     * Returns whether or not it is possible for the pairs to collide\r\n     */ get canCollide() {\n            const colliderA = this.colliderA;\n            const colliderB = this.colliderB;\n            return Pair.canCollide(colliderA, colliderB);\n        }\n        /**\r\n     * Runs the collision intersection logic on the members of this pair\r\n     */ collide() {\n            return this.colliderA.collide(this.colliderB);\n        }\n        /**\r\n     * Check if the collider is part of the pair\r\n     * @param collider\r\n     */ hasCollider(collider) {\n            return collider === this.colliderA || collider === this.colliderB;\n        }\n        /**\r\n     * Calculates the unique pair hash id for this collision pair (owning id)\r\n     */ static calculatePairHash(idA, idB) {\n            if (idA.value < idB.value) return `#${idA.value}+${idB.value}`;\n            else return `#${idB.value}+${idA.value}`;\n        }\n    }\n    /**\r\n * A 1 dimensional projection on an axis, used to test overlaps\r\n */ class Projection {\n        constructor(min, max){\n            this.min = min;\n            this.max = max;\n        }\n        overlaps(projection) {\n            return this.max > projection.min && projection.max > this.min;\n        }\n        getOverlap(projection) {\n            if (this.overlaps(projection)) {\n                if (this.max > projection.max) return projection.max - this.min;\n                else return this.max - projection.min;\n            }\n            return 0;\n        }\n    }\n    /**\r\n * Dynamic Tree Node used for tracking bounds within the tree\r\n */ class TreeNode {\n        constructor(parent){\n            this.parent = parent;\n            this.parent = parent || null;\n            this.data = null;\n            this.bounds = new BoundingBox();\n            this.left = null;\n            this.right = null;\n            this.height = 0;\n        }\n        isLeaf() {\n            return !this.left && !this.right;\n        }\n    }\n    /**\r\n * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for\r\n * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n *\r\n * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n */ class DynamicTree {\n        constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)){\n            this.worldBounds = worldBounds;\n            this.root = null;\n            this.nodes = {};\n        }\n        /**\r\n     * Inserts a node into the dynamic tree\r\n     */ _insert(leaf) {\n            // If there are no nodes in the tree, make this the root leaf\n            if (this.root === null) {\n                this.root = leaf;\n                this.root.parent = null;\n                return;\n            }\n            // Search the tree for a node that is not a leaf and find the best place to insert\n            const leafAABB = leaf.bounds;\n            let currentRoot = this.root;\n            while(!currentRoot.isLeaf()){\n                const left = currentRoot.left;\n                const right = currentRoot.right;\n                const area = currentRoot.bounds.getPerimeter();\n                const combinedAABB = currentRoot.bounds.combine(leafAABB);\n                const combinedArea = combinedAABB.getPerimeter();\n                // Calculate cost heuristic for creating a new parent and leaf\n                const cost = 2 * combinedArea;\n                // Minimum cost of pushing the leaf down the tree\n                const inheritanceCost = 2 * (combinedArea - area);\n                // Cost of descending\n                let leftCost = 0;\n                const leftCombined = leafAABB.combine(left.bounds);\n                let newArea;\n                let oldArea;\n                if (left.isLeaf()) leftCost = leftCombined.getPerimeter() + inheritanceCost;\n                else {\n                    oldArea = left.bounds.getPerimeter();\n                    newArea = leftCombined.getPerimeter();\n                    leftCost = newArea - oldArea + inheritanceCost;\n                }\n                let rightCost = 0;\n                const rightCombined = leafAABB.combine(right.bounds);\n                if (right.isLeaf()) rightCost = rightCombined.getPerimeter() + inheritanceCost;\n                else {\n                    oldArea = right.bounds.getPerimeter();\n                    newArea = rightCombined.getPerimeter();\n                    rightCost = newArea - oldArea + inheritanceCost;\n                }\n                // cost is acceptable\n                if (cost < leftCost && cost < rightCost) break;\n                // Descend to the depths\n                if (leftCost < rightCost) currentRoot = left;\n                else currentRoot = right;\n            }\n            // Create the new parent node and insert into the tree\n            const oldParent = currentRoot.parent;\n            const newParent = new TreeNode(oldParent);\n            newParent.bounds = leafAABB.combine(currentRoot.bounds);\n            newParent.height = currentRoot.height + 1;\n            if (oldParent !== null) {\n                // The sibling node was not the root\n                if (oldParent.left === currentRoot) oldParent.left = newParent;\n                else oldParent.right = newParent;\n                newParent.left = currentRoot;\n                newParent.right = leaf;\n                currentRoot.parent = newParent;\n                leaf.parent = newParent;\n            } else {\n                // The sibling node was the root\n                newParent.left = currentRoot;\n                newParent.right = leaf;\n                currentRoot.parent = newParent;\n                leaf.parent = newParent;\n                this.root = newParent;\n            }\n            // Walk up the tree fixing heights and AABBs\n            let currentNode = leaf.parent;\n            while(currentNode){\n                currentNode = this._balance(currentNode);\n                if (!currentNode.left) throw new Error(\"Parent of current leaf cannot have a null left child\" + currentNode);\n                if (!currentNode.right) throw new Error(\"Parent of current leaf cannot have a null right child\" + currentNode);\n                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\n                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\n                currentNode = currentNode.parent;\n            }\n        }\n        /**\r\n     * Removes a node from the dynamic tree\r\n     */ _remove(leaf) {\n            if (leaf === this.root) {\n                this.root = null;\n                return;\n            }\n            const parent = leaf.parent;\n            const grandParent = parent.parent;\n            let sibling;\n            if (parent.left === leaf) sibling = parent.right;\n            else sibling = parent.left;\n            if (grandParent) {\n                if (grandParent.left === parent) grandParent.left = sibling;\n                else grandParent.right = sibling;\n                sibling.parent = grandParent;\n                let currentNode = grandParent;\n                while(currentNode){\n                    currentNode = this._balance(currentNode);\n                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\n                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\n                    currentNode = currentNode.parent;\n                }\n            } else {\n                this.root = sibling;\n                sibling.parent = null;\n            }\n        }\n        /**\r\n     * Tracks a body in the dynamic tree\r\n     */ trackCollider(collider) {\n            const node = new TreeNode();\n            node.data = collider;\n            node.bounds = collider.bounds;\n            node.bounds.left -= 2;\n            node.bounds.top -= 2;\n            node.bounds.right += 2;\n            node.bounds.bottom += 2;\n            this.nodes[collider.id.value] = node;\n            this._insert(node);\n        }\n        /**\r\n     * Updates the dynamic tree given the current bounds of each body being tracked\r\n     */ updateCollider(collider) {\n            var _a;\n            const node = this.nodes[collider.id.value];\n            if (!node) return false;\n            const b = collider.bounds;\n            // if the body is outside the world no longer update it\n            if (!this.worldBounds.contains(b)) {\n                Logger.getInstance().warn(\"Collider with id \" + collider.id.value + \" is outside the world bounds and will no longer be tracked for physics\");\n                this.untrackCollider(collider);\n                return false;\n            }\n            if (node.bounds.contains(b)) return false;\n            this._remove(node);\n            b.left -= Physics.boundsPadding;\n            b.top -= Physics.boundsPadding;\n            b.right += Physics.boundsPadding;\n            b.bottom += Physics.boundsPadding;\n            // THIS IS CAUSING UNECESSARY CHECKS\n            if (collider.owner) {\n                const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n                if (body) {\n                    const multdx = body.vel.x * 32 / 1000 * Physics.dynamicTreeVelocityMultiplier;\n                    const multdy = body.vel.y * 32 / 1000 * Physics.dynamicTreeVelocityMultiplier;\n                    if (multdx < 0) b.left += multdx;\n                    else b.right += multdx;\n                    if (multdy < 0) b.top += multdy;\n                    else b.bottom += multdy;\n                }\n            }\n            node.bounds = b;\n            this._insert(node);\n            return true;\n        }\n        /**\r\n     * Untracks a body from the dynamic tree\r\n     */ untrackCollider(collider) {\n            const node = this.nodes[collider.id.value];\n            if (!node) return;\n            this._remove(node);\n            this.nodes[collider.id.value] = null;\n            delete this.nodes[collider.id.value];\n        }\n        /**\r\n     * Balances the tree about a node\r\n     */ _balance(node) {\n            if (node === null) throw new Error(\"Cannot balance at null node\");\n            if (node.isLeaf() || node.height < 2) return node;\n            const left = node.left;\n            const right = node.right;\n            const a = node;\n            const b = left;\n            const c = right;\n            const d = left.left;\n            const e = left.right;\n            const f = right.left;\n            const g = right.right;\n            const balance = c.height - b.height;\n            // Rotate c node up\n            if (balance > 1) {\n                // Swap the right node with it's parent\n                c.left = a;\n                c.parent = a.parent;\n                a.parent = c;\n                // The original node's old parent should point to the right node\n                // this is mega confusing\n                if (c.parent) {\n                    if (c.parent.left === a) c.parent.left = c;\n                    else c.parent.right = c;\n                } else this.root = c;\n                // Rotate\n                if (f.height > g.height) {\n                    c.right = f;\n                    a.right = g;\n                    g.parent = a;\n                    a.bounds = b.bounds.combine(g.bounds);\n                    c.bounds = a.bounds.combine(f.bounds);\n                    a.height = 1 + Math.max(b.height, g.height);\n                    c.height = 1 + Math.max(a.height, f.height);\n                } else {\n                    c.right = g;\n                    a.right = f;\n                    f.parent = a;\n                    a.bounds = b.bounds.combine(f.bounds);\n                    c.bounds = a.bounds.combine(g.bounds);\n                    a.height = 1 + Math.max(b.height, f.height);\n                    c.height = 1 + Math.max(a.height, g.height);\n                }\n                return c;\n            }\n            // Rotate left node up\n            if (balance < -1) {\n                // swap\n                b.left = a;\n                b.parent = a.parent;\n                a.parent = b;\n                // node's old parent should point to b\n                if (b.parent) {\n                    if (b.parent.left === a) b.parent.left = b;\n                    else {\n                        if (b.parent.right !== a) throw \"Error rotating Dynamic Tree\";\n                        b.parent.right = b;\n                    }\n                } else this.root = b;\n                // rotate\n                if (d.height > e.height) {\n                    b.right = d;\n                    a.left = e;\n                    e.parent = a;\n                    a.bounds = c.bounds.combine(e.bounds);\n                    b.bounds = a.bounds.combine(d.bounds);\n                    a.height = 1 + Math.max(c.height, e.height);\n                    b.height = 1 + Math.max(a.height, d.height);\n                } else {\n                    b.right = e;\n                    a.left = d;\n                    d.parent = a;\n                    a.bounds = c.bounds.combine(d.bounds);\n                    b.bounds = a.bounds.combine(e.bounds);\n                    a.height = 1 + Math.max(c.height, d.height);\n                    b.height = 1 + Math.max(a.height, e.height);\n                }\n                return b;\n            }\n            return node;\n        }\n        /**\r\n     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n     */ getHeight() {\n            if (this.root === null) return 0;\n            return this.root.height;\n        }\n        /**\r\n     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n     *\r\n     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n     * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n     * the tree until all possible colliders have been returned.\r\n     */ query(collider, callback) {\n            const bounds = collider.bounds;\n            const helper = (currentNode)=>{\n                if (currentNode && currentNode.bounds.overlaps(bounds)) {\n                    if (currentNode.isLeaf() && currentNode.data !== collider) {\n                        if (callback.call(collider, currentNode.data)) return true;\n                    } else return helper(currentNode.left) || helper(currentNode.right);\n                }\n                return false;\n            };\n            helper(this.root);\n        }\n        /**\r\n     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n     * long ray to test the tree specified by `max`.\r\n     *\r\n     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this\r\n     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n     * the tree until all possible bodies that would intersect with the ray have been returned.\r\n     */ rayCastQuery(ray, max = Infinity, callback) {\n            const helper = (currentNode)=>{\n                if (currentNode && currentNode.bounds.rayCast(ray, max)) {\n                    if (currentNode.isLeaf()) {\n                        if (callback.call(ray, currentNode.data)) // ray hit a leaf! return the body\n                        return true;\n                    } else // ray hit but not at a leaf, recurse deeper\n                    return helper(currentNode.left) || helper(currentNode.right);\n                }\n                return false; // ray missed\n            };\n            helper(this.root);\n        }\n        getNodes() {\n            const helper = (currentNode)=>{\n                if (currentNode) return [\n                    currentNode\n                ].concat(helper(currentNode.left), helper(currentNode.right));\n                else return [];\n            };\n            return helper(this.root);\n        }\n        debug(ex) {\n            // draw all the nodes in the Dynamic Tree\n            const helper = (currentNode)=>{\n                if (currentNode) {\n                    if (currentNode.isLeaf()) currentNode.bounds.draw(ex, Color.Green);\n                    else currentNode.bounds.draw(ex, Color.White);\n                    if (currentNode.left) helper(currentNode.left);\n                    if (currentNode.right) helper(currentNode.right);\n                }\n            };\n            helper(this.root);\n        }\n    }\n    /**\r\n * A 2D ray that can be cast into the scene to do collision detection\r\n */ class Ray {\n        /**\r\n     * @param pos The starting position for the ray\r\n     * @param dir The vector indicating the direction of the ray\r\n     */ constructor(pos, dir){\n            this.pos = pos;\n            this.dir = dir.normalize();\n        }\n        /**\r\n     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\r\n     * This number indicates the mathematical intersection time.\r\n     * @param line  The line to test\r\n     */ intersect(line) {\n            const numerator = line.begin.sub(this.pos);\n            // Test is line and ray are parallel and non intersecting\n            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) return -1;\n            // Lines are parallel\n            const divisor = this.dir.cross(line.getSlope());\n            if (divisor === 0) return -1;\n            const t = numerator.cross(line.getSlope()) / divisor;\n            if (t >= 0) {\n                const u = numerator.cross(this.dir) / divisor / line.getLength();\n                if (u >= 0 && u <= 1) return t;\n            }\n            return -1;\n        }\n        intersectPoint(line) {\n            const time = this.intersect(line);\n            if (time < 0) return null;\n            return this.getPoint(time);\n        }\n        /**\r\n     * Returns the point of intersection given the intersection time\r\n     */ getPoint(time) {\n            return this.pos.add(this.dir.scale(time));\n        }\n    }\n    /**\r\n * Responsible for performing the collision broadphase (locating potential collisions) and\r\n * the narrowphase (actual collision contacts)\r\n */ class DynamicTreeCollisionProcessor {\n        constructor(){\n            this._dynamicCollisionTree = new DynamicTree();\n            this._pairs = new Set();\n            this._collisionPairCache = [];\n            this._colliders = [];\n        }\n        getColliders() {\n            return this._colliders;\n        }\n        /**\r\n     * Tracks a physics body for collisions\r\n     */ track(target) {\n            if (!target) {\n                Logger.getInstance().warn(\"Cannot track null collider\");\n                return;\n            }\n            if (target instanceof CompositeCollider) {\n                const colliders = target.getColliders();\n                for (const c of colliders){\n                    c.owner = target.owner;\n                    this._colliders.push(c);\n                    this._dynamicCollisionTree.trackCollider(c);\n                }\n            } else {\n                this._colliders.push(target);\n                this._dynamicCollisionTree.trackCollider(target);\n            }\n        }\n        /**\r\n     * Untracks a physics body\r\n     */ untrack(target) {\n            if (!target) {\n                Logger.getInstance().warn(\"Cannot untrack a null collider\");\n                return;\n            }\n            if (target instanceof CompositeCollider) {\n                const colliders = target.getColliders();\n                for (const c of colliders){\n                    const index = this._colliders.indexOf(c);\n                    if (index !== -1) this._colliders.splice(index, 1);\n                    this._dynamicCollisionTree.untrackCollider(c);\n                }\n            } else {\n                const index = this._colliders.indexOf(target);\n                if (index !== -1) this._colliders.splice(index, 1);\n                this._dynamicCollisionTree.untrackCollider(target);\n            }\n        }\n        _pairExists(colliderA, colliderB) {\n            // if the collision pair has been calculated already short circuit\n            const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);\n            return this._pairs.has(hash);\n        }\n        /**\r\n     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy\r\n     */ broadphase(targets, delta, stats) {\n            const seconds = delta / 1000;\n            // Retrieve the list of potential colliders, exclude killed, prevented, and self\n            const potentialColliders = targets.filter((other)=>{\n                var _a, _b;\n                const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n                return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;\n            });\n            // clear old list of collision pairs\n            this._collisionPairCache = [];\n            this._pairs.clear();\n            // check for normal collision pairs\n            let collider;\n            for(let j = 0, l = potentialColliders.length; j < l; j++){\n                collider = potentialColliders[j];\n                // Query the collision tree for potential colliders\n                this._dynamicCollisionTree.query(collider, (other)=>{\n                    if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\n                        const pair = new Pair(collider, other);\n                        this._pairs.add(pair.id);\n                        this._collisionPairCache.push(pair);\n                    }\n                    // Always return false, to query whole tree. Returning true in the query method stops searching\n                    return false;\n                });\n            }\n            if (stats) stats.physics.pairs = this._collisionPairCache.length;\n            // Check dynamic tree for fast moving objects\n            // Fast moving objects are those moving at least there smallest bound per frame\n            if (Physics.checkForFastBodies) for (const collider of potentialColliders){\n                const body = collider.owner.get(BodyComponent);\n                // Skip non-active objects. Does not make sense on other collision types\n                if (body.collisionType !== CollisionType.Active) continue;\n                // Maximum travel distance next frame\n                const updateDistance = body.vel.size * seconds + // velocity term\n                body.acc.size * 0.5 * seconds * seconds; // acc term\n                // Find the minimum dimension\n                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);\n                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {\n                    if (stats) stats.physics.fastBodies++;\n                    // start with the oldPos because the integration for actors has already happened\n                    // objects resting on a surface may be slightly penetrating in the current position\n                    const updateVec = body.globalPos.sub(body.oldPos);\n                    const centerPoint = collider.center;\n                    const furthestPoint = collider.getFurthestPoint(body.vel);\n                    const origin = furthestPoint.sub(updateVec);\n                    const ray = new Ray(origin, body.vel);\n                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface\n                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));\n                    let minCollider;\n                    let minTranslate = new Vector(Infinity, Infinity);\n                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other)=>{\n                        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\n                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);\n                            if (hitPoint) {\n                                const translate = hitPoint.sub(origin);\n                                if (translate.size < minTranslate.size) {\n                                    minTranslate = translate;\n                                    minCollider = other;\n                                }\n                            }\n                        }\n                        return false;\n                    });\n                    if (minCollider && Vector.isValid(minTranslate)) {\n                        const pair = new Pair(collider, minCollider);\n                        if (!this._pairs.has(pair.id)) {\n                            this._pairs.add(pair.id);\n                            this._collisionPairCache.push(pair);\n                        }\n                        // move the fast moving object to the other body\n                        // need to push into the surface by ex.Physics.surfaceEpsilon\n                        const shift = centerPoint.sub(furthestPoint);\n                        body.globalPos = origin.add(shift).add(minTranslate).add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact\n                        collider.update(body.transform.get());\n                        if (stats) stats.physics.fastBodyCollisions++;\n                    }\n                }\n            }\n            // return cache\n            return this._collisionPairCache;\n        }\n        /**\r\n     * Applies narrow phase on collision pairs to find actual area intersections\r\n     * Adds actual colliding pairs to stats' Frame data\r\n     */ narrowphase(pairs, stats) {\n            let contacts = [];\n            for(let i = 0; i < pairs.length; i++){\n                const newContacts = pairs[i].collide();\n                contacts = contacts.concat(newContacts);\n                if (stats && newContacts.length > 0) for (const c of newContacts)stats.physics.contacts.set(c.id, c);\n            }\n            if (stats) stats.physics.collisions += contacts.length;\n            return contacts;\n        }\n        /**\r\n     * Update the dynamic tree positions\r\n     */ update(targets) {\n            let updated = 0;\n            const len = targets.length;\n            for(let i = 0; i < len; i++)if (this._dynamicCollisionTree.updateCollider(targets[i])) updated++;\n            return updated;\n        }\n        debug(ex) {\n            this._dynamicCollisionTree.debug(ex);\n        }\n    }\n    /**\r\n * A collision collider specifies the geometry that can detect when other collision colliders intersect\r\n * for the purposes of colliding 2 objects in excalibur.\r\n */ class Collider {\n        constructor(){\n            this.id = createId(\"collider\", Collider._ID++);\n            /**\r\n         * Excalibur uses this to signal to the [[CollisionSystem]] this is part of a composite collider\r\n         * @internal\r\n         * @hidden\r\n         */ this.__compositeColliderId = null;\n            this.events = new EventDispatcher();\n        }\n        /**\r\n     * Returns a boolean indicating whether this body collided with\r\n     * or was in stationary contact with\r\n     * the body of the other [[Collider]]\r\n     */ touching(other) {\n            const contact = this.collide(other);\n            if (contact) return true;\n            return false;\n        }\n    }\n    Collider._ID = 0;\n    class CompositeCollider extends Collider {\n        constructor(colliders){\n            super();\n            this._collisionProcessor = new DynamicTreeCollisionProcessor();\n            this._dynamicAABBTree = new DynamicTree();\n            this._colliders = [];\n            for (const c of colliders)this.addCollider(c);\n        }\n        clearColliders() {\n            this._colliders = [];\n        }\n        addCollider(collider) {\n            this.events.wire(collider.events);\n            collider.__compositeColliderId = this.id;\n            this._colliders.push(collider);\n            this._collisionProcessor.track(collider);\n            this._dynamicAABBTree.trackCollider(collider);\n        }\n        removeCollider(collider) {\n            this.events.unwire(collider.events);\n            collider.__compositeColliderId = null;\n            removeItemFromArray(collider, this._colliders);\n            this._collisionProcessor.untrack(collider);\n            this._dynamicAABBTree.untrackCollider(collider);\n        }\n        getColliders() {\n            return this._colliders;\n        }\n        get worldPos() {\n            var _a, _b;\n            // TODO transform component world pos\n            return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;\n        }\n        get center() {\n            var _a, _b;\n            return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;\n        }\n        get bounds() {\n            var _a, _b;\n            // TODO cache this\n            const colliders = this.getColliders();\n            const results = colliders.reduce((acc, collider)=>acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));\n            return results;\n        }\n        get localBounds() {\n            var _a, _b;\n            // TODO cache this\n            const colliders = this.getColliders();\n            const results = colliders.reduce((acc, collider)=>acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());\n            return results;\n        }\n        get axes() {\n            // TODO cache this\n            const colliders = this.getColliders();\n            let axes = [];\n            for (const collider of colliders)axes = axes.concat(collider.axes);\n            return axes;\n        }\n        getFurthestPoint(direction) {\n            const colliders = this.getColliders();\n            const furthestPoints = [];\n            for (const collider of colliders)furthestPoints.push(collider.getFurthestPoint(direction));\n            // Pick best point from all colliders\n            let bestPoint = furthestPoints[0];\n            let maxDistance = -Number.MAX_VALUE;\n            for (const point of furthestPoints){\n                const distance = point.dot(direction);\n                if (distance > maxDistance) {\n                    bestPoint = point;\n                    maxDistance = distance;\n                }\n            }\n            return bestPoint;\n        }\n        getInertia(mass) {\n            const colliders = this.getColliders();\n            let totalInertia = 0;\n            for (const collider of colliders)totalInertia += collider.getInertia(mass);\n            return totalInertia;\n        }\n        collide(other) {\n            let otherColliders = [\n                other\n            ];\n            if (other instanceof CompositeCollider) otherColliders = other.getColliders();\n            const pairs = [];\n            for (const c of otherColliders)this._dynamicAABBTree.query(c, (potentialCollider)=>{\n                pairs.push(new Pair(c, potentialCollider));\n                return false;\n            });\n            let contacts = [];\n            for (const p of pairs)contacts = contacts.concat(p.collide());\n            return contacts;\n        }\n        getClosestLineBetween(other) {\n            const colliders = this.getColliders();\n            const lines = [];\n            if (other instanceof CompositeCollider) {\n                const otherColliders = other.getColliders();\n                for (const colliderA of colliders)for (const colliderB of otherColliders){\n                    const maybeLine = colliderA.getClosestLineBetween(colliderB);\n                    if (maybeLine) lines.push(maybeLine);\n                }\n            } else for (const collider of colliders){\n                const maybeLine = other.getClosestLineBetween(collider);\n                if (maybeLine) lines.push(maybeLine);\n            }\n            if (lines.length) {\n                let minLength = lines[0].getLength();\n                let minLine = lines[0];\n                for (const line of lines){\n                    const length = line.getLength();\n                    if (length < minLength) {\n                        minLength = length;\n                        minLine = line;\n                    }\n                }\n                return minLine;\n            }\n            return null;\n        }\n        contains(point) {\n            const colliders = this.getColliders();\n            for (const collider of colliders){\n                if (collider.contains(point)) return true;\n            }\n            return false;\n        }\n        rayCast(ray, max) {\n            const colliders = this.getColliders();\n            const points = [];\n            for (const collider of colliders){\n                const vec = collider.rayCast(ray, max);\n                if (vec) points.push(vec);\n            }\n            if (points.length) {\n                let minPoint = points[0];\n                let minDistance = minPoint.dot(ray.dir);\n                for (const point of points){\n                    const distance = ray.dir.dot(point);\n                    if (distance < minDistance) {\n                        minPoint = point;\n                        minDistance = distance;\n                    }\n                }\n                return minPoint;\n            }\n            return null;\n        }\n        project(axis) {\n            const colliders = this.getColliders();\n            const projs = [];\n            for (const collider of colliders){\n                const proj = collider.project(axis);\n                if (proj) projs.push(proj);\n            }\n            // Merge all proj's on the same axis\n            if (projs.length) {\n                const newProjection = new Projection(projs[0].min, projs[0].max);\n                for (const proj of projs){\n                    newProjection.min = Math.min(proj.min, newProjection.min);\n                    newProjection.max = Math.max(proj.max, newProjection.max);\n                }\n                return newProjection;\n            }\n            return null;\n        }\n        update(transform) {\n            if (transform) {\n                const colliders = this.getColliders();\n                for (const collider of colliders){\n                    collider.owner = this.owner;\n                    collider.update(transform);\n                }\n            }\n        }\n        debug(ex, color) {\n            const colliders = this.getColliders();\n            for (const collider of colliders)collider.debug(ex, color);\n        }\n        clone() {\n            return new CompositeCollider(this._colliders.map((c)=>c.clone()));\n        }\n    }\n    /**\r\n * A 2D line segment\r\n */ class LineSegment {\n        /**\r\n     * @param begin  The starting point of the line segment\r\n     * @param end  The ending point of the line segment\r\n     */ constructor(begin, end){\n            this.begin = begin;\n            this.end = end;\n        }\n        /**\r\n     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\r\n     */ get slope() {\n            return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\n        }\n        /**\r\n     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\r\n     */ get intercept() {\n            return this.begin.y - this.slope * this.begin.x;\n        }\n        /**\r\n     * Gets the normal of the line\r\n     */ normal() {\n            if (this._normal) return this._normal;\n            return this._normal = this.end.sub(this.begin).normal();\n        }\n        dir() {\n            if (this._dir) return this._dir;\n            return this._dir = this.end.sub(this.begin);\n        }\n        getPoints() {\n            return [\n                this.begin,\n                this.end\n            ];\n        }\n        /**\r\n     * Returns the slope of the line in the form of a vector of length 1\r\n     */ getSlope() {\n            if (this._slope) return this._slope;\n            const begin = this.begin;\n            const end = this.end;\n            const distance = begin.distance(end);\n            return this._slope = end.sub(begin).scale(1 / distance);\n        }\n        /**\r\n     * Returns the edge of the line as vector, the length of the vector is the length of the edge\r\n     */ getEdge() {\n            const begin = this.begin;\n            const end = this.end;\n            return end.sub(begin);\n        }\n        /**\r\n     * Returns the length of the line segment in pixels\r\n     */ getLength() {\n            if (this._length) return this._length;\n            const begin = this.begin;\n            const end = this.end;\n            const distance = begin.distance(end);\n            return this._length = distance;\n        }\n        /**\r\n     * Returns the midpoint of the edge\r\n     */ get midpoint() {\n            return this.begin.add(this.end).scale(0.5);\n        }\n        /**\r\n     * Flips the direction of the line segment\r\n     */ flip() {\n            return new LineSegment(this.end, this.begin);\n        }\n        /**\r\n     * Tests if a given point is below the line, points in the normal direction above the line are considered above.\r\n     * @param point\r\n     */ below(point) {\n            const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);\n            return above2 >= 0;\n        }\n        /**\r\n     * Returns the clip point\r\n     * @param sideVector Vector that traces the line\r\n     * @param length Length to clip along side\r\n     */ clip(sideVector, length) {\n            let dir = sideVector;\n            dir = dir.normalize();\n            const near = dir.dot(this.begin) - length;\n            const far = dir.dot(this.end) - length;\n            const results = [];\n            if (near <= 0) results.push(this.begin);\n            if (far <= 0) results.push(this.end);\n            if (near * far < 0) {\n                const clipTime = near / (near - far);\n                results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));\n            }\n            if (results.length !== 2) return null;\n            return new LineSegment(results[0], results[1]);\n        }\n        /**\r\n     * Find the perpendicular distance from the line to a point\r\n     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n     * @param point\r\n     */ distanceToPoint(point, signed = false) {\n            const x0 = point.x;\n            const y0 = point.y;\n            const l = this.getLength();\n            const dy = this.end.y - this.begin.y;\n            const dx = this.end.x - this.begin.x;\n            const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\n            return signed ? distance : Math.abs(distance);\n        }\n        /**\r\n     * Find the perpendicular line from the line to a point\r\n     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n     * (a - p) - ((a - p) * n)n\r\n     * a is a point on the line\r\n     * p is the arbitrary point above the line\r\n     * n is a unit vector in direction of the line\r\n     * @param point\r\n     */ findVectorToPoint(point) {\n            const aMinusP = this.begin.sub(point);\n            const n = this.getSlope();\n            return aMinusP.sub(n.scale(aMinusP.dot(n)));\n        }\n        /**\r\n     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\r\n     * a new point with the calculated Y value and vice-versa.\r\n     *\r\n     * @param x The known X value of the target point\r\n     * @param y The known Y value of the target point\r\n     * @returns A new point with the other calculated axis value\r\n     */ findPoint(x = null, y = null) {\n            const m = this.slope;\n            const b = this.intercept;\n            if (x !== null) return new Vector(x, m * x + b);\n            else if (y !== null) return new Vector((y - b) / m, y);\n            else throw new Error(\"You must provide an X or a Y value\");\n        }\n        /**\r\n     * @see http://stackoverflow.com/a/11908158/109458\r\n     */ hasPoint() {\n            let currPoint;\n            let threshold = 0;\n            if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n                currPoint = new Vector(arguments[0], arguments[1]);\n                threshold = arguments[2] || 0;\n            } else if (arguments[0] instanceof Vector) {\n                currPoint = arguments[0];\n                threshold = arguments[1] || 0;\n            } else throw \"Could not determine the arguments for Vector.hasPoint\";\n            const dxc = currPoint.x - this.begin.x;\n            const dyc = currPoint.y - this.begin.y;\n            const dx1 = this.end.x - this.begin.x;\n            const dy1 = this.end.y - this.begin.y;\n            const cross = dxc * dy1 - dyc * dx1;\n            // check whether point lines on the line\n            if (Math.abs(cross) > threshold) return false;\n            // check whether point lies in-between start and end\n            if (Math.abs(dx1) >= Math.abs(dy1)) return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\n            else return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\n        }\n    }\n    /**\r\n * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment\r\n * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n * @param p0 Point where L1 begins\r\n * @param u Direction and length of L1\r\n * @param q0 Point were L2 begins\r\n * @param v Direction and length of L2\r\n */ function ClosestLine(p0, u, q0, v) {\n        // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html\n        // w(s, t) = P(s) - Q(t)\n        // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest\n        //\n        // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.\n        // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0\n        //\n        // The closest point between 2 lines then satisfies this pair of equations\n        // 1: u * wClosest = 0\n        // 2: v * wClosest = 0\n        //\n        // Substituting wClosest into the equations we get\n        //\n        // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0\n        // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0\n        // simplify w0\n        const w0 = p0.sub(q0);\n        // simplify (u * u);\n        const a = u.dot(u);\n        // simplify (u * v);\n        const b = u.dot(v);\n        // simplify (v * v)\n        const c = v.dot(v);\n        // simplify (u * w0)\n        const d = u.dot(w0);\n        // simplify (v * w0)\n        const e = v.dot(w0);\n        // denominator ac - b^2\n        const denom = a * c - b * b;\n        let sDenom = denom;\n        let tDenom = denom;\n        // if denom is 0 they are parallel, use any point from either as the start in this case p0\n        if (denom === 0 || denom <= 0.01) {\n            const tClosestParallel = d / b;\n            return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));\n        }\n        // Solve for sClosest for infinite line\n        let sClosest = b * e - c * d; // / denom;\n        // Solve for tClosest for infinite line\n        let tClosest = a * e - b * d; // / denom;\n        // Solve for segments candidate edges, if sClosest and tClosest are outside their segments\n        if (sClosest < 0) {\n            sClosest = 0;\n            tClosest = e;\n            tDenom = c;\n        } else if (sClosest > sDenom) {\n            sClosest = sDenom;\n            tClosest = e + b;\n            tDenom = c;\n        }\n        if (tClosest < 0) {\n            tClosest = 0;\n            if (-d < 0) sClosest = 0;\n            else if (-d > a) sClosest = sDenom;\n            else {\n                sClosest = -d;\n                sDenom = a;\n            }\n        } else if (tClosest > tDenom) {\n            tClosest = tDenom;\n            if (-d + b < 0) sClosest = 0;\n            else if (-d + b > a) sClosest = sDenom;\n            else {\n                sClosest = -d + b;\n                sDenom = a;\n            }\n        }\n        sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;\n        tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;\n        return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));\n    }\n    const ClosestLineJumpTable = {\n        PolygonPolygonClosestLine (polygonA, polygonB) {\n            // Find the 2 closest faces on each polygon\n            const otherWorldPos = polygonB.worldPos;\n            const otherDirection = otherWorldPos.sub(polygonA.worldPos);\n            const thisDirection = otherDirection.negate();\n            const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);\n            const rayTowardsThis = new Ray(otherWorldPos, thisDirection);\n            const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\n            const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));\n            const thisFace = polygonA.getClosestFace(thisPoint);\n            const otherFace = polygonB.getClosestFace(otherPoint);\n            // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n            const p0 = thisFace.face.begin;\n            const u = thisFace.face.getEdge();\n            // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n            const q0 = otherFace.face.begin;\n            const v = otherFace.face.getEdge();\n            return ClosestLine(p0, u, q0, v);\n        },\n        PolygonEdgeClosestLine (polygon, edge) {\n            // Find the 2 closest faces on each polygon\n            const otherWorldPos = edge.worldPos;\n            const otherDirection = otherWorldPos.sub(polygon.worldPos);\n            const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);\n            const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\n            const thisFace = polygon.getClosestFace(thisPoint);\n            // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n            const p0 = thisFace.face.begin;\n            const u = thisFace.face.getEdge();\n            // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n            const edgeLine = edge.asLine();\n            const edgeStart = edgeLine.begin;\n            const edgeVector = edgeLine.getEdge();\n            const q0 = edgeStart;\n            const v = edgeVector;\n            return ClosestLine(p0, u, q0, v);\n        },\n        PolygonCircleClosestLine (polygon, circle) {\n            // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\n            // Find the 2 closest faces on each polygon\n            const otherWorldPos = circle.worldPos;\n            const otherDirection = otherWorldPos.sub(polygon.worldPos);\n            const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());\n            const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\n            const thisFace = polygon.getClosestFace(thisPoint);\n            // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n            const p0 = thisFace.face.begin;\n            const u = thisFace.face.getEdge();\n            // Time of minimum distance\n            let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\n            // If time of minimum is past the edge clamp\n            if (t > 1) t = 1;\n            else if (t < 0) t = 0;\n            // Minimum distance\n            const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;\n            const circlex = (p0.x + u.x * t - otherWorldPos.x) * circle.radius / (circle.radius + d);\n            const circley = (p0.y + u.y * t - otherWorldPos.y) * circle.radius / (circle.radius + d);\n            return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));\n        },\n        CircleCircleClosestLine (circleA, circleB) {\n            // Find the 2 closest faces on each polygon\n            const otherWorldPos = circleB.worldPos;\n            const otherDirection = otherWorldPos.sub(circleA.worldPos);\n            const thisWorldPos = circleA.worldPos;\n            const thisDirection = thisWorldPos.sub(circleB.worldPos);\n            const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);\n            const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);\n            const thisPoint = circleA.rayCast(rayTowardsOther);\n            const otherPoint = circleB.rayCast(rayTowardsThis);\n            return new LineSegment(thisPoint, otherPoint);\n        },\n        CircleEdgeClosestLine (circle, edge) {\n            // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\n            const circleWorlPos = circle.worldPos;\n            // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n            const edgeLine = edge.asLine();\n            const edgeStart = edgeLine.begin;\n            const edgeVector = edgeLine.getEdge();\n            const p0 = edgeStart;\n            const u = edgeVector;\n            // Time of minimum distance\n            let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\n            // If time of minimum is past the edge clamp to edge\n            if (t > 1) t = 1;\n            else if (t < 0) t = 0;\n            // Minimum distance\n            const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;\n            const circlex = (p0.x + u.x * t - circleWorlPos.x) * circle.radius / (circle.radius + d);\n            const circley = (p0.y + u.y * t - circleWorlPos.y) * circle.radius / (circle.radius + d);\n            return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));\n        },\n        EdgeEdgeClosestLine (edgeA, edgeB) {\n            // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n            const edgeLineA = edgeA.asLine();\n            const edgeStartA = edgeLineA.begin;\n            const edgeVectorA = edgeLineA.getEdge();\n            const p0 = edgeStartA;\n            const u = edgeVectorA;\n            // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n            const edgeLineB = edgeB.asLine();\n            const edgeStartB = edgeLineB.begin;\n            const edgeVectorB = edgeLineB.getEdge();\n            const q0 = edgeStartB;\n            const v = edgeVectorB;\n            return ClosestLine(p0, u, q0, v);\n        }\n    };\n    /**\r\n * This is a circle collider for the excalibur rigid body physics simulation\r\n */ class CircleCollider extends Collider {\n        constructor(options){\n            super();\n            /**\r\n         * Position of the circle relative to the collider, by default (0, 0).\r\n         */ this.offset = Vector.Zero;\n            this._globalMatrix = AffineMatrix.identity();\n            this.offset = options.offset || Vector.Zero;\n            this.radius = options.radius || 0;\n            this._globalMatrix.translate(this.offset.x, this.offset.y);\n        }\n        get worldPos() {\n            return this._globalMatrix.getPosition();\n        }\n        /**\r\n     * Get the radius of the circle\r\n     */ get radius() {\n            var _a;\n            const tx = this._transform;\n            const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\n            // This is a trade off, the alternative is retooling circles to support ellipse collisions\n            return this._naturalRadius * Math.min(scale.x, scale.y);\n        }\n        /**\r\n     * Set the radius of the circle\r\n     */ set radius(val) {\n            var _a;\n            const tx = this._transform;\n            const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\n            // This is a trade off, the alternative is retooling circles to support ellipse collisions\n            this._naturalRadius = val / Math.min(scale.x, scale.y);\n        }\n        /**\r\n     * Returns a clone of this shape, not associated with any collider\r\n     */ clone() {\n            return new CircleCollider({\n                offset: this.offset.clone(),\n                radius: this.radius\n            });\n        }\n        /**\r\n     * Get the center of the collider in world coordinates\r\n     */ get center() {\n            return this._globalMatrix.getPosition();\n        }\n        /**\r\n     * Tests if a point is contained in this collider\r\n     */ contains(point) {\n            var _a, _b;\n            const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;\n            const distance = pos.distance(point);\n            if (distance <= this.radius) return true;\n            return false;\n        }\n        /**\r\n     * Casts a ray at the Circle collider and returns the nearest point of collision\r\n     * @param ray\r\n     */ rayCast(ray, max = Infinity) {\n            //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\n            const c = this.center;\n            const dir = ray.dir;\n            const orig = ray.pos;\n            const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));\n            if (discriminant < 0) // no intersection\n            return null;\n            else {\n                let toi = 0;\n                if (discriminant === 0) {\n                    toi = -dir.dot(orig.sub(c));\n                    if (toi > 0 && toi < max) return ray.getPoint(toi);\n                    return null;\n                } else {\n                    const toi1 = -dir.dot(orig.sub(c)) + discriminant;\n                    const toi2 = -dir.dot(orig.sub(c)) - discriminant;\n                    const positiveToi = [];\n                    if (toi1 >= 0) positiveToi.push(toi1);\n                    if (toi2 >= 0) positiveToi.push(toi2);\n                    const mintoi = Math.min(...positiveToi);\n                    if (mintoi <= max) return ray.getPoint(mintoi);\n                    return null;\n                }\n            }\n        }\n        getClosestLineBetween(shape) {\n            if (shape instanceof CircleCollider) return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);\n            else if (shape instanceof PolygonCollider) return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();\n            else if (shape instanceof EdgeCollider) return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();\n            else throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\n        }\n        /**\r\n     * @inheritdoc\r\n     */ collide(collider) {\n            if (collider instanceof CircleCollider) return CollisionJumpTable.CollideCircleCircle(this, collider);\n            else if (collider instanceof PolygonCollider) return CollisionJumpTable.CollideCirclePolygon(this, collider);\n            else if (collider instanceof EdgeCollider) return CollisionJumpTable.CollideCircleEdge(this, collider);\n            else throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);\n        }\n        /**\r\n     * Find the point on the collider furthest in the direction specified\r\n     */ getFurthestPoint(direction) {\n            return this.center.add(direction.normalize().scale(this.radius));\n        }\n        /**\r\n     * Find the local point on the shape in the direction specified\r\n     * @param direction\r\n     */ getFurthestLocalPoint(direction) {\n            const dir = direction.normalize();\n            return dir.scale(this.radius);\n        }\n        /**\r\n     * Get the axis aligned bounding box for the circle collider in world coordinates\r\n     */ get bounds() {\n            var _a, _b, _c;\n            const tx = this._transform;\n            const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\n            const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;\n            const pos = (_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero;\n            return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius).rotate(rotation).scale(scale).translate(pos);\n        }\n        /**\r\n     * Get the axis aligned bounding box for the circle collider in local coordinates\r\n     */ get localBounds() {\n            return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius);\n        }\n        /**\r\n     * Get axis not implemented on circles, since there are infinite axis in a circle\r\n     */ get axes() {\n            return [];\n        }\n        /**\r\n     * Returns the moment of inertia of a circle given it's mass\r\n     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n     */ getInertia(mass) {\n            return mass * this.radius * this.radius / 2;\n        }\n        /* istanbul ignore next */ update(transform) {\n            var _a;\n            this._transform = transform;\n            const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;\n            globalMat.clone(this._globalMatrix);\n            this._globalMatrix.translate(this.offset.x, this.offset.y);\n        }\n        /**\r\n     * Project the circle along a specified axis\r\n     */ project(axis) {\n            const scalars = [];\n            const point = this.center;\n            const dotProduct = point.dot(axis);\n            scalars.push(dotProduct);\n            scalars.push(dotProduct + this.radius);\n            scalars.push(dotProduct - this.radius);\n            return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\n        }\n        debug(ex, color) {\n            var _a, _b, _c, _d;\n            const tx = this._transform;\n            const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\n            const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;\n            const pos = (_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero;\n            ex.save();\n            ex.translate(pos.x, pos.y);\n            ex.rotate(rotation);\n            ex.scale(scale.x, scale.y);\n            ex.drawCircle((_d = this.offset) !== null && _d !== void 0 ? _d : Vector.Zero, this._naturalRadius, Color.Transparent, color, 2);\n            ex.restore();\n        }\n    }\n    /**\r\n * Collision contacts are used internally by Excalibur to resolve collision between colliders. This\r\n * Pair prevents collisions from being evaluated more than one time\r\n */ class CollisionContact {\n        constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info){\n            var _a, _b;\n            this._canceled = false;\n            this.colliderA = colliderA;\n            this.colliderB = colliderB;\n            this.mtv = mtv;\n            this.normal = normal;\n            this.tangent = tangent;\n            this.points = points;\n            this.localPoints = localPoints;\n            this.info = info;\n            this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\n            if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) // Add on the parent composite pair for start/end contact\n            this.id += \"|\" + Pair.calculatePairHash((_a = colliderA.__compositeColliderId) !== null && _a !== void 0 ? _a : colliderA.id, (_b = colliderB.__compositeColliderId) !== null && _b !== void 0 ? _b : colliderB.id);\n        }\n        /**\r\n     * Match contact awake state, except if body's are Fixed\r\n     */ matchAwake() {\n            const bodyA = this.colliderA.owner.get(BodyComponent);\n            const bodyB = this.colliderB.owner.get(BodyComponent);\n            if (bodyA && bodyB) {\n                if (bodyA.sleeping !== bodyB.sleeping) {\n                    if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) bodyA.setSleeping(false);\n                    if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) bodyB.setSleeping(false);\n                }\n            }\n        }\n        isCanceled() {\n            return this._canceled;\n        }\n        cancel() {\n            this._canceled = true;\n        }\n    }\n    class SeparatingAxis {\n        static findPolygonPolygonSeparation(polyA, polyB) {\n            let bestSeparation = -Number.MAX_VALUE;\n            let bestSide = null;\n            let bestAxis = null;\n            let bestSideIndex = -1;\n            let bestOtherPoint = null;\n            const sides = polyA.getSides();\n            const localSides = polyA.getLocalSides();\n            for(let i = 0; i < sides.length; i++){\n                const side = sides[i];\n                const axis = side.normal();\n                const vertB = polyB.getFurthestPoint(axis.negate());\n                // Separation on side i's axis\n                // We are looking for the largest separation between poly A's sides\n                const vertSeparation = side.distanceToPoint(vertB, true);\n                if (vertSeparation > bestSeparation) {\n                    bestSeparation = vertSeparation;\n                    bestSide = side;\n                    bestAxis = axis;\n                    bestSideIndex = i;\n                    bestOtherPoint = vertB;\n                }\n            }\n            return {\n                collider: polyA,\n                separation: bestAxis ? bestSeparation : 99,\n                axis: bestAxis,\n                side: bestSide,\n                localSide: localSides[bestSideIndex],\n                sideId: bestSideIndex,\n                point: bestOtherPoint,\n                localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null\n            };\n        }\n        static findCirclePolygonSeparation(circle, polygon) {\n            const axes = polygon.axes;\n            const pc = polygon.center;\n            // Special SAT with circles\n            const polyDir = pc.sub(circle.worldPos);\n            const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());\n            axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());\n            let minOverlap = Number.MAX_VALUE;\n            let minAxis = null;\n            let minIndex = -1;\n            for(let i = 0; i < axes.length; i++){\n                const proj1 = polygon.project(axes[i]);\n                const proj2 = circle.project(axes[i]);\n                const overlap = proj1.getOverlap(proj2);\n                if (overlap <= 0) return null;\n                else if (overlap < minOverlap) {\n                    minOverlap = overlap;\n                    minAxis = axes[i];\n                    minIndex = i;\n                }\n            }\n            if (minIndex < 0) return null;\n            return minAxis.normalize().scale(minOverlap);\n        }\n    }\n    const CollisionJumpTable = {\n        CollideCircleCircle (circleA, circleB) {\n            const circleAPos = circleA.worldPos;\n            const circleBPos = circleB.worldPos;\n            const combinedRadius = circleA.radius + circleB.radius;\n            const distance = circleAPos.distance(circleBPos);\n            if (distance > combinedRadius) return [];\n            // negative means overlap\n            const separation = combinedRadius - distance;\n            // Normal points from A -> B\n            const normal = circleBPos.sub(circleAPos).normalize();\n            const tangent = normal.perpendicular();\n            const mvt = normal.scale(separation);\n            const point = circleA.getFurthestPoint(normal);\n            const local = circleA.getFurthestLocalPoint(normal);\n            const info = {\n                collider: circleA,\n                separation: separation,\n                axis: normal,\n                point: point\n            };\n            return [\n                new CollisionContact(circleA, circleB, mvt, normal, tangent, [\n                    point\n                ], [\n                    local\n                ], info)\n            ];\n        },\n        CollideCirclePolygon (circle, polygon) {\n            var _a, _b;\n            let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);\n            if (!minAxis) return [];\n            // make sure that the minAxis is pointing away from circle\n            const samedir = minAxis.dot(polygon.center.sub(circle.center));\n            minAxis = samedir < 0 ? minAxis.negate() : minAxis;\n            const point = circle.getFurthestPoint(minAxis);\n            const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();\n            const local = xf.applyInverse(point);\n            const normal = minAxis.normalize();\n            const info = {\n                collider: circle,\n                separation: -minAxis.size,\n                axis: normal,\n                point: point,\n                localPoint: local,\n                side: polygon.findSide(normal.negate()),\n                localSide: polygon.findLocalSide(normal.negate())\n            };\n            return [\n                new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [\n                    point\n                ], [\n                    local\n                ], info)\n            ];\n        },\n        CollideCircleEdge (circle, edge) {\n            // TODO not sure this actually abides by local/world collisions\n            // Are edge.begin and edge.end local space or world space? I think they should be local\n            // center of the circle in world pos\n            const cc = circle.center;\n            // vector in the direction of the edge\n            const edgeWorld = edge.asLine();\n            const e = edgeWorld.end.sub(edgeWorld.begin);\n            // amount of overlap with the circle's center along the edge direction\n            const u = e.dot(edgeWorld.end.sub(cc));\n            const v = e.dot(cc.sub(edgeWorld.begin));\n            const side = edge.asLine();\n            const localSide = edge.asLocalLine();\n            // Potential region A collision (circle is on the left side of the edge, before the beginning)\n            if (v <= 0) {\n                const da = edgeWorld.begin.sub(cc);\n                const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\n                // save some sqrts\n                if (dda > circle.radius * circle.radius) return []; // no collision\n                const normal = da.normalize();\n                const separation = circle.radius - Math.sqrt(dda);\n                const info = {\n                    collider: circle,\n                    separation: separation,\n                    axis: normal,\n                    point: side.begin,\n                    side: side,\n                    localSide: localSide\n                };\n                return [\n                    new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [\n                        side.begin\n                    ], [\n                        localSide.begin\n                    ], info)\n                ];\n            }\n            // Potential region B collision (circle is on the right side of the edge, after the end)\n            if (u <= 0) {\n                const db = edgeWorld.end.sub(cc);\n                const ddb = db.dot(db);\n                if (ddb > circle.radius * circle.radius) return [];\n                const normal = db.normalize();\n                const separation = circle.radius - Math.sqrt(ddb);\n                const info = {\n                    collider: circle,\n                    separation: separation,\n                    axis: normal,\n                    point: side.end,\n                    side: side,\n                    localSide: localSide\n                };\n                return [\n                    new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [\n                        side.end\n                    ], [\n                        localSide.end\n                    ], info)\n                ];\n            }\n            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\n            const den = e.dot(e);\n            const pointOnEdge = edgeWorld.begin.scale(u).add(edgeWorld.end.scale(v)).scale(1 / den);\n            const d = cc.sub(pointOnEdge);\n            const dd = d.dot(d);\n            if (dd > circle.radius * circle.radius) return []; // no collision\n            let normal = e.perpendicular();\n            // flip correct direction\n            if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {\n                normal.x = -normal.x;\n                normal.y = -normal.y;\n            }\n            normal = normal.normalize();\n            const separation = circle.radius - Math.sqrt(dd);\n            const mvt = normal.scale(separation);\n            const info = {\n                collider: circle,\n                separation: separation,\n                axis: normal,\n                point: pointOnEdge,\n                side: side,\n                localSide: localSide\n            };\n            return [\n                new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [\n                    pointOnEdge\n                ], [\n                    pointOnEdge.sub(edge.worldPos)\n                ], info)\n            ];\n        },\n        CollideEdgeEdge () {\n            // Edge-edge collision doesn't make sense\n            return [];\n        },\n        CollidePolygonEdge (polygon, edge) {\n            var _a;\n            const pc = polygon.center;\n            const ec = edge.center;\n            const dir = ec.sub(pc).normalize();\n            // build a temporary polygon from the edge to use SAT\n            const linePoly = new PolygonCollider({\n                points: [\n                    edge.begin,\n                    edge.end,\n                    edge.end.add(dir.scale(100)),\n                    edge.begin.add(dir.scale(100))\n                ],\n                offset: edge.offset\n            });\n            linePoly.owner = edge.owner;\n            const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);\n            if (tx) linePoly.update(edge.owner.get(TransformComponent).get());\n            // Gross hack but poly-poly works well\n            const contact = this.CollidePolygonPolygon(polygon, linePoly);\n            if (contact.length) {\n                // Fudge the contact back to edge\n                contact[0].colliderB = edge;\n                contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);\n            }\n            return contact;\n        },\n        CollidePolygonPolygon (polyA, polyB) {\n            var _a, _b, _c, _d;\n            // Multi contact from SAT\n            // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection\n            // do a SAT test to find a min axis if it exists\n            const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);\n            // If there is no overlap from boxA's perspective we can end early\n            if (separationA.separation > 0) return [];\n            const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);\n            // If there is no overlap from boxB's perspective exit now\n            if (separationB.separation > 0) return [];\n            // Separations are both negative, we want to pick the least negative (minimal movement)\n            const separation = separationA.separation > separationB.separation ? separationA : separationB;\n            // The incident side is the most opposite from the axes of collision on the other collider\n            const other = separation.collider === polyA ? polyB : polyA;\n            const incident = other.findSide(separation.axis.negate());\n            // Clip incident side by the perpendicular lines at each end of the reference side\n            // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\n            const reference = separation.side;\n            const refDir = reference.dir().normalize();\n            // Find our contact points by clipping the incident by the collision side\n            const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));\n            let clipLeft = null;\n            if (clipRight) clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));\n            // If there is no left there is no collision\n            if (clipLeft) {\n                // We only want clip points below the reference edge, discard the others\n                const points = clipLeft.getPoints().filter((p)=>{\n                    return reference.below(p);\n                });\n                let normal = separation.axis;\n                let tangent = normal.perpendicular();\n                // Point Contact A -> B\n                if (polyB.center.sub(polyA.center).dot(normal) < 0) {\n                    normal = normal.negate();\n                    tangent = normal.perpendicular();\n                }\n                // Points are clipped from incident which is the other collider\n                // Store those as locals\n                let localPoints = [];\n                if (separation.collider === polyA) {\n                    const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();\n                    localPoints = points.map((p)=>xf.applyInverse(p));\n                } else {\n                    const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();\n                    localPoints = points.map((p)=>xf.applyInverse(p));\n                }\n                return [\n                    new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)\n                ];\n            }\n            return [];\n        },\n        FindContactSeparation (contact, localPoint) {\n            var _a, _b, _c, _d;\n            const shapeA = contact.colliderA;\n            const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();\n            const shapeB = contact.colliderB;\n            const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();\n            // both are circles\n            if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {\n                const combinedRadius = shapeA.radius + shapeB.radius;\n                const distance = txA.pos.distance(txB.pos);\n                const separation = combinedRadius - distance;\n                return -separation;\n            }\n            // both are polygons\n            if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {\n                if (contact.info.localSide) {\n                    let side;\n                    let worldPoint;\n                    if (contact.info.collider === shapeA) {\n                        side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));\n                        worldPoint = txB.apply(localPoint);\n                    } else {\n                        side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));\n                        worldPoint = txA.apply(localPoint);\n                    }\n                    return side.distanceToPoint(worldPoint, true);\n                }\n            }\n            // polygon v circle\n            if (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider || shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider) {\n                const worldPoint = txA.apply(localPoint);\n                if (contact.info.side) return contact.info.side.distanceToPoint(worldPoint, true);\n            }\n            // polygon v edge\n            if (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider || shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider) {\n                let worldPoint;\n                if (contact.info.collider === shapeA) worldPoint = txB.apply(localPoint);\n                else worldPoint = txA.apply(localPoint);\n                if (contact.info.side) return contact.info.side.distanceToPoint(worldPoint, true);\n            }\n            // circle v edge\n            if (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider || shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider) {\n                // Local point is always on the edge which is always shapeB\n                const worldPoint = txB.apply(localPoint);\n                let circlePoint;\n                if (shapeA instanceof CircleCollider) circlePoint = shapeA.getFurthestPoint(contact.normal);\n                const dist = worldPoint.distance(circlePoint);\n                if (contact.info.side) return dist > 0 ? -dist : 0;\n            }\n            return 0;\n        }\n    };\n    /**\r\n * Edge is a single line collider to create collisions with a single line.\r\n */ class EdgeCollider extends Collider {\n        constructor(options){\n            var _a;\n            super();\n            this._globalMatrix = AffineMatrix.identity();\n            this.begin = options.begin || Vector.Zero;\n            this.end = options.end || Vector.Zero;\n            this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;\n        }\n        /**\r\n     * Returns a clone of this Edge, not associated with any collider\r\n     */ clone() {\n            return new EdgeCollider({\n                begin: this.begin.clone(),\n                end: this.end.clone()\n            });\n        }\n        get worldPos() {\n            var _a;\n            const tx = this._transform;\n            return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;\n        }\n        /**\r\n     * Get the center of the collision area in world coordinates\r\n     */ get center() {\n            const begin = this._getTransformedBegin();\n            const end = this._getTransformedEnd();\n            const pos = begin.average(end);\n            return pos;\n        }\n        _getTransformedBegin() {\n            return this._globalMatrix.multiply(this.begin);\n        }\n        _getTransformedEnd() {\n            return this._globalMatrix.multiply(this.end);\n        }\n        /**\r\n     * Returns the slope of the line in the form of a vector\r\n     */ getSlope() {\n            const begin = this._getTransformedBegin();\n            const end = this._getTransformedEnd();\n            const distance = begin.distance(end);\n            return end.sub(begin).scale(1 / distance);\n        }\n        /**\r\n     * Returns the length of the line segment in pixels\r\n     */ getLength() {\n            const begin = this._getTransformedBegin();\n            const end = this._getTransformedEnd();\n            const distance = begin.distance(end);\n            return distance;\n        }\n        /**\r\n     * Tests if a point is contained in this collision area\r\n     */ contains() {\n            return false;\n        }\n        /**\r\n     * @inheritdoc\r\n     */ rayCast(ray, max = Infinity) {\n            const numerator = this._getTransformedBegin().sub(ray.pos);\n            // Test is line and ray are parallel and non intersecting\n            if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) return null;\n            // Lines are parallel\n            const divisor = ray.dir.cross(this.getSlope());\n            if (divisor === 0) return null;\n            const t = numerator.cross(this.getSlope()) / divisor;\n            if (t >= 0 && t <= max) {\n                const u = numerator.cross(ray.dir) / divisor / this.getLength();\n                if (u >= 0 && u <= 1) return ray.getPoint(t);\n            }\n            return null;\n        }\n        /**\r\n     * Returns the closes line between this and another collider, from this -> collider\r\n     * @param shape\r\n     */ getClosestLineBetween(shape) {\n            if (shape instanceof CircleCollider) return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);\n            else if (shape instanceof PolygonCollider) return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();\n            else if (shape instanceof EdgeCollider) return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);\n            else throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\n        }\n        /**\r\n     * @inheritdoc\r\n     */ collide(shape) {\n            if (shape instanceof CircleCollider) return CollisionJumpTable.CollideCircleEdge(shape, this);\n            else if (shape instanceof PolygonCollider) return CollisionJumpTable.CollidePolygonEdge(shape, this);\n            else if (shape instanceof EdgeCollider) return CollisionJumpTable.CollideEdgeEdge();\n            else throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);\n        }\n        /**\r\n     * Find the point on the collider furthest in the direction specified\r\n     */ getFurthestPoint(direction) {\n            const transformedBegin = this._getTransformedBegin();\n            const transformedEnd = this._getTransformedEnd();\n            if (direction.dot(transformedBegin) > 0) return transformedBegin;\n            else return transformedEnd;\n        }\n        _boundsFromBeginEnd(begin, end, padding = 10) {\n            // A perfectly vertical or horizontal edge would have a bounds 0 width or height\n            // this causes problems for the collision system so we give them some padding\n            return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);\n        }\n        /**\r\n     * Get the axis aligned bounding box for the edge collider in world space\r\n     */ get bounds() {\n            const transformedBegin = this._getTransformedBegin();\n            const transformedEnd = this._getTransformedEnd();\n            return this._boundsFromBeginEnd(transformedBegin, transformedEnd);\n        }\n        /**\r\n     * Get the axis aligned bounding box for the edge collider in local space\r\n     */ get localBounds() {\n            return this._boundsFromBeginEnd(this.begin, this.end);\n        }\n        /**\r\n     * Returns this edge represented as a line in world coordinates\r\n     */ asLine() {\n            return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());\n        }\n        /**\r\n     * Return this edge as a line in local line coordinates (relative to the position)\r\n     */ asLocalLine() {\n            return new LineSegment(this.begin, this.end);\n        }\n        /**\r\n     * Get the axis associated with the edge\r\n     */ get axes() {\n            const e = this._getTransformedEnd().sub(this._getTransformedBegin());\n            const edgeNormal = e.normal();\n            const axes = [];\n            axes.push(edgeNormal);\n            axes.push(edgeNormal.negate());\n            axes.push(edgeNormal.normal());\n            axes.push(edgeNormal.normal().negate());\n            return axes;\n        }\n        /**\r\n     * Get the moment of inertia for an edge\r\n     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n     */ getInertia(mass) {\n            const length = this.end.sub(this.begin).distance() / 2;\n            return mass * length * length;\n        }\n        /**\r\n     * @inheritdoc\r\n     */ update(transform) {\n            var _a;\n            this._transform = transform;\n            const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;\n            globalMat.clone(this._globalMatrix);\n            this._globalMatrix.translate(this.offset.x, this.offset.y);\n        }\n        /**\r\n     * Project the edge along a specified axis\r\n     */ project(axis) {\n            const scalars = [];\n            const points = [\n                this._getTransformedBegin(),\n                this._getTransformedEnd()\n            ];\n            const len = points.length;\n            for(let i = 0; i < len; i++)scalars.push(points[i].dot(axis));\n            return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\n        }\n        debug(ex, color) {\n            const begin = this._getTransformedBegin();\n            const end = this._getTransformedEnd();\n            ex.drawLine(begin, end, color, 2);\n            ex.drawCircle(begin, 2, color);\n            ex.drawCircle(end, 2, color);\n        }\n    }\n    /**\r\n * Polygon collider for detecting collisions\r\n */ class PolygonCollider extends Collider {\n        constructor(options){\n            var _a, _b;\n            super();\n            this._logger = Logger.getInstance();\n            this._transformedPoints = [];\n            this._sides = [];\n            this._localSides = [];\n            this._globalMatrix = AffineMatrix.identity();\n            this._transformedPointsDirty = true;\n            this._sidesDirty = true;\n            this._localSidesDirty = true;\n            this._localBoundsDirty = true;\n            this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;\n            this._globalMatrix.translate(this.offset.x, this.offset.y);\n            this.points = (_b = options.points) !== null && _b !== void 0 ? _b : [];\n            const counterClockwise = this._isCounterClockwiseWinding(this.points);\n            if (!counterClockwise) this.points.reverse();\n            if (!this.isConvex()) this._logger.warn(\"Excalibur only supports convex polygon colliders and will not behave properly.Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles\");\n            // calculate initial transformation\n            this._calculateTransformation();\n        }\n        /**\r\n     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n     * Excalibur stores these in counter-clockwise order\r\n     */ set points(points) {\n            this._localBoundsDirty = true;\n            this._localSidesDirty = true;\n            this._sidesDirty = true;\n            this._points = points;\n        }\n        /**\r\n     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n     * Excalibur stores these in counter-clockwise order\r\n     */ get points() {\n            return this._points;\n        }\n        _isCounterClockwiseWinding(points) {\n            // https://stackoverflow.com/a/1165943\n            let sum = 0;\n            for(let i = 0; i < points.length; i++)sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);\n            return sum < 0;\n        }\n        /**\r\n     * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.\r\n     * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape\r\n     */ isConvex() {\n            // From SO: https://stackoverflow.com/a/45372025\n            if (this.points.length < 3) return false;\n            let oldPoint = this.points[this.points.length - 2];\n            let newPoint = this.points[this.points.length - 1];\n            let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\n            let oldDirection = 0;\n            let orientation = 0;\n            let angleSum = 0;\n            for (const [i, point] of this.points.entries()){\n                oldPoint = newPoint;\n                oldDirection = direction;\n                newPoint = point;\n                direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\n                if (oldPoint.equals(newPoint)) return false; // repeat point\n                let angle = direction - oldDirection;\n                if (angle <= -Math.PI) angle += Math.PI * 2;\n                else if (angle > Math.PI) angle -= Math.PI * 2;\n                if (i === 0) {\n                    if (angle === 0.0) return false;\n                    orientation = angle > 0 ? 1 : -1;\n                } else {\n                    if (orientation * angle <= 0) return false;\n                }\n                angleSum += angle;\n            }\n            return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;\n        }\n        /**\r\n     * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons\r\n     */ tessellate() {\n            const polygons = [];\n            for(let i = 1; i < this.points.length - 2; i++)polygons.push([\n                this.points[0],\n                this.points[i + 1],\n                this.points[i + 2]\n            ]);\n            polygons.push([\n                this.points[0],\n                this.points[1],\n                this.points[2]\n            ]);\n            return new CompositeCollider(polygons.map((points)=>Shape.Polygon(points)));\n        }\n        /**\r\n     * Triangulate the polygon collider using the \"Ear Clipping\" algorithm.\r\n     * Returns a new [[CompositeCollider]] made up of smaller triangles.\r\n     */ triangulate() {\n            // https://www.youtube.com/watch?v=hTJFcHutls8\n            if (this.points.length < 3) throw Error(\"Invalid polygon\");\n            /**\r\n         * Helper to get a vertex in the list\r\n         */ function getItem(index, list) {\n                if (index >= list.length) return list[index % list.length];\n                else if (index < 0) return list[index % list.length + list.length];\n                else return list[index];\n            }\n            /**\r\n         * Quick test for point in triangle\r\n         */ function isPointInTriangle(point, a, b, c) {\n                const ab = b.sub(a);\n                const bc = c.sub(b);\n                const ca = a.sub(c);\n                const ap = point.sub(a);\n                const bp = point.sub(b);\n                const cp = point.sub(c);\n                const cross1 = ab.cross(ap);\n                const cross2 = bc.cross(bp);\n                const cross3 = ca.cross(cp);\n                if (cross1 > 0 || cross2 > 0 || cross3 > 0) return false;\n                return true;\n            }\n            const triangles = [];\n            const vertices = [\n                ...this.points\n            ];\n            const indices = range(0, this.points.length - 1);\n            // 1. Loop through vertices clockwise\n            //    if the vertex is convex (interior angle is < 180) (cross product positive)\n            //    if the polygon formed by it's edges doesn't contain the points\n            //         it's an ear add it to our list of triangles, and restart\n            while(indices.length > 3)for(let i = 0; i < indices.length; i++){\n                const a = indices[i];\n                const b = getItem(i - 1, indices);\n                const c = getItem(i + 1, indices);\n                const va = vertices[a];\n                const vb = vertices[b];\n                const vc = vertices[c];\n                // Check convexity\n                const leftArm = vb.sub(va);\n                const rightArm = vc.sub(va);\n                const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex\n                if (!isConvex) continue;\n                let isEar = true;\n                // Check that if any vertices are in the triangle a, b, c\n                for(let j = 0; j < indices.length; j++){\n                    const vertIndex = indices[j];\n                    // We can skip these\n                    if (vertIndex === a || vertIndex === b || vertIndex === c) continue;\n                    const point = vertices[vertIndex];\n                    if (isPointInTriangle(point, vb, va, vc)) {\n                        isEar = false;\n                        break;\n                    }\n                }\n                // Add ear to polygon list and remove from list\n                if (isEar) {\n                    triangles.push([\n                        vb,\n                        va,\n                        vc\n                    ]);\n                    indices.splice(i, 1);\n                    break;\n                }\n            }\n            triangles.push([\n                vertices[indices[0]],\n                vertices[indices[1]],\n                vertices[indices[2]]\n            ]);\n            return new CompositeCollider(triangles.map((points)=>Shape.Polygon(points)));\n        }\n        /**\r\n     * Returns a clone of this ConvexPolygon, not associated with any collider\r\n     */ clone() {\n            return new PolygonCollider({\n                offset: this.offset.clone(),\n                points: this.points.map((p)=>p.clone())\n            });\n        }\n        /**\r\n     * Returns the world position of the collider, which is the current body transform plus any defined offset\r\n     */ get worldPos() {\n            if (this._transform) return this._transform.pos.add(this.offset);\n            return this.offset;\n        }\n        /**\r\n     * Get the center of the collider in world coordinates\r\n     */ get center() {\n            return this.bounds.center;\n        }\n        /**\r\n     * Calculates the underlying transformation from the body relative space to world space\r\n     */ _calculateTransformation() {\n            const points = this.points;\n            const len = points.length;\n            this._transformedPoints.length = 0; // clear out old transform\n            for(let i = 0; i < len; i++)this._transformedPoints[i] = this._globalMatrix.multiply(points[i].clone());\n        }\n        /**\r\n     * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n     */ getTransformedPoints() {\n            if (this._transformedPointsDirty) {\n                this._calculateTransformation();\n                this._transformedPointsDirty = false;\n            }\n            return this._transformedPoints;\n        }\n        /**\r\n     * Gets the sides of the polygon in world space\r\n     */ getSides() {\n            if (this._sidesDirty) {\n                const lines = [];\n                const points = this.getTransformedPoints();\n                const len = points.length;\n                for(let i = 0; i < len; i++)// This winding is important\n                lines.push(new LineSegment(points[i], points[(i + 1) % len]));\n                this._sides = lines;\n                this._sidesDirty = false;\n            }\n            return this._sides;\n        }\n        /**\r\n     * Returns the local coordinate space sides\r\n     */ getLocalSides() {\n            if (this._localSidesDirty) {\n                const lines = [];\n                const points = this.points;\n                const len = points.length;\n                for(let i = 0; i < len; i++)// This winding is important\n                lines.push(new LineSegment(points[i], points[(i + 1) % len]));\n                this._localSides = lines;\n                this._localSidesDirty = false;\n            }\n            return this._localSides;\n        }\n        /**\r\n     * Given a direction vector find the world space side that is most in that direction\r\n     * @param direction\r\n     */ findSide(direction) {\n            const sides = this.getSides();\n            let bestSide = sides[0];\n            let maxDistance = -Number.MAX_VALUE;\n            for(let side = 0; side < sides.length; side++){\n                const currentSide = sides[side];\n                const sideNormal = currentSide.normal();\n                const mostDirection = sideNormal.dot(direction);\n                if (mostDirection > maxDistance) {\n                    bestSide = currentSide;\n                    maxDistance = mostDirection;\n                }\n            }\n            return bestSide;\n        }\n        /**\r\n     * Given a direction vector find the local space side that is most in that direction\r\n     * @param direction\r\n     */ findLocalSide(direction) {\n            const sides = this.getLocalSides();\n            let bestSide = sides[0];\n            let maxDistance = -Number.MAX_VALUE;\n            for(let side = 0; side < sides.length; side++){\n                const currentSide = sides[side];\n                const sideNormal = currentSide.normal();\n                const mostDirection = sideNormal.dot(direction);\n                if (mostDirection > maxDistance) {\n                    bestSide = currentSide;\n                    maxDistance = mostDirection;\n                }\n            }\n            return bestSide;\n        }\n        /**\r\n     * Get the axis associated with the convex polygon\r\n     */ get axes() {\n            const axes = [];\n            const sides = this.getSides();\n            for(let i = 0; i < sides.length; i++)axes.push(sides[i].normal());\n            return axes;\n        }\n        /**\r\n     * Updates the transform for the collision geometry\r\n     *\r\n     * Collision geometry (points/bounds) will not change until this is called.\r\n     * @param transform\r\n     */ update(transform) {\n            var _a;\n            this._transform = transform;\n            this._transformedPointsDirty = true;\n            this._sidesDirty = true;\n            // This change means an update must be performed in order for geometry to update\n            const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;\n            globalMat.clone(this._globalMatrix);\n            this._globalMatrix.translate(this.offset.x, this.offset.y);\n        }\n        /**\r\n     * Tests if a point is contained in this collider in world space\r\n     */ contains(point) {\n            // Always cast to the right, as long as we cast in a consistent fixed direction we\n            // will be fine\n            const testRay = new Ray(point, new Vector(1, 0));\n            const intersectCount = this.getSides().reduce(function(accum, side) {\n                if (testRay.intersect(side) >= 0) return accum + 1;\n                return accum;\n            }, 0);\n            if (intersectCount % 2 === 0) return false;\n            return true;\n        }\n        getClosestLineBetween(collider) {\n            if (collider instanceof CircleCollider) return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);\n            else if (collider instanceof PolygonCollider) return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);\n            else if (collider instanceof EdgeCollider) return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);\n            else throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\n        }\n        /**\r\n     * Returns a collision contact if the 2 colliders collide, otherwise collide will\r\n     * return null.\r\n     * @param collider\r\n     */ collide(collider) {\n            if (collider instanceof CircleCollider) return CollisionJumpTable.CollideCirclePolygon(collider, this);\n            else if (collider instanceof PolygonCollider) return CollisionJumpTable.CollidePolygonPolygon(this, collider);\n            else if (collider instanceof EdgeCollider) return CollisionJumpTable.CollidePolygonEdge(this, collider);\n            else throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\n        }\n        /**\r\n     * Find the point on the collider furthest in the direction specified\r\n     */ getFurthestPoint(direction) {\n            const pts = this.getTransformedPoints();\n            let furthestPoint = null;\n            let maxDistance = -Number.MAX_VALUE;\n            for(let i = 0; i < pts.length; i++){\n                const distance = direction.dot(pts[i]);\n                if (distance > maxDistance) {\n                    maxDistance = distance;\n                    furthestPoint = pts[i];\n                }\n            }\n            return furthestPoint;\n        }\n        /**\r\n     * Find the local point on the collider furthest in the direction specified\r\n     * @param direction\r\n     */ getFurthestLocalPoint(direction) {\n            const pts = this.points;\n            let furthestPoint = pts[0];\n            let maxDistance = -Number.MAX_VALUE;\n            for(let i = 0; i < pts.length; i++){\n                const distance = direction.dot(pts[i]);\n                if (distance > maxDistance) {\n                    maxDistance = distance;\n                    furthestPoint = pts[i];\n                }\n            }\n            return furthestPoint;\n        }\n        /**\r\n     * Finds the closes face to the point using perpendicular distance\r\n     * @param point point to test against polygon\r\n     */ getClosestFace(point) {\n            const sides = this.getSides();\n            let min = Number.POSITIVE_INFINITY;\n            let faceIndex = -1;\n            let distance = -1;\n            for(let i = 0; i < sides.length; i++){\n                const dist = sides[i].distanceToPoint(point);\n                if (dist < min) {\n                    min = dist;\n                    faceIndex = i;\n                    distance = dist;\n                }\n            }\n            if (faceIndex !== -1) return {\n                distance: sides[faceIndex].normal().scale(distance),\n                face: sides[faceIndex]\n            };\n            return null;\n        }\n        /**\r\n     * Get the axis aligned bounding box for the polygon collider in world coordinates\r\n     */ get bounds() {\n            return this.localBounds.transform(this._globalMatrix);\n        }\n        /**\r\n     * Get the axis aligned bounding box for the polygon collider in local coordinates\r\n     */ get localBounds() {\n            if (this._localBoundsDirty) {\n                this._localBounds = BoundingBox.fromPoints(this.points);\n                this._localBoundsDirty = false;\n            }\n            return this._localBounds;\n        }\n        /**\r\n     * Get the moment of inertia for an arbitrary polygon\r\n     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n     */ getInertia(mass) {\n            if (this._cachedMass === mass && this._cachedInertia) return this._cachedInertia;\n            let numerator = 0;\n            let denominator = 0;\n            const points = this.points;\n            for(let i = 0; i < points.length; i++){\n                const iplusone = (i + 1) % points.length;\n                const crossTerm = points[iplusone].cross(points[i]);\n                numerator += crossTerm * (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));\n                denominator += crossTerm;\n            }\n            this._cachedMass = mass;\n            return this._cachedInertia = mass / 6 * (numerator / denominator);\n        }\n        /**\r\n     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n     */ rayCast(ray, max = Infinity) {\n            // find the minimum contact time greater than 0\n            // contact times less than 0 are behind the ray and we don't want those\n            const sides = this.getSides();\n            const len = sides.length;\n            let minContactTime = Number.MAX_VALUE;\n            let contactIndex = -1;\n            for(let i = 0; i < len; i++){\n                const contactTime = ray.intersect(sides[i]);\n                if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\n                    minContactTime = contactTime;\n                    contactIndex = i;\n                }\n            }\n            // contact was found\n            if (contactIndex >= 0) return ray.getPoint(minContactTime);\n            // no contact found\n            return null;\n        }\n        /**\r\n     * Project the edges of the polygon along a specified axis\r\n     */ project(axis) {\n            const points = this.getTransformedPoints();\n            const len = points.length;\n            let min = Number.MAX_VALUE;\n            let max = -Number.MAX_VALUE;\n            for(let i = 0; i < len; i++){\n                const scalar = points[i].dot(axis);\n                min = Math.min(min, scalar);\n                max = Math.max(max, scalar);\n            }\n            return new Projection(min, max);\n        }\n        debug(ex, color) {\n            const firstPoint = this.getTransformedPoints()[0];\n            const points = [\n                firstPoint,\n                ...this.getTransformedPoints(),\n                firstPoint\n            ];\n            for(let i = 0; i < points.length - 1; i++){\n                ex.drawLine(points[i], points[i + 1], color, 2);\n                ex.drawCircle(points[i], 2, color);\n                ex.drawCircle(points[i + 1], 2, color);\n            }\n        }\n    }\n    /**\r\n * Excalibur helper for defining colliders quickly\r\n */ class Shape {\n        /**\r\n     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider\r\n     * @param width Width of the box\r\n     * @param height Height of the box\r\n     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position\r\n     * @param offset Optional offset relative to the collider in local coordinates\r\n     */ static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {\n            return new PolygonCollider({\n                points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),\n                offset: offset\n            });\n        }\n        /**\r\n     * Creates a new [[PolygonCollider|arbitrary polygon]] collider\r\n     *\r\n     * PolygonColliders are useful for creating convex polygon shapes\r\n     * @param points Points specified in counter clockwise\r\n     * @param offset Optional offset relative to the collider in local coordinates\r\n     */ static Polygon(points, offset = Vector.Zero) {\n            return new PolygonCollider({\n                points: points,\n                offset: offset\n            });\n        }\n        /**\r\n     * Creates a new [[CircleCollider|circle]] collider\r\n     *\r\n     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges\r\n     * @param radius Radius of the circle collider\r\n     * @param offset Optional offset relative to the collider in local coordinates\r\n     */ static Circle(radius, offset = Vector.Zero) {\n            return new CircleCollider({\n                radius: radius,\n                offset: offset\n            });\n        }\n        /**\r\n     * Creates a new [[EdgeCollider|edge]] collider\r\n     *\r\n     * Edge colliders are useful for  floors, walls, and other barriers\r\n     * @param begin Beginning of the edge in local coordinates to the collider\r\n     * @param end Ending of the edge in local coordinates to the collider\r\n     */ static Edge(begin, end) {\n            return new EdgeCollider({\n                begin: begin,\n                end: end\n            });\n        }\n        /**\r\n     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box\r\n     *\r\n     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth\r\n     * player experience.\r\n     *\r\n     * @param width\r\n     * @param height\r\n     * @param offset Optional offset\r\n     */ static Capsule(width, height, offset = Vector.Zero) {\n            const logger = Logger.getInstance();\n            if (width === height) logger.warn(\"A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider\");\n            const vertical = height >= width;\n            if (vertical) {\n                // height > width, if equal maybe use a circle\n                const capsule = new CompositeCollider([\n                    Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),\n                    Shape.Box(width, height - width, Vector.Half, offset),\n                    Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))\n                ]);\n                return capsule;\n            } else {\n                // width > height, if equal maybe use a circle\n                const capsule = new CompositeCollider([\n                    Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),\n                    Shape.Box(width - height, height, Vector.Half, offset),\n                    Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))\n                ]);\n                return capsule;\n            }\n        }\n    }\n    class ColliderComponent extends Component {\n        constructor(collider){\n            super();\n            this.type = \"ex.collider\";\n            this.events = new EventDispatcher();\n            /**\r\n         * Observable that notifies when a collider is added to the body\r\n         */ this.$colliderAdded = new Observable();\n            /**\r\n         * Observable that notifies when a collider is removed from the body\r\n         */ this.$colliderRemoved = new Observable();\n            this.set(collider);\n        }\n        /**\r\n     * Get the current collider geometry\r\n     */ get() {\n            return this._collider;\n        }\n        /**\r\n     * Set the collider geometry\r\n     * @param collider\r\n     * @returns the collider you set\r\n     */ set(collider) {\n            this.clear();\n            if (collider) {\n                this._collider = collider;\n                this._collider.owner = this.owner;\n                this.events.wire(collider.events);\n                this.$colliderAdded.notifyAll(collider);\n                this.update();\n            }\n            return collider;\n        }\n        /**\r\n     * Remove collider geometry from collider component\r\n     */ clear() {\n            if (this._collider) {\n                this.events.unwire(this._collider.events);\n                this.$colliderRemoved.notifyAll(this._collider);\n                this._collider.owner = null;\n                this._collider = null;\n            }\n        }\n        /**\r\n     * Return world space bounds\r\n     */ get bounds() {\n            var _a, _b;\n            return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();\n        }\n        /**\r\n     * Return local space bounds\r\n     */ get localBounds() {\n            var _a, _b;\n            return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();\n        }\n        /**\r\n     * Update the collider's transformed geometry\r\n     */ update() {\n            var _a;\n            const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);\n            if (this._collider) {\n                this._collider.owner = this.owner;\n                if (tx) this._collider.update(tx.get());\n            }\n        }\n        /**\r\n     * Collide component with another\r\n     * @param other\r\n     */ collide(other) {\n            let colliderA = this._collider;\n            let colliderB = other._collider;\n            if (!colliderA || !colliderB) return [];\n            // If we have a composite lefthand side :(\n            // Might bite us, but to avoid updating all the handlers make composite always left side\n            let flipped = false;\n            if (colliderB instanceof CompositeCollider) {\n                colliderA = colliderB;\n                colliderB = this._collider;\n                flipped = true;\n            }\n            if (this._collider) {\n                const contacts = colliderA.collide(colliderB);\n                if (contacts) {\n                    if (flipped) contacts.forEach((contact)=>{\n                        contact.mtv = contact.mtv.negate();\n                        contact.normal = contact.normal.negate();\n                        contact.tangent = contact.normal.perpendicular();\n                        contact.colliderA = this._collider;\n                        contact.colliderB = other._collider;\n                    });\n                    return contacts;\n                }\n                return [];\n            }\n            return [];\n        }\n        onAdd(entity) {\n            if (this._collider) this.update();\n            // Wire up the collider events to the owning entity\n            this.events.on(\"precollision\", (evt)=>{\n                const precollision = evt;\n                entity.events.emit(\"precollision\", new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));\n            });\n            this.events.on(\"postcollision\", (evt)=>{\n                const postcollision = evt;\n                entity.events.emit(\"postcollision\", new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));\n            });\n            this.events.on(\"collisionstart\", (evt)=>{\n                const start = evt;\n                entity.events.emit(\"collisionstart\", new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));\n            });\n            this.events.on(\"collisionend\", (evt)=>{\n                const end = evt;\n                entity.events.emit(\"collisionend\", new CollisionEndEvent(end.target.owner, end.other.owner));\n            });\n        }\n        onRemove() {\n            this.events.clear();\n            this.$colliderRemoved.notifyAll(this._collider);\n        }\n        /**\r\n     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.\r\n     *\r\n     * If no width/height are specified the body will attempt to use the associated actor's width/height.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */ useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {\n            const collider = Shape.Box(width, height, anchor, center);\n            return this.set(collider);\n        }\n        /**\r\n     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative\r\n     *  to the anchor of the associated actor\r\n     * of this physics body.\r\n     *\r\n     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */ usePolygonCollider(points, center = Vector.Zero) {\n            const poly = Shape.Polygon(points, center);\n            return this.set(poly);\n        }\n        /**\r\n     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */ useCircleCollider(radius, center = Vector.Zero) {\n            const collider = Shape.Circle(radius, center);\n            return this.set(collider);\n        }\n        /**\r\n     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor\r\n     * of this physics body.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */ useEdgeCollider(begin, end) {\n            const collider = Shape.Edge(begin, end);\n            return this.set(collider);\n        }\n        /**\r\n     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders\r\n     * @param colliders\r\n     */ useCompositeCollider(colliders) {\n            return this.set(new CompositeCollider(colliders));\n        }\n    }\n    var DegreeOfFreedom;\n    (function(DegreeOfFreedom) {\n        DegreeOfFreedom[\"Rotation\"] = \"rotation\";\n        DegreeOfFreedom[\"X\"] = \"x\";\n        DegreeOfFreedom[\"Y\"] = \"y\";\n    })(DegreeOfFreedom || (DegreeOfFreedom = {}));\n    /**\r\n * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of\r\n * of physics simulation.\r\n */ class BodyComponent extends Component {\n        constructor(options){\n            var _a, _b, _c;\n            super();\n            this.type = \"ex.body\";\n            this.dependencies = [\n                TransformComponent,\n                MotionComponent\n            ];\n            this.id = createId(\"body\", BodyComponent._ID++);\n            this.events = new EventDispatcher();\n            this._oldTransform = new Transform();\n            /**\r\n         * Indicates whether the old transform has been captured at least once for interpolation\r\n         * @internal\r\n         */ this.__oldTransformCaptured = false;\n            /**\r\n         * Enable or disabled the fixed update interpolation, by default interpolation is on.\r\n         */ this.enableFixedUpdateInterpolate = true;\n            /**\r\n         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]\r\n         */ this.collisionType = CollisionType.PreventCollision;\n            /**\r\n         * The collision group for the body's colliders, by default body colliders collide with everything\r\n         */ this.group = CollisionGroup.All;\n            /**\r\n         * The amount of mass the body has\r\n         */ this._mass = Physics.defaultMass;\n            /**\r\n         * Amount of \"motion\" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to \"sleep\"\r\n         */ this.sleepMotion = Physics.sleepEpsilon * 5;\n            /**\r\n         * Can this body sleep, by default bodies do not sleep\r\n         */ this.canSleep = Physics.bodiesCanSleepByDefault;\n            this._sleeping = false;\n            /**\r\n         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the\r\n         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.\r\n         */ this.bounciness = 0.2;\n            /**\r\n         * The coefficient of friction on this actor\r\n         */ this.friction = 0.99;\n            /**\r\n         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true\r\n         */ this.useGravity = true;\n            /**\r\n         * Degrees of freedom to limit\r\n         *\r\n         * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond\r\n         */ this.limitDegreeOfFreedom = [];\n            /**\r\n         * The velocity of the actor last frame (vx, vy) in pixels/second\r\n         */ this.oldVel = new Vector(0, 0);\n            /**\r\n         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n         */ this.oldAcc = Vector.Zero;\n            if (options) {\n                this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;\n                this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;\n                this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;\n            }\n        }\n        get matrix() {\n            return this.transform.get().matrix;\n        }\n        get mass() {\n            return this._mass;\n        }\n        set mass(newMass) {\n            this._mass = newMass;\n            this._cachedInertia = undefined;\n            this._cachedInverseInertia = undefined;\n        }\n        /**\r\n     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n     */ get inverseMass() {\n            return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;\n        }\n        /**\r\n     * Whether this body is sleeping or not\r\n     */ get sleeping() {\n            return this._sleeping;\n        }\n        /**\r\n     * Set the sleep state of the body\r\n     * @param sleeping\r\n     */ setSleeping(sleeping) {\n            this._sleeping = sleeping;\n            if (!sleeping) // Give it a kick to keep it from falling asleep immediately\n            this.sleepMotion = Physics.sleepEpsilon * 5;\n            else {\n                this.vel = Vector.Zero;\n                this.acc = Vector.Zero;\n                this.angularVelocity = 0;\n                this.sleepMotion = 0;\n            }\n        }\n        /**\r\n     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping\r\n     */ updateMotion() {\n            if (this._sleeping) this.setSleeping(true);\n            const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);\n            const bias = Physics.sleepBias;\n            this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;\n            this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);\n            if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) this.setSleeping(true);\n        }\n        /**\r\n     * Get the moment of inertia from the [[ColliderComponent]]\r\n     */ get inertia() {\n            if (this._cachedInertia) return this._cachedInertia;\n            // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?\n            const collider = this.owner.get(ColliderComponent);\n            if (collider) {\n                collider.$colliderAdded.subscribe(()=>{\n                    this._cachedInertia = null;\n                });\n                collider.$colliderRemoved.subscribe(()=>{\n                    this._cachedInertia = null;\n                });\n                const maybeCollider = collider.get();\n                if (maybeCollider) return this._cachedInertia = maybeCollider.getInertia(this.mass);\n            }\n            return 0;\n        }\n        /**\r\n     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n     */ get inverseInertia() {\n            if (this._cachedInverseInertia) return this._cachedInverseInertia;\n            return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;\n        }\n        /**\r\n     * Returns if the owner is active\r\n     */ get active() {\n            var _a;\n            return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);\n        }\n        /**\r\n     * @deprecated Use globalP0s\r\n     */ get center() {\n            return this.globalPos;\n        }\n        get transform() {\n            var _a;\n            return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);\n        }\n        get motion() {\n            var _a;\n            return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);\n        }\n        get pos() {\n            return this.transform.pos;\n        }\n        set pos(val) {\n            this.transform.pos = val;\n        }\n        /**\r\n     * The (x, y) position of the actor this will be in the middle of the actor if the\r\n     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n     */ get globalPos() {\n            return this.transform.globalPos;\n        }\n        set globalPos(val) {\n            this.transform.globalPos = val;\n        }\n        /**\r\n     * The position of the actor last frame (x, y) in pixels\r\n     */ get oldPos() {\n            return this._oldTransform.pos;\n        }\n        /**\r\n     * The current velocity vector (vx, vy) of the actor in pixels/second\r\n     */ get vel() {\n            return this.motion.vel;\n        }\n        set vel(val) {\n            this.motion.vel = val;\n        }\n        /**\r\n     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n     * be useful to simulate a gravitational effect.\r\n     */ get acc() {\n            return this.motion.acc;\n        }\n        set acc(val) {\n            this.motion.acc = val;\n        }\n        /**\r\n     * The current torque applied to the actor\r\n     */ get torque() {\n            return this.motion.torque;\n        }\n        set torque(val) {\n            this.motion.torque = val;\n        }\n        /**\r\n     * Gets/sets the rotation of the body from the last frame.\r\n     */ get oldRotation() {\n            return this._oldTransform.rotation;\n        }\n        /**\r\n     * The rotation of the body in radians\r\n     */ get rotation() {\n            return this.transform.globalRotation;\n        }\n        set rotation(val) {\n            this.transform.globalRotation = val;\n        }\n        /**\r\n     * The scale vector of the actor\r\n     */ get scale() {\n            return this.transform.globalScale;\n        }\n        set scale(val) {\n            this.transform.globalScale = val;\n        }\n        /**\r\n     * The scale of the actor last frame\r\n     */ get oldScale() {\n            return this._oldTransform.scale;\n        }\n        /**\r\n     * The scale rate of change of the actor in scale/second\r\n     */ get scaleFactor() {\n            return this.motion.scaleFactor;\n        }\n        set scaleFactor(scaleFactor) {\n            this.motion.scaleFactor = scaleFactor;\n        }\n        /**\r\n     * Get the angular velocity in radians/second\r\n     */ get angularVelocity() {\n            return this.motion.angularVelocity;\n        }\n        /**\r\n     * Set the angular velocity in radians/second\r\n     */ set angularVelocity(value) {\n            this.motion.angularVelocity = value;\n        }\n        /**\r\n     * Apply a specific impulse to the body\r\n     * @param point\r\n     * @param impulse\r\n     */ applyImpulse(point, impulse) {\n            if (this.collisionType !== CollisionType.Active) return; // only active objects participate in the simulation\n            const finalImpulse = impulse.scale(this.inverseMass);\n            if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) finalImpulse.x = 0;\n            if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) finalImpulse.y = 0;\n            this.vel.addEqual(finalImpulse);\n            if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\n                const distanceFromCenter = point.sub(this.globalPos);\n                this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\n            }\n        }\n        /**\r\n     * Apply only linear impulse to the body\r\n     * @param impulse\r\n     */ applyLinearImpulse(impulse) {\n            if (this.collisionType !== CollisionType.Active) return; // only active objects participate in the simulation\n            const finalImpulse = impulse.scale(this.inverseMass);\n            if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) finalImpulse.x = 0;\n            if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) finalImpulse.y = 0;\n            this.vel = this.vel.add(finalImpulse);\n        }\n        /**\r\n     * Apply only angular impulse to the body\r\n     * @param point\r\n     * @param impulse\r\n     */ applyAngularImpulse(point, impulse) {\n            if (this.collisionType !== CollisionType.Active) return; // only active objects participate in the simulation\n            if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\n                const distanceFromCenter = point.sub(this.globalPos);\n                this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\n            }\n        }\n        /**\r\n     * Sets the old versions of pos, vel, acc, and scale.\r\n     */ captureOldTransform() {\n            // Capture old values before integration step updates them\n            this.__oldTransformCaptured = true;\n            this.transform.get().clone(this._oldTransform);\n            this.oldVel.setTo(this.vel.x, this.vel.y);\n            this.oldAcc.setTo(this.acc.x, this.acc.y);\n        }\n    }\n    BodyComponent._ID = 0;\n    /**\r\n * AddedComponent message\r\n */ class AddedComponent {\n        constructor(data){\n            this.data = data;\n            this.type = \"Component Added\";\n        }\n    }\n    /**\r\n * Type guard to know if message is f an Added Component\r\n */ function isAddedComponent(x) {\n        return !!x && x.type === \"Component Added\";\n    }\n    /**\r\n * RemovedComponent message\r\n */ class RemovedComponent {\n        constructor(data){\n            this.data = data;\n            this.type = \"Component Removed\";\n        }\n    }\n    /**\r\n * Type guard to know if message is for a Removed Component\r\n */ function isRemovedComponent(x) {\n        return !!x && x.type === \"Component Removed\";\n    }\n    /**\r\n * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system\r\n *\r\n * Entities can be strongly typed with the components they contain\r\n *\r\n * ```typescript\r\n * const entity = new Entity<ComponentA | ComponentB>();\r\n * entity.components.a; // Type ComponentA\r\n * entity.components.b; // Type ComponentB\r\n * ```\r\n */ class Entity extends Class {\n        constructor(components, name){\n            super();\n            /**\r\n         * The unique identifier for the entity\r\n         */ this.id = Entity._ID++;\n            this._name = \"anonymous\";\n            /**\r\n         * Whether this entity is active, if set to false it will be reclaimed\r\n         */ this.active = true;\n            /**\r\n         * Bucket to hold on to deferred removals\r\n         */ this._componentsToRemove = [];\n            this._componentTypeToInstance = new Map();\n            this._componentStringToInstance = new Map();\n            this._tagsMemo = [];\n            this._typesMemo = [];\n            /**\r\n         * Observable that keeps track of component add or remove changes on the entity\r\n         */ this.componentAdded$ = new Observable();\n            this.componentRemoved$ = new Observable();\n            this._parent = null;\n            this.childrenAdded$ = new Observable();\n            this.childrenRemoved$ = new Observable();\n            this._children = [];\n            this._isInitialized = false;\n            this._setName(name);\n            if (components) for (const component of components)this.addComponent(component);\n        }\n        _setName(name) {\n            if (name) this._name = name;\n        }\n        get name() {\n            return this._name;\n        }\n        get events() {\n            return this.eventDispatcher;\n        }\n        /**\r\n     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.\r\n     */ kill() {\n            this.active = false;\n        }\n        isKilled() {\n            return !this.active;\n        }\n        /**\r\n     * Specifically get the tags on the entity from [[TagComponent]]\r\n     */ get tags() {\n            return this._tagsMemo;\n        }\n        /**\r\n     * Check if a tag exists on the entity\r\n     * @param tag name to check for\r\n     */ hasTag(tag) {\n            return this.tags.includes(tag);\n        }\n        /**\r\n     * Adds a tag to an entity\r\n     * @param tag\r\n     * @returns Entity\r\n     */ addTag(tag) {\n            return this.addComponent(new TagComponent(tag));\n        }\n        /**\r\n     * Removes a tag on the entity\r\n     *\r\n     * Removals are deferred until the end of update\r\n     * @param tag\r\n     * @param force Remove component immediately, no deferred\r\n     */ removeTag(tag, force = false) {\n            return this.removeComponent(tag, force);\n        }\n        /**\r\n     * The types of the components on the Entity\r\n     */ get types() {\n            return this._typesMemo;\n        }\n        _rebuildMemos() {\n            this._tagsMemo = Array.from(this._componentStringToInstance.values()).filter((c)=>c instanceof TagComponent).map((c)=>c.type);\n            this._typesMemo = Array.from(this._componentStringToInstance.keys());\n        }\n        getComponents() {\n            return Array.from(this._componentStringToInstance.values());\n        }\n        _notifyAddComponent(component) {\n            this._rebuildMemos();\n            const added = new AddedComponent({\n                component: component,\n                entity: this\n            });\n            this.componentAdded$.notifyAll(added);\n        }\n        _notifyRemoveComponent(component) {\n            const removed = new RemovedComponent({\n                component: component,\n                entity: this\n            });\n            this.componentRemoved$.notifyAll(removed);\n            this._rebuildMemos();\n        }\n        get parent() {\n            return this._parent;\n        }\n        /**\r\n     * Get the direct children of this entity\r\n     */ get children() {\n            return this._children;\n        }\n        /**\r\n     * Unparents this entity, if there is a parent. Otherwise it does nothing.\r\n     */ unparent() {\n            if (this._parent) {\n                this._parent.removeChild(this);\n                this._parent = null;\n            }\n        }\n        /**\r\n     * Adds an entity to be a child of this entity\r\n     * @param entity\r\n     */ addChild(entity) {\n            if (entity.parent === null) {\n                if (this.getAncestors().includes(entity)) throw new Error(\"Cycle detected, cannot add entity\");\n                this._children.push(entity);\n                entity._parent = this;\n                this.childrenAdded$.notifyAll(entity);\n            } else throw new Error(\"Entity already has a parent, cannot add without unparenting\");\n            return this;\n        }\n        /**\r\n     * Remove an entity from children if it exists\r\n     * @param entity\r\n     */ removeChild(entity) {\n            if (entity.parent === this) {\n                removeItemFromArray(entity, this._children);\n                entity._parent = null;\n                this.childrenRemoved$.notifyAll(entity);\n            }\n            return this;\n        }\n        /**\r\n     * Removes all children from this entity\r\n     */ removeAllChildren() {\n            this.children.forEach((c)=>{\n                this.removeChild(c);\n            });\n            return this;\n        }\n        /**\r\n     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.\r\n     */ getAncestors() {\n            const result = [\n                this\n            ];\n            let current = this.parent;\n            while(current){\n                result.push(current);\n                current = current.parent;\n            }\n            return result.reverse();\n        }\n        /**\r\n     * Returns a list of all the entities that descend from this entity. Includes the current entity.\r\n     */ getDescendants() {\n            let result = [\n                this\n            ];\n            let queue = [\n                this\n            ];\n            while(queue.length > 0){\n                const curr = queue.pop();\n                queue = queue.concat(curr.children);\n                result = result.concat(curr.children);\n            }\n            return result;\n        }\n        /**\r\n     * Creates a deep copy of the entity and a copy of all its components\r\n     */ clone() {\n            const newEntity = new Entity();\n            for (const c of this.types)newEntity.addComponent(this.get(c).clone());\n            for (const child of this.children)newEntity.addChild(child.clone());\n            return newEntity;\n        }\n        /**\r\n     * Adds a copy of all the components from another template entity as a \"prefab\"\r\n     * @param templateEntity Entity to use as a template\r\n     * @param force Force component replacement if it already exists on the target entity\r\n     */ addTemplate(templateEntity, force = false) {\n            for (const c of templateEntity.getComponents())this.addComponent(c.clone(), force);\n            for (const child of templateEntity.children)this.addChild(child.clone().addTemplate(child));\n            return this;\n        }\n        /**\r\n     * Adds a component to the entity\r\n     * @param component Component or Entity to add copy of components from\r\n     * @param force Optionally overwrite any existing components of the same type\r\n     */ addComponent(component, force = false) {\n            // if component already exists, skip if not forced\n            if (this.has(component.type)) {\n                if (force) // Remove existing component type if exists when forced\n                this.removeComponent(component);\n                else // early exit component exits\n                return this;\n            }\n            // TODO circular dependencies will be a problem\n            if (component.dependencies && component.dependencies.length) for (const ctor of component.dependencies)this.addComponent(new ctor());\n            component.owner = this;\n            const constuctorType = component.constructor;\n            this._componentTypeToInstance.set(constuctorType, component);\n            this._componentStringToInstance.set(component.type, component);\n            if (component.onAdd) component.onAdd(this);\n            this._notifyAddComponent(component);\n            return this;\n        }\n        /**\r\n     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues\r\n     *\r\n     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately\r\n     * @param componentOrType\r\n     * @param force\r\n     */ removeComponent(componentOrType, force = false) {\n            if (force) {\n                if (typeof componentOrType === \"string\") this._removeComponentByType(componentOrType);\n                else if (componentOrType instanceof Component) this._removeComponentByType(componentOrType.type);\n            } else this._componentsToRemove.push(componentOrType);\n            return this;\n        }\n        _removeComponentByType(type) {\n            if (this.has(type)) {\n                const component = this.get(type);\n                component.owner = null;\n                if (component.onRemove) component.onRemove(this);\n                const ctor = component.constructor;\n                this._componentTypeToInstance.delete(ctor);\n                this._componentStringToInstance.delete(component.type);\n                this._notifyRemoveComponent(component);\n            }\n        }\n        /**\r\n     * @hidden\r\n     * @internal\r\n     */ processComponentRemoval() {\n            for (const componentOrType of this._componentsToRemove){\n                const type = typeof componentOrType === \"string\" ? componentOrType : componentOrType.type;\n                this._removeComponentByType(type);\n            }\n            this._componentsToRemove.length = 0;\n        }\n        has(type) {\n            if (typeof type === \"string\") return this._componentStringToInstance.has(type);\n            else return this._componentTypeToInstance.has(type);\n        }\n        get(type) {\n            if (typeof type === \"string\") return this._componentStringToInstance.get(type);\n            else return this._componentTypeToInstance.get(type);\n        }\n        /**\r\n     * Gets whether the actor is Initialized\r\n     */ get isInitialized() {\n            return this._isInitialized;\n        }\n        /**\r\n     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.\r\n     *\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * @internal\r\n     */ _initialize(engine) {\n            if (!this.isInitialized) {\n                this.onInitialize(engine);\n                super.emit(\"initialize\", new InitializeEvent(engine, this));\n                this._isInitialized = true;\n            }\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */ _preupdate(engine, delta) {\n            this.emit(\"preupdate\", new PreUpdateEvent(engine, delta, this));\n            this.onPreUpdate(engine, delta);\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */ _postupdate(engine, delta) {\n            this.emit(\"postupdate\", new PostUpdateEvent(engine, delta, this));\n            this.onPostUpdate(engine, delta);\n        }\n        /**\r\n     * `onInitialize` is called before the first update of the entity. This method is meant to be\r\n     * overridden.\r\n     *\r\n     * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n     */ onInitialize(_engine) {\n        // Override me\n        }\n        /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before an entity is updated.\r\n     */ onPreUpdate(_engine, _delta) {\n        // Override me\n        }\n        /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after an entity is updated.\r\n     */ onPostUpdate(_engine, _delta) {\n        // Override me\n        }\n        /**\r\n     *\r\n     * Entity update lifecycle, called internally\r\n     *\r\n     * @internal\r\n     * @param engine\r\n     * @param delta\r\n     */ update(engine, delta) {\n            this._initialize(engine);\n            this._preupdate(engine, delta);\n            for (const child of this.children)child.update(engine, delta);\n            this._postupdate(engine, delta);\n        }\n    }\n    Entity._ID = 0;\n    /**\r\n * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)\r\n * @param graphic\r\n */ function hasGraphicsTick(graphic) {\n        return !!graphic.tick;\n    }\n    class GraphicsLayer {\n        constructor(_options, _graphics){\n            this._options = _options;\n            this._graphics = _graphics;\n            this.graphics = [];\n        }\n        get name() {\n            return this._options.name;\n        }\n        hide(nameOrGraphic) {\n            if (!nameOrGraphic) this.graphics.length = 0;\n            else {\n                let gfx = null;\n                if (nameOrGraphic instanceof Graphic) gfx = nameOrGraphic;\n                else gfx = this._graphics.getGraphic(nameOrGraphic);\n                this.graphics = this.graphics.filter((g)=>g.graphic !== gfx);\n                this._graphics.recalculateBounds();\n            }\n        }\n        /**\r\n     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.\r\n     *\r\n     * If `show()` is called multiple times for the same graphic it will be shown multiple times.\r\n     * @param nameOrGraphic\r\n     * @param options\r\n     */ show(nameOrGraphic, options) {\n            options = {\n                ...options\n            };\n            let gfx;\n            if (nameOrGraphic instanceof Graphic) gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;\n            else {\n                gfx = this._graphics.getGraphic(nameOrGraphic);\n                if (!gfx) Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());\n            }\n            if (gfx) {\n                this.graphics.push({\n                    graphic: gfx,\n                    options: options\n                });\n                this._graphics.recalculateBounds();\n                return gfx;\n            } else return null;\n        }\n        /**\r\n     * Use a specific graphic, swap out any current graphics being shown\r\n     * @param nameOrGraphic\r\n     * @param options\r\n     */ use(nameOrGraphic, options) {\n            options = {\n                ...options\n            };\n            this.hide();\n            return this.show(nameOrGraphic, options);\n        }\n        /**\r\n     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n     *\r\n     * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n     */ get order() {\n            return this._options.order;\n        }\n        /**\r\n     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n     *\r\n     * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n     */ set order(order) {\n            this._options.order = order;\n        }\n        /**\r\n     * Get or set the pixel offset from the layer anchor for all graphics in the layer\r\n     */ get offset() {\n            var _a;\n            return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;\n        }\n        set offset(value) {\n            this._options.offset = value;\n        }\n        get currentKeys() {\n            var _a;\n            return (_a = this.name) !== null && _a !== void 0 ? _a : \"anonymous\";\n        }\n    }\n    class GraphicsLayers {\n        constructor(_component){\n            this._component = _component;\n            this._layers = [];\n            this._layerMap = {};\n            this.default = new GraphicsLayer({\n                name: \"default\",\n                order: 0\n            }, _component);\n            this._maybeAddLayer(this.default);\n        }\n        create(options) {\n            const layer = new GraphicsLayer(options, this._component);\n            return this._maybeAddLayer(layer);\n        }\n        get(name) {\n            if (name) return this._getLayer(name);\n            return this._layers;\n        }\n        currentKeys() {\n            const graphicsLayerKeys = [];\n            for (const layer of this._layers)graphicsLayerKeys.push(layer.currentKeys);\n            return graphicsLayerKeys;\n        }\n        has(name) {\n            return name in this._layerMap;\n        }\n        _maybeAddLayer(layer) {\n            if (this._layerMap[layer.name]) // todo log warning\n            return this._layerMap[layer.name];\n            this._layerMap[layer.name] = layer;\n            this._layers.push(layer);\n            this._layers.sort((a, b)=>a.order - b.order);\n            return layer;\n        }\n        _getLayer(name) {\n            return this._layerMap[name];\n        }\n    }\n    /**\r\n * Component to manage drawings, using with the position component\r\n */ class GraphicsComponent extends Component {\n        constructor(options){\n            super();\n            this.type = \"ex.graphics\";\n            this._graphics = {};\n            /**\r\n         * Sets or gets wether any drawing should be visible in this component\r\n         */ this.visible = true;\n            /**\r\n         * Sets or gets wither all drawings should have an opacity applied\r\n         */ this.opacity = 1;\n            /**\r\n         * Offset to apply to graphics by default\r\n         */ this.offset = Vector.Zero;\n            /**\r\n         * Anchor to apply to graphics by default\r\n         */ this.anchor = Vector.Half;\n            /**\r\n         * If set to true graphics added to the component will be copied. This can affect performance\r\n         */ this.copyGraphics = false;\n            this._localBounds = null;\n            // Defaults\n            options = {\n                visible: this.visible,\n                ...options\n            };\n            const { current: current , anchor: anchor , opacity: opacity , visible: visible , graphics: graphics , offset: offset , copyGraphics: copyGraphics , onPreDraw: onPreDraw , onPostDraw: onPostDraw  } = options;\n            this._graphics = graphics || {};\n            this.offset = offset !== null && offset !== void 0 ? offset : this.offset;\n            this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;\n            this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;\n            this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;\n            this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;\n            this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;\n            this.visible = !!visible;\n            this.layers = new GraphicsLayers(this);\n            if (current && this._graphics[current]) this.show(this._graphics[current]);\n        }\n        getGraphic(name) {\n            return this._graphics[name];\n        }\n        /**\r\n     * Get registered graphics names\r\n     */ getNames() {\n            return Object.keys(this._graphics);\n        }\n        /**\r\n     * Returns the currently displayed graphics and their offsets, empty array if hidden\r\n     */ get current() {\n            return this.layers.default.graphics;\n        }\n        /**\r\n     * Returns all graphics associated with this component\r\n     */ get graphics() {\n            return this._graphics;\n        }\n        add(nameOrGraphic, graphic) {\n            let name = \"default\";\n            let graphicToSet = null;\n            if (typeof nameOrGraphic === \"string\") {\n                name = nameOrGraphic;\n                graphicToSet = graphic;\n            } else graphicToSet = nameOrGraphic;\n            this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;\n            if (name === \"default\") this.show(\"default\");\n            return graphicToSet;\n        }\n        /**\r\n     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]\r\n     */ show(nameOrGraphic, options) {\n            const result = this.layers.default.show(nameOrGraphic, options);\n            this.recalculateBounds();\n            return result;\n        }\n        /**\r\n     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]\r\n     * @param nameOrGraphic\r\n     * @param options\r\n     */ use(nameOrGraphic, options) {\n            const result = this.layers.default.use(nameOrGraphic, options);\n            this.recalculateBounds();\n            return result;\n        }\n        hide(nameOrGraphic) {\n            this.layers.default.hide(nameOrGraphic);\n        }\n        set localBounds(bounds) {\n            this._localBounds = bounds;\n        }\n        recalculateBounds() {\n            let bb = new BoundingBox();\n            for (const layer of this.layers.get())for (const { graphic: graphic , options: options  } of layer.graphics){\n                let anchor = this.anchor;\n                let offset = this.offset;\n                if (options === null || options === void 0 ? void 0 : options.anchor) anchor = options.anchor;\n                if (options === null || options === void 0 ? void 0 : options.offset) offset = options.offset;\n                const bounds = graphic.localBounds;\n                const offsetX = -bounds.width * anchor.x + offset.x;\n                const offsetY = -bounds.height * anchor.y + offset.y;\n                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);\n            }\n            this._localBounds = bb;\n        }\n        get localBounds() {\n            if (!this._localBounds || this._localBounds.hasZeroDimensions()) this.recalculateBounds();\n            return this._localBounds;\n        }\n        /**\r\n     * Update underlying graphics if necesary, called internally\r\n     * @param elapsed\r\n     * @internal\r\n     */ update(elapsed, idempotencyToken = 0) {\n            for (const layer of this.layers.get()){\n                for (const { graphic: graphic  } of layer.graphics)if (hasGraphicsTick(graphic)) graphic === null || graphic === void 0 || graphic.tick(elapsed, idempotencyToken);\n            }\n        }\n    }\n    /**\r\n * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]\r\n */ class Rectangle extends Raster {\n        constructor(options){\n            super(options);\n            this.width = options.width;\n            this.height = options.height;\n            this.rasterize();\n        }\n        clone() {\n            return new Rectangle({\n                width: this.width,\n                height: this.height,\n                ...this.cloneGraphicOptions(),\n                ...this.cloneRasterOptions()\n            });\n        }\n        execute(ctx) {\n            if (this.color) ctx.fillRect(0, 0, this.width, this.height);\n            if (this.strokeColor) ctx.strokeRect(0, 0, this.width, this.height);\n        }\n    }\n    /**\r\n * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Circles default to [[ImageFiltering.Blended]]\r\n */ class Circle extends Raster {\n        constructor(options){\n            var _a, _b;\n            super(options);\n            this._radius = 0;\n            this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice\n            this.radius = options.radius;\n            this.filtering = (_b = options.filtering) !== null && _b !== void 0 ? _b : ImageFiltering.Blended;\n            this.rasterize();\n        }\n        get radius() {\n            return this._radius;\n        }\n        set radius(value) {\n            this._radius = value;\n            this.width = this._radius * 2;\n            this.height = this._radius * 2;\n            this.flagDirty();\n        }\n        clone() {\n            return new Circle({\n                radius: this.radius,\n                ...this.cloneGraphicOptions(),\n                ...this.cloneRasterOptions()\n            });\n        }\n        execute(ctx) {\n            if (this.radius > 0) {\n                ctx.beginPath();\n                ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);\n                if (this.color) ctx.fill();\n                if (this.strokeColor) ctx.stroke();\n            }\n        }\n    }\n    /**\r\n * Add this component to optionally configure how the pointer\r\n * system detects pointer events.\r\n *\r\n * By default the collider shape is used and graphics bounds is not.\r\n *\r\n * If both collider shape and graphics bounds are enabled it will fire events if either or\r\n * are intersecting the pointer.\r\n */ class PointerComponent extends Component {\n        constructor(){\n            super(...arguments);\n            this.type = \"ex.pointer\";\n            /**\r\n         * Use any existing Collider component geometry for pointer events. This is useful if you want\r\n         * user pointer events only to trigger on the same collision geometry used in the collider component\r\n         * for collision resolution. Default is `true`.\r\n         */ this.useColliderShape = true;\n            /**\r\n         * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned\r\n         * bounds around the graphic to trigger pointer events. Default is `false`.\r\n         */ this.useGraphicsBounds = false;\n        }\n    }\n    /**\r\n * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\r\n * Given a time, the function will return a value from positive startValue to positive endValue.\r\n *\r\n * ```js\r\n * function Linear (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInQuad (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutQuad (t) {\r\n *    return t * (2 - t);\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutQuad (t) {\r\n *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInCubic (t) {\r\n *    return t * t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutCubic (t) {\r\n *    return (--t) * t * t + 1;\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutCubic (t) {\r\n *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n * }\r\n * ```\r\n */ class EasingFunctions {\n        static CreateReversibleEasingFunction(easing) {\n            return (time, start, end, duration)=>{\n                if (end < start) return start - (easing(time, end, start, duration) - end);\n                else return easing(time, start, end, duration);\n            };\n        }\n        static CreateVectorEasingFunction(easing) {\n            return (time, start, end, duration)=>{\n                return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));\n            };\n        }\n    }\n    EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        return endValue * currentTime / duration + startValue;\n    });\n    EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        currentTime /= duration;\n        return endValue * currentTime * currentTime + startValue;\n    });\n    EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        currentTime /= duration;\n        return -endValue * currentTime * (currentTime - 2) + startValue;\n    });\n    EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        currentTime /= duration / 2;\n        if (currentTime < 1) return endValue / 2 * currentTime * currentTime + startValue;\n        currentTime--;\n        return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;\n    });\n    EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        currentTime /= duration;\n        return endValue * currentTime * currentTime * currentTime + startValue;\n    });\n    EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        currentTime /= duration;\n        currentTime--;\n        return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\n    });\n    EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration)=>{\n        endValue = endValue - startValue;\n        currentTime /= duration / 2;\n        if (currentTime < 1) return endValue / 2 * currentTime * currentTime * currentTime + startValue;\n        currentTime -= 2;\n        return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;\n    });\n    /**\r\n * Action Queues represent an ordered sequence of actions\r\n *\r\n * Action queues are part of the [[ActionContext|Action API]] and\r\n * store the list of actions to be executed for an [[Actor]].\r\n *\r\n * Actors implement [[Actor.actions]] which can be manipulated by\r\n * advanced users to adjust the actions currently being executed in the\r\n * queue.\r\n */ class ActionQueue {\n        constructor(entity){\n            this._actions = [];\n            this._completedActions = [];\n            this._entity = entity;\n        }\n        /**\r\n     * Add an action to the sequence\r\n     * @param action\r\n     */ add(action) {\n            this._actions.push(action);\n        }\n        /**\r\n     * Remove an action by reference from the sequence\r\n     * @param action\r\n     */ remove(action) {\n            const index = this._actions.indexOf(action);\n            this._actions.splice(index, 1);\n        }\n        /**\r\n     * Removes all actions from this sequence\r\n     */ clearActions() {\n            this._actions.length = 0;\n            this._completedActions.length = 0;\n            if (this._currentAction) this._currentAction.stop();\n        }\n        /**\r\n     *\r\n     * @returns The total list of actions in this sequence complete or not\r\n     */ getActions() {\n            return this._actions.concat(this._completedActions);\n        }\n        /**\r\n     *\r\n     * @returns `true` if there are more actions to process in the sequence\r\n     */ hasNext() {\n            return this._actions.length > 0;\n        }\n        /**\r\n     * @returns `true` if the current sequence of actions is done\r\n     */ isComplete() {\n            return this._actions.length === 0;\n        }\n        /**\r\n     * Resets the sequence of actions, this is used to restart a sequence from the beginning\r\n     */ reset() {\n            this._actions = this.getActions();\n            const len = this._actions.length;\n            for(let i = 0; i < len; i++)this._actions[i].reset();\n            this._completedActions = [];\n        }\n        /**\r\n     * Update the queue which updates actions and handles completing actions\r\n     * @param elapsedMs\r\n     */ update(elapsedMs) {\n            if (this._actions.length > 0) {\n                this._currentAction = this._actions[0];\n                this._currentAction.update(elapsedMs);\n                if (this._currentAction.isComplete(this._entity)) this._completedActions.push(this._actions.shift());\n            }\n        }\n    }\n    class Repeat {\n        constructor(entity, repeatBuilder, repeat){\n            this._stopped = false;\n            this._repeatBuilder = repeatBuilder;\n            this._repeatContext = new ActionContext(entity);\n            this._actionQueue = this._repeatContext.getQueue();\n            this._repeat = repeat;\n            this._originalRepeat = repeat;\n            this._repeatBuilder(this._repeatContext);\n            this._repeat--; // current execution is the first repeat\n        }\n        update(delta) {\n            if (this._actionQueue.isComplete()) {\n                this._actionQueue.clearActions();\n                this._repeatBuilder(this._repeatContext);\n                this._repeat--;\n            }\n            this._actionQueue.update(delta);\n        }\n        isComplete() {\n            return this._stopped || this._repeat <= 0 && this._actionQueue.isComplete();\n        }\n        stop() {\n            this._stopped = true;\n        }\n        reset() {\n            this._repeat = this._originalRepeat;\n        }\n    }\n    /**\r\n * RepeatForever Action implementation, it is recommended you use the fluent action\r\n * context API.\r\n *\r\n *\r\n */ class RepeatForever {\n        constructor(entity, repeatBuilder){\n            this._stopped = false;\n            this._repeatBuilder = repeatBuilder;\n            this._repeatContext = new ActionContext(entity);\n            this._actionQueue = this._repeatContext.getQueue();\n            this._repeatBuilder(this._repeatContext);\n        }\n        update(delta) {\n            if (this._stopped) return;\n            if (this._actionQueue.isComplete()) {\n                this._actionQueue.clearActions();\n                this._repeatBuilder(this._repeatContext);\n            }\n            this._actionQueue.update(delta);\n        }\n        isComplete() {\n            return this._stopped;\n        }\n        stop() {\n            this._stopped = true;\n            this._actionQueue.clearActions();\n        }\n        reset() {\n            return;\n        }\n    }\n    class MoveBy {\n        constructor(entity, offsetX, offsetY, speed){\n            this._started = false;\n            this._stopped = false;\n            this._entity = entity;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._speed = speed;\n            this._offset = new Vector(offsetX, offsetY);\n            if (speed <= 0) {\n                Logger.getInstance().error(\"Attempted to moveBy with speed less than or equal to zero : \" + speed);\n                throw new Error(\"Speed must be greater than 0 pixels per second\");\n            }\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\n                this._end = this._start.add(this._offset);\n                this._distance = this._offset.size;\n                this._dir = this._end.sub(this._start).normalize();\n            }\n            if (this.isComplete(this._entity)) {\n                this._tx.pos = vec(this._end.x, this._end.y);\n                this._motion.vel = vec(0, 0);\n            } else this._motion.vel = this._dir.scale(this._speed);\n        }\n        isComplete(entity) {\n            const tx = entity.get(TransformComponent);\n            return this._stopped || tx.pos.distance(this._start) >= this._distance;\n        }\n        stop() {\n            this._motion.vel = vec(0, 0);\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class MoveTo {\n        constructor(entity, destx, desty, speed){\n            this.entity = entity;\n            this._started = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._end = new Vector(destx, desty);\n            this._speed = speed;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\n                this._distance = this._start.distance(this._end);\n                this._dir = this._end.sub(this._start).normalize();\n            }\n            const m = this._dir.scale(this._speed);\n            this._motion.vel = vec(m.x, m.y);\n            if (this.isComplete(this.entity)) {\n                this._tx.pos = vec(this._end.x, this._end.y);\n                this._motion.vel = vec(0, 0);\n            }\n        }\n        isComplete(entity) {\n            const tx = entity.get(TransformComponent);\n            return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;\n        }\n        stop() {\n            this._motion.vel = vec(0, 0);\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    /**\r\n * An enum that describes the strategies that rotation actions can use\r\n */ var RotationType;\n    (function(RotationType) {\n        /**\r\n     * Rotation via `ShortestPath` will use the smallest angle\r\n     * between the starting and ending points. This strategy is the default behavior.\r\n     */ RotationType[RotationType[\"ShortestPath\"] = 0] = \"ShortestPath\";\n        /**\r\n     * Rotation via `LongestPath` will use the largest angle\r\n     * between the starting and ending points.\r\n     */ RotationType[RotationType[\"LongestPath\"] = 1] = \"LongestPath\";\n        /**\r\n     * Rotation via `Clockwise` will travel in a clockwise direction,\r\n     * regardless of the starting and ending points.\r\n     */ RotationType[RotationType[\"Clockwise\"] = 2] = \"Clockwise\";\n        /**\r\n     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n     * regardless of the starting and ending points.\r\n     */ RotationType[RotationType[\"CounterClockwise\"] = 3] = \"CounterClockwise\";\n    })(RotationType || (RotationType = {}));\n    class RotateTo {\n        constructor(entity, angleRadians, speed, rotationType){\n            this._started = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._end = angleRadians;\n            this._speed = speed;\n            this._rotationType = rotationType || RotationType.ShortestPath;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._start = this._tx.rotation;\n                this._currentNonCannonAngle = this._tx.rotation;\n                const distance1 = Math.abs(this._end - this._start);\n                const distance2 = TwoPI - distance1;\n                if (distance1 > distance2) {\n                    this._shortDistance = distance2;\n                    this._longDistance = distance1;\n                } else {\n                    this._shortDistance = distance1;\n                    this._longDistance = distance2;\n                }\n                this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\n                switch(this._rotationType){\n                    case RotationType.ShortestPath:\n                        this._distance = this._shortDistance;\n                        if (this._shortestPathIsPositive) this._direction = 1;\n                        else this._direction = -1;\n                        break;\n                    case RotationType.LongestPath:\n                        this._distance = this._longDistance;\n                        if (this._shortestPathIsPositive) this._direction = -1;\n                        else this._direction = 1;\n                        break;\n                    case RotationType.Clockwise:\n                        this._direction = 1;\n                        if (this._shortestPathIsPositive) this._distance = this._shortDistance;\n                        else this._distance = this._longDistance;\n                        break;\n                    case RotationType.CounterClockwise:\n                        this._direction = -1;\n                        if (!this._shortestPathIsPositive) this._distance = this._shortDistance;\n                        else this._distance = this._longDistance;\n                        break;\n                }\n            }\n            this._motion.angularVelocity = this._direction * this._speed;\n            this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\n            if (this.isComplete()) {\n                this._tx.rotation = this._end;\n                this._motion.angularVelocity = 0;\n                this._stopped = true;\n            }\n        }\n        isComplete() {\n            const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\n            return this._stopped || distanceTraveled >= Math.abs(this._distance);\n        }\n        stop() {\n            this._motion.angularVelocity = 0;\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class RotateBy {\n        constructor(entity, angleRadiansOffset, speed, rotationType){\n            this._started = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._speed = speed;\n            this._offset = angleRadiansOffset;\n            this._rotationType = rotationType || RotationType.ShortestPath;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._start = this._tx.rotation;\n                this._currentNonCannonAngle = this._tx.rotation;\n                this._end = this._start + this._offset;\n                const distance1 = Math.abs(this._end - this._start);\n                const distance2 = TwoPI - distance1;\n                if (distance1 > distance2) {\n                    this._shortDistance = distance2;\n                    this._longDistance = distance1;\n                } else {\n                    this._shortDistance = distance1;\n                    this._longDistance = distance2;\n                }\n                this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\n                switch(this._rotationType){\n                    case RotationType.ShortestPath:\n                        this._distance = this._shortDistance;\n                        if (this._shortestPathIsPositive) this._direction = 1;\n                        else this._direction = -1;\n                        break;\n                    case RotationType.LongestPath:\n                        this._distance = this._longDistance;\n                        if (this._shortestPathIsPositive) this._direction = -1;\n                        else this._direction = 1;\n                        break;\n                    case RotationType.Clockwise:\n                        this._direction = 1;\n                        if (this._shortDistance >= 0) this._distance = this._shortDistance;\n                        else this._distance = this._longDistance;\n                        break;\n                    case RotationType.CounterClockwise:\n                        this._direction = -1;\n                        if (this._shortDistance <= 0) this._distance = this._shortDistance;\n                        else this._distance = this._longDistance;\n                        break;\n                }\n            }\n            this._motion.angularVelocity = this._direction * this._speed;\n            this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\n            if (this.isComplete()) {\n                this._tx.rotation = this._end;\n                this._motion.angularVelocity = 0;\n                this._stopped = true;\n            }\n        }\n        isComplete() {\n            const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\n            return this._stopped || distanceTraveled >= Math.abs(this._distance);\n        }\n        stop() {\n            this._motion.angularVelocity = 0;\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n            this._start = undefined;\n            this._currentNonCannonAngle = undefined;\n            this._distance = undefined;\n        }\n    }\n    class ScaleTo {\n        constructor(entity, scaleX, scaleY, speedX, speedY){\n            this._started = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._endX = scaleX;\n            this._endY = scaleY;\n            this._speedX = speedX;\n            this._speedY = speedY;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._startX = this._tx.scale.x;\n                this._startY = this._tx.scale.y;\n                this._distanceX = Math.abs(this._endX - this._startX);\n                this._distanceY = Math.abs(this._endY - this._startY);\n            }\n            if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {\n                const directionX = this._endY < this._startY ? -1 : 1;\n                this._motion.scaleFactor.x = this._speedX * directionX;\n            } else this._motion.scaleFactor.x = 0;\n            if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {\n                const directionY = this._endY < this._startY ? -1 : 1;\n                this._motion.scaleFactor.y = this._speedY * directionY;\n            } else this._motion.scaleFactor.y = 0;\n            if (this.isComplete()) {\n                this._tx.scale = vec(this._endX, this._endY);\n                this._motion.scaleFactor.x = 0;\n                this._motion.scaleFactor.y = 0;\n            }\n        }\n        isComplete() {\n            return this._stopped || Math.abs(this._tx.scale.y - this._startX) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY - 0.01;\n        }\n        stop() {\n            this._motion.scaleFactor.x = 0;\n            this._motion.scaleFactor.y = 0;\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class ScaleBy {\n        constructor(entity, scaleOffsetX, scaleOffsetY, speed){\n            this._started = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._offset = new Vector(scaleOffsetX, scaleOffsetY);\n            this._speedX = this._speedY = speed;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._startScale = this._tx.scale.clone();\n                this._endScale = this._startScale.add(this._offset);\n                this._distanceX = Math.abs(this._endScale.x - this._startScale.x);\n                this._distanceY = Math.abs(this._endScale.y - this._startScale.y);\n                this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;\n                this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;\n            }\n            this._motion.scaleFactor.x = this._speedX * this._directionX;\n            this._motion.scaleFactor.y = this._speedY * this._directionY;\n            if (this.isComplete()) {\n                this._tx.scale = this._endScale;\n                this._motion.scaleFactor.x = 0;\n                this._motion.scaleFactor.y = 0;\n            }\n        }\n        isComplete() {\n            return this._stopped || Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY - 0.01;\n        }\n        stop() {\n            this._motion.scaleFactor.x = 0;\n            this._motion.scaleFactor.y = 0;\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class CallMethod {\n        constructor(method){\n            this._method = null;\n            this._hasBeenCalled = false;\n            this._method = method;\n        }\n        update(_delta) {\n            this._method();\n            this._hasBeenCalled = true;\n        }\n        isComplete() {\n            return this._hasBeenCalled;\n        }\n        reset() {\n            this._hasBeenCalled = false;\n        }\n        stop() {\n            this._hasBeenCalled = true;\n        }\n    }\n    class EaseTo {\n        constructor(entity, x, y, duration, easingFcn){\n            this.easingFcn = easingFcn;\n            this._currentLerpTime = 0;\n            this._lerpDuration = 1000; // 1 second\n            this._lerpStart = new Vector(0, 0);\n            this._lerpEnd = new Vector(0, 0);\n            this._initialized = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._lerpDuration = duration;\n            this._lerpEnd = new Vector(x, y);\n        }\n        _initialize() {\n            this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\n            this._currentLerpTime = 0;\n        }\n        update(delta) {\n            if (!this._initialized) {\n                this._initialize();\n                this._initialized = true;\n            }\n            // Need to update lerp time first, otherwise the first update will always be zero\n            this._currentLerpTime += delta;\n            let newX = this._tx.pos.x;\n            let newY = this._tx.pos.y;\n            if (this._currentLerpTime < this._lerpDuration) {\n                if (this._lerpEnd.x < this._lerpStart.x) newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\n                else newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\n                if (this._lerpEnd.y < this._lerpStart.y) newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\n                else newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\n                // Given the lerp position figure out the velocity in pixels per second\n                this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\n            } else {\n                this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\n                this._motion.vel = Vector.Zero;\n            }\n        }\n        isComplete() {\n            return this._stopped || this._currentLerpTime >= this._lerpDuration;\n        }\n        reset() {\n            this._initialized = false;\n            this._stopped = false;\n            this._currentLerpTime = 0;\n        }\n        stop() {\n            this._motion.vel = vec(0, 0);\n            this._stopped = true;\n        }\n    }\n    class EaseBy {\n        constructor(entity, offsetX, offsetY, duration, easingFcn){\n            this.easingFcn = easingFcn;\n            this._currentLerpTime = 0;\n            this._lerpDuration = 1000; // 1 second\n            this._lerpStart = new Vector(0, 0);\n            this._lerpEnd = new Vector(0, 0);\n            this._initialized = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._lerpDuration = duration;\n            this._offset = new Vector(offsetX, offsetY);\n        }\n        _initialize() {\n            this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\n            this._currentLerpTime = 0;\n            this._lerpEnd = this._lerpStart.add(this._offset);\n        }\n        update(delta) {\n            if (!this._initialized) {\n                this._initialize();\n                this._initialized = true;\n            }\n            // Need to update lerp time first, otherwise the first update will always be zero\n            this._currentLerpTime += delta;\n            let newX = this._tx.pos.x;\n            let newY = this._tx.pos.y;\n            if (this._currentLerpTime < this._lerpDuration) {\n                if (this._lerpEnd.x < this._lerpStart.x) newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\n                else newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\n                if (this._lerpEnd.y < this._lerpStart.y) newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\n                else newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\n                // Given the lerp position figure out the velocity in pixels per second\n                this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\n            } else {\n                this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\n                this._motion.vel = Vector.Zero;\n            }\n        }\n        isComplete() {\n            return this._stopped || this._currentLerpTime >= this._lerpDuration;\n        }\n        reset() {\n            this._initialized = false;\n            this._stopped = false;\n            this._currentLerpTime = 0;\n        }\n        stop() {\n            this._motion.vel = vec(0, 0);\n            this._stopped = true;\n        }\n    }\n    class Blink {\n        constructor(entity, timeVisible, timeNotVisible, numBlinks = 1){\n            this._timeVisible = 0;\n            this._timeNotVisible = 0;\n            this._elapsedTime = 0;\n            this._totalTime = 0;\n            this._stopped = false;\n            this._started = false;\n            this._graphics = entity.get(GraphicsComponent);\n            this._timeVisible = timeVisible;\n            this._timeNotVisible = timeNotVisible;\n            this._duration = (timeVisible + timeNotVisible) * numBlinks;\n        }\n        update(delta) {\n            if (!this._started) {\n                this._started = true;\n                this._elapsedTime = 0;\n                this._totalTime = 0;\n            }\n            if (!this._graphics) return;\n            this._elapsedTime += delta;\n            this._totalTime += delta;\n            if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {\n                this._graphics.visible = false;\n                this._elapsedTime = 0;\n            }\n            if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {\n                this._graphics.visible = true;\n                this._elapsedTime = 0;\n            }\n            if (this.isComplete()) this._graphics.visible = true;\n        }\n        isComplete() {\n            return this._stopped || this._totalTime >= this._duration;\n        }\n        stop() {\n            if (this._graphics) this._graphics.visible = true;\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n            this._elapsedTime = 0;\n            this._totalTime = 0;\n        }\n    }\n    class Fade {\n        constructor(entity, endOpacity, speed){\n            this._multiplier = 1;\n            this._started = false;\n            this._stopped = false;\n            this._graphics = entity.get(GraphicsComponent);\n            this._endOpacity = endOpacity;\n            this._speed = this._ogspeed = speed;\n        }\n        update(delta) {\n            if (!this._graphics) return;\n            if (!this._started) {\n                this._started = true;\n                this._speed = this._ogspeed;\n                // determine direction when we start\n                if (this._endOpacity < this._graphics.opacity) this._multiplier = -1;\n                else this._multiplier = 1;\n            }\n            if (this._speed > 0) this._graphics.opacity += this._multiplier * (Math.abs(this._graphics.opacity - this._endOpacity) * delta) / this._speed;\n            this._speed -= delta;\n            if (this.isComplete()) this._graphics.opacity = this._endOpacity;\n            Logger.getInstance().debug(\"[Action fade] Actor opacity:\", this._graphics.opacity);\n        }\n        isComplete() {\n            return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;\n        }\n        stop() {\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class Delay {\n        constructor(delay){\n            this._elapsedTime = 0;\n            this._started = false;\n            this._stopped = false;\n            this._delay = delay;\n        }\n        update(delta) {\n            if (!this._started) this._started = true;\n            this._elapsedTime += delta;\n        }\n        isComplete() {\n            return this._stopped || this._elapsedTime >= this._delay;\n        }\n        stop() {\n            this._stopped = true;\n        }\n        reset() {\n            this._elapsedTime = 0;\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class Die {\n        constructor(entity){\n            this._stopped = false;\n            this._entity = entity;\n        }\n        update(_delta) {\n            this._entity.get(ActionsComponent).clearActions();\n            this._entity.kill();\n            this._stopped = true;\n        }\n        isComplete() {\n            return this._stopped;\n        }\n        stop() {\n            return;\n        }\n        reset() {\n            return;\n        }\n    }\n    class Follow {\n        constructor(entity, entityToFollow, followDistance){\n            this._started = false;\n            this._stopped = false;\n            this._tx = entity.get(TransformComponent);\n            this._motion = entity.get(MotionComponent);\n            this._followTx = entityToFollow.get(TransformComponent);\n            this._followMotion = entityToFollow.get(MotionComponent);\n            this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\n            this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);\n            this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);\n            this._speed = 0;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._distanceBetween = this._current.distance(this._end);\n                this._dir = this._end.sub(this._current).normalize();\n            }\n            const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));\n            if (actorToFollowSpeed !== 0) this._speed = actorToFollowSpeed;\n            this._current = vec(this._tx.pos.x, this._tx.pos.y);\n            this._end = vec(this._followTx.pos.x, this._followTx.pos.y);\n            this._distanceBetween = this._current.distance(this._end);\n            this._dir = this._end.sub(this._current).normalize();\n            if (this._distanceBetween >= this._maximumDistance) {\n                const m = this._dir.scale(this._speed);\n                this._motion.vel = vec(m.x, m.y);\n            } else this._motion.vel = vec(0, 0);\n            if (this.isComplete()) {\n                this._tx.pos = vec(this._end.x, this._end.y);\n                this._motion.vel = vec(0, 0);\n            }\n        }\n        stop() {\n            this._motion.vel = vec(0, 0);\n            this._stopped = true;\n        }\n        isComplete() {\n            // the actor following should never stop unless specified to do so\n            return this._stopped;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n        }\n    }\n    class Meet {\n        constructor(actor, actorToMeet, speed){\n            this._started = false;\n            this._stopped = false;\n            this._speedWasSpecified = false;\n            this._tx = actor.get(TransformComponent);\n            this._motion = actor.get(MotionComponent);\n            this._meetTx = actorToMeet.get(TransformComponent);\n            this._meetMotion = actorToMeet.get(MotionComponent);\n            this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\n            this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);\n            this._speed = speed || 0;\n            if (speed !== undefined) this._speedWasSpecified = true;\n        }\n        update(_delta) {\n            if (!this._started) {\n                this._started = true;\n                this._distanceBetween = this._current.distance(this._end);\n                this._dir = this._end.sub(this._current).normalize();\n            }\n            const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));\n            if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) this._speed = actorToMeetSpeed;\n            this._current = vec(this._tx.pos.x, this._tx.pos.y);\n            this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);\n            this._distanceBetween = this._current.distance(this._end);\n            this._dir = this._end.sub(this._current).normalize();\n            const m = this._dir.scale(this._speed);\n            this._motion.vel = vec(m.x, m.y);\n            if (this.isComplete()) {\n                this._tx.pos = vec(this._end.x, this._end.y);\n                this._motion.vel = vec(0, 0);\n            }\n        }\n        isComplete() {\n            return this._stopped || this._distanceBetween <= 1;\n        }\n        stop() {\n            this._motion.vel = vec(0, 0);\n            this._stopped = true;\n        }\n        reset() {\n            this._started = false;\n            this._stopped = false;\n            this._distanceBetween = undefined;\n        }\n    }\n    /**\r\n * The fluent Action API allows you to perform \"actions\" on\r\n * [[Actor|Actors]] such as following, moving, rotating, and\r\n * more. You can implement your own actions by implementing\r\n * the [[Action]] interface.\r\n */ class ActionContext {\n        constructor(entity){\n            this._entity = entity;\n            this._queue = new ActionQueue(entity);\n        }\n        getQueue() {\n            return this._queue;\n        }\n        update(elapsedMs) {\n            this._queue.update(elapsedMs);\n        }\n        /**\r\n     * Clears all queued actions from the Actor\r\n     */ clearActions() {\n            this._queue.clearActions();\n        }\n        runAction(action) {\n            action.reset();\n            this._queue.add(action);\n            return this;\n        }\n        easeTo(...args) {\n            var _a, _b;\n            let x = 0;\n            let y = 0;\n            let duration = 0;\n            let easingFcn = EasingFunctions.Linear;\n            if (args[0] instanceof Vector) {\n                x = args[0].x;\n                y = args[0].y;\n                duration = args[1];\n                easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;\n            } else {\n                x = args[0];\n                y = args[1];\n                duration = args[2];\n                easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;\n            }\n            this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));\n            return this;\n        }\n        easeBy(...args) {\n            var _a, _b;\n            let offsetX = 0;\n            let offsetY = 0;\n            let duration = 0;\n            let easingFcn = EasingFunctions.Linear;\n            if (args[0] instanceof Vector) {\n                offsetX = args[0].x;\n                offsetY = args[0].y;\n                duration = args[1];\n                easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;\n            } else {\n                offsetX = args[0];\n                offsetY = args[1];\n                duration = args[2];\n                easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;\n            }\n            this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));\n            return this;\n        }\n        moveTo(xOrPos, yOrSpeed, speedOrUndefined) {\n            let x = 0;\n            let y = 0;\n            let speed = 0;\n            if (xOrPos instanceof Vector) {\n                x = xOrPos.x;\n                y = xOrPos.y;\n                speed = yOrSpeed;\n            } else {\n                x = xOrPos;\n                y = yOrSpeed;\n                speed = speedOrUndefined;\n            }\n            this._queue.add(new MoveTo(this._entity, x, y, speed));\n            return this;\n        }\n        moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {\n            let xOffset = 0;\n            let yOffset = 0;\n            let speed = 0;\n            if (xOffsetOrVector instanceof Vector) {\n                xOffset = xOffsetOrVector.x;\n                yOffset = xOffsetOrVector.y;\n                speed = yOffsetOrSpeed;\n            } else {\n                xOffset = xOffsetOrVector;\n                yOffset = yOffsetOrSpeed;\n                speed = speedOrUndefined;\n            }\n            this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));\n            return this;\n        }\n        /**\r\n     * This method will rotate an actor to the specified angle at the speed\r\n     * specified (in radians per second) and return back the actor. This\r\n     * method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadians  The angle to rotate to in radians\r\n     * @param speed         The angular velocity of the rotation specified in radians per second\r\n     * @param rotationType  The [[RotationType]] to use for this rotation\r\n     */ rotateTo(angleRadians, speed, rotationType) {\n            this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));\n            return this;\n        }\n        /**\r\n     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n     * in radians/sec and return back the actor. This method is part\r\n     * of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n     * @param speed          The speed in radians/sec the actor should rotate at\r\n     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n     */ rotateBy(angleRadiansOffset, speed, rotationType) {\n            this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));\n            return this;\n        }\n        scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {\n            let sizeX = 1;\n            let sizeY = 1;\n            let speedX = 0;\n            let speedY = 0;\n            if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {\n                sizeX = sizeXOrVector.x;\n                sizeY = sizeXOrVector.y;\n                speedX = sizeYOrSpeed.x;\n                speedY = sizeYOrSpeed.y;\n            }\n            if (typeof sizeXOrVector === \"number\" && typeof sizeYOrSpeed === \"number\") {\n                sizeX = sizeXOrVector;\n                sizeY = sizeYOrSpeed;\n                speedX = speedXOrUndefined;\n                speedY = speedYOrUndefined;\n            }\n            this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));\n            return this;\n        }\n        scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {\n            let sizeOffsetX = 1;\n            let sizeOffsetY = 1;\n            if (sizeOffsetXOrVector instanceof Vector) {\n                sizeOffsetX = sizeOffsetXOrVector.x;\n                sizeOffsetY = sizeOffsetXOrVector.y;\n                speed = sizeOffsetYOrSpeed;\n            }\n            if (typeof sizeOffsetXOrVector === \"number\" && typeof sizeOffsetYOrSpeed === \"number\") {\n                sizeOffsetX = sizeOffsetXOrVector;\n                sizeOffsetY = sizeOffsetYOrSpeed;\n            }\n            this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));\n            return this;\n        }\n        /**\r\n     * This method will cause an actor to blink (become visible and not\r\n     * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n     * the actor should be visible per blink, and the amount of time not visible.\r\n     * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n     * @param numBlinks       The number of times to blink\r\n     */ blink(timeVisible, timeNotVisible, numBlinks = 1) {\n            this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));\n            return this;\n        }\n        /**\r\n     * This method will cause an actor's opacity to change from its current value\r\n     * to the provided value by a specified time (in milliseconds). This method is\r\n     * part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param opacity  The ending opacity\r\n     * @param time     The time it should take to fade the actor (in milliseconds)\r\n     */ fade(opacity, time) {\n            this._queue.add(new Fade(this._entity, opacity, time));\n            return this;\n        }\n        /**\r\n     * This method will delay the next action from executing for a certain\r\n     * amount of time (in milliseconds). This method is part of the actor\r\n     * 'Action' fluent API allowing action chaining.\r\n     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n     */ delay(time) {\n            this._queue.add(new Delay(time));\n            return this;\n        }\n        /**\r\n     * This method will add an action to the queue that will remove the actor from the\r\n     * scene once it has completed its previous  Any actions on the\r\n     * action queue after this action will not be executed.\r\n     */ die() {\n            this._queue.add(new Die(this._entity));\n            return this;\n        }\n        /**\r\n     * This method allows you to call an arbitrary method as the next action in the\r\n     * action queue. This is useful if you want to execute code in after a specific\r\n     * action, i.e An actor arrives at a destination after traversing a path\r\n     */ callMethod(method) {\n            this._queue.add(new CallMethod(method));\n            return this;\n        }\n        /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n     * will repeat forever\r\n     */ repeat(repeatBuilder, times) {\n            if (!times) {\n                this.repeatForever(repeatBuilder);\n                return this;\n            }\n            this._queue.add(new Repeat(this._entity, repeatBuilder, times));\n            return this;\n        }\n        /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     */ repeatForever(repeatBuilder) {\n            this._queue.add(new RepeatForever(this._entity, repeatBuilder));\n            return this;\n        }\n        /**\r\n     * This method will cause the entity to follow another at a specified distance\r\n     * @param entity           The entity to follow\r\n     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n     */ follow(entity, followDistance) {\n            if (followDistance === undefined) this._queue.add(new Follow(this._entity, entity));\n            else this._queue.add(new Follow(this._entity, entity, followDistance));\n            return this;\n        }\n        /**\r\n     * This method will cause the entity to move towards another until they\r\n     * collide \"meet\" at a specified speed.\r\n     * @param entity  The entity to meet\r\n     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n     */ meet(entity, speed) {\n            if (speed === undefined) this._queue.add(new Meet(this._entity, entity));\n            else this._queue.add(new Meet(this._entity, entity, speed));\n            return this;\n        }\n        /**\r\n     * Returns a promise that resolves when the current action queue up to now\r\n     * is finished.\r\n     */ toPromise() {\n            const temp = new Promise((resolve)=>{\n                this._queue.add(new CallMethod(()=>{\n                    resolve();\n                }));\n            });\n            return temp;\n        }\n    }\n    class ActionsComponent extends Component {\n        constructor(){\n            super(...arguments);\n            this.type = \"ex.actions\";\n            this.dependencies = [\n                TransformComponent,\n                MotionComponent\n            ];\n        }\n        onAdd(entity) {\n            this._ctx = new ActionContext(entity);\n        }\n        onRemove() {\n            this._ctx = null;\n        }\n        /**\r\n     * Returns the internal action queue\r\n     * @returns action queue\r\n     */ getQueue() {\n            var _a;\n            return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();\n        }\n        runAction(action) {\n            var _a;\n            return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.runAction(action);\n        }\n        /**\r\n     * Updates the internal action context, performing action and moving through the internal queue\r\n     * @param elapsedMs\r\n     */ update(elapsedMs) {\n            var _a;\n            return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);\n        }\n        /**\r\n     * Clears all queued actions from the Actor\r\n     */ clearActions() {\n            var _a;\n            (_a = this._ctx) === null || _a === void 0 || _a.clearActions();\n        }\n        easeTo(...args) {\n            return this._ctx.easeTo.apply(this._ctx, args);\n        }\n        easeBy(...args) {\n            return this._ctx.easeBy.apply(this._ctx, args);\n        }\n        moveTo(xOrPos, yOrSpeed, speedOrUndefined) {\n            return this._ctx.moveTo.apply(this._ctx, [\n                xOrPos,\n                yOrSpeed,\n                speedOrUndefined\n            ]);\n        }\n        moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {\n            return this._ctx.moveBy.apply(this._ctx, [\n                xOffsetOrVector,\n                yOffsetOrSpeed,\n                speedOrUndefined\n            ]);\n        }\n        /**\r\n     * This method will rotate an actor to the specified angle at the speed\r\n     * specified (in radians per second) and return back the actor. This\r\n     * method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadians  The angle to rotate to in radians\r\n     * @param speed         The angular velocity of the rotation specified in radians per second\r\n     * @param rotationType  The [[RotationType]] to use for this rotation\r\n     */ rotateTo(angleRadians, speed, rotationType) {\n            return this._ctx.rotateTo(angleRadians, speed, rotationType);\n        }\n        /**\r\n     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n     * in radians/sec and return back the actor. This method is part\r\n     * of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n     * @param speed          The speed in radians/sec the actor should rotate at\r\n     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n     */ rotateBy(angleRadiansOffset, speed, rotationType) {\n            return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);\n        }\n        scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {\n            return this._ctx.scaleTo.apply(this._ctx, [\n                sizeXOrVector,\n                sizeYOrSpeed,\n                speedXOrUndefined,\n                speedYOrUndefined\n            ]);\n        }\n        scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {\n            return this._ctx.scaleBy.apply(this._ctx, [\n                sizeOffsetXOrVector,\n                sizeOffsetYOrSpeed,\n                speed\n            ]);\n        }\n        /**\r\n     * This method will cause an actor to blink (become visible and not\r\n     * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n     * the actor should be visible per blink, and the amount of time not visible.\r\n     * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n     * @param numBlinks       The number of times to blink\r\n     */ blink(timeVisible, timeNotVisible, numBlinks) {\n            return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);\n        }\n        /**\r\n     * This method will cause an actor's opacity to change from its current value\r\n     * to the provided value by a specified time (in milliseconds). This method is\r\n     * part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param opacity  The ending opacity\r\n     * @param time     The time it should take to fade the actor (in milliseconds)\r\n     */ fade(opacity, time) {\n            return this._ctx.fade(opacity, time);\n        }\n        /**\r\n     * This method will delay the next action from executing for a certain\r\n     * amount of time (in milliseconds). This method is part of the actor\r\n     * 'Action' fluent API allowing action chaining.\r\n     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n     */ delay(time) {\n            return this._ctx.delay(time);\n        }\n        /**\r\n     * This method will add an action to the queue that will remove the actor from the\r\n     * scene once it has completed its previous  Any actions on the\r\n     * action queue after this action will not be executed.\r\n     */ die() {\n            return this._ctx.die();\n        }\n        /**\r\n     * This method allows you to call an arbitrary method as the next action in the\r\n     * action queue. This is useful if you want to execute code in after a specific\r\n     * action, i.e An actor arrives at a destination after traversing a path\r\n     */ callMethod(method) {\n            return this._ctx.callMethod(method);\n        }\n        /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n     * will repeat forever\r\n     */ repeat(repeatBuilder, times) {\n            return this._ctx.repeat(repeatBuilder, times);\n        }\n        /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     */ repeatForever(repeatBuilder) {\n            return this._ctx.repeatForever(repeatBuilder);\n        }\n        /**\r\n     * This method will cause the entity to follow another at a specified distance\r\n     * @param entity           The entity to follow\r\n     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n     */ follow(entity, followDistance) {\n            return this._ctx.follow(entity, followDistance);\n        }\n        /**\r\n     * This method will cause the entity to move towards another until they\r\n     * collide \"meet\" at a specified speed.\r\n     * @param entity  The entity to meet\r\n     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n     */ meet(entity, speed) {\n            return this._ctx.meet(entity, speed);\n        }\n        /**\r\n     * Returns a promise that resolves when the current action queue up to now\r\n     * is finished.\r\n     */ toPromise() {\n            return this._ctx.toPromise();\n        }\n    }\n    /**\r\n * Enum representing the different font size units\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\r\n */ var FontUnit;\n    (function(FontUnit) {\n        /**\r\n     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\r\n     */ FontUnit[\"Em\"] = \"em\";\n        /**\r\n     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element\r\n     */ FontUnit[\"Rem\"] = \"rem\";\n        /**\r\n     * Pixel is a unit of length in screen pixels\r\n     */ FontUnit[\"Px\"] = \"px\";\n        /**\r\n     * Point is a physical unit length (1/72 of an inch)\r\n     */ FontUnit[\"Pt\"] = \"pt\";\n        /**\r\n     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\r\n     */ FontUnit[\"Percent\"] = \"%\";\n    })(FontUnit || (FontUnit = {}));\n    /**\r\n * Enum representing the different horizontal text alignments\r\n */ var TextAlign;\n    (function(TextAlign) {\n        /**\r\n     * The text is left-aligned.\r\n     */ TextAlign[\"Left\"] = \"left\";\n        /**\r\n     * The text is right-aligned.\r\n     */ TextAlign[\"Right\"] = \"right\";\n        /**\r\n     * The text is centered.\r\n     */ TextAlign[\"Center\"] = \"center\";\n        /**\r\n     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\r\n     * right-aligned for right-to-left locales).\r\n     */ TextAlign[\"Start\"] = \"start\";\n        /**\r\n     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\r\n     * left-aligned for right-to-left locales).\r\n     */ TextAlign[\"End\"] = \"end\";\n    })(TextAlign || (TextAlign = {}));\n    /**\r\n * Enum representing the different baseline text alignments\r\n */ var BaseAlign;\n    (function(BaseAlign) {\n        /**\r\n     * The text baseline is the top of the em square.\r\n     */ BaseAlign[\"Top\"] = \"top\";\n        /**\r\n     * The text baseline is the hanging baseline.  Currently unsupported; this will act like\r\n     * alphabetic.\r\n     */ BaseAlign[\"Hanging\"] = \"hanging\";\n        /**\r\n     * The text baseline is the middle of the em square.\r\n     */ BaseAlign[\"Middle\"] = \"middle\";\n        /**\r\n     * The text baseline is the normal alphabetic baseline.\r\n     */ BaseAlign[\"Alphabetic\"] = \"alphabetic\";\n        /**\r\n     * The text baseline is the ideographic baseline; this is the bottom of\r\n     * the body of the characters, if the main body of characters protrudes\r\n     * beneath the alphabetic baseline.  Currently unsupported; this will\r\n     * act like alphabetic.\r\n     */ BaseAlign[\"Ideographic\"] = \"ideographic\";\n        /**\r\n     * The text baseline is the bottom of the bounding box.  This differs\r\n     * from the ideographic baseline in that the ideographic baseline\r\n     * doesn't consider descenders.\r\n     */ BaseAlign[\"Bottom\"] = \"bottom\";\n    })(BaseAlign || (BaseAlign = {}));\n    /**\r\n * Enum representing the different possible font styles\r\n */ var FontStyle;\n    (function(FontStyle) {\n        FontStyle[\"Normal\"] = \"normal\";\n        FontStyle[\"Italic\"] = \"italic\";\n        FontStyle[\"Oblique\"] = \"oblique\";\n    })(FontStyle || (FontStyle = {}));\n    /**\r\n * Enum representing the text direction, useful for other languages, or writing text in reverse\r\n */ var Direction;\n    (function(Direction) {\n        Direction[\"LeftToRight\"] = \"ltr\";\n        Direction[\"RightToLeft\"] = \"rtl\";\n    })(Direction || (Direction = {}));\n    /**\r\n * Represents a system or web font in Excalibur\r\n *\r\n * If no options specified, the system sans-serif 10 pixel is used\r\n *\r\n * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/\r\n */ class Font extends Graphic {\n        constructor(options = {}){\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n            super(options); // <- Graphics properties\n            /**\r\n         * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing\r\n         *\r\n         * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]\r\n         */ this.filtering = ImageFiltering.Blended;\n            /**\r\n         * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.\r\n         * If quality is set to 1, then just enough raster bitmap is generated to render the text.\r\n         *\r\n         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.\r\n         *\r\n         * (Default 2)\r\n         */ this.quality = 2;\n            // Raster properties for fonts\n            this.padding = 2;\n            this.smoothing = false;\n            this.lineWidth = 1;\n            this.lineDash = [];\n            this.color = Color.Black;\n            this.family = \"sans-serif\";\n            this.style = FontStyle.Normal;\n            this.bold = false;\n            this.unit = FontUnit.Px;\n            this.textAlign = TextAlign.Left;\n            this.baseAlign = BaseAlign.Alphabetic;\n            this.direction = Direction.LeftToRight;\n            this.size = 10;\n            this.shadow = null;\n            this._textBounds = new BoundingBox();\n            this._cachedTextMeasurement = new Map();\n            this._bitmapToTextMeasurement = new Map();\n            this._textToBitmap = new Map();\n            this._bitmapUsage = new Map();\n            this._textFragments = [];\n            // Raster properties\n            this.smoothing = (_a = options === null || options === void 0 ? void 0 : options.smoothing) !== null && _a !== void 0 ? _a : this.smoothing;\n            this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : this.padding;\n            this.color = (_c = options === null || options === void 0 ? void 0 : options.color) !== null && _c !== void 0 ? _c : this.color;\n            this.strokeColor = (_d = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _d !== void 0 ? _d : this.strokeColor;\n            this.lineDash = (_e = options === null || options === void 0 ? void 0 : options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;\n            this.lineWidth = (_f = options === null || options === void 0 ? void 0 : options.lineWidth) !== null && _f !== void 0 ? _f : this.lineWidth;\n            this.filtering = (_g = options === null || options === void 0 ? void 0 : options.filtering) !== null && _g !== void 0 ? _g : this.filtering;\n            // Font specific properties\n            this.family = (_h = options === null || options === void 0 ? void 0 : options.family) !== null && _h !== void 0 ? _h : this.family;\n            this.style = (_j = options === null || options === void 0 ? void 0 : options.style) !== null && _j !== void 0 ? _j : this.style;\n            this.bold = (_k = options === null || options === void 0 ? void 0 : options.bold) !== null && _k !== void 0 ? _k : this.bold;\n            this.size = (_l = options === null || options === void 0 ? void 0 : options.size) !== null && _l !== void 0 ? _l : this.size;\n            this.unit = (_m = options === null || options === void 0 ? void 0 : options.unit) !== null && _m !== void 0 ? _m : this.unit;\n            this.textAlign = (_o = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _o !== void 0 ? _o : this.textAlign;\n            this.baseAlign = (_p = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _p !== void 0 ? _p : this.baseAlign;\n            this.direction = (_q = options === null || options === void 0 ? void 0 : options.direction) !== null && _q !== void 0 ? _q : this.direction;\n            this.quality = (_r = options === null || options === void 0 ? void 0 : options.quality) !== null && _r !== void 0 ? _r : this.quality;\n            if (options === null || options === void 0 ? void 0 : options.shadow) {\n                this.shadow = {};\n                this.shadow.blur = (_s = options.shadow.blur) !== null && _s !== void 0 ? _s : this.shadow.blur;\n                this.shadow.offset = (_t = options.shadow.offset) !== null && _t !== void 0 ? _t : this.shadow.offset;\n                this.shadow.color = (_u = options.shadow.color) !== null && _u !== void 0 ? _u : this.shadow.color;\n            }\n        }\n        clone() {\n            return new Font({\n                ...this.cloneGraphicOptions(),\n                size: this.size,\n                unit: this.unit,\n                family: this.family,\n                style: this.style,\n                bold: this.bold,\n                textAlign: this.textAlign,\n                baseAlign: this.baseAlign,\n                direction: this.direction,\n                shadow: this.shadow ? {\n                    blur: this.shadow.blur,\n                    offset: this.shadow.offset,\n                    color: this.shadow.color\n                } : null\n            });\n        }\n        get fontString() {\n            return `${this.style} ${this.bold ? \"bold\" : \"\"} ${this.size}${this.unit} ${this.family}`;\n        }\n        get localBounds() {\n            return this._textBounds;\n        }\n        _drawImage(_ex, _x, _y) {\n        // TODO weird vestigial drawimage\n        }\n        _rotate(ex) {\n            var _a;\n            // TODO this needs to change depending on the bounding box...\n            const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;\n            ex.translate(origin.x, origin.y);\n            ex.rotate(this.rotation);\n            ex.translate(-origin.x, -origin.y);\n        }\n        _flip(ex) {\n            if (this.flipHorizontal) {\n                ex.translate(this._textBounds.width / this.scale.x, 0);\n                ex.scale(-1, 1);\n            }\n            if (this.flipVertical) {\n                ex.translate(0, -this._textBounds.height / 2 / this.scale.y);\n                ex.scale(1, -1);\n            }\n        }\n        /**\r\n     * Returns a BoundingBox that is the total size of the text including multiple lines\r\n     *\r\n     * Does not include any padding or adjustment\r\n     * @param text\r\n     * @returns BoundingBox\r\n     */ measureText(text) {\n            let measurementDirty = false;\n            let cached = this._cachedTextMeasurement.get(text);\n            if (!cached) measurementDirty = true;\n            const rasterProps = this._getRasterPropertiesHash();\n            if (!cached || rasterProps !== cached.rasterProps) measurementDirty = true;\n            if (measurementDirty) {\n                const lines = text.split(\"\\n\");\n                const maxWidthLine = lines.reduce((a, b)=>{\n                    return a.length > b.length ? a : b;\n                });\n                const ctx = this._getTextBitmap(text);\n                this._applyFont(ctx); // font must be applied to the context to measure it\n                const metrics = ctx.measureText(maxWidthLine);\n                let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);\n                // TODO lineheight makes the text bounds wonky\n                const lineAdjustedHeight = textHeight * lines.length;\n                textHeight = lineAdjustedHeight;\n                const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);\n                const x = 0;\n                const y = 0;\n                // this._cachedText = text;\n                // this._cachedRasterProps = rasterProps;\n                // this._measurementDirty = false;\n                const measurement = new BoundingBox({\n                    left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,\n                    top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,\n                    bottom: y + bottomBounds + this.padding,\n                    right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding\n                });\n                cached = {\n                    text: text,\n                    rasterProps: rasterProps,\n                    measurement: measurement\n                };\n                this._cachedTextMeasurement.set(text, cached);\n                this._bitmapToTextMeasurement.set(ctx, cached);\n                return cached.measurement;\n            } else return cached.measurement;\n        }\n        _setDimension(textBounds, bitmap) {\n            // Changing the width and height clears the context properties\n            // We double the bitmap width to account for all possible alignment\n            // We scale by \"quality\" so we render text without jaggies\n            bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;\n            bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;\n        }\n        _postDraw(ex) {\n            ex.restore();\n        }\n        /**\r\n     * We need to identify bitmaps with more than just the text content\r\n     *\r\n     * Any properties that can change the rendering of the text\r\n     */ _getRasterPropertiesHash(color) {\n            var _a, _b;\n            const hash = \"__hashcode__\" + this.fontString + this.showDebug + this.textAlign + this.baseAlign + this.direction + JSON.stringify(this.shadow) + (this.padding.toString() + this.smoothing.toString() + this.lineWidth.toString() + this.lineDash.toString() + ((_a = this.strokeColor) === null || _a === void 0 ? void 0 : _a.toString()) + (color ? color.toString() : (_b = this.color) === null || _b === void 0 ? void 0 : _b.toString()).toString());\n            return hash;\n        }\n        _applyRasterProperties(ctx, color) {\n            var _a, _b, _c;\n            ctx.translate(this.padding, this.padding);\n            ctx.imageSmoothingEnabled = this.smoothing;\n            ctx.lineWidth = this.lineWidth;\n            ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());\n            ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();\n            ctx.fillStyle = color ? color.toString() : (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();\n        }\n        _applyFont(ctx) {\n            ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);\n            ctx.scale(this.quality, this.quality);\n            ctx.textAlign = this.textAlign;\n            ctx.textBaseline = this.baseAlign;\n            ctx.font = this.fontString;\n            ctx.direction = this.direction;\n            if (this.shadow) {\n                ctx.shadowColor = this.shadow.color.toString();\n                ctx.shadowBlur = this.shadow.blur;\n                ctx.shadowOffsetX = this.shadow.offset.x;\n                ctx.shadowOffsetY = this.shadow.offset.y;\n            }\n        }\n        _drawText(ctx, text, colorOverride, lineHeight) {\n            const lines = text.split(\"\\n\");\n            this._applyRasterProperties(ctx, colorOverride);\n            this._applyFont(ctx);\n            for(let i = 0; i < lines.length; i++){\n                const line = lines[i];\n                if (this.color) ctx.fillText(line, 0, i * lineHeight);\n                if (this.strokeColor) ctx.strokeText(line, 0, i * lineHeight);\n            }\n            if (this.showDebug) {\n                // Horizontal line\n                /* istanbul ignore next */ line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);\n                // Vertical line\n                /* istanbul ignore next */ line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);\n            }\n        }\n        _getTextBitmap(text, color) {\n            const textAndHash = text + this._getRasterPropertiesHash(color);\n            const bitmap = this._textToBitmap.get(textAndHash);\n            if (bitmap) return bitmap;\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            this._textToBitmap.set(textAndHash, ctx);\n            return ctx;\n        }\n        _splitTextBitmap(bitmap) {\n            const textImages = [];\n            let currentX = 0;\n            let currentY = 0;\n            // 4k is the max for mobile devices\n            const width = Math.min(4096, bitmap.canvas.width);\n            const height = Math.min(4096, bitmap.canvas.height);\n            // Splits the original bitmap into 4k max chunks\n            while(currentX < bitmap.canvas.width){\n                while(currentY < bitmap.canvas.height){\n                    // create new bitmap\n                    const canvas = document.createElement(\"canvas\");\n                    canvas.width = width;\n                    canvas.height = height;\n                    const ctx = canvas.getContext(\"2d\");\n                    // draw current slice to new bitmap in < 4k chunks\n                    ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);\n                    textImages.push({\n                        x: currentX,\n                        y: currentY,\n                        canvas: canvas\n                    });\n                    currentY += height;\n                }\n                currentX += width;\n                currentY = 0;\n            }\n            return textImages;\n        }\n        render(ex, text, colorOverride, x, y) {\n            if (this.showDebug) this.clearCache();\n            this.checkAndClearCache();\n            // Get bitmap for rastering text, this is cached by raster properties\n            const bitmap = this._getTextBitmap(text, colorOverride);\n            const isNewBitmap = !this._bitmapUsage.get(bitmap);\n            // Bounds of the text\n            this._textBounds = this.measureText(text);\n            if (isNewBitmap) // Setting dimension is expensive because it invalidates the bitmap\n            this._setDimension(this._textBounds, bitmap);\n            // Apply affine transformations\n            this._preDraw(ex, x, y);\n            const lines = text.split(\"\\n\");\n            const lineHeight = this._textBounds.height / lines.length;\n            if (isNewBitmap) {\n                // draws the text to the bitmap\n                this._drawText(bitmap, text, colorOverride, lineHeight);\n                // clean up any existing fragments\n                for (const frag of this._textFragments)TextureLoader[\"delete\"](frag.canvas);\n                this._textFragments = this._splitTextBitmap(bitmap);\n                for (const frag of this._textFragments)TextureLoader.load(frag.canvas, this.filtering, true);\n            }\n            // draws the bitmap fragments to excalibur graphics context\n            for (const frag of this._textFragments)ex.drawImage(frag.canvas, 0, 0, frag.canvas.width, frag.canvas.height, frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2, frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2, frag.canvas.width / this.quality, frag.canvas.height / this.quality);\n            this._postDraw(ex);\n            // Cache the bitmap for certain amount of time\n            this._bitmapUsage.set(bitmap, performance.now());\n        }\n        /**\r\n     * Get the internal cache size of the font\r\n     * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps\r\n     */ get cacheSize() {\n            return this._bitmapUsage.size;\n        }\n        /**\r\n     * Force clear all cached text bitmaps\r\n     */ clearCache() {\n            this._bitmapUsage.clear();\n        }\n        /**\r\n     * Remove any expired cached text bitmaps\r\n     */ checkAndClearCache() {\n            for (const [bitmap, time] of this._bitmapUsage.entries())// if bitmap hasn't been used in 1 second clear it\n            if (time + 1000 < performance.now()) {\n                this._bitmapUsage.delete(bitmap);\n                // Cleanup measurements\n                const measurement = this._bitmapToTextMeasurement.get(bitmap);\n                if (measurement) {\n                    this._cachedTextMeasurement.delete(measurement.text);\n                    this._bitmapToTextMeasurement.delete(bitmap);\n                }\n                TextureLoader[\"delete\"](bitmap.canvas);\n            }\n        }\n    }\n    /**\r\n * Represent Text graphics in excalibur\r\n *\r\n * Useful for in game labels, ui, or overlays\r\n */ class Text extends Graphic {\n        constructor(options){\n            var _a, _b;\n            super(options);\n            this._text = \"\";\n            this._textWidth = 0;\n            this._textHeight = 0;\n            // This order is important font, color, then text\n            this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();\n            this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;\n            this.text = options.text;\n        }\n        clone() {\n            var _a, _b;\n            return new Text({\n                text: this.text.slice(),\n                color: (_b = (_a = this.color) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : Color.Black,\n                font: this.font.clone()\n            });\n        }\n        get text() {\n            return this._text;\n        }\n        set text(value) {\n            this._text = value;\n            const bounds = this.font.measureText(this._text);\n            this._textWidth = bounds.width;\n            this._textHeight = bounds.height;\n        }\n        get font() {\n            return this._font;\n        }\n        set font(font) {\n            this._font = font;\n        }\n        get width() {\n            if (this._textWidth === 0) this._calculateDimension();\n            return this._textWidth * this.scale.x;\n        }\n        get height() {\n            if (this._textHeight === 0) this._calculateDimension();\n            return this._textHeight * this.scale.y;\n        }\n        _calculateDimension() {\n            const { width: width , height: height  } = this.font.measureText(this._text);\n            this._textWidth = width;\n            this._textHeight = height;\n        }\n        get localBounds() {\n            return this.font.measureText(this._text).scale(this.scale);\n        }\n        _rotate(_ex) {\n        // None this is delegated to font\n        // This override erases the default behavior\n        }\n        _flip(_ex) {\n        // None this is delegated to font\n        // This override erases the default behavior\n        }\n        _drawImage(ex, x, y) {\n            var _a;\n            let color = Color.Black;\n            if (this.font instanceof Font) color = (_a = this.color) !== null && _a !== void 0 ? _a : this.font.color;\n            if (this.isStale() || this.font.isStale()) {\n                this.font.flipHorizontal = this.flipHorizontal;\n                this.font.flipVertical = this.flipVertical;\n                this.font.rotation = this.rotation;\n                this.font.origin = this.origin;\n                this.font.opacity = this.opacity;\n            }\n            this.font.tint = this.tint;\n            const { width: width , height: height  } = this.font.measureText(this._text);\n            this._textWidth = width;\n            this._textHeight = height;\n            this.font.render(ex, this._text, color, x, y);\n            if (this.font.showDebug) ex.debug.drawRect(x - width, y - height, width * 2, height * 2);\n        }\n    }\n    /**\r\n * Type guard for checking if something is an Actor\r\n * @param x\r\n */ function isActor(x) {\n        return x instanceof Actor;\n    }\n    /**\r\n * The most important primitive in Excalibur is an `Actor`. Anything that\r\n * can move on the screen, collide with another `Actor`, respond to events,\r\n * or interact with the current scene, must be an actor. An `Actor` **must**\r\n * be part of a [[Scene]] for it to be drawn to the screen.\r\n */ class Actor extends Entity {\n        // #endregion\n        /**\r\n     *\r\n     * @param config\r\n     */ constructor(config){\n            super();\n            /**\r\n         * The anchor to apply all actor related transformations like rotation,\r\n         * translation, and scaling. By default the anchor is in the center of\r\n         * the actor. By default it is set to the center of the actor (.5, .5)\r\n         *\r\n         * An anchor of (.5, .5) will ensure that drawings are centered.\r\n         *\r\n         * Use `anchor.setTo` to set the anchor to a different point using\r\n         * values between 0 and 1. For example, anchoring to the top-left would be\r\n         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.\r\n         */ this._anchor = watch(Vector.Half, (v)=>this._handleAnchorChange(v));\n            /**\r\n         * Convenience reference to the global logger\r\n         */ this.logger = Logger.getInstance();\n            /**\r\n         * The scene that the actor is in\r\n         */ this.scene = null;\n            /**\r\n         * Draggable helper\r\n         */ this._draggable = false;\n            this._dragging = false;\n            this._pointerDragStartHandler = ()=>{\n                this._dragging = true;\n            };\n            this._pointerDragEndHandler = ()=>{\n                this._dragging = false;\n            };\n            this._pointerDragMoveHandler = (pe)=>{\n                if (this._dragging) this.pos = pe.worldPos;\n            };\n            this._pointerDragLeaveHandler = (pe)=>{\n                if (this._dragging) this.pos = pe.worldPos;\n            };\n            const { name: name , x: x , y: y , pos: pos , coordPlane: coordPlane , scale: scale , width: width , height: height , radius: radius , collider: collider , vel: vel , acc: acc , rotation: rotation , angularVelocity: angularVelocity , z: z , color: color , visible: visible , anchor: anchor , collisionType: collisionType , collisionGroup: collisionGroup  } = {\n                ...config\n            };\n            this._setName(name);\n            this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();\n            const tx = new TransformComponent();\n            this.addComponent(tx);\n            this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);\n            this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;\n            this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);\n            this.z = z !== null && z !== void 0 ? z : 0;\n            tx.coordPlane = coordPlane !== null && coordPlane !== void 0 ? coordPlane : CoordPlane.World;\n            this.addComponent(new PointerComponent);\n            this.addComponent(new GraphicsComponent({\n                anchor: this.anchor\n            }));\n            this.addComponent(new MotionComponent());\n            this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;\n            this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;\n            this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;\n            this.addComponent(new ActionsComponent());\n            this.addComponent(new BodyComponent());\n            this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;\n            if (collisionGroup) this.body.group = collisionGroup;\n            if (collider) this.addComponent(new ColliderComponent(collider));\n            else if (radius) this.addComponent(new ColliderComponent(Shape.Circle(radius)));\n            else if (width > 0 && height > 0) this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));\n            else this.addComponent(new ColliderComponent()); // no collider\n            this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;\n            if (color) {\n                this.color = color;\n                if (width && height) this.graphics.add(new Rectangle({\n                    color: color,\n                    width: width,\n                    height: height\n                }));\n                else if (radius) this.graphics.add(new Circle({\n                    color: color,\n                    radius: radius\n                }));\n            }\n        }\n        /**\r\n     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n     * acceleration, mass, inertia, etc.\r\n     */ get body() {\n            return this.get(BodyComponent);\n        }\n        /**\r\n     * Access the Actor's built in [[TransformComponent]]\r\n     */ get transform() {\n            return this.get(TransformComponent);\n        }\n        /**\r\n     * Access the Actor's built in [[MotionComponent]]\r\n     */ get motion() {\n            return this.get(MotionComponent);\n        }\n        /**\r\n     * Access to the Actor's built in [[GraphicsComponent]]\r\n     */ get graphics() {\n            return this.get(GraphicsComponent);\n        }\n        /**\r\n     * Access to the Actor's built in [[ColliderComponent]]\r\n     */ get collider() {\n            return this.get(ColliderComponent);\n        }\n        /**\r\n     * Access to the Actor's built in [[PointerComponent]] config\r\n     */ get pointer() {\n            return this.get(PointerComponent);\n        }\n        /**\r\n     * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.\r\n     *\r\n     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the\r\n     * [[ActionContext|Action context]] of the actor.\r\n     */ get actions() {\n            return this.get(ActionsComponent);\n        }\n        /**\r\n     * Gets the position vector of the actor in pixels\r\n     */ get pos() {\n            return this.transform.pos;\n        }\n        /**\r\n     * Sets the position vector of the actor in pixels\r\n     */ set pos(thePos) {\n            this.transform.pos = thePos.clone();\n        }\n        /**\r\n     * Gets the position vector of the actor from the last frame\r\n     */ get oldPos() {\n            return this.body.oldPos;\n        }\n        /**\r\n     * Sets the position vector of the actor in the last frame\r\n     */ set oldPos(thePos) {\n            this.body.oldPos.setTo(thePos.x, thePos.y);\n        }\n        /**\r\n     * Gets the velocity vector of the actor in pixels/sec\r\n     */ get vel() {\n            return this.motion.vel;\n        }\n        /**\r\n     * Sets the velocity vector of the actor in pixels/sec\r\n     */ set vel(theVel) {\n            this.motion.vel = theVel.clone();\n        }\n        /**\r\n     * Gets the velocity vector of the actor from the last frame\r\n     */ get oldVel() {\n            return this.body.oldVel;\n        }\n        /**\r\n     * Sets the velocity vector of the actor from the last frame\r\n     */ set oldVel(theVel) {\n            this.body.oldVel.setTo(theVel.x, theVel.y);\n        }\n        /**\r\n     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n     * useful to simulate a gravitational effect.\r\n     */ get acc() {\n            return this.motion.acc;\n        }\n        /**\r\n     * Sets the acceleration vector of teh actor in pixels/second/second\r\n     */ set acc(theAcc) {\n            this.motion.acc = theAcc.clone();\n        }\n        /**\r\n     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n     */ set oldAcc(theAcc) {\n            this.body.oldAcc.setTo(theAcc.x, theAcc.y);\n        }\n        /**\r\n     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n     */ get oldAcc() {\n            return this.body.oldAcc;\n        }\n        /**\r\n     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n     */ get rotation() {\n            return this.transform.rotation;\n        }\n        /**\r\n     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n     */ set rotation(theAngle) {\n            this.transform.rotation = theAngle;\n        }\n        /**\r\n     * Gets the rotational velocity of the actor in radians/second\r\n     */ get angularVelocity() {\n            return this.motion.angularVelocity;\n        }\n        /**\r\n     * Sets the rotational velocity of the actor in radians/sec\r\n     */ set angularVelocity(angularVelocity) {\n            this.motion.angularVelocity = angularVelocity;\n        }\n        get scale() {\n            return this.get(TransformComponent).scale;\n        }\n        set scale(scale) {\n            this.get(TransformComponent).scale = scale;\n        }\n        get anchor() {\n            return this._anchor;\n        }\n        set anchor(vec) {\n            this._anchor = watch(vec, (v)=>this._handleAnchorChange(v));\n            this._handleAnchorChange(vec);\n        }\n        _handleAnchorChange(v) {\n            if (this.graphics) this.graphics.anchor = v;\n        }\n        /**\r\n     * Indicates whether the actor is physically in the viewport\r\n     */ get isOffScreen() {\n            return this.hasTag(\"ex.offscreen\");\n        }\n        get draggable() {\n            return this._draggable;\n        }\n        set draggable(isDraggable) {\n            if (isDraggable) {\n                if (isDraggable && !this._draggable) {\n                    this.on(\"pointerdragstart\", this._pointerDragStartHandler);\n                    this.on(\"pointerdragend\", this._pointerDragEndHandler);\n                    this.on(\"pointerdragmove\", this._pointerDragMoveHandler);\n                    this.on(\"pointerdragleave\", this._pointerDragLeaveHandler);\n                } else if (!isDraggable && this._draggable) {\n                    this.off(\"pointerdragstart\", this._pointerDragStartHandler);\n                    this.off(\"pointerdragend\", this._pointerDragEndHandler);\n                    this.off(\"pointerdragmove\", this._pointerDragMoveHandler);\n                    this.off(\"pointerdragleave\", this._pointerDragLeaveHandler);\n                }\n                this._draggable = isDraggable;\n            }\n        }\n        /**\r\n     * Sets the color of the actor's current graphic\r\n     */ get color() {\n            return this._color;\n        }\n        set color(v) {\n            var _a;\n            this._color = v.clone();\n            const defaultLayer = this.graphics.layers.default;\n            const currentGraphic = (_a = defaultLayer.graphics[0]) === null || _a === void 0 ? void 0 : _a.graphic;\n            if (currentGraphic instanceof Raster || currentGraphic instanceof Text) currentGraphic.color = this._color;\n        }\n        /**\r\n     * `onInitialize` is called before the first update of the actor. This method is meant to be\r\n     * overridden. This is where initialization of child actors should take place.\r\n     *\r\n     * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n     */ onInitialize(_engine) {\n        // Override me\n        }\n        /**\r\n     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n     *\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * @internal\r\n     */ _initialize(engine) {\n            super._initialize(engine);\n            for (const child of this.children)child._initialize(engine);\n        }\n        on(eventName, handler) {\n            super.on(eventName, handler);\n        }\n        once(eventName, handler) {\n            super.once(eventName, handler);\n        }\n        off(eventName, handler) {\n            super.off(eventName, handler);\n        }\n        // #endregion\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _prekill handler for [[onPreKill]] lifecycle event\r\n     * @internal\r\n     */ _prekill(_scene) {\n            super.emit(\"prekill\", new PreKillEvent(this));\n            this.onPreKill(_scene);\n        }\n        /**\r\n     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`\r\n     *\r\n     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].\r\n     */ onPreKill(_scene) {\n        // Override me\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _prekill handler for [[onPostKill]] lifecycle event\r\n     * @internal\r\n     */ _postkill(_scene) {\n            super.emit(\"postkill\", new PostKillEvent(this));\n            this.onPostKill(_scene);\n        }\n        /**\r\n     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`\r\n     *\r\n     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].\r\n     */ onPostKill(_scene) {\n        // Override me\n        }\n        /**\r\n     * If the current actor is a member of the scene, this will remove\r\n     * it from the scene graph. It will no longer be drawn or updated.\r\n     */ kill() {\n            if (this.scene) {\n                this._prekill(this.scene);\n                this.emit(\"kill\", new KillEvent(this));\n                super.kill();\n                this._postkill(this.scene);\n            } else this.logger.warn(\"Cannot kill actor, it was never added to the Scene\");\n        }\n        /**\r\n     * If the current actor is killed, it will now not be killed.\r\n     */ unkill() {\n            this.active = true;\n        }\n        /**\r\n     * Indicates wether the actor has been killed.\r\n     */ isKilled() {\n            return !this.active;\n        }\n        /**\r\n     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n     * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n     */ get z() {\n            return this.get(TransformComponent).z;\n        }\n        /**\r\n     * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n     * The z-index determines the relative order an actor is drawn in.\r\n     * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n     * @param newZ new z-index to assign\r\n     */ set z(newZ) {\n            this.get(TransformComponent).z = newZ;\n        }\n        /**\r\n     * Get the center point of an actor (global position)\r\n     */ get center() {\n            const globalPos = this.getGlobalPos();\n            return new Vector(globalPos.x + this.width / 2 - this.anchor.x * this.width, globalPos.y + this.height / 2 - this.anchor.y * this.height);\n        }\n        /**\r\n     * Get the local center point of an actor\r\n     */ get localCenter() {\n            return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);\n        }\n        get width() {\n            return this.collider.localBounds.width * this.getGlobalScale().x;\n        }\n        get height() {\n            return this.collider.localBounds.height * this.getGlobalScale().y;\n        }\n        /**\r\n     * Gets this actor's rotation taking into account any parent relationships\r\n     *\r\n     * @returns Rotation angle in radians\r\n     */ getGlobalRotation() {\n            return this.get(TransformComponent).globalRotation;\n        }\n        /**\r\n     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation\r\n     *\r\n     * @returns Position in world coordinates\r\n     */ getGlobalPos() {\n            return this.get(TransformComponent).globalPos;\n        }\n        /**\r\n     * Gets the global scale of the Actor\r\n     */ getGlobalScale() {\n            return this.get(TransformComponent).globalScale;\n        }\n        // #region Collision\n        /**\r\n     * Tests whether the x/y specified are contained in the actor\r\n     * @param x  X coordinate to test (in world coordinates)\r\n     * @param y  Y coordinate to test (in world coordinates)\r\n     * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n     */ contains(x, y, recurse = false) {\n            const point = vec(x, y);\n            const collider = this.get(ColliderComponent);\n            collider.update();\n            const geom = collider.get();\n            if (!geom) return false;\n            const containment = geom.contains(point);\n            if (recurse) return containment || this.children.some((child)=>{\n                return child.contains(x, y, true);\n            });\n            return containment;\n        }\n        /**\r\n     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other\r\n     * @param actor     Actor to test\r\n     * @param distance  Distance in pixels to test\r\n     */ within(actor, distance) {\n            const collider = this.get(ColliderComponent);\n            const otherCollider = actor.get(ColliderComponent);\n            const me = collider.get();\n            const other = otherCollider.get();\n            if (me && other) return me.getClosestLineBetween(other).getLength() <= distance;\n            return false;\n        }\n        // #endregion\n        // #region Update\n        /**\r\n     * Called by the Engine, updates the state of the actor\r\n     * @internal\r\n     * @param engine The reference to the current game engine\r\n     * @param delta  The time elapsed since the last update in milliseconds\r\n     */ update(engine, delta) {\n            this._initialize(engine);\n            this._preupdate(engine, delta);\n            this._postupdate(engine, delta);\n        }\n        /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before an actor is updated.\r\n     */ onPreUpdate(_engine, _delta) {\n        // Override me\n        }\n        /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after an actor is updated.\r\n     */ onPostUpdate(_engine, _delta) {\n        // Override me\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */ _preupdate(engine, delta) {\n            this.emit(\"preupdate\", new PreUpdateEvent(engine, delta, this));\n            this.onPreUpdate(engine, delta);\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */ _postupdate(engine, delta) {\n            this.emit(\"postupdate\", new PreUpdateEvent(engine, delta, this));\n            this.onPostUpdate(engine, delta);\n        }\n    }\n    // #region Properties\n    /**\r\n * Set defaults for all Actors\r\n */ Actor.defaults = {\n        anchor: Vector.Half\n    };\n    /**\r\n * Type guard to detect a screen element\r\n */ function isScreenElement(actor) {\n        return actor instanceof ScreenElement;\n    }\n    /**\r\n * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does\r\n * not participate in collisions. Drawn on top of all other actors.\r\n */ class ScreenElement extends Actor {\n        constructor(config){\n            super({\n                ...config\n            });\n            this.get(TransformComponent).coordPlane = CoordPlane.Screen;\n            this.anchor = vec(0, 0);\n            this.body.collisionType = CollisionType.PreventCollision;\n            this.collider.useBoxCollider(this.width, this.height, this.anchor);\n        }\n        _initialize(engine) {\n            this._engine = engine;\n            super._initialize(engine);\n        }\n        contains(x, y, useWorld = true) {\n            if (useWorld) return super.contains(x, y);\n            const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));\n            return super.contains(coords.x, coords.y);\n        }\n    }\n    /**\r\n * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n * after a certain interval, optionally repeating.\r\n */ class Timer {\n        constructor(fcn, interval, repeats, numberOfRepeats, randomRange, random){\n            this._logger = Logger.getInstance();\n            this.id = 0;\n            this._elapsedTime = 0;\n            this._totalTimeAlive = 0;\n            this._running = false;\n            this._numberOfTicks = 0;\n            this.interval = 10;\n            this.repeats = false;\n            this.maxNumberOfRepeats = -1;\n            this.randomRange = [\n                0,\n                0\n            ];\n            this._baseInterval = 10;\n            this._generateRandomInterval = ()=>{\n                return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);\n            };\n            this._complete = false;\n            this.scene = null;\n            if (typeof fcn !== \"function\") {\n                const options = fcn;\n                fcn = options.fcn;\n                interval = options.interval;\n                repeats = options.repeats;\n                numberOfRepeats = options.numberOfRepeats;\n                randomRange = options.randomRange;\n                random = options.random;\n            }\n            if (!!numberOfRepeats && numberOfRepeats >= 0) {\n                this.maxNumberOfRepeats = numberOfRepeats;\n                if (!repeats) throw new Error(\"repeats must be set to true if numberOfRepeats is set\");\n            }\n            this.id = Timer._MAX_ID++;\n            this._callbacks = [];\n            this._baseInterval = this.interval = interval;\n            if (!!randomRange) {\n                if (randomRange[0] > randomRange[1]) throw new Error(\"min value must be lower than max value for range\");\n                //We use the instance of ex.Random to generate the range\n                this.random = random !== null && random !== void 0 ? random : new Random();\n                this.randomRange = randomRange;\n                this.interval = this._generateRandomInterval();\n                this.on(()=>{\n                    this.interval = this._generateRandomInterval();\n                });\n            }\n            this.repeats = repeats || this.repeats;\n            if (fcn) this.on(fcn);\n        }\n        get complete() {\n            return this._complete;\n        }\n        /**\r\n     * Adds a new callback to be fired after the interval is complete\r\n     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.\r\n     */ on(fcn) {\n            this._callbacks.push(fcn);\n        }\n        /**\r\n     * Removes a callback from the callback list to be fired after the interval is complete.\r\n     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.\r\n     */ off(fcn) {\n            const index = this._callbacks.indexOf(fcn);\n            this._callbacks.splice(index, 1);\n        }\n        /**\r\n     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n     * @param delta  Number of elapsed milliseconds since the last update.\r\n     */ update(delta) {\n            if (this._running) {\n                this._totalTimeAlive += delta;\n                this._elapsedTime += delta;\n                if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {\n                    this._complete = true;\n                    this._running = false;\n                    this._elapsedTime = 0;\n                }\n                if (!this.complete && this._elapsedTime >= this.interval) {\n                    this._callbacks.forEach((c)=>{\n                        c.call(this);\n                    });\n                    this._numberOfTicks++;\n                    if (this.repeats) this._elapsedTime = 0;\n                    else {\n                        this._complete = true;\n                        this._running = false;\n                        this._elapsedTime = 0;\n                    }\n                }\n            }\n        }\n        /**\r\n     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n     *\r\n     * Warning** you may need to call `timer.start()` again if the timer had completed\r\n     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes\r\n     */ reset(newInterval, newNumberOfRepeats) {\n            if (!!newInterval && newInterval >= 0) this._baseInterval = this.interval = newInterval;\n            if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {\n                this.maxNumberOfRepeats = newNumberOfRepeats;\n                if (!this.repeats) throw new Error(\"repeats must be set to true if numberOfRepeats is set\");\n            }\n            this._complete = false;\n            this._elapsedTime = 0;\n            this._numberOfTicks = 0;\n        }\n        get timesRepeated() {\n            return this._numberOfTicks;\n        }\n        getTimeRunning() {\n            return this._totalTimeAlive;\n        }\n        /**\r\n     * @returns milliseconds until the next action callback, if complete will return 0\r\n     */ get timeToNextAction() {\n            if (this.complete) return 0;\n            return this.interval - this._elapsedTime;\n        }\n        /**\r\n     * @returns milliseconds elapsed toward the next action\r\n     */ get timeElapsedTowardNextAction() {\n            return this._elapsedTime;\n        }\n        get isRunning() {\n            return this._running;\n        }\n        /**\r\n     * Pauses the timer, time will no longer increment towards the next call\r\n     */ pause() {\n            this._running = false;\n            return this;\n        }\n        /**\r\n     * Resumes the timer, time will now increment towards the next call.\r\n     */ resume() {\n            this._running = true;\n            return this;\n        }\n        /**\r\n     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter\r\n     */ start() {\n            if (!this.scene) this._logger.warn(\"Cannot start a timer not part of a scene, timer wont start until added\");\n            this._running = true;\n            if (this.complete) {\n                this._complete = false;\n                this._elapsedTime = 0;\n                this._numberOfTicks = 0;\n            }\n            return this;\n        }\n        /**\r\n     * Stops the timer and resets the elapsed time counter towards the next action invocation\r\n     */ stop() {\n            this._running = false;\n            this._elapsedTime = 0;\n            this._numberOfTicks = 0;\n            return this;\n        }\n        /**\r\n     * Cancels the timer, preventing any further executions.\r\n     */ cancel() {\n            this.pause();\n            if (this.scene) this.scene.cancelTimer(this);\n        }\n    }\n    Timer._MAX_ID = 0;\n    class ParallaxComponent extends Component {\n        constructor(parallaxFactor){\n            super();\n            this.type = \"ex.parallax\";\n            this.parallaxFactor = vec(1.0, 1.0);\n            this.parallaxFactor = parallaxFactor !== null && parallaxFactor !== void 0 ? parallaxFactor : this.parallaxFactor;\n        }\n    }\n    /**\r\n * Provide arbitrary drawing for the purposes of debugging your game\r\n *\r\n * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]\r\n *\r\n */ class DebugGraphicsComponent extends Component {\n        constructor(draw, useTransform = true){\n            super();\n            this.draw = draw;\n            this.useTransform = useTransform;\n            this.type = \"ex.debuggraphics\";\n        }\n    }\n    /**\r\n * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.\r\n *\r\n * TileMaps are useful for top down or side scrolling grid oriented games.\r\n */ class TileMap extends Entity {\n        /**\r\n     * @param options\r\n     */ constructor(options){\n            var _a, _b;\n            super(null, options.name);\n            this._token = 0;\n            this._onScreenXStart = 0;\n            this._onScreenXEnd = Number.MAX_VALUE;\n            this._onScreenYStart = 0;\n            this._onScreenYEnd = Number.MAX_VALUE;\n            this.logger = Logger.getInstance();\n            this.tiles = [];\n            this._rows = [];\n            this._cols = [];\n            this.renderFromTopOfGraphic = false;\n            this._collidersDirty = true;\n            this._originalOffsets = new WeakMap();\n            this.addComponent(new TransformComponent());\n            this.addComponent(new MotionComponent());\n            this.addComponent(new BodyComponent({\n                type: CollisionType.Fixed\n            }));\n            this.addComponent(new GraphicsComponent({\n                onPostDraw: (ctx, delta)=>this.draw(ctx, delta)\n            }));\n            this.addComponent(new DebugGraphicsComponent((ctx)=>this.debug(ctx)));\n            this.addComponent(new ColliderComponent());\n            this._graphics = this.get(GraphicsComponent);\n            this._transform = this.get(TransformComponent);\n            this._motion = this.get(MotionComponent);\n            this._collider = this.get(ColliderComponent);\n            this._composite = this._collider.useCompositeCollider([]);\n            this._transform.pos = (_a = options.pos) !== null && _a !== void 0 ? _a : Vector.Zero;\n            this._oldPos = this._transform.pos;\n            this.renderFromTopOfGraphic = (_b = options.renderFromTopOfGraphic) !== null && _b !== void 0 ? _b : this.renderFromTopOfGraphic;\n            this.tileWidth = options.tileWidth;\n            this.tileHeight = options.tileHeight;\n            this.rows = options.rows;\n            this.columns = options.columns;\n            this.tiles = new Array(this.rows * this.columns);\n            this._rows = new Array(this.rows);\n            this._cols = new Array(this.columns);\n            let currentCol = [];\n            for(let i = 0; i < this.columns; i++){\n                for(let j = 0; j < this.rows; j++){\n                    const cd = new Tile({\n                        x: i,\n                        y: j,\n                        map: this\n                    });\n                    cd.map = this;\n                    this.tiles[i + j * this.columns] = cd;\n                    currentCol.push(cd);\n                    if (!this._rows[j]) this._rows[j] = [];\n                    this._rows[j].push(cd);\n                }\n                this._cols[i] = currentCol;\n                currentCol = [];\n            }\n            this._graphics.localBounds = new BoundingBox({\n                left: 0,\n                top: 0,\n                right: this.columns * this.tileWidth,\n                bottom: this.rows * this.tileHeight\n            });\n        }\n        flagCollidersDirty() {\n            this._collidersDirty = true;\n        }\n        get x() {\n            var _a;\n            return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;\n        }\n        set x(val) {\n            var _a;\n            if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) this.get(TransformComponent).pos = vec(val, this.y);\n        }\n        get y() {\n            var _a, _b;\n            return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;\n        }\n        set y(val) {\n            var _a;\n            if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) this._transform.pos = vec(this.x, val);\n        }\n        get z() {\n            var _a;\n            return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;\n        }\n        set z(val) {\n            if (this._transform) this._transform.z = val;\n        }\n        get rotation() {\n            var _a, _b;\n            return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;\n        }\n        set rotation(val) {\n            var _a;\n            if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) this._transform.rotation = val;\n        }\n        get scale() {\n            var _a, _b;\n            return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;\n        }\n        set scale(val) {\n            var _a;\n            if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) this._transform.scale = val;\n        }\n        get pos() {\n            return this._transform.pos;\n        }\n        set pos(val) {\n            this._transform.pos = val;\n        }\n        get vel() {\n            return this._motion.vel;\n        }\n        set vel(val) {\n            this._motion.vel = val;\n        }\n        on(eventName, handler) {\n            super.on(eventName, handler);\n        }\n        _initialize(engine) {\n            super._initialize(engine);\n        }\n        _getOrSetColliderOriginalOffset(collider) {\n            if (!this._originalOffsets.has(collider)) {\n                const originalOffset = collider.offset;\n                this._originalOffsets.set(collider, originalOffset);\n                return originalOffset;\n            } else return this._originalOffsets.get(collider);\n        }\n        /**\r\n     * Tiles colliders based on the solid tiles in the tilemap.\r\n     */ _updateColliders() {\n            this._composite.clearColliders();\n            const colliders = [];\n            this._composite = this._collider.useCompositeCollider([]);\n            let current;\n            // Bad square tesselation algo\n            for(let i = 0; i < this.columns; i++){\n                // Scan column for colliders\n                for(let j = 0; j < this.rows; j++){\n                    // Columns start with a new collider\n                    if (j === 0) current = null;\n                    const tile = this.tiles[i + j * this.columns];\n                    // Current tile in column is solid build up current collider\n                    if (tile.solid) {\n                        // Use custom collider otherwise bounding box\n                        if (tile.getColliders().length > 0) {\n                            for (const collider of tile.getColliders()){\n                                const originalOffset = this._getOrSetColliderOriginalOffset(collider);\n                                collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);\n                                collider.owner = this;\n                                this._composite.addCollider(collider);\n                            }\n                            current = null;\n                        } else if (!current) current = tile.bounds;\n                        else current = current.combine(tile.bounds);\n                    } else {\n                        // Not solid skip and cut off the current collider\n                        if (current) colliders.push(current);\n                        current = null;\n                    }\n                }\n                // After a column is complete check to see if it can be merged into the last one\n                if (current) {\n                    // if previous is the same combine it\n                    const prev = colliders[colliders.length - 1];\n                    if (prev && prev.top === current.top && prev.bottom === current.bottom) colliders[colliders.length - 1] = prev.combine(current);\n                    else // else new collider\n                    colliders.push(current);\n                }\n            }\n            for (const c of colliders){\n                const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));\n                collider.owner = this;\n                this._composite.addCollider(collider);\n            }\n            this._collider.update();\n        }\n        /**\r\n     * Returns the [[Tile]] by index (row major order)\r\n     */ getTileByIndex(index) {\n            return this.tiles[index];\n        }\n        /**\r\n     * Returns the [[Tile]] by its x and y integer coordinates\r\n     */ getTile(x, y) {\n            if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) return null;\n            return this.tiles[x + y * this.columns];\n        }\n        /**\r\n     * Returns the [[Tile]] by testing a point in world coordinates,\r\n     * returns `null` if no Tile was found.\r\n     */ getTileByPoint(point) {\n            const x = Math.floor((point.x - this.pos.x) / this.tileWidth);\n            const y = Math.floor((point.y - this.pos.y) / this.tileHeight);\n            const tile = this.getTile(x, y);\n            if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) return tile;\n            return null;\n        }\n        getRows() {\n            return this._rows;\n        }\n        getColumns() {\n            return this._cols;\n        }\n        update(engine, delta) {\n            this.onPreUpdate(engine, delta);\n            this.emit(\"preupdate\", new PreUpdateEvent(engine, delta, this));\n            if (!this._oldPos.equals(this.pos)) {\n                this.flagCollidersDirty();\n                for(let i = 0; i < this.tiles.length; i++)if (this.tiles[i]) this.tiles[i].flagDirty();\n            }\n            if (this._collidersDirty) {\n                this._collidersDirty = false;\n                this._updateColliders();\n            }\n            this._token++;\n            const worldBounds = engine.getWorldBounds();\n            const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);\n            const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);\n            let pos = this.pos;\n            const maybeParallax = this.get(ParallaxComponent);\n            let parallaxOffset = Vector.One;\n            if (maybeParallax) {\n                const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\n                parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);\n                pos = pos.add(parallaxOffset);\n            }\n            this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);\n            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);\n            this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);\n            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);\n            // why are we resetting pos?\n            this._transform.pos = vec(this.x, this.y);\n            this.onPostUpdate(engine, delta);\n            this.emit(\"postupdate\", new PostUpdateEvent(engine, delta, this));\n        }\n        /**\r\n     * Draws the tile map to the screen. Called by the [[Scene]].\r\n     * @param ctx ExcaliburGraphicsContext\r\n     * @param delta  The number of milliseconds since the last draw\r\n     */ draw(ctx, delta) {\n            this.emit(\"predraw\", new PreDrawEvent(ctx, delta, this)); // TODO fix event\n            let x = this._onScreenXStart;\n            const xEnd = Math.min(this._onScreenXEnd, this.columns);\n            let y = this._onScreenYStart;\n            const yEnd = Math.min(this._onScreenYEnd, this.rows);\n            let graphics, graphicsIndex, graphicsLen;\n            for(x; x < xEnd; x++){\n                for(y; y < yEnd; y++){\n                    // get non-negative tile sprites\n                    graphics = this.getTile(x, y).getGraphics();\n                    for(graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++){\n                        // draw sprite, warning if sprite doesn't exist\n                        const graphic = graphics[graphicsIndex];\n                        if (graphic) {\n                            if (hasGraphicsTick(graphic)) graphic === null || graphic === void 0 || graphic.tick(delta, this._token);\n                            const offsetY = this.renderFromTopOfGraphic ? 0 : graphic.height - this.tileHeight;\n                            graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight - offsetY);\n                        }\n                    }\n                }\n                y = this._onScreenYStart;\n            }\n            this.emit(\"postdraw\", new PostDrawEvent(ctx, delta, this));\n        }\n        debug(gfx) {\n            const width = this.tileWidth * this.columns;\n            const height = this.tileHeight * this.rows;\n            const pos = Vector.Zero;\n            for(let r = 0; r < this.rows + 1; r++){\n                const yOffset = vec(0, r * this.tileHeight);\n                gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);\n            }\n            for(let c = 0; c < this.columns + 1; c++){\n                const xOffset = vec(c * this.tileWidth, 0);\n                gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);\n            }\n            const colliders = this._composite.getColliders();\n            for (const collider of colliders){\n                const grayish = Color.Gray;\n                grayish.a = 0.5;\n                const bounds = collider.localBounds;\n                const pos = collider.worldPos.sub(this.pos);\n                gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);\n            }\n        }\n    }\n    /**\r\n * TileMap Tile\r\n *\r\n * A light-weight object that occupies a space in a collision map. Generally\r\n * created by a [[TileMap]].\r\n *\r\n * Tiles can draw multiple sprites. Note that the order of drawing is the order\r\n * of the sprites in the array so the last one will be drawn on top. You can\r\n * use transparency to create layers this way.\r\n */ class Tile extends Entity {\n        constructor(options){\n            var _a, _b;\n            super();\n            this._posDirty = false;\n            this._solid = false;\n            this._graphics = [];\n            /**\r\n         * Current list of colliders for this tile\r\n         */ this._colliders = [];\n            /**\r\n         * Arbitrary data storage per tile, useful for any game specific data\r\n         */ this.data = new Map();\n            this.x = options.x;\n            this.y = options.y;\n            this.map = options.map;\n            this.width = options.map.tileWidth;\n            this.height = options.map.tileHeight;\n            this.solid = (_a = options.solid) !== null && _a !== void 0 ? _a : this.solid;\n            this._graphics = (_b = options.graphics) !== null && _b !== void 0 ? _b : [];\n            this._recalculate();\n        }\n        // private _transform: TransformComponent;\n        /**\r\n     * Return the world position of the top left corner of the tile\r\n     */ get pos() {\n            if (this._posDirty) {\n                this._recalculate();\n                this._posDirty = false;\n            }\n            return this._pos;\n        }\n        /**\r\n     * Wether this tile should be treated as solid by the tilemap\r\n     */ get solid() {\n            return this._solid;\n        }\n        /**\r\n     * Wether this tile should be treated as solid by the tilemap\r\n     */ set solid(val) {\n            var _a;\n            (_a = this.map) === null || _a === void 0 || _a.flagCollidersDirty();\n            this._solid = val;\n        }\n        /**\r\n     * Current list of graphics for this tile\r\n     */ getGraphics() {\n            return this._graphics;\n        }\n        /**\r\n     * Add another [[Graphic]] to this TileMap tile\r\n     * @param graphic\r\n     */ addGraphic(graphic) {\n            this._graphics.push(graphic);\n        }\n        /**\r\n     * Remove an instance of a [[Graphic]] from this tile\r\n     */ removeGraphic(graphic) {\n            removeItemFromArray(graphic, this._graphics);\n        }\n        /**\r\n     * Clear all graphics from this tile\r\n     */ clearGraphics() {\n            this._graphics.length = 0;\n        }\n        /**\r\n     * Returns the list of colliders\r\n     */ getColliders() {\n            return this._colliders;\n        }\n        /**\r\n     * Adds a custom collider to the [[Tile]] to use instead of it's bounds\r\n     *\r\n     * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.\r\n     *\r\n     * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n     * @param collider\r\n     */ addCollider(collider) {\n            this._colliders.push(collider);\n            this.map.flagCollidersDirty();\n        }\n        /**\r\n     * Removes a collider from the [[Tile]]\r\n     * @param collider\r\n     */ removeCollider(collider) {\n            const index = this._colliders.indexOf(collider);\n            if (index > -1) this._colliders.splice(index, 1);\n            this.map.flagCollidersDirty();\n        }\n        /**\r\n     * Clears all colliders from the [[Tile]]\r\n     */ clearColliders() {\n            this._colliders.length = 0;\n            this.map.flagCollidersDirty();\n        }\n        flagDirty() {\n            return this._posDirty = true;\n        }\n        _recalculate() {\n            this._pos = this.map.pos.add(vec(this.x * this.map.tileWidth, this.y * this.map.tileHeight));\n            this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);\n            this._posDirty = false;\n        }\n        get bounds() {\n            if (this._posDirty) this._recalculate();\n            return this._bounds;\n        }\n        get center() {\n            if (this._posDirty) this._recalculate();\n            return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);\n        }\n    }\n    /**\r\n * Container to house convenience strategy methods\r\n * @internal\r\n */ class StrategyContainer {\n        constructor(camera){\n            this.camera = camera;\n        }\n        /**\r\n     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n     * @param actor The actor to lock the camera to\r\n     */ lockToActor(actor) {\n            this.camera.addStrategy(new LockCameraToActorStrategy(actor));\n        }\n        /**\r\n     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n     * @param actor The actor to lock the camera to\r\n     * @param axis The axis to follow the actor on\r\n     */ lockToActorAxis(actor, axis) {\n            this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\n        }\n        /**\r\n     * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n     * correct and bounce around the target\r\n     *\r\n     * @param actor Target actor to elastically follow\r\n     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n     */ elasticToActor(actor, cameraElasticity, cameraFriction) {\n            this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\n        }\n        /**\r\n     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n     * @param actor Target actor to follow when it is \"radius\" pixels away\r\n     * @param radius Number of pixels away before the camera will follow\r\n     */ radiusAroundActor(actor, radius) {\n            this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\n        }\n        /**\r\n     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera\r\n     * @param box The bounding box to limit the camera to.\r\n     */ limitCameraBounds(box) {\n            this.camera.addStrategy(new LimitCameraBoundsStrategy(box));\n        }\n    }\n    /**\r\n * Camera axis enum\r\n */ var Axis;\n    (function(Axis) {\n        Axis[Axis[\"X\"] = 0] = \"X\";\n        Axis[Axis[\"Y\"] = 1] = \"Y\";\n    })(Axis || (Axis = {}));\n    /**\r\n * Lock a camera to the exact x/y position of an actor.\r\n */ class LockCameraToActorStrategy {\n        constructor(target){\n            this.target = target;\n            this.action = (target, _cam, _eng, _delta)=>{\n                const center = target.center;\n                return center;\n            };\n        }\n    }\n    /**\r\n * Lock a camera to a specific axis around an actor.\r\n */ class LockCameraToActorAxisStrategy {\n        constructor(target, axis){\n            this.target = target;\n            this.axis = axis;\n            this.action = (target, cam, _eng, _delta)=>{\n                const center = target.center;\n                const currentFocus = cam.getFocus();\n                if (this.axis === Axis.X) return new Vector(center.x, currentFocus.y);\n                else return new Vector(currentFocus.x, center.y);\n            };\n        }\n    }\n    /**\r\n * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.\r\n */ class ElasticToActorStrategy {\n        /**\r\n     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n     * correct and bounce around the target\r\n     *\r\n     * @param target Target actor to elastically follow\r\n     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n     */ constructor(target, cameraElasticity, cameraFriction){\n            this.target = target;\n            this.cameraElasticity = cameraElasticity;\n            this.cameraFriction = cameraFriction;\n            this.action = (target, cam, _eng, _delta)=>{\n                const position = target.center;\n                let focus = cam.getFocus();\n                let cameraVel = cam.vel.clone();\n                // Calculate the stretch vector, using the spring equation\n                // F = kX\n                // https://en.wikipedia.org/wiki/Hooke's_law\n                // Apply to the current camera velocity\n                const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X\n                cameraVel = cameraVel.add(stretch);\n                // Calculate the friction (-1 to apply a force in the opposition of motion)\n                // Apply to the current camera velocity\n                const friction = cameraVel.scale(-1).scale(this.cameraFriction);\n                cameraVel = cameraVel.add(friction);\n                // Update position by velocity deltas\n                focus = focus.add(cameraVel);\n                return focus;\n            };\n        }\n    }\n    class RadiusAroundActorStrategy {\n        /**\r\n     *\r\n     * @param target Target actor to follow when it is \"radius\" pixels away\r\n     * @param radius Number of pixels away before the camera will follow\r\n     */ constructor(target, radius){\n            this.target = target;\n            this.radius = radius;\n            this.action = (target, cam, _eng, _delta)=>{\n                const position = target.center;\n                const focus = cam.getFocus();\n                const direction = position.sub(focus);\n                const distance = direction.size;\n                if (distance >= this.radius) {\n                    const offset = distance - this.radius;\n                    return focus.add(direction.normalize().scale(offset));\n                }\n                return focus;\n            };\n        }\n    }\n    /**\r\n * Prevent a camera from going beyond the given camera dimensions.\r\n */ class LimitCameraBoundsStrategy {\n        constructor(target){\n            this.target = target;\n            /**\r\n         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.\r\n         *\r\n         * Note that this strategy does not perform any movement by itself.\r\n         * It only sets the camera position to within the given bounds when the camera has gone beyond them.\r\n         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.\r\n         *\r\n         * Make sure that the camera bounds are at least as large as the viewport size.\r\n         *\r\n         * @param target The bounding box to limit the camera to\r\n         */ this.boundSizeChecked = false; // Check and warn only once\n            this.action = (target, cam, _eng, _delta)=>{\n                const focus = cam.getFocus();\n                if (!this.boundSizeChecked) {\n                    if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) Logger.getInstance().warn(\"Camera bounds should not be smaller than the engine viewport\");\n                    this.boundSizeChecked = true;\n                }\n                let focusX = focus.x;\n                let focusY = focus.y;\n                if (focus.x < target.left + _eng.halfDrawWidth) focusX = target.left + _eng.halfDrawWidth;\n                else if (focus.x > target.right - _eng.halfDrawWidth) focusX = target.right - _eng.halfDrawWidth;\n                if (focus.y < target.top + _eng.halfDrawHeight) focusY = target.top + _eng.halfDrawHeight;\n                else if (focus.y > target.bottom - _eng.halfDrawHeight) focusY = target.bottom - _eng.halfDrawHeight;\n                return vec(focusX, focusY);\n            };\n        }\n    }\n    /**\r\n * Cameras\r\n *\r\n * [[Camera]] is the base class for all Excalibur cameras. Cameras are used\r\n * to move around your game and set focus. They are used to determine\r\n * what is \"off screen\" and can be used to scale the game.\r\n *\r\n */ class Camera extends Class {\n        constructor(){\n            super(...arguments);\n            this.transform = AffineMatrix.identity();\n            this.inverse = AffineMatrix.identity();\n            this._cameraStrategies = [];\n            this.strategy = new StrategyContainer(this);\n            /**\r\n         * Get or set current zoom of the camera, defaults to 1\r\n         */ this._z = 1;\n            /**\r\n         * Get or set rate of change in zoom, defaults to 0\r\n         */ this.dz = 0;\n            /**\r\n         * Get or set zoom acceleration\r\n         */ this.az = 0;\n            /**\r\n         * Current rotation of the camera\r\n         */ this.rotation = 0;\n            this._angularVelocity = 0;\n            /**\r\n         * Get or set the camera's position\r\n         */ this._posChanged = false;\n            this._pos = watchAny(Vector.Zero, ()=>this._posChanged = true);\n            /**\r\n         * Get or set the camera's velocity\r\n         */ this.vel = Vector.Zero;\n            /**\r\n         * Get or set the camera's acceleration\r\n         */ this.acc = Vector.Zero;\n            this._cameraMoving = false;\n            this._currentLerpTime = 0;\n            this._lerpDuration = 1000; // 1 second\n            this._lerpStart = null;\n            this._lerpEnd = null;\n            //camera effects\n            this._isShaking = false;\n            this._shakeMagnitudeX = 0;\n            this._shakeMagnitudeY = 0;\n            this._shakeDuration = 0;\n            this._elapsedShakeTime = 0;\n            this._xShake = 0;\n            this._yShake = 0;\n            this._isZooming = false;\n            this._zoomStart = 1;\n            this._zoomEnd = 1;\n            this._currentZoomTime = 0;\n            this._zoomDuration = 0;\n            this._zoomEasing = EasingFunctions.EaseInOutCubic;\n            this._easing = EasingFunctions.EaseInOutCubic;\n            this._halfWidth = 0;\n            this._halfHeight = 0;\n            this._viewport = null;\n            this._isInitialized = false;\n        }\n        get zoom() {\n            return this._z;\n        }\n        set zoom(val) {\n            this._z = val;\n            if (this._engine) {\n                this._halfWidth = this._engine.halfDrawWidth;\n                this._halfHeight = this._engine.halfDrawHeight;\n            }\n        }\n        /**\r\n     * Get or set the camera's angular velocity\r\n     */ get angularVelocity() {\n            return this._angularVelocity;\n        }\n        set angularVelocity(value) {\n            this._angularVelocity = value;\n        }\n        get pos() {\n            return this._pos;\n        }\n        set pos(vec) {\n            this._pos = watchAny(vec, ()=>this._posChanged = true);\n            this._posChanged = true;\n        }\n        /**\r\n     * Get the camera's x position\r\n     */ get x() {\n            return this.pos.x;\n        }\n        /**\r\n     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)\r\n     */ set x(value) {\n            if (!this._follow && !this._cameraMoving) this.pos = vec(value, this.pos.y);\n        }\n        /**\r\n     * Get the camera's y position\r\n     */ get y() {\n            return this.pos.y;\n        }\n        /**\r\n     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)\r\n     */ set y(value) {\n            if (!this._follow && !this._cameraMoving) this.pos = vec(this.pos.x, value);\n        }\n        /**\r\n     * Get or set the camera's x velocity\r\n     */ get dx() {\n            return this.vel.x;\n        }\n        set dx(value) {\n            this.vel = vec(value, this.vel.y);\n        }\n        /**\r\n     * Get or set the camera's y velocity\r\n     */ get dy() {\n            return this.vel.y;\n        }\n        set dy(value) {\n            this.vel = vec(this.vel.x, value);\n        }\n        /**\r\n     * Get or set the camera's x acceleration\r\n     */ get ax() {\n            return this.acc.x;\n        }\n        set ax(value) {\n            this.acc = vec(value, this.acc.y);\n        }\n        /**\r\n     * Get or set the camera's y acceleration\r\n     */ get ay() {\n            return this.acc.y;\n        }\n        set ay(value) {\n            this.acc = vec(this.acc.x, value);\n        }\n        /**\r\n     * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n     */ getFocus() {\n            return this.pos;\n        }\n        /**\r\n     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n     *\r\n     * @param pos The target position to move to\r\n     * @param duration The duration in milliseconds the move should last\r\n     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.\r\n     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n     */ move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {\n            if (typeof easingFn !== \"function\") throw \"Please specify an EasingFunction\";\n            // cannot move when following an actor\n            if (this._follow) return Promise.reject(pos);\n            // resolve existing promise, if any\n            if (this._lerpPromise && this._lerpResolve) this._lerpResolve(pos);\n            this._lerpPromise = new Promise((resolve)=>{\n                this._lerpResolve = resolve;\n            });\n            this._lerpStart = this.getFocus().clone();\n            this._lerpDuration = duration;\n            this._lerpEnd = pos;\n            this._currentLerpTime = 0;\n            this._cameraMoving = true;\n            this._easing = easingFn;\n            return this._lerpPromise;\n        }\n        /**\r\n     * Sets the camera to shake at the specified magnitudes for the specified duration\r\n     * @param magnitudeX  The x magnitude of the shake\r\n     * @param magnitudeY  The y magnitude of the shake\r\n     * @param duration    The duration of the shake in milliseconds\r\n     */ shake(magnitudeX, magnitudeY, duration) {\n            this._isShaking = true;\n            this._shakeMagnitudeX = magnitudeX;\n            this._shakeMagnitudeY = magnitudeY;\n            this._shakeDuration = duration;\n        }\n        /**\r\n     * Zooms the camera in or out by the specified scale over the specified duration.\r\n     * If no duration is specified, it take effect immediately.\r\n     * @param scale    The scale of the zoom\r\n     * @param duration The duration of the zoom in milliseconds\r\n     */ zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {\n            this._zoomPromise = new Promise((resolve)=>{\n                this._zoomResolve = resolve;\n            });\n            if (duration) {\n                this._isZooming = true;\n                this._zoomEasing = easingFn;\n                this._currentZoomTime = 0;\n                this._zoomDuration = duration;\n                this._zoomStart = this.zoom;\n                this._zoomEnd = scale;\n            } else {\n                this._isZooming = false;\n                this.zoom = scale;\n                return Promise.resolve(true);\n            }\n            return this._zoomPromise;\n        }\n        /**\r\n     * Gets the bounding box of the viewport of this camera in world coordinates\r\n     */ get viewport() {\n            if (this._viewport) return this._viewport;\n            return new BoundingBox(0, 0, 0, 0);\n        }\n        /**\r\n     * Adds a new camera strategy to this camera\r\n     * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n     */ addStrategy(cameraStrategy) {\n            this._cameraStrategies.push(cameraStrategy);\n        }\n        /**\r\n     * Removes a camera strategy by reference\r\n     * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n     */ removeStrategy(cameraStrategy) {\n            removeItemFromArray(cameraStrategy, this._cameraStrategies);\n        }\n        /**\r\n     * Clears all camera strategies from the camera\r\n     */ clearAllStrategies() {\n            this._cameraStrategies.length = 0;\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */ _preupdate(engine, delta) {\n            this.emit(\"preupdate\", new PreUpdateEvent(engine, delta, this));\n            this.onPreUpdate(engine, delta);\n        }\n        /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before a scene is updated.\r\n     */ onPreUpdate(_engine, _delta) {\n        // Overridable\n        }\n        /**\r\n     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */ _postupdate(engine, delta) {\n            this.emit(\"postupdate\", new PostUpdateEvent(engine, delta, this));\n            this.onPostUpdate(engine, delta);\n        }\n        /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after a scene is updated.\r\n     */ onPostUpdate(_engine, _delta) {\n        // Overridable\n        }\n        get isInitialized() {\n            return this._isInitialized;\n        }\n        _initialize(_engine) {\n            if (!this.isInitialized) {\n                this._engine = _engine;\n                this._screen = _engine.screen;\n                const currentRes = this._screen.resolution;\n                let center = vec(currentRes.width / 2, currentRes.height / 2);\n                if (!this._engine.loadingComplete) {\n                    // If there was a loading screen, we peek the configured resolution\n                    const res = this._screen.peekResolution();\n                    if (res) center = vec(res.width / 2, res.height / 2);\n                }\n                this._halfWidth = center.x;\n                this._halfHeight = center.y;\n                // If the user has not set the camera pos, apply default center screen position\n                if (!this._posChanged) this.pos = center;\n                // First frame bootstrap\n                // Ensure camera tx is correct\n                // Run update twice to ensure properties are init'd\n                this.updateTransform();\n                // Run strategies for first frame\n                this.runStrategies(_engine, _engine.clock.elapsed());\n                // Setup the first frame viewport\n                this.updateViewport();\n                // It's important to update the camera after strategies\n                // This prevents jitter\n                this.updateTransform();\n                this.onInitialize(_engine);\n                super.emit(\"initialize\", new InitializeEvent(_engine, this));\n                this._isInitialized = true;\n            }\n        }\n        /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after a scene is updated.\r\n     */ onInitialize(_engine) {\n        // Overridable\n        }\n        on(eventName, handler) {\n            super.on(eventName, handler);\n        }\n        off(eventName, handler) {\n            super.off(eventName, handler);\n        }\n        once(eventName, handler) {\n            super.once(eventName, handler);\n        }\n        runStrategies(engine, delta) {\n            for (const s of this._cameraStrategies)this.pos = s.action.call(s, s.target, this, engine, delta);\n        }\n        updateViewport() {\n            // recalc viewport\n            this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);\n        }\n        update(_engine, delta) {\n            this._initialize(_engine);\n            this._preupdate(_engine, delta);\n            // Update placements based on linear algebra\n            this.pos = this.pos.add(this.vel.scale(delta / 1000));\n            this.zoom += this.dz * delta / 1000;\n            this.vel = this.vel.add(this.acc.scale(delta / 1000));\n            this.dz += this.az * delta / 1000;\n            this.rotation += this.angularVelocity * delta / 1000;\n            if (this._isZooming) {\n                if (this._currentZoomTime < this._zoomDuration) {\n                    const zoomEasing = this._zoomEasing;\n                    const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);\n                    this.zoom = newZoom;\n                    this._currentZoomTime += delta;\n                } else {\n                    this._isZooming = false;\n                    this.zoom = this._zoomEnd;\n                    this._currentZoomTime = 0;\n                    this._zoomResolve(true);\n                }\n            }\n            if (this._cameraMoving) {\n                if (this._currentLerpTime < this._lerpDuration) {\n                    const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);\n                    const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);\n                    this.pos = lerpPoint;\n                    this._currentLerpTime += delta;\n                } else {\n                    this.pos = this._lerpEnd;\n                    const end = this._lerpEnd.clone();\n                    this._lerpStart = null;\n                    this._lerpEnd = null;\n                    this._currentLerpTime = 0;\n                    this._cameraMoving = false;\n                    // Order matters here, resolve should be last so any chain promises have a clean slate\n                    this._lerpResolve(end);\n                }\n            }\n            if (this._isDoneShaking()) {\n                this._isShaking = false;\n                this._elapsedShakeTime = 0;\n                this._shakeMagnitudeX = 0;\n                this._shakeMagnitudeY = 0;\n                this._shakeDuration = 0;\n                this._xShake = 0;\n                this._yShake = 0;\n            } else {\n                this._elapsedShakeTime += delta;\n                this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;\n                this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;\n            }\n            this.runStrategies(_engine, delta);\n            this.updateViewport();\n            // It's important to update the camera after strategies\n            // This prevents jitter\n            this.updateTransform();\n            this._postupdate(_engine, delta);\n        }\n        /**\r\n     * Applies the relevant transformations to the game canvas to \"move\" or apply effects to the Camera\r\n     * @param ctx Canvas context to apply transformations\r\n     */ draw(ctx) {\n            ctx.multiply(this.transform);\n        }\n        updateTransform() {\n            // center the camera\n            const newCanvasWidth = this._screen.resolution.width / this.zoom;\n            const newCanvasHeight = this._screen.resolution.height / this.zoom;\n            const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);\n            // Calculate camera transform\n            this.transform.reset();\n            this.transform.scale(this.zoom, this.zoom);\n            this.transform.translate(cameraPos.x, cameraPos.y);\n            this.transform.inverse(this.inverse);\n        }\n        _isDoneShaking() {\n            return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;\n        }\n    }\n    const triggerDefaults = {\n        pos: Vector.Zero,\n        width: 10,\n        height: 10,\n        visible: false,\n        action: ()=>{\n            return;\n        },\n        filter: ()=>true,\n        repeat: -1\n    };\n    /**\r\n * Triggers are a method of firing arbitrary code on collision. These are useful\r\n * as 'buttons', 'switches', or to trigger effects in a game. By default triggers\r\n * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\r\n */ class Trigger extends Actor {\n        /**\r\n     *\r\n     * @param opts Trigger options\r\n     */ constructor(opts){\n            super({\n                x: opts.pos.x,\n                y: opts.pos.y,\n                width: opts.width,\n                height: opts.height\n            });\n            /**\r\n         * Action to fire when triggered by collision\r\n         */ this.action = ()=>{\n                return;\n            };\n            /**\r\n         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\r\n         * filter return true for the collided actor.\r\n         */ this.filter = ()=>true;\n            /**\r\n         * Number of times to repeat before killing the trigger,\r\n         */ this.repeat = -1;\n            opts = {\n                ...triggerDefaults,\n                ...opts\n            };\n            this.filter = opts.filter || this.filter;\n            this.repeat = opts.repeat || this.repeat;\n            this.action = opts.action || this.action;\n            if (opts.target) this.target = opts.target;\n            this.graphics.visible = opts.visible;\n            this.body.collisionType = CollisionType.Passive;\n            this.eventDispatcher = new EventDispatcher();\n            this.events.on(\"collisionstart\", (evt)=>{\n                if (this.filter(evt.other)) {\n                    this.emit(\"enter\", new EnterTriggerEvent(this, evt.other));\n                    this._dispatchAction();\n                    // remove trigger if its done, -1 repeat forever\n                    if (this.repeat === 0) this.kill();\n                }\n            });\n            this.events.on(\"collisionend\", (evt)=>{\n                if (this.filter(evt.other)) this.emit(\"exit\", new ExitTriggerEvent(this, evt.other));\n            });\n        }\n        set target(target) {\n            this._target = target;\n            this.filter = (actor)=>actor === target;\n        }\n        get target() {\n            return this._target;\n        }\n        _initialize(engine) {\n            super._initialize(engine);\n        }\n        _dispatchAction() {\n            if (this.repeat !== 0) {\n                this.action.call(this);\n                this.repeat--;\n            }\n        }\n    }\n    /**\r\n * Enum that determines whether to run the system in the update or draw phase\r\n */ var SystemType;\n    (function(SystemType) {\n        SystemType[\"Update\"] = \"update\";\n        SystemType[\"Draw\"] = \"draw\";\n    })(SystemType || (SystemType = {}));\n    /**\r\n * An Excalibur [[System]] that updates entities of certain types.\r\n * Systems are scene specific\r\n *\r\n * Excalibur Systems currently require at least 1 Component type to operated\r\n *\r\n * Multiple types are declared as a type union\r\n * For example:\r\n *\r\n * ```typescript\r\n * class MySystem extends System<ComponentA | ComponentB> {\r\n *   public readonly types = ['a', 'b'] as const;\r\n *   public readonly systemType = SystemType.Update;\r\n *   public update(entities: Entity<ComponentA | ComponentB>) {\r\n *      ...\r\n *   }\r\n * }\r\n * ```\r\n */ class System {\n        constructor(){\n            /**\r\n         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.\r\n         * For a system to execute before all other a lower priority value (-1 for example) must be set.\r\n         * For a system to execute after all other a higher priority value (10 for example) must be set.\r\n         */ this.priority = 0;\n        }\n        /**\r\n     * Systems observe when entities match their types or no longer match their types, override\r\n     * @param _entityAddedOrRemoved\r\n     */ notify(_entityAddedOrRemoved) {\n        // Override me\n        }\n    }\n    /**\r\n * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.\r\n */ class AddedEntity {\n        constructor(data){\n            this.data = data;\n            this.type = \"Entity Added\";\n        }\n    }\n    /**\r\n * Type guard to check for AddedEntity messages\r\n * @param x\r\n */ function isAddedSystemEntity(x) {\n        return !!x && x.type === \"Entity Added\";\n    }\n    /**\r\n * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.\r\n */ class RemovedEntity {\n        constructor(data){\n            this.data = data;\n            this.type = \"Entity Removed\";\n        }\n    }\n    /**\r\n * type guard to check for the RemovedEntity message\r\n */ function isRemoveSystemEntity(x) {\n        return !!x && x.type === \"Entity Removed\";\n    }\n    // Add/Remove entities and components\n    class EntityManager {\n        constructor(_world){\n            this._world = _world;\n            this.entities = [];\n            this._entityIndex = {};\n            this._entitiesToRemove = [];\n        }\n        /**\r\n     * Runs the entity lifecycle\r\n     * @param _context\r\n     */ updateEntities(_context, elapsed) {\n            for (const entity of this.entities){\n                // TODO is this right?\n                entity.update(_context.engine, elapsed);\n                if (!entity.active) this.removeEntity(entity);\n            }\n        }\n        findEntitiesForRemoval() {\n            for (const entity of this.entities)if (!entity.active) this.removeEntity(entity);\n        }\n        /**\r\n     * EntityManager observes changes on entities\r\n     * @param message\r\n     */ notify(message) {\n            if (isAddedComponent(message)) // we don't need the component, it's already on the entity\n            this._world.queryManager.addEntity(message.data.entity);\n            if (isRemovedComponent(message)) this._world.queryManager.removeComponent(message.data.entity, message.data.component);\n        }\n        /**\r\n     * Adds an entity to be tracked by the EntityManager\r\n     * @param entity\r\n     */ addEntity(entity) {\n            entity.active = true;\n            if (entity && !this._entityIndex[entity.id]) {\n                this._entityIndex[entity.id] = entity;\n                this.entities.push(entity);\n                this._world.queryManager.addEntity(entity);\n                entity.componentAdded$.register(this);\n                entity.componentRemoved$.register(this);\n                // if entity has children\n                entity.children.forEach((c)=>this.addEntity(c));\n                entity.childrenAdded$.register({\n                    notify: (e)=>{\n                        this.addEntity(e);\n                    }\n                });\n                entity.childrenRemoved$.register({\n                    notify: (e)=>{\n                        this.removeEntity(e, false);\n                    }\n                });\n            }\n        }\n        removeEntity(idOrEntity, deferred = true) {\n            var _a;\n            let id = 0;\n            if (idOrEntity instanceof Entity) id = idOrEntity.id;\n            else id = idOrEntity;\n            const entity = this._entityIndex[id];\n            if (entity && entity.active) entity.kill();\n            if (entity && deferred) {\n                this._entitiesToRemove.push(entity);\n                return;\n            }\n            delete this._entityIndex[id];\n            if (entity) {\n                removeItemFromArray(entity, this.entities);\n                this._world.queryManager.removeEntity(entity);\n                entity.componentAdded$.unregister(this);\n                entity.componentRemoved$.unregister(this);\n                // if entity has children\n                entity.children.forEach((c)=>this.removeEntity(c, deferred));\n                entity.childrenAdded$.clear();\n                entity.childrenRemoved$.clear();\n                // stats\n                if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) this._world.context.engine.stats.currFrame.actors.killed++;\n            }\n        }\n        processEntityRemovals() {\n            for (const entity of this._entitiesToRemove){\n                if (entity.active) continue;\n                this.removeEntity(entity, false);\n            }\n        }\n        processComponentRemovals() {\n            for (const entity of this.entities)entity.processComponentRemoval();\n        }\n        getById(id) {\n            return this._entityIndex[id];\n        }\n        getByName(name) {\n            return this.entities.filter((e)=>e.name === name);\n        }\n        clear() {\n            for (const entity of this.entities)this.removeEntity(entity);\n        }\n    }\n    const buildTypeKey = (types)=>{\n        const key = [\n            ...types\n        ].sort((a, b)=>a.localeCompare(b)).join(\"+\");\n        return key;\n    };\n    /**\r\n * Represents query for entities that match a list of types that is cached and observable\r\n *\r\n * Queries can be strongly typed by supplying a type union in the optional type parameter\r\n * ```typescript\r\n * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);\r\n * ```\r\n */ class Query extends Observable {\n        constructor(types){\n            super();\n            this._entities = [];\n            if (types[0] instanceof Function) this.types = types.map((T)=>(new T).type);\n            else this.types = types;\n        }\n        get key() {\n            if (this._key) return this._key;\n            return this._key = buildTypeKey(this.types);\n        }\n        /**\r\n     * Returns a list of entities that match the query\r\n     *\r\n     * @param sort Optional sorting function to sort entities returned from the query\r\n     */ getEntities(sort) {\n            if (sort) this._entities.sort(sort);\n            return this._entities;\n        }\n        /**\r\n     * Add an entity to the query, will only be added if the entity matches the query types\r\n     * @param entity\r\n     */ addEntity(entity) {\n            if (!contains(this._entities, entity) && this.matches(entity)) {\n                this._entities.push(entity);\n                this.notifyAll(new AddedEntity(entity));\n            }\n        }\n        /**\r\n     * If the entity is part of the query it will be removed regardless of types\r\n     * @param entity\r\n     */ removeEntity(entity) {\n            if (removeItemFromArray(entity, this._entities)) this.notifyAll(new RemovedEntity(entity));\n        }\n        /**\r\n     * Removes all entities and observers from the query\r\n     */ clear() {\n            this._entities.length = 0;\n            for (const observer of this.observers)this.unregister(observer);\n        }\n        matches(typesOrEntity) {\n            let types = [];\n            if (typesOrEntity instanceof Entity) types = typesOrEntity.types;\n            else types = typesOrEntity;\n            let matches = true;\n            for (const type of this.types){\n                matches = matches && types.indexOf(type) > -1;\n                if (!matches) return false;\n            }\n            return matches;\n        }\n        contain(type) {\n            return this.types.indexOf(type) > -1;\n        }\n    }\n    /**\r\n * The query manager is responsible for updating all queries when entities/components change\r\n */ class QueryManager {\n        constructor(_world){\n            this._world = _world;\n            this._queries = {};\n        }\n        /**\r\n     * Adds a query to the manager and populates with any entities that match\r\n     * @param query\r\n     */ _addQuery(query) {\n            this._queries[buildTypeKey(query.types)] = query;\n            for (const entity of this._world.entityManager.entities)query.addEntity(entity);\n        }\n        /**\r\n     * Removes the query if there are no observers left\r\n     * @param query\r\n     */ maybeRemoveQuery(query) {\n            if (query.observers.length === 0) {\n                query.clear();\n                delete this._queries[buildTypeKey(query.types)];\n            }\n        }\n        /**\r\n     * Adds the entity to any matching query in the query manage\r\n     * @param entity\r\n     */ addEntity(entity) {\n            for(const queryType in this._queries)if (this._queries[queryType]) this._queries[queryType].addEntity(entity);\n        }\n        /**\r\n     * Removes an entity from queries if the removed component disqualifies it\r\n     * @param entity\r\n     * @param component\r\n     */ removeComponent(entity, component) {\n            for(const queryType in this._queries)// If the component being removed from an entity is a part of a query,\n            // it is now disqualified from that query, remove it\n            if (this._queries[queryType].contain(component.type)) this._queries[queryType].removeEntity(entity);\n        }\n        /**\r\n     * Removes an entity from all queries it is currently a part of\r\n     * @param entity\r\n     */ removeEntity(entity) {\n            for(const queryType in this._queries)this._queries[queryType].removeEntity(entity);\n        }\n        /**\r\n     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance\r\n     * @param types\r\n     */ createQuery(types) {\n            const maybeExistingQuery = this.getQuery(types);\n            if (maybeExistingQuery) return maybeExistingQuery;\n            const query = new Query(types);\n            this._addQuery(query);\n            return query;\n        }\n        /**\r\n     * Retrieves an existing query by types if it exists otherwise returns null\r\n     * @param types\r\n     */ getQuery(types) {\n            const key = buildTypeKey(types);\n            if (this._queries[key]) return this._queries[key];\n            return null;\n        }\n    }\n    /**\r\n * The SystemManager is responsible for keeping track of all systems in a scene.\r\n * Systems are scene specific\r\n */ class SystemManager {\n        constructor(_world){\n            this._world = _world;\n            /**\r\n         * List of systems, to add a new system call [[SystemManager.addSystem]]\r\n         */ this.systems = [];\n            this.initialized = false;\n        }\n        /**\r\n     * Get a system registered in the manager by type\r\n     * @param systemType\r\n     */ get(systemType) {\n            return this.systems.find((s)=>s instanceof systemType);\n        }\n        /**\r\n     * Adds a system to the manager, it will now be updated every frame\r\n     * @param system\r\n     */ addSystem(system) {\n            // validate system has types\n            if (!system.types || system.types.length === 0) throw new Error(`Attempted to add a System without any types`);\n            const query = this._world.queryManager.createQuery(system.types);\n            this.systems.push(system);\n            this.systems.sort((a, b)=>a.priority - b.priority);\n            query.register(system);\n            if (this.initialized && system.initialize) system.initialize(this._world.context);\n        }\n        /**\r\n     * Removes a system from the manager, it will no longer be updated\r\n     * @param system\r\n     */ removeSystem(system) {\n            removeItemFromArray(system, this.systems);\n            const query = this._world.queryManager.getQuery(system.types);\n            if (query) {\n                query.unregister(system);\n                this._world.queryManager.maybeRemoveQuery(query);\n            }\n        }\n        /**\r\n     * Initialize all systems in the manager\r\n     *\r\n     * Systems added after initialize() will be initialized on add\r\n     */ initialize() {\n            if (!this.initialized) {\n                this.initialized = true;\n                for (const s of this.systems)if (s.initialize) s.initialize(this._world.context);\n            }\n        }\n        /**\r\n     * Updates all systems\r\n     * @param type whether this is an update or draw system\r\n     * @param context context reference\r\n     * @param delta time in milliseconds\r\n     */ updateSystems(type, context, delta) {\n            const systems = this.systems.filter((s)=>s.systemType === type);\n            for (const s of systems)if (s.preupdate) s.preupdate(context, delta);\n            for (const s of systems){\n                // Get entities that match the system types, pre-sort\n                const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);\n                // Initialize entities if needed\n                if (context instanceof Scene) for (const entity of entities)entity._initialize(context === null || context === void 0 ? void 0 : context.engine);\n                s.update(entities, delta);\n            }\n            for (const s of systems)if (s.postupdate) s.postupdate(context, delta);\n        }\n        clear() {\n            for (const system of this.systems)this.removeSystem(system);\n        }\n    }\n    /**\r\n * The World is a self-contained entity component system for a particular context.\r\n */ class World {\n        /**\r\n     * The context type is passed to the system updates\r\n     * @param context\r\n     */ constructor(context){\n            this.context = context;\n            this.queryManager = new QueryManager(this);\n            this.entityManager = new EntityManager(this);\n            this.systemManager = new SystemManager(this);\n        }\n        /**\r\n     * Update systems by type and time elapsed in milliseconds\r\n     */ update(type, delta) {\n            if (type === SystemType.Update) this.entityManager.updateEntities(this.context, delta);\n            this.systemManager.updateSystems(type, this.context, delta);\n            this.entityManager.findEntitiesForRemoval();\n            this.entityManager.processComponentRemovals();\n            this.entityManager.processEntityRemovals();\n        }\n        add(entityOrSystem) {\n            if (entityOrSystem instanceof Entity) this.entityManager.addEntity(entityOrSystem);\n            if (entityOrSystem instanceof System) this.systemManager.addSystem(entityOrSystem);\n        }\n        remove(entityOrSystem, deferred = true) {\n            if (entityOrSystem instanceof Entity) this.entityManager.removeEntity(entityOrSystem, deferred);\n            if (entityOrSystem instanceof System) this.systemManager.removeSystem(entityOrSystem);\n        }\n        clearEntities() {\n            this.entityManager.clear();\n        }\n        clearSystems() {\n            this.systemManager.clear();\n        }\n    }\n    class EulerIntegrator {\n        static integrate(transform, motion, totalAcc, elapsedMs) {\n            const seconds = elapsedMs / 1000;\n            // This code looks a little wild, but it's to avoid creating any new Vector instances\n            // integration is done in a tight loop so this is key to avoid GC'ing\n            motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));\n            transform.pos.add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS).addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));\n            motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;\n            const rotation = transform.rotation + motion.angularVelocity * seconds;\n            transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);\n            const tx = transform.get();\n            tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);\n        }\n    }\n    // Scratch vectors to avoid allocation\n    EulerIntegrator._POS = new Vector(0, 0);\n    EulerIntegrator._SCALE = new Vector(1, 1);\n    EulerIntegrator._ACC = new Vector(0, 0);\n    EulerIntegrator._VEL = new Vector(0, 0);\n    EulerIntegrator._VEL_ACC = new Vector(0, 0);\n    EulerIntegrator._SCALE_FACTOR = new Vector(0, 0);\n    class MotionSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\",\n                \"ex.motion\"\n            ];\n            this.systemType = SystemType.Update;\n            this.priority = -1;\n        }\n        update(entities, elapsedMs) {\n            let transform;\n            let motion;\n            for(let i = 0; i < entities.length; i++){\n                transform = entities[i].get(TransformComponent);\n                motion = entities[i].get(MotionComponent);\n                const optionalBody = entities[i].get(BodyComponent);\n                if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) continue;\n                const totalAcc = motion.acc.clone();\n                if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) totalAcc.addEqual(Physics.gravity);\n                optionalBody === null || optionalBody === void 0 || optionalBody.captureOldTransform();\n                // Update transform and motion based on Euler linear algebra\n                EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);\n            }\n        }\n    }\n    /**\r\n * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,\r\n * and negates velocity along the collision normal.\r\n *\r\n * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.\r\n *\r\n */ class ArcadeSolver {\n        constructor(){\n            this.directionMap = new Map();\n            this.distanceMap = new Map();\n        }\n        solve(contacts) {\n            // Events and init\n            this.preSolve(contacts);\n            // Remove any canceled contacts\n            contacts = contacts.filter((c)=>!c.isCanceled());\n            // Sort contacts by distance to avoid artifacts with seams\n            // It's important to solve in a specific order\n            contacts.sort((a, b)=>{\n                const aDist = this.distanceMap.get(a.id);\n                const bDist = this.distanceMap.get(b.id);\n                return aDist - bDist;\n            });\n            for (const contact of contacts){\n                // Solve position first in arcade\n                this.solvePosition(contact);\n                // Solve velocity second in arcade\n                this.solveVelocity(contact);\n            }\n            // Events and any contact house-keeping the solver needs\n            this.postSolve(contacts);\n            return contacts;\n        }\n        preSolve(contacts) {\n            for (const contact of contacts){\n                const side = Side.fromDirection(contact.mtv);\n                const mtv = contact.mtv.negate();\n                const distance = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);\n                this.distanceMap.set(contact.id, distance);\n                // Publish collision events on both participants\n                contact.colliderA.events.emit(\"precollision\", new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\n                contact.colliderB.events.emit(\"precollision\", new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));\n            }\n        }\n        postSolve(contacts) {\n            var _a, _b;\n            for (const contact of contacts){\n                if (contact.isCanceled()) continue;\n                const colliderA = contact.colliderA;\n                const colliderB = contact.colliderB;\n                const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n                const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n                if (bodyA && bodyB) {\n                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) continue;\n                }\n                const side = Side.fromDirection(contact.mtv);\n                const mtv = contact.mtv.negate();\n                // Publish collision events on both participants\n                contact.colliderA.events.emit(\"postcollision\", new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\n                contact.colliderB.events.emit(\"postcollision\", new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));\n            }\n        }\n        solvePosition(contact) {\n            var _a, _b;\n            const epsilon = .0001;\n            // if bounds no longer intersect skip to the next\n            // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles\n            if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {\n                // Cancel the contact to prevent and solving\n                contact.cancel();\n                return;\n            }\n            if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {\n                // Cancel near 0 mtv collisions\n                contact.cancel();\n                return;\n            }\n            let mtv = contact.mtv;\n            const colliderA = contact.colliderA;\n            const colliderB = contact.colliderB;\n            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n            if (bodyA && bodyB) {\n                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) return;\n                if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) // split overlaps if both are Active\n                mtv = mtv.scale(0.5);\n                // Resolve overlaps\n                if (bodyA.collisionType === CollisionType.Active) {\n                    bodyA.globalPos.x -= mtv.x;\n                    bodyA.globalPos.y -= mtv.y;\n                    colliderA.update(bodyA.transform.get());\n                }\n                if (bodyB.collisionType === CollisionType.Active) {\n                    bodyB.globalPos.x += mtv.x;\n                    bodyB.globalPos.y += mtv.y;\n                    colliderB.update(bodyB.transform.get());\n                }\n            }\n        }\n        solveVelocity(contact) {\n            var _a, _b;\n            if (contact.isCanceled()) return;\n            const colliderA = contact.colliderA;\n            const colliderB = contact.colliderB;\n            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n            if (bodyA && bodyB) {\n                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) return;\n                const normal = contact.normal;\n                const opposite = normal.negate();\n                if (bodyA.collisionType === CollisionType.Active) // only adjust velocity if the contact normal is opposite to the current velocity\n                // this avoids catching edges on a platform when sliding off\n                {\n                    if (bodyA.vel.normalize().dot(opposite) < 0) {\n                        // Cancel out velocity opposite direction of collision normal\n                        const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));\n                        bodyA.vel = bodyA.vel.add(velAdj);\n                    }\n                }\n                if (bodyB.collisionType === CollisionType.Active) // only adjust velocity if the contact normal is opposite to the current velocity\n                // this avoids catching edges on a platform\n                {\n                    if (bodyB.vel.normalize().dot(normal) < 0) {\n                        const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));\n                        bodyB.vel = bodyB.vel.add(velAdj);\n                    }\n                }\n            }\n        }\n    }\n    /**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */ class ContactConstraintPoint {\n        constructor(point, local, contact){\n            this.point = point;\n            this.local = local;\n            this.contact = contact;\n            /**\r\n         * Impulse accumulated over time in normal direction\r\n         */ this.normalImpulse = 0;\n            /**\r\n         * Impulse accumulated over time in the tangent direction\r\n         */ this.tangentImpulse = 0;\n            /**\r\n         * Effective mass seen in the normal direction\r\n         */ this.normalMass = 0;\n            /**\r\n         * Effective mass seen in the tangent direction\r\n         */ this.tangentMass = 0;\n            /**\r\n         * Direction from center of mass of bodyA to contact point\r\n         */ this.aToContact = new Vector(0, 0);\n            /**\r\n         * Direction from center of mass of bodyB to contact point\r\n         */ this.bToContact = new Vector(0, 0);\n            /**\r\n         * Original contact velocity combined with bounciness\r\n         */ this.originalVelocityAndRestitution = 0;\n            this.update();\n        }\n        /**\r\n     * Updates the contact information\r\n     */ update() {\n            var _a, _b;\n            const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n            const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n            if (bodyA && bodyB) {\n                const normal = this.contact.normal;\n                const tangent = this.contact.tangent;\n                this.aToContact = this.point.sub(bodyA.globalPos);\n                this.bToContact = this.point.sub(bodyB.globalPos);\n                const aToContactNormal = this.aToContact.cross(normal);\n                const bToContactNormal = this.bToContact.cross(normal);\n                this.normalMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactNormal * aToContactNormal + bodyB.inverseInertia * bToContactNormal * bToContactNormal;\n                const aToContactTangent = this.aToContact.cross(tangent);\n                const bToContactTangent = this.bToContact.cross(tangent);\n                this.tangentMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactTangent * aToContactTangent + bodyB.inverseInertia * bToContactTangent * bToContactTangent;\n            }\n            return this;\n        }\n        /**\r\n     * Returns the relative velocity between bodyA and bodyB\r\n     */ getRelativeVelocity() {\n            var _a, _b;\n            const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n            const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n            if (bodyA && bodyB) {\n                // Relative velocity in linear terms\n                // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\n                const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));\n                const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));\n                return velB.sub(velA);\n            }\n            return Vector.Zero;\n        }\n    }\n    class RealisticSolver {\n        constructor(){\n            this.lastFrameContacts = new Map();\n            // map contact id to contact points\n            this.idToContactConstraint = new Map();\n        }\n        getContactConstraints(id) {\n            var _a;\n            return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];\n        }\n        solve(contacts) {\n            // Events and init\n            this.preSolve(contacts);\n            // Remove any canceled contacts\n            contacts = contacts.filter((c)=>!c.isCanceled());\n            // Solve velocity first\n            this.solveVelocity(contacts);\n            // Solve position last because non-overlap is the most important\n            this.solvePosition(contacts);\n            // Events and any contact house-keeping the solver needs\n            this.postSolve(contacts);\n            return contacts;\n        }\n        preSolve(contacts) {\n            var _a, _b, _c;\n            for (const contact of contacts){\n                // Publish collision events on both participants\n                const side = Side.fromDirection(contact.mtv);\n                contact.colliderA.events.emit(\"precollision\", new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\n                contact.colliderA.events.emit(\"beforecollisionresolve\", new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));\n                contact.colliderB.events.emit(\"precollision\", new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));\n                contact.colliderB.events.emit(\"beforecollisionresolve\", new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));\n                // Match awake state for sleeping\n                contact.matchAwake();\n            }\n            // Keep track of contacts that done\n            const finishedContactIds = Array.from(this.idToContactConstraint.keys());\n            for (const contact of contacts){\n                // Remove all current contacts that are not done\n                const index = finishedContactIds.indexOf(contact.id);\n                if (index > -1) finishedContactIds.splice(index, 1);\n                const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];\n                let pointIndex = 0;\n                const bodyA = contact.colliderA.owner.get(BodyComponent);\n                const bodyB = contact.colliderB.owner.get(BodyComponent);\n                if (bodyA && bodyB) for (const point of contact.points){\n                    const normal = contact.normal;\n                    const tangent = contact.tangent;\n                    const aToContact = point.sub(bodyA.globalPos);\n                    const bToContact = point.sub(bodyB.globalPos);\n                    const aToContactNormal = aToContact.cross(normal);\n                    const bToContactNormal = bToContact.cross(normal);\n                    const normalMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactNormal * aToContactNormal + bodyB.inverseInertia * bToContactNormal * bToContactNormal;\n                    const aToContactTangent = aToContact.cross(tangent);\n                    const bToContactTangent = bToContact.cross(tangent);\n                    const tangentMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactTangent * aToContactTangent + bodyB.inverseInertia * bToContactTangent * bToContactTangent;\n                    // Preserve normal/tangent impulse by re-using the contact point if it's close\n                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {\n                        contactPoints[pointIndex].point = point;\n                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];\n                    } else // new contact if it's not close or doesn't exist\n                    contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);\n                    // Update contact point calculations\n                    contactPoints[pointIndex].aToContact = aToContact;\n                    contactPoints[pointIndex].bToContact = bToContact;\n                    contactPoints[pointIndex].normalMass = 1.0 / normalMass;\n                    contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;\n                    // Calculate relative velocity before solving to accurately do restitution\n                    const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;\n                    const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());\n                    contactPoints[pointIndex].originalVelocityAndRestitution = 0;\n                    if (relativeVelocity < -0.1) contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;\n                    pointIndex++;\n                }\n                this.idToContactConstraint.set(contact.id, contactPoints);\n            }\n            // Clean up any contacts that did not occur last frame\n            for (const id of finishedContactIds)this.idToContactConstraint.delete(id);\n            // Warm contacts with accumulated impulse\n            // Useful for tall stacks\n            if (Physics.warmStart) this.warmStart(contacts);\n            else for (const contact of contacts){\n                const contactPoints = this.getContactConstraints(contact.id);\n                for (const point of contactPoints){\n                    point.normalImpulse = 0;\n                    point.tangentImpulse = 0;\n                }\n            }\n        }\n        postSolve(contacts) {\n            for (const contact of contacts){\n                const bodyA = contact.colliderA.owner.get(BodyComponent);\n                const bodyB = contact.colliderB.owner.get(BodyComponent);\n                if (bodyA && bodyB) {\n                    // Skip post solve for active+passive collisions\n                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) continue;\n                    // Update motion values for sleeping\n                    bodyA.updateMotion();\n                    bodyB.updateMotion();\n                }\n                // Publish collision events on both participants\n                const side = Side.fromDirection(contact.mtv);\n                contact.colliderA.events.emit(\"postcollision\", new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\n                contact.colliderA.events.emit(\"aftercollisionresolve\", new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));\n                contact.colliderB.events.emit(\"postcollision\", new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));\n                contact.colliderB.events.emit(\"aftercollisionresolve\", new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));\n            }\n            // Store contacts\n            this.lastFrameContacts.clear();\n            for (const c of contacts)this.lastFrameContacts.set(c.id, c);\n        }\n        /**\r\n     * Warm up body's based on previous frame contact points\r\n     * @param contacts\r\n     */ warmStart(contacts) {\n            var _a, _b, _c;\n            for (const contact of contacts){\n                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n                if (bodyA && bodyB) {\n                    const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];\n                    for (const point of contactPoints)if (Physics.warmStart) {\n                        const normalImpulse = contact.normal.scale(point.normalImpulse);\n                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\n                        const impulse = normalImpulse.add(tangentImpulse);\n                        bodyA.applyImpulse(point.point, impulse.negate());\n                        bodyB.applyImpulse(point.point, impulse);\n                    } else {\n                        point.normalImpulse = 0;\n                        point.tangentImpulse = 0;\n                    }\n                }\n            }\n        }\n        /**\r\n     * Iteratively solve the position overlap constraint\r\n     * @param contacts\r\n     */ solvePosition(contacts) {\n            var _a, _b, _c;\n            for(let i = 0; i < Physics.positionIterations; i++)for (const contact of contacts){\n                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n                if (bodyA && bodyB) {\n                    // Skip solving active+passive\n                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) continue;\n                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];\n                    for (const point of constraints){\n                        const normal = contact.normal;\n                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);\n                        const steeringConstant = Physics.steeringFactor; //0.2;\n                        const maxCorrection = -5;\n                        const slop = Physics.slop; //1;\n                        // Clamp to avoid over-correction\n                        // Remember that we are shooting for 0 overlap in the end\n                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\n                        const impulse = normal.scale(-steeringForce * point.normalMass);\n                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\n                        // We adjust position and rotation instead of doing the velocity\n                        if (bodyA.collisionType === CollisionType.Active) {\n                            // TODO make applyPseudoImpulse function?\n                            const impulseForce = impulse.negate().scale(bodyA.inverseMass);\n                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) impulseForce.x = 0;\n                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) impulseForce.y = 0;\n                            bodyA.globalPos = bodyA.globalPos.add(impulseForce);\n                            if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\n                        }\n                        if (bodyB.collisionType === CollisionType.Active) {\n                            const impulseForce = impulse.scale(bodyB.inverseMass);\n                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) impulseForce.x = 0;\n                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) impulseForce.y = 0;\n                            bodyB.globalPos = bodyB.globalPos.add(impulseForce);\n                            if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\n                        }\n                    }\n                }\n            }\n        }\n        solveVelocity(contacts) {\n            var _a, _b, _c;\n            for(let i = 0; i < Physics.velocityIterations; i++)for (const contact of contacts){\n                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\n                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\n                if (bodyA && bodyB) {\n                    // Skip solving active+passive\n                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) continue;\n                    const friction = Math.min(bodyA.friction, bodyB.friction);\n                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];\n                    // Friction constraint\n                    for (const point of constraints){\n                        const relativeVelocity = point.getRelativeVelocity();\n                        // Negate velocity in tangent direction to simulate friction\n                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);\n                        let impulseDelta = tangentVelocity * point.tangentMass;\n                        // Clamping based in Erin Catto's GDC 2006 talk\n                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\n                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\n                        // But deltas can vary\n                        const maxFriction = friction * point.normalImpulse;\n                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\n                        impulseDelta = newImpulse - point.tangentImpulse;\n                        point.tangentImpulse = newImpulse;\n                        const impulse = contact.tangent.scale(impulseDelta);\n                        bodyA.applyImpulse(point.point, impulse.negate());\n                        bodyB.applyImpulse(point.point, impulse);\n                    }\n                    // Bounce constraint\n                    for (const point of constraints){\n                        // Need to recalc relative velocity because the previous step could have changed vel\n                        const relativeVelocity = point.getRelativeVelocity();\n                        // Compute impulse in normal direction\n                        const normalVelocity = relativeVelocity.dot(contact.normal);\n                        // Per Erin it is a mistake to apply the restitution inside the iteration\n                        // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses\n                        let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);\n                        // Clamping based in Erin Catto's GDC 2014 talk\n                        // Accumulated impulse stored in the contact is always positive (dV > 0)\n                        // But deltas can be negative\n                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\n                        impulseDelta = newImpulse - point.normalImpulse;\n                        point.normalImpulse = newImpulse;\n                        const impulse = contact.normal.scale(impulseDelta);\n                        bodyA.applyImpulse(point.point, impulse.negate());\n                        bodyB.applyImpulse(point.point, impulse);\n                    }\n                }\n            }\n        }\n    }\n    class CollisionSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\",\n                \"ex.motion\",\n                \"ex.collider\"\n            ];\n            this.systemType = SystemType.Update;\n            this.priority = -1;\n            this._realisticSolver = new RealisticSolver();\n            this._arcadeSolver = new ArcadeSolver();\n            this._processor = new DynamicTreeCollisionProcessor();\n            this._lastFrameContacts = new Map();\n            this._currentFrameContacts = new Map();\n            this._trackCollider = (c)=>this._processor.track(c);\n            this._untrackCollider = (c)=>this._processor.untrack(c);\n        }\n        notify(message) {\n            if (isAddedSystemEntity(message)) {\n                const colliderComponent = message.data.get(ColliderComponent);\n                colliderComponent.$colliderAdded.subscribe(this._trackCollider);\n                colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);\n                const collider = colliderComponent.get();\n                if (collider) this._processor.track(collider);\n            } else {\n                const colliderComponent = message.data.get(ColliderComponent);\n                const collider = colliderComponent.get();\n                if (colliderComponent && collider) this._processor.untrack(collider);\n            }\n        }\n        initialize(scene) {\n            this._engine = scene.engine;\n        }\n        update(entities, elapsedMs) {\n            var _a, _b, _c, _d;\n            if (!Physics.enabled) return;\n            // Collect up all the colliders and update them\n            let colliders = [];\n            for (const entity of entities){\n                const colliderComp = entity.get(ColliderComponent);\n                const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();\n                if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {\n                    colliderComp.update();\n                    if (collider instanceof CompositeCollider) {\n                        const compositeColliders = collider.getColliders();\n                        colliders = colliders.concat(compositeColliders);\n                    } else colliders.push(collider);\n                }\n            }\n            // Update the spatial partitioning data structures\n            // TODO if collider invalid it will break the processor\n            // TODO rename \"update\" to something more specific\n            this._processor.update(colliders);\n            // Run broadphase on all colliders and locates potential collisions\n            const pairs = this._processor.broadphase(colliders, elapsedMs);\n            this._currentFrameContacts.clear();\n            // Given possible pairs find actual contacts\n            let contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.currFrame);\n            const solver = this.getSolver();\n            // Solve, this resolves the position/velocity so entities aren't overlapping\n            contacts = solver.solve(contacts);\n            // Record contacts for start/end\n            for (const contact of contacts){\n                // Process composite ids, things with the same composite id are treated as the same collider for start/end\n                const index = contact.id.indexOf(\"|\");\n                if (index > 0) {\n                    const compositeId = contact.id.substring(index + 1);\n                    this._currentFrameContacts.set(compositeId, contact);\n                } else this._currentFrameContacts.set(contact.id, contact);\n            }\n            // Emit contact start/end events\n            this.runContactStartEnd();\n            // reset the last frame cache\n            this._lastFrameContacts.clear();\n            // Keep track of collisions contacts that have started or ended\n            this._lastFrameContacts = new Map(this._currentFrameContacts);\n        }\n        getSolver() {\n            return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;\n        }\n        debug(ex) {\n            this._processor.debug(ex);\n        }\n        runContactStartEnd() {\n            // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end\n            for (const [id, c] of this._currentFrameContacts)// find all new contacts\n            if (!this._lastFrameContacts.has(id)) {\n                const colliderA = c.colliderA;\n                const colliderB = c.colliderB;\n                colliderA.events.emit(\"collisionstart\", new CollisionStartEvent(colliderA, colliderB, c));\n                colliderA.events.emit(\"contactstart\", new ContactStartEvent(colliderA, colliderB, c));\n                colliderB.events.emit(\"collisionstart\", new CollisionStartEvent(colliderB, colliderA, c));\n                colliderB.events.emit(\"contactstart\", new ContactStartEvent(colliderB, colliderA, c));\n            }\n            // find all contacts that have ceased\n            for (const [id, c] of this._lastFrameContacts)if (!this._currentFrameContacts.has(id)) {\n                const colliderA = c.colliderA;\n                const colliderB = c.colliderB;\n                colliderA.events.emit(\"collisionend\", new CollisionEndEvent(colliderA, colliderB));\n                colliderA.events.emit(\"contactend\", new ContactEndEvent(colliderA, colliderB));\n                colliderB.events.emit(\"collisionend\", new CollisionEndEvent(colliderB, colliderA));\n                colliderB.events.emit(\"contactend\", new ContactEndEvent(colliderB, colliderA));\n            }\n        }\n    }\n    var AnimationDirection;\n    (function(AnimationDirection) {\n        /**\r\n     * Animation is playing forwards\r\n     */ AnimationDirection[\"Forward\"] = \"forward\";\n        /**\r\n     * Animation is play backwards\r\n     */ AnimationDirection[\"Backward\"] = \"backward\";\n    })(AnimationDirection || (AnimationDirection = {}));\n    var AnimationStrategy;\n    (function(AnimationStrategy) {\n        /**\r\n     * Animation ends without displaying anything\r\n     */ AnimationStrategy[\"End\"] = \"end\";\n        /**\r\n     * Animation loops to the first frame after the last frame\r\n     */ AnimationStrategy[\"Loop\"] = \"loop\";\n        /**\r\n     * Animation plays to the last frame, then backwards to the first frame, then repeats\r\n     */ AnimationStrategy[\"PingPong\"] = \"pingpong\";\n        /**\r\n     * Animation ends stopping on the last frame\r\n     */ AnimationStrategy[\"Freeze\"] = \"freeze\";\n    })(AnimationStrategy || (AnimationStrategy = {}));\n    /**\r\n * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]\r\n *\r\n * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]\r\n */ class Animation extends Graphic {\n        constructor(options){\n            var _a, _b;\n            super(options);\n            this.events = new EventDispatcher(); // TODO replace with new Emitter\n            this.frames = [];\n            this.strategy = AnimationStrategy.Loop;\n            this.frameDuration = 100;\n            this.timeScale = 1;\n            this._idempotencyToken = -1;\n            this._firstTick = true;\n            this._currentFrame = 0;\n            this._timeLeftInFrame = 0;\n            this._direction = 1; // TODO only used in ping-pong\n            this._done = false;\n            this._playing = true;\n            this._reversed = false;\n            this.frames = options.frames;\n            this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;\n            this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;\n            if (options.reverse) this.reverse();\n            this.goToFrame(0);\n        }\n        clone() {\n            return new Animation({\n                frames: this.frames.map((f)=>({\n                        ...f\n                    })),\n                frameDuration: this.frameDuration,\n                reverse: this._reversed,\n                strategy: this.strategy,\n                ...this.cloneGraphicOptions()\n            });\n        }\n        get width() {\n            const maybeFrame = this.currentFrame;\n            if (maybeFrame) return Math.abs(maybeFrame.graphic.width * this.scale.x);\n            return 0;\n        }\n        get height() {\n            const maybeFrame = this.currentFrame;\n            if (maybeFrame) return Math.abs(maybeFrame.graphic.height * this.scale.y);\n            return 0;\n        }\n        /**\r\n     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame\r\n     * and optional [[AnimationStrategy]]\r\n     *\r\n     * Example:\r\n     * ```typescript\r\n     * const spriteSheet = SpriteSheet.fromImageSource({...});\r\n     *\r\n     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);\r\n     * ```\r\n     *\r\n     * @param spriteSheet\r\n     * @param frameIndices\r\n     * @param durationPerFrameMs\r\n     * @param strategy\r\n     */ static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {\n            const maxIndex = spriteSheet.sprites.length - 1;\n            const invalidIndices = frameIndices.filter((index)=>index < 0 || index > maxIndex);\n            if (invalidIndices.length) Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\\'t exist: ${invalidIndices.join(\",\")} no frame will be shown`);\n            return new Animation({\n                frames: spriteSheet.sprites.filter((_, index)=>frameIndices.indexOf(index) > -1).map((f)=>({\n                        graphic: f,\n                        duration: durationPerFrameMs\n                    })),\n                strategy: strategy\n            });\n        }\n        /**\r\n     * Returns the current Frame of the animation\r\n     */ get currentFrame() {\n            if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) return this.frames[this._currentFrame];\n            return null;\n        }\n        /**\r\n     * Returns the current frame index of the animation\r\n     */ get currentFrameIndex() {\n            return this._currentFrame;\n        }\n        /**\r\n     * Returns `true` if the animation is playing\r\n     */ get isPlaying() {\n            return this._playing;\n        }\n        /**\r\n     * Reverses the play direction of the Animation, this preserves the current frame\r\n     */ reverse() {\n            // Don't mutate with the original frame list, create a copy\n            this.frames = this.frames.slice().reverse();\n            this._reversed = !this._reversed;\n        }\n        /**\r\n     * Returns the current play direction of the animation\r\n     */ get direction() {\n            // Keep logically consistent with ping-pong direction\n            // If ping-pong is forward = 1 and reversed is true then we are logically reversed\n            const reversed = this._reversed && this._direction === 1 ? true : false;\n            return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;\n        }\n        /**\r\n     * Plays or resumes the animation from the current frame\r\n     */ play() {\n            this._playing = true;\n        }\n        /**\r\n     * Pauses the animation on the current frame\r\n     */ pause() {\n            this._playing = false;\n            this._firstTick = true; // firstTick must be set to emit the proper frame event\n        }\n        /**\r\n     * Reset the animation back to the beginning, including if the animation were done\r\n     */ reset() {\n            this._done = false;\n            this._firstTick = true;\n            this._currentFrame = 0;\n        }\n        /**\r\n     * Returns `true` if the animation can end\r\n     */ get canFinish() {\n            switch(this.strategy){\n                case AnimationStrategy.End:\n                case AnimationStrategy.Freeze:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        /**\r\n     * Returns `true` if the animation is done, for looping type animations\r\n     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`\r\n     *\r\n     * See the `ex.Animation.canFinish()` method to know if an animation type can end\r\n     */ get done() {\n            return this._done;\n        }\n        /**\r\n     * Jump the animation immediately to a specific frame if it exists\r\n     * @param frameNumber\r\n     */ goToFrame(frameNumber) {\n            this._currentFrame = frameNumber;\n            this._timeLeftInFrame = this.frameDuration;\n            const maybeFrame = this.frames[this._currentFrame];\n            if (maybeFrame && !this._done) {\n                this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;\n                this.events.emit(\"frame\", maybeFrame);\n            }\n        }\n        _nextFrame() {\n            const currentFrame = this._currentFrame;\n            if (this._done) return currentFrame;\n            let next = -1;\n            switch(this.strategy){\n                case AnimationStrategy.Loop:\n                    next = (currentFrame + 1) % this.frames.length;\n                    if (next === 0) this.events.emit(\"loop\", this);\n                    break;\n                case AnimationStrategy.End:\n                    next = currentFrame + 1;\n                    if (next >= this.frames.length) {\n                        this._done = true;\n                        this._currentFrame = this.frames.length;\n                        this.events.emit(\"end\", this);\n                    }\n                    break;\n                case AnimationStrategy.Freeze:\n                    next = clamp(currentFrame + 1, 0, this.frames.length - 1);\n                    if (next >= this.frames.length - 1) {\n                        this._done = true;\n                        this.events.emit(\"end\", this);\n                    }\n                    break;\n                case AnimationStrategy.PingPong:\n                    if (currentFrame + this._direction >= this.frames.length) {\n                        this._direction = -1;\n                        this.events.emit(\"loop\", this);\n                    }\n                    if (currentFrame + this._direction < 0) {\n                        this._direction = 1;\n                        this.events.emit(\"loop\", this);\n                    }\n                    next = currentFrame + this._direction % this.frames.length;\n                    break;\n            }\n            return next;\n        }\n        /**\r\n     * Called internally by Excalibur to update the state of the animation potential update the current frame\r\n     * @param elapsedMilliseconds Milliseconds elapsed\r\n     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame\r\n     */ tick(elapsedMilliseconds, idempotencyToken = 0) {\n            if (this._idempotencyToken === idempotencyToken) return;\n            this._idempotencyToken = idempotencyToken;\n            if (!this._playing) return;\n            // if it's the first frame emit frame event\n            if (this._firstTick) {\n                this._firstTick = false;\n                this.events.emit(\"frame\", this.currentFrame);\n            }\n            this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;\n            if (this._timeLeftInFrame <= 0) this.goToFrame(this._nextFrame());\n        }\n        _drawImage(ctx, x, y) {\n            if (this.currentFrame) this.currentFrame.graphic.draw(ctx, x, y);\n        }\n    }\n    Animation._LOGGER = Logger.getInstance();\n    class GraphicsGroup extends Graphic {\n        constructor(options){\n            super(options);\n            this.members = [];\n            this.members = options.members;\n            this._updateDimensions();\n        }\n        clone() {\n            return new GraphicsGroup({\n                members: [\n                    ...this.members\n                ],\n                ...this.cloneGraphicOptions()\n            });\n        }\n        _updateDimensions() {\n            let bb = new BoundingBox();\n            for (const { graphic: graphic , pos: pos  } of this.members)bb = graphic.localBounds.translate(pos).combine(bb);\n            this.width = bb.width;\n            this.height = bb.height;\n            return bb;\n        }\n        get localBounds() {\n            let bb = new BoundingBox();\n            for (const { graphic: graphic , pos: pos  } of this.members)bb = graphic.localBounds.translate(pos).combine(bb);\n            return bb;\n        }\n        _isAnimationOrGroup(graphic) {\n            return graphic instanceof Animation || graphic instanceof GraphicsGroup;\n        }\n        tick(elapsedMilliseconds, idempotencyToken) {\n            for (const member of this.members){\n                const maybeAnimation = member.graphic;\n                if (this._isAnimationOrGroup(maybeAnimation)) maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);\n            }\n        }\n        reset() {\n            for (const member of this.members){\n                const maybeAnimation = member.graphic;\n                if (this._isAnimationOrGroup(maybeAnimation)) maybeAnimation.reset();\n            }\n        }\n        _preDraw(ex, x, y) {\n            this._updateDimensions();\n            super._preDraw(ex, x, y);\n        }\n        _drawImage(ex, x, y) {\n            for (const member of this.members){\n                ex.save();\n                ex.translate(x, y);\n                member.graphic.draw(ex, member.pos.x, member.pos.y);\n                if (this.showDebug) /* istanbul ignore next */ ex.debug.drawRect(0, 0, this.width, this.height);\n                ex.restore();\n            }\n        }\n    }\n    /**\r\n * Configurable helper extends base type and makes all properties available as option bag arguments\r\n * @internal\r\n * @param base\r\n */ function Configurable(base) {\n        return class extends base {\n            assign(props) {\n                //set the value of every property that was passed in,\n                //if the constructor previously set this value, it will be overridden here\n                for(const k in props)// eslint-disable-next-line\n                if (typeof this[k] !== \"function\") // eslint-disable-next-line\n                this[k] = props[k];\n            }\n            constructor(...args){\n                super(...args);\n                //get the number of arguments that aren't undefined. TS passes a value to all parameters\n                //of whatever ctor is the implementation, so args.length doesn't work here.\n                const size = args.filter(function(value) {\n                    return value !== undefined;\n                }).length;\n                if (size === 1 && args[0] && typeof args[0] === \"object\" && !(args[0] instanceof Array)) this.assign(args[0]);\n            }\n        };\n    }\n    /**\r\n * An enum that represents the types of emitter nozzles\r\n */ var EmitterType;\n    (function(EmitterType) {\n        /**\r\n     * Constant for the circular emitter type\r\n     */ EmitterType[EmitterType[\"Circle\"] = 0] = \"Circle\";\n        /**\r\n     * Constant for the rectangular emitter type\r\n     */ EmitterType[EmitterType[\"Rectangle\"] = 1] = \"Rectangle\";\n    })(EmitterType || (EmitterType = {}));\n    /**\r\n * @hidden\r\n */ class ParticleImpl extends Entity {\n        constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize){\n            super();\n            this.position = new Vector(0, 0);\n            this.velocity = new Vector(0, 0);\n            this.acceleration = new Vector(0, 0);\n            this.particleRotationalVelocity = 0;\n            this.currentRotation = 0;\n            this.focus = null;\n            this.focusAccel = 0;\n            this.opacity = 1;\n            this.beginColor = Color.White;\n            this.endColor = Color.White;\n            // Life is counted in ms\n            this.life = 300;\n            this.fadeFlag = false;\n            // Color transitions\n            this._rRate = 1;\n            this._gRate = 1;\n            this._bRate = 1;\n            this._aRate = 0;\n            this._currentColor = Color.White;\n            this.emitter = null;\n            this.particleSize = 5;\n            this.particleSprite = null;\n            this.sizeRate = 0;\n            this.elapsedMultiplier = 0;\n            this.visible = true;\n            this.isOffscreen = false;\n            let emitter = emitterOrConfig;\n            if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {\n                const config = emitterOrConfig;\n                emitter = config.emitter;\n                life = config.life;\n                opacity = config.opacity;\n                endColor = config.endColor;\n                beginColor = config.beginColor;\n                position = config.position;\n                velocity = config.velocity;\n                acceleration = config.acceleration;\n                startSize = config.startSize;\n                endSize = config.endSize;\n            }\n            this.emitter = emitter;\n            this.life = life || this.life;\n            this.opacity = opacity || this.opacity;\n            this.endColor = endColor || this.endColor.clone();\n            this.beginColor = beginColor || this.beginColor.clone();\n            this._currentColor = this.beginColor.clone();\n            this.position = (position || this.position).add(this.emitter.pos);\n            this.velocity = velocity || this.velocity;\n            this.acceleration = acceleration || this.acceleration;\n            this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\n            this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\n            this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\n            this._aRate = this.opacity / this.life;\n            this.startSize = startSize || 0;\n            this.endSize = endSize || 0;\n            if (this.endSize > 0 && this.startSize > 0) {\n                this.sizeRate = (this.endSize - this.startSize) / this.life;\n                this.particleSize = this.startSize;\n            }\n            this.addComponent(this.transform = new TransformComponent());\n            this.addComponent(this.graphics = new GraphicsComponent());\n            this.transform.pos = this.position;\n            this.transform.rotation = this.currentRotation;\n            this.transform.scale = vec(1, 1); // TODO wut\n            if (this.particleSprite) {\n                this.graphics.opacity = this.opacity;\n                this.graphics.use(this.particleSprite);\n            } else {\n                this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);\n                this.graphics.onPostDraw = (ctx)=>{\n                    ctx.save();\n                    this.graphics.opacity = this.opacity;\n                    const tmpColor = this._currentColor.clone();\n                    tmpColor.a = 1;\n                    ctx.debug.drawPoint(vec(0, 0), {\n                        color: tmpColor,\n                        size: this.particleSize\n                    });\n                    ctx.restore();\n                };\n            }\n        }\n        kill() {\n            this.emitter.removeParticle(this);\n        }\n        update(_engine, delta) {\n            this.life = this.life - delta;\n            this.elapsedMultiplier = this.elapsedMultiplier + delta;\n            if (this.life < 0) this.kill();\n            if (this.fadeFlag) this.opacity = clamp(this._aRate * this.life, 0.0001, 1);\n            if (this.startSize > 0 && this.endSize > 0) this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));\n            this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);\n            this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);\n            this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);\n            this._currentColor.a = clamp(this.opacity, 0.0001, 1);\n            if (this.focus) {\n                const accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);\n                this.velocity = this.velocity.add(accel);\n            } else this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\n            this.position = this.position.add(this.velocity.scale(delta / 1000));\n            if (this.particleRotationalVelocity) this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);\n            this.transform.pos = this.position;\n            this.transform.rotation = this.currentRotation;\n            this.transform.scale = vec(1, 1); // todo wut\n            this.graphics.opacity = this.opacity;\n        }\n    }\n    /**\r\n * Particle is used in a [[ParticleEmitter]]\r\n */ class Particle extends Configurable(ParticleImpl) {\n        constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize){\n            super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);\n        }\n    }\n    /**\r\n * Using a particle emitter is a great way to create interesting effects\r\n * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n * extend [[Actor]] allowing you to use all of the features that come with.\r\n */ class ParticleEmitter extends Actor {\n        /**\r\n     * @param config particle emitter options bag\r\n     */ constructor(config){\n            var _a, _b;\n            super({\n                width: (_a = config.width) !== null && _a !== void 0 ? _a : 0,\n                height: (_b = config.height) !== null && _b !== void 0 ? _b : 0\n            });\n            this._particlesToEmit = 0;\n            this.numParticles = 0;\n            /**\r\n         * Gets or sets the isEmitting flag\r\n         */ this.isEmitting = true;\n            /**\r\n         * Gets or sets the backing particle collection\r\n         */ this.particles = [];\n            /**\r\n         * Gets or sets the backing deadParticle collection\r\n         */ this.deadParticles = [];\n            /**\r\n         * Gets or sets the minimum particle velocity\r\n         */ this.minVel = 0;\n            /**\r\n         * Gets or sets the maximum particle velocity\r\n         */ this.maxVel = 0;\n            /**\r\n         * Gets or sets the acceleration vector for all particles\r\n         */ this.acceleration = new Vector(0, 0);\n            /**\r\n         * Gets or sets the minimum angle in radians\r\n         */ this.minAngle = 0;\n            /**\r\n         * Gets or sets the maximum angle in radians\r\n         */ this.maxAngle = 0;\n            /**\r\n         * Gets or sets the emission rate for particles (particles/sec)\r\n         */ this.emitRate = 1; //particles/sec\n            /**\r\n         * Gets or sets the life of each particle in milliseconds\r\n         */ this.particleLife = 2000;\n            /**\r\n         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n         */ this.fadeFlag = false;\n            /**\r\n         * Gets or sets the optional focus where all particles should accelerate towards\r\n         */ this.focus = null;\n            /**\r\n         * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n         */ this.focusAccel = null;\n            /**\r\n         * Gets or sets the optional starting size for the particles\r\n         */ this.startSize = null;\n            /**\r\n         * Gets or sets the optional ending size for the particles\r\n         */ this.endSize = null;\n            /**\r\n         * Gets or sets the minimum size of all particles\r\n         */ this.minSize = 5;\n            /**\r\n         * Gets or sets the maximum size of all particles\r\n         */ this.maxSize = 5;\n            /**\r\n         * Gets or sets the beginning color of all particles\r\n         */ this.beginColor = Color.White;\n            /**\r\n         * Gets or sets the ending color of all particles\r\n         */ this.endColor = Color.White;\n            this._sprite = null;\n            /**\r\n         * Gets or sets the emitter type for the particle emitter\r\n         */ this.emitterType = EmitterType.Rectangle;\n            /**\r\n         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n         */ this.radius = 0;\n            /**\r\n         * Gets or sets the particle rotational speed velocity\r\n         */ this.particleRotationalVelocity = 0;\n            /**\r\n         * Indicates whether particles should start with a random rotation\r\n         */ this.randomRotation = false;\n            const { x: x , y: y , pos: pos , isEmitting: isEmitting , minVel: minVel , maxVel: maxVel , acceleration: acceleration , minAngle: minAngle , maxAngle: maxAngle , emitRate: emitRate , particleLife: particleLife , opacity: opacity , fadeFlag: fadeFlag , focus: focus , focusAccel: focusAccel , startSize: startSize , endSize: endSize , minSize: minSize , maxSize: maxSize , beginColor: beginColor , endColor: endColor , particleSprite: particleSprite , emitterType: emitterType , radius: radius , particleRotationalVelocity: particleRotationalVelocity , randomRotation: randomRotation , random: random  } = {\n                ...config\n            };\n            this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);\n            this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;\n            this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;\n            this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;\n            this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;\n            this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;\n            this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;\n            this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;\n            this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;\n            this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;\n            this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;\n            this.focus = focus !== null && focus !== void 0 ? focus : this.focus;\n            this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;\n            this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;\n            this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;\n            this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;\n            this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;\n            this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;\n            this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;\n            this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;\n            this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;\n            this.radius = radius !== null && radius !== void 0 ? radius : this.radius;\n            this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;\n            this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;\n            this.body.collisionType = CollisionType.PreventCollision;\n            this.random = random !== null && random !== void 0 ? random : new Random();\n        }\n        /**\r\n     * Gets the opacity of each particle from 0 to 1.0\r\n     */ get opacity() {\n            return super.graphics.opacity;\n        }\n        /**\r\n     * Gets the opacity of each particle from 0 to 1.0\r\n     */ set opacity(opacity) {\n            super.graphics.opacity = opacity;\n        }\n        /**\r\n     * Gets or sets the sprite that a particle should use\r\n     */ get particleSprite() {\n            return this._sprite;\n        }\n        set particleSprite(val) {\n            if (val) this._sprite = val;\n        }\n        removeParticle(particle) {\n            this.deadParticles.push(particle);\n        }\n        /**\r\n     * Causes the emitter to emit particles\r\n     * @param particleCount  Number of particles to emit right now\r\n     */ emitParticles(particleCount) {\n            var _a;\n            for(let i = 0; i < particleCount; i++){\n                const p = this._createParticle();\n                this.particles.push(p);\n                if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) this.scene.world.add(p);\n            }\n        }\n        clearParticles() {\n            this.particles.length = 0;\n        }\n        // Creates a new particle given the constraints of the emitter\n        _createParticle() {\n            // todo implement emitter constraints;\n            let ranX = 0;\n            let ranY = 0;\n            const angle = randomInRange(this.minAngle, this.maxAngle, this.random);\n            const vel = randomInRange(this.minVel, this.maxVel, this.random);\n            const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);\n            const dx = vel * Math.cos(angle);\n            const dy = vel * Math.sin(angle);\n            if (this.emitterType === EmitterType.Rectangle) {\n                ranX = randomInRange(0, this.width, this.random);\n                ranY = randomInRange(0, this.height, this.random);\n            } else if (this.emitterType === EmitterType.Circle) {\n                const radius = randomInRange(0, this.radius, this.random);\n                ranX = radius * Math.cos(angle);\n                ranY = radius * Math.sin(angle);\n            }\n            const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);\n            p.fadeFlag = this.fadeFlag;\n            p.particleSize = size;\n            if (this.particleSprite) {\n                p.particleSprite = this.particleSprite;\n                p.graphics.opacity = this.opacity;\n                p.graphics.use(this._sprite);\n            }\n            p.particleRotationalVelocity = this.particleRotationalVelocity;\n            if (this.randomRotation) p.currentRotation = randomInRange(0, Math.PI * 2, this.random);\n            if (this.focus) {\n                p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));\n                p.focusAccel = this.focusAccel;\n            }\n            return p;\n        }\n        update(engine, delta) {\n            var _a;\n            super.update(engine, delta);\n            if (this.isEmitting) {\n                this._particlesToEmit += this.emitRate * (delta / 1000);\n                if (this._particlesToEmit > 1.0) {\n                    this.emitParticles(Math.floor(this._particlesToEmit));\n                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\n                }\n            }\n            // deferred removal\n            for(let i = 0; i < this.deadParticles.length; i++){\n                removeItemFromArray(this.deadParticles[i], this.particles);\n                if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) this.scene.world.remove(this.deadParticles[i], false);\n            }\n            this.deadParticles.length = 0;\n        }\n    }\n    class GraphicsSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\",\n                \"ex.graphics\"\n            ];\n            this.systemType = SystemType.Draw;\n            this.priority = 0;\n            this._token = 0;\n            this._sortedTransforms = [];\n            this._zHasChanged = false;\n            this._zIndexUpdate = ()=>{\n                this._zHasChanged = true;\n            };\n        }\n        get sortedTransforms() {\n            return this._sortedTransforms;\n        }\n        initialize(scene) {\n            this._camera = scene.camera;\n            this._engine = scene.engine;\n        }\n        preupdate() {\n            // Graphics context could be switched to fallback in a new frame\n            this._graphicsContext = this._engine.graphicsContext;\n            if (this._zHasChanged) {\n                this._sortedTransforms.sort((a, b)=>{\n                    return a.z - b.z;\n                });\n                this._zHasChanged = false;\n            }\n        }\n        notify(entityAddedOrRemoved) {\n            if (isAddedSystemEntity(entityAddedOrRemoved)) {\n                const tx = entityAddedOrRemoved.data.get(TransformComponent);\n                this._sortedTransforms.push(tx);\n                tx.zIndexChanged$.subscribe(this._zIndexUpdate);\n                this._zHasChanged = true;\n            } else {\n                const tx = entityAddedOrRemoved.data.get(TransformComponent);\n                tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\n                const index = this._sortedTransforms.indexOf(tx);\n                if (index > -1) this._sortedTransforms.splice(index, 1);\n            }\n        }\n        update(_entities, delta) {\n            this._token++;\n            let graphics;\n            // This is a performance enhancement, most things are in world space\n            // so if we can only do this once saves a ton of transform updates\n            this._graphicsContext.save();\n            if (this._camera) this._camera.draw(this._graphicsContext);\n            for (const transform of this._sortedTransforms){\n                const entity = transform.owner;\n                // If the entity is offscreen skip\n                if (entity.hasTag(\"ex.offscreen\")) continue;\n                graphics = entity.get(GraphicsComponent);\n                // Exit if graphics set to not visible\n                if (!graphics.visible) continue;\n                // This optionally sets our camera based on the entity coord plan (world vs. screen)\n                if (transform.coordPlane === CoordPlane.Screen) this._graphicsContext.restore();\n                this._graphicsContext.save();\n                // Tick any graphics state (but only once) for animations and graphics groups\n                graphics.update(delta, this._token);\n                // Apply parallax\n                const parallax = entity.get(ParallaxComponent);\n                if (parallax) {\n                    // We use the Tiled formula\n                    // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\n                    // cameraPos * (1 - parallaxFactor)\n                    const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);\n                    const parallaxOffset = this._camera.pos.scale(oneMinusFactor);\n                    this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);\n                }\n                // Position the entity + estimate lag\n                this._applyTransform(entity);\n                // Optionally run the onPreDraw graphics lifecycle draw\n                if (graphics.onPreDraw) graphics.onPreDraw(this._graphicsContext, delta);\n                // TODO remove this hack on the particle redo\n                const particleOpacity = entity instanceof Particle ? entity.opacity : 1;\n                this._graphicsContext.opacity = graphics.opacity * particleOpacity;\n                // Draw the graphics component\n                this._drawGraphicsComponent(graphics);\n                // Optionally run the onPostDraw graphics lifecycle draw\n                if (graphics.onPostDraw) graphics.onPostDraw(this._graphicsContext, delta);\n                this._graphicsContext.restore();\n                // Reset the transform back to the original world space\n                if (transform.coordPlane === CoordPlane.Screen) {\n                    this._graphicsContext.save();\n                    if (this._camera) this._camera.draw(this._graphicsContext);\n                }\n            }\n            this._graphicsContext.restore();\n        }\n        _drawGraphicsComponent(graphicsComponent) {\n            var _a, _b;\n            if (graphicsComponent.visible) {\n                // this should be moved to the graphics system\n                for (const layer of graphicsComponent.layers.get())for (const { graphic: graphic , options: options  } of layer.graphics){\n                    let anchor = graphicsComponent.anchor;\n                    let offset = graphicsComponent.offset;\n                    if (options === null || options === void 0 ? void 0 : options.anchor) anchor = options.anchor;\n                    if (options === null || options === void 0 ? void 0 : options.offset) offset = options.offset;\n                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\n                    const offsetX = -graphic.width * anchor.x + offset.x;\n                    const offsetY = -graphic.height * anchor.y + offset.y;\n                    graphic === null || graphic === void 0 || graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);\n                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {\n                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);\n                        if (graphic instanceof GraphicsGroup) for (const g of graphic.members)(_b = g.graphic) === null || _b === void 0 || _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\n                        else /* istanbul ignore next */ graphic === null || graphic === void 0 || graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\n                    }\n                }\n            }\n        }\n        /**\r\n     * This applies the current entity transform to the graphics context\r\n     * @param entity\r\n     */ _applyTransform(entity) {\n            const ancestors = entity.getAncestors();\n            for (const ancestor of ancestors){\n                const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);\n                const optionalBody = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(BodyComponent);\n                let interpolatedPos = transform.pos;\n                let interpolatedScale = transform.scale;\n                let interpolatedRotation = transform.rotation;\n                if (optionalBody) {\n                    if (this._engine.fixedUpdateFps && optionalBody.__oldTransformCaptured && optionalBody.enableFixedUpdateInterpolate) {\n                        // Interpolate graphics if needed\n                        const blend = this._engine.currentFrameLagMs / (1000 / this._engine.fixedUpdateFps);\n                        interpolatedPos = transform.pos.scale(blend).add(optionalBody.oldPos.scale(1.0 - blend));\n                        interpolatedScale = transform.scale.scale(blend).add(optionalBody.oldScale.scale(1.0 - blend));\n                        // Rotational lerp https://stackoverflow.com/a/30129248\n                        const cosine = (1.0 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);\n                        const sine = (1.0 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);\n                        interpolatedRotation = Math.atan2(sine, cosine);\n                    }\n                }\n                if (transform) {\n                    this._graphicsContext.z = transform.z;\n                    this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);\n                    this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);\n                    this._graphicsContext.rotate(interpolatedRotation);\n                }\n            }\n        }\n    }\n    class DebugSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\"\n            ];\n            this.systemType = SystemType.Draw;\n            this.priority = 999; // lowest priority\n        }\n        initialize(scene) {\n            this._graphicsContext = scene.engine.graphicsContext;\n            this._camera = scene.camera;\n            this._engine = scene.engine;\n            this._collisionSystem = scene.world.systemManager.get(CollisionSystem);\n        }\n        update(entities, _delta) {\n            var _a;\n            if (!this._engine.isDebug) return;\n            const filterSettings = this._engine.debug.filter;\n            let id;\n            let name;\n            const entitySettings = this._engine.debug.entity;\n            let tx;\n            const txSettings = this._engine.debug.transform;\n            let motion;\n            const motionSettings = this._engine.debug.motion;\n            let colliderComp;\n            const colliderSettings = this._engine.debug.collider;\n            const physicsSettings = this._engine.debug.physics;\n            let graphics;\n            const graphicsSettings = this._engine.debug.graphics;\n            let debugDraw;\n            let body;\n            const bodySettings = this._engine.debug.body;\n            const cameraSettings = this._engine.debug.camera;\n            for (const entity of entities){\n                if (entity.hasTag(\"offscreen\")) continue;\n                if (entity instanceof Particle) continue;\n                if (filterSettings.useFilter) {\n                    const allIds = filterSettings.ids.length === 0;\n                    const idMatch = allIds || filterSettings.ids.includes(entity.id);\n                    if (!idMatch) continue;\n                    const allNames = filterSettings.nameQuery === \"\";\n                    const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);\n                    if (!nameMatch) continue;\n                }\n                let cursor = Vector.Zero;\n                const lineHeight = vec(0, 16);\n                id = entity.id;\n                name = entity.name;\n                tx = entity.get(TransformComponent);\n                // This optionally sets our camera based on the entity coord plan (world vs. screen)\n                this._pushCameraTransform(tx);\n                this._graphicsContext.save();\n                this._applyTransform(entity);\n                if (tx) {\n                    if (txSettings.showAll || txSettings.showPosition) this._graphicsContext.debug.drawPoint(Vector.Zero, {\n                        size: 4,\n                        color: txSettings.positionColor\n                    });\n                    if (txSettings.showAll || txSettings.showPositionLabel) {\n                        this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (txSettings.showAll || txSettings.showZIndex) {\n                        this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (entitySettings.showAll || entitySettings.showId) {\n                        this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? \"child of id(\" + ((_a = entity.parent) === null || _a === void 0 ? void 0 : _a.id) + \")\" : \"\"}`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (entitySettings.showAll || entitySettings.showName) {\n                        this._graphicsContext.debug.drawText(`name(${name})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (txSettings.showAll || txSettings.showRotation) {\n                        this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);\n                        this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (txSettings.showAll || txSettings.showScale) this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);\n                }\n                graphics = entity.get(GraphicsComponent);\n                if (graphics) {\n                    if (graphicsSettings.showAll || graphicsSettings.showBounds) {\n                        const bounds = graphics.localBounds;\n                        bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);\n                    }\n                }\n                debugDraw = entity.get(DebugGraphicsComponent);\n                if (debugDraw) {\n                    if (!debugDraw.useTransform) this._graphicsContext.restore();\n                    debugDraw.draw(this._graphicsContext);\n                    if (!debugDraw.useTransform) {\n                        this._graphicsContext.save();\n                        this._applyTransform(entity);\n                    }\n                }\n                body = entity.get(BodyComponent);\n                if (body) {\n                    if (bodySettings.showAll || bodySettings.showCollisionGroup) {\n                        this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (bodySettings.showAll || bodySettings.showCollisionType) {\n                        this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (bodySettings.showAll || bodySettings.showMass) {\n                        this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (bodySettings.showAll || bodySettings.showMotion) {\n                        this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (bodySettings.showAll || bodySettings.showSleeping) {\n                        this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : \"cant sleep\"})`, cursor);\n                        cursor = cursor.add(lineHeight);\n                    }\n                }\n                this._graphicsContext.restore();\n                motion = entity.get(MotionComponent);\n                if (motion) {\n                    if (motionSettings.showAll || motionSettings.showVelocity) {\n                        this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));\n                        this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);\n                        cursor = cursor.add(lineHeight);\n                    }\n                    if (motionSettings.showAll || motionSettings.showAcceleration) this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);\n                }\n                // Colliders live in world space already so after the restore()\n                colliderComp = entity.get(ColliderComponent);\n                if (colliderComp) {\n                    const collider = colliderComp.get();\n                    if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) collider.debug(this._graphicsContext, colliderSettings.geometryColor);\n                    if (colliderSettings.showAll || colliderSettings.showBounds) {\n                        if (collider instanceof CompositeCollider) {\n                            const colliders = collider.getColliders();\n                            for (const collider of colliders){\n                                const bounds = collider.bounds;\n                                const pos = vec(bounds.left, bounds.top);\n                                this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, {\n                                    color: colliderSettings.boundsColor\n                                });\n                                if (colliderSettings.showAll || colliderSettings.showOwner) this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);\n                            }\n                            colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);\n                        } else if (collider) {\n                            const bounds = colliderComp.bounds;\n                            const pos = vec(bounds.left, bounds.top);\n                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, {\n                                color: colliderSettings.boundsColor\n                            });\n                            if (colliderSettings.showAll || colliderSettings.showOwner) this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);\n                        }\n                    }\n                }\n                this._popCameraTransform(tx);\n            }\n            this._graphicsContext.save();\n            this._camera.draw(this._graphicsContext);\n            if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) this._collisionSystem.debug(this._graphicsContext);\n            if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts){\n                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) for (const point of contact.points)this._graphicsContext.debug.drawPoint(point, {\n                    size: 5,\n                    color: physicsSettings.collisionContactColor\n                });\n                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) for (const point of contact.points)this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {\n                    color: physicsSettings.collisionNormalColor\n                });\n            }\n            this._graphicsContext.restore();\n            if (cameraSettings) {\n                this._graphicsContext.save();\n                this._camera.draw(this._graphicsContext);\n                if (cameraSettings.showAll || cameraSettings.showFocus) this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);\n                if (cameraSettings.showAll || cameraSettings.showZoom) this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);\n                this._graphicsContext.restore();\n            }\n            this._graphicsContext.flush();\n        }\n        /**\r\n     * This applies the current entity transform to the graphics context\r\n     * @param entity\r\n     */ _applyTransform(entity) {\n            const ancestors = entity.getAncestors();\n            for (const ancestor of ancestors){\n                const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);\n                if (transform) {\n                    this._graphicsContext.translate(transform.pos.x, transform.pos.y);\n                    this._graphicsContext.scale(transform.scale.x, transform.scale.y);\n                    this._graphicsContext.rotate(transform.rotation);\n                }\n            }\n        }\n        /**\r\n     * Applies the current camera transform if in world coordinates\r\n     * @param transform\r\n     */ _pushCameraTransform(transform) {\n            // Establish camera offset per entity\n            if (transform.coordPlane === CoordPlane.World) {\n                this._graphicsContext.save();\n                if (this._camera) this._camera.draw(this._graphicsContext);\n            }\n        }\n        /**\r\n     * Resets the current camera transform if in world coordinates\r\n     * @param transform\r\n     */ _popCameraTransform(transform) {\n            if (transform.coordPlane === CoordPlane.World) // Apply camera world offset\n            this._graphicsContext.restore();\n        }\n    }\n    /**\r\n * The PointerSystem is responsible for dispatching pointer events to entities\r\n * that need them.\r\n *\r\n * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use\r\n * the [[Collider]]'s shape for pointer events.\r\n */ class PointerSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\",\n                \"ex.pointer\"\n            ];\n            this.systemType = SystemType.Update;\n            this.priority = -1;\n            /**\r\n         * Optionally override component configuration for all entities\r\n         */ this.overrideUseColliderShape = false;\n            /**\r\n         * Optionally override component configuration for all entities\r\n         */ this.overrideUseGraphicsBounds = false;\n            this.lastFrameEntityToPointers = new Map();\n            this.currentFrameEntityToPointers = new Map();\n            this._sortedTransforms = [];\n            this._sortedEntities = [];\n            this._zHasChanged = false;\n            this._zIndexUpdate = ()=>{\n                this._zHasChanged = true;\n            };\n        }\n        initialize(scene) {\n            this._engine = scene.engine;\n        }\n        preupdate() {\n            // event receiver might change per frame\n            this._receiver = this._engine.input.pointers;\n            if (this._zHasChanged) {\n                this._sortedTransforms.sort((a, b)=>{\n                    return b.z - a.z;\n                });\n                this._sortedEntities = this._sortedTransforms.map((t)=>t.owner);\n                this._zHasChanged = false;\n            }\n        }\n        notify(entityAddedOrRemoved) {\n            if (isAddedSystemEntity(entityAddedOrRemoved)) {\n                const tx = entityAddedOrRemoved.data.get(TransformComponent);\n                this._sortedTransforms.push(tx);\n                this._sortedEntities.push(tx.owner);\n                tx.zIndexChanged$.subscribe(this._zIndexUpdate);\n                this._zHasChanged = true;\n            } else {\n                const tx = entityAddedOrRemoved.data.get(TransformComponent);\n                tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\n                const index = this._sortedTransforms.indexOf(tx);\n                if (index > -1) {\n                    this._sortedTransforms.splice(index, 1);\n                    this._sortedEntities.splice(index, 1);\n                }\n            }\n        }\n        entityCurrentlyUnderPointer(entity, pointerId) {\n            return this.currentFrameEntityToPointers.has(entity.id) && this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);\n        }\n        entityWasUnderPointer(entity, pointerId) {\n            return this.lastFrameEntityToPointers.has(entity.id) && this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);\n        }\n        entered(entity, pointerId) {\n            return this.entityCurrentlyUnderPointer(entity, pointerId) && !this.lastFrameEntityToPointers.has(entity.id);\n        }\n        left(entity, pointerId) {\n            return !this.currentFrameEntityToPointers.has(entity.id) && this.entityWasUnderPointer(entity, pointerId);\n        }\n        addPointerToEntity(entity, pointerId) {\n            if (!this.currentFrameEntityToPointers.has(entity.id)) {\n                this.currentFrameEntityToPointers.set(entity.id, [\n                    pointerId\n                ]);\n                return;\n            }\n            const pointers = this.currentFrameEntityToPointers.get(entity.id);\n            this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));\n        }\n        update(_entities) {\n            // Locate all the pointer/entity mappings\n            this._processPointerToEntity(this._sortedEntities);\n            // Dispatch pointer events on entities\n            this._dispatchEvents(this._sortedEntities);\n            // Clear last frame's events\n            this._receiver.update();\n            this.lastFrameEntityToPointers.clear();\n            this.lastFrameEntityToPointers = new Map(this.currentFrameEntityToPointers);\n            this.currentFrameEntityToPointers.clear();\n            this._receiver.clear();\n        }\n        _processPointerToEntity(entities) {\n            var _a;\n            let transform;\n            let collider;\n            let graphics;\n            let pointer;\n            // TODO probably a spatial partition optimization here to quickly query bounds for pointer\n            // doesn't seem to cause issues tho for perf\n            // Pre-process find entities under pointers\n            for (const entity of entities){\n                transform = entity.get(TransformComponent);\n                pointer = (_a = entity.get(PointerComponent)) !== null && _a !== void 0 ? _a : new PointerComponent;\n                // Check collider contains pointer\n                collider = entity.get(ColliderComponent);\n                if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {\n                    collider.update();\n                    const geom = collider.get();\n                    if (geom) {\n                        for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries())if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) this.addPointerToEntity(entity, pointerId);\n                    }\n                }\n                // Check graphics contains pointer\n                graphics = entity.get(GraphicsComponent);\n                if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {\n                    const graphicBounds = graphics.localBounds.transform(transform.get().matrix);\n                    for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries())if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) this.addPointerToEntity(entity, pointerId);\n                }\n            }\n        }\n        _processDownAndEmit(entity) {\n            const lastDownPerPointer = new Map();\n            // Loop through down and dispatch to entities\n            for (const event of this._receiver.currentFrameDown){\n                if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\n                    entity.events.emit(\"pointerdown\", event);\n                    if (this._receiver.isDragStart(event.pointerId)) entity.events.emit(\"pointerdragstart\", event);\n                }\n                lastDownPerPointer.set(event.pointerId, event);\n            }\n            return lastDownPerPointer;\n        }\n        _processUpAndEmit(entity) {\n            const lastUpPerPointer = new Map();\n            // Loop through up and dispatch to entities\n            for (const event of this._receiver.currentFrameUp){\n                if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\n                    entity.events.emit(\"pointerup\", event);\n                    if (this._receiver.isDragEnd(event.pointerId)) entity.events.emit(\"pointerdragend\", event);\n                }\n                lastUpPerPointer.set(event.pointerId, event);\n            }\n            return lastUpPerPointer;\n        }\n        _processMoveAndEmit(entity) {\n            const lastMovePerPointer = new Map();\n            // Loop through move and dispatch to entities\n            for (const event of this._receiver.currentFrameMove){\n                if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\n                    // move\n                    entity.events.emit(\"pointermove\", event);\n                    if (this._receiver.isDragging(event.pointerId)) entity.events.emit(\"pointerdragmove\", event);\n                }\n                lastMovePerPointer.set(event.pointerId, event);\n            }\n            return lastMovePerPointer;\n        }\n        _processEnterLeaveAndEmit(entity, lastUpDownMoveEvents) {\n            // up, down, and move are considered for enter and leave\n            for (const event of lastUpDownMoveEvents){\n                // enter\n                if (event.active && entity.active && this.entered(entity, event.pointerId)) {\n                    entity.events.emit(\"pointerenter\", event);\n                    if (this._receiver.isDragging(event.pointerId)) entity.events.emit(\"pointerdragenter\", event);\n                    break;\n                }\n                if (event.active && entity.active && // leave can happen on move\n                (this.left(entity, event.pointerId) || // or leave can happen on pointer up\n                this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === \"up\")) {\n                    entity.events.emit(\"pointerleave\", event);\n                    if (this._receiver.isDragging(event.pointerId)) entity.events.emit(\"pointerdragleave\", event);\n                    break;\n                }\n            }\n        }\n        _processCancelAndEmit(entity) {\n            // cancel\n            for (const event of this._receiver.currentFrameCancel)if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) entity.events.emit(\"pointercancel\", event);\n        }\n        _processWheelAndEmit(entity) {\n            // wheel\n            for (const event of this._receiver.currentFrameWheel)// Currently the wheel only fires under the primary pointer '0'\n            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) entity.events.emit(\"pointerwheel\", event);\n        }\n        _dispatchEvents(entities) {\n            const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());\n            const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());\n            // Filter preserves z order\n            const entitiesWithEvents = entities.filter((e)=>lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));\n            let lastMovePerPointer;\n            let lastUpPerPointer;\n            let lastDownPerPointer;\n            // Dispatch events in entity z order\n            for (const entity of entitiesWithEvents){\n                lastDownPerPointer = this._processDownAndEmit(entity);\n                lastUpPerPointer = this._processUpAndEmit(entity);\n                lastMovePerPointer = this._processMoveAndEmit(entity);\n                const lastUpDownMoveEvents = [\n                    ...lastMovePerPointer.values(),\n                    ...lastDownPerPointer.values(),\n                    ...lastUpPerPointer.values()\n                ];\n                this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);\n                this._processCancelAndEmit(entity);\n                this._processWheelAndEmit(entity);\n            }\n        }\n    }\n    class ActionsSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.actions\"\n            ];\n            this.systemType = SystemType.Update;\n            this.priority = -1;\n            this._actions = [];\n        }\n        notify(entityAddedOrRemoved) {\n            if (isAddedSystemEntity(entityAddedOrRemoved)) {\n                const action = entityAddedOrRemoved.data.get(ActionsComponent);\n                this._actions.push(action);\n            } else {\n                const action = entityAddedOrRemoved.data.get(ActionsComponent);\n                const index = this._actions.indexOf(action);\n                if (index > -1) this._actions.splice(index, 1);\n            }\n        }\n        update(_entities, delta) {\n            for (const actions of this._actions)actions.update(delta);\n        }\n    }\n    class IsometricEntityComponent extends Component {\n        /**\r\n     * Specify the isometric map to use to position this entity's z-index\r\n     * @param map\r\n     */ constructor(map){\n            super();\n            this.type = \"ex.isometricentity\";\n            /**\r\n         * Vertical \"height\" in the isometric world\r\n         */ this.elevation = 0;\n            this.map = map;\n        }\n    }\n    class IsometricEntitySystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\",\n                \"ex.isometricentity\"\n            ];\n            this.systemType = SystemType.Update;\n            this.priority = 99;\n        }\n        update(entities, _delta) {\n            let transform;\n            let iso;\n            for (const entity of entities){\n                transform = entity.get(TransformComponent);\n                iso = entity.get(IsometricEntityComponent);\n                const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);\n                const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;\n                transform.z = newZ;\n            }\n        }\n    }\n    class OffscreenSystem extends System {\n        constructor(){\n            super(...arguments);\n            this.types = [\n                \"ex.transform\",\n                \"ex.graphics\"\n            ];\n            this.systemType = SystemType.Draw;\n            this.priority = -1;\n        }\n        initialize(scene) {\n            this._camera = scene.camera;\n        }\n        update(entities) {\n            let transform;\n            let graphics;\n            let maybeParallax;\n            for (const entity of entities){\n                graphics = entity.get(GraphicsComponent);\n                transform = entity.get(TransformComponent);\n                maybeParallax = entity.get(ParallaxComponent);\n                let parallaxOffset;\n                if (maybeParallax) {\n                    // We use the Tiled formula\n                    // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\n                    // cameraPos * (1 - parallaxFactor)\n                    const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\n                    parallaxOffset = this._camera.pos.scale(oneMinusFactor);\n                }\n                // Figure out if entities are offscreen\n                const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);\n                if (entityOffscreen && !entity.hasTag(\"ex.offscreen\")) {\n                    entity.eventDispatcher.emit(\"exitviewport\", new ExitViewPortEvent(entity));\n                    entity.addTag(\"ex.offscreen\");\n                }\n                if (!entityOffscreen && entity.hasTag(\"ex.offscreen\")) {\n                    entity.eventDispatcher.emit(\"enterviewport\", new EnterViewPortEvent(entity));\n                    entity.removeTag(\"ex.offscreen\");\n                }\n            }\n        }\n        _isOffscreen(transform, graphics, parallaxOffset) {\n            if (transform.coordPlane === CoordPlane.World) {\n                let bounds = graphics.localBounds;\n                if (parallaxOffset) bounds = bounds.translate(parallaxOffset);\n                const transformedBounds = bounds.transform(transform.get().matrix);\n                const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);\n                return graphicsOffscreen;\n            } else // TODO screen coordinates\n            return false;\n        }\n    }\n    /**\r\n * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n * Excalibur. The metaphor models the same idea behind real world\r\n * actors in a scene. Only actors in scenes will be updated and drawn.\r\n *\r\n * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n */ class Scene extends Class {\n        constructor(){\n            super();\n            this._logger = Logger.getInstance();\n            /**\r\n         * Gets or sets the current camera for the scene\r\n         */ this.camera = new Camera();\n            /**\r\n         * The ECS world for the scene\r\n         */ this.world = new World(this);\n            this._isInitialized = false;\n            this._timers = [];\n            this._cancelQueue = [];\n            // Initialize systems\n            // Update\n            this.world.add(new ActionsSystem());\n            this.world.add(new MotionSystem());\n            this.world.add(new CollisionSystem());\n            this.world.add(new PointerSystem());\n            this.world.add(new IsometricEntitySystem());\n            // Draw\n            this.world.add(new OffscreenSystem());\n            this.world.add(new GraphicsSystem());\n            this.world.add(new DebugSystem());\n        }\n        /**\r\n     * The actors in the current scene\r\n     */ get actors() {\n            return this.world.entityManager.entities.filter((e)=>{\n                return e instanceof Actor;\n            });\n        }\n        /**\r\n     * The entities in the current scene\r\n     */ get entities() {\n            return this.world.entityManager.entities;\n        }\n        /**\r\n     * The triggers in the current scene\r\n     */ get triggers() {\n            return this.world.entityManager.entities.filter((e)=>{\n                return e instanceof Trigger;\n            });\n        }\n        /**\r\n     * The [[TileMap]]s in the scene, if any\r\n     */ get tileMaps() {\n            return this.world.entityManager.entities.filter((e)=>{\n                return e instanceof TileMap;\n            });\n        }\n        get timers() {\n            return this._timers;\n        }\n        on(eventName, handler) {\n            super.on(eventName, handler);\n        }\n        once(eventName, handler) {\n            super.once(eventName, handler);\n        }\n        off(eventName, handler) {\n            super.off(eventName, handler);\n        }\n        /**\r\n     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n     * overridden. This is where initialization of child actors should take place.\r\n     */ onInitialize(_engine) {\n        // will be overridden\n        }\n        /**\r\n     * This is called when the scene is made active and started. It is meant to be overridden,\r\n     * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n     */ onActivate(_context) {\n        // will be overridden\n        }\n        /**\r\n     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,\r\n     * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n     */ onDeactivate(_context) {\n        // will be overridden\n        }\n        /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before a scene is updated.\r\n     */ onPreUpdate(_engine, _delta) {\n        // will be overridden\n        }\n        /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after a scene is updated.\r\n     */ onPostUpdate(_engine, _delta) {\n        // will be overridden\n        }\n        /**\r\n     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreDraw` is called directly before a scene is drawn.\r\n     *\r\n     */ onPreDraw(_ctx, _delta) {\n        // will be overridden\n        }\n        /**\r\n     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostDraw` is called directly after a scene is drawn.\r\n     *\r\n     */ onPostDraw(_ctx, _delta) {\n        // will be overridden\n        }\n        /**\r\n     * Initializes actors in the scene\r\n     */ _initializeChildren() {\n            for (const child of this.entities)child._initialize(this.engine);\n        }\n        /**\r\n     * Gets whether or not the [[Scene]] has been initialized\r\n     */ get isInitialized() {\n            return this._isInitialized;\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Initializes the scene before the first update, meant to be called by engine not by users of\r\n     * Excalibur\r\n     * @internal\r\n     */ _initialize(engine) {\n            if (!this.isInitialized) {\n                this.engine = engine;\n                // Initialize camera first\n                this.camera._initialize(engine);\n                this.world.systemManager.initialize();\n                // This order is important! we want to be sure any custom init that add actors\n                // fire before the actor init\n                this.onInitialize.call(this, engine);\n                this._initializeChildren();\n                this._logger.debug(\"Scene.onInitialize\", this, engine);\n                this.eventDispatcher.emit(\"initialize\", new InitializeEvent(engine, this));\n                this._isInitialized = true;\n            }\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.\r\n     * @internal\r\n     */ _activate(context) {\n            this._logger.debug(\"Scene.onActivate\", this);\n            this.onActivate(context);\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.\r\n     * @internal\r\n     */ _deactivate(context) {\n            this._logger.debug(\"Scene.onDeactivate\", this);\n            this.onDeactivate(context);\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */ _preupdate(_engine, delta) {\n            this.emit(\"preupdate\", new PreUpdateEvent(_engine, delta, this));\n            this.onPreUpdate(_engine, delta);\n        }\n        /**\r\n     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */ _postupdate(_engine, delta) {\n            this.emit(\"postupdate\", new PostUpdateEvent(_engine, delta, this));\n            this.onPostUpdate(_engine, delta);\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n     *\r\n     * @internal\r\n     */ _predraw(_ctx, _delta) {\n            this.emit(\"predraw\", new PreDrawEvent(_ctx, _delta, this));\n            this.onPreDraw(_ctx, _delta);\n        }\n        /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n     *\r\n     * @internal\r\n     */ _postdraw(_ctx, _delta) {\n            this.emit(\"postdraw\", new PostDrawEvent(_ctx, _delta, this));\n            this.onPostDraw(_ctx, _delta);\n        }\n        /**\r\n     * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n     * @param engine  Reference to the current Engine\r\n     * @param delta   The number of milliseconds since the last update\r\n     */ update(engine, delta) {\n            this._preupdate(engine, delta);\n            // TODO differed entity removal for timers\n            let i, len;\n            // Remove timers in the cancel queue before updating them\n            for(i = 0, len = this._cancelQueue.length; i < len; i++)this.removeTimer(this._cancelQueue[i]);\n            this._cancelQueue.length = 0;\n            // Cycle through timers updating timers\n            for (const timer of this._timers)timer.update(delta);\n            this.world.update(SystemType.Update, delta);\n            // Camera last keeps renders smooth that are based on entity/actor\n            if (this.camera) this.camera.update(engine, delta);\n            this._collectActorStats(engine);\n            this._postupdate(engine, delta);\n        }\n        /**\r\n     * Draws all the actors in the Scene. Called by the [[Engine]].\r\n     *\r\n     * @param ctx    The current rendering context\r\n     * @param delta  The number of milliseconds since the last draw\r\n     */ draw(ctx, delta) {\n            var _a;\n            this._predraw(ctx, delta);\n            this.world.update(SystemType.Draw, delta);\n            if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) this.debugDraw(ctx);\n            this._postdraw(ctx, delta);\n        }\n        /**\r\n     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].\r\n     * @param ctx  The current rendering context\r\n     */ /* istanbul ignore next */ debugDraw(ctx) {\n            this.emit(\"predebugdraw\", new PreDebugDrawEvent(ctx, this));\n            // pass\n            this.emit(\"postdebugdraw\", new PostDebugDrawEvent(ctx, this));\n        }\n        /**\r\n     * Checks whether an actor is contained in this scene or not\r\n     */ contains(actor) {\n            return this.actors.indexOf(actor) > -1;\n        }\n        add(entity) {\n            this.emit(\"entityadded\", {\n                target: entity\n            });\n            this.world.add(entity);\n            entity.scene = this;\n            if (entity instanceof Timer) {\n                if (!contains(this._timers, entity)) this.addTimer(entity);\n                return;\n            }\n        }\n        remove(entity) {\n            if (entity instanceof Entity) {\n                this.emit(\"entityremoved\", {\n                    target: entity\n                });\n                this.world.remove(entity);\n            }\n            if (entity instanceof Timer) this.removeTimer(entity);\n        }\n        /**\r\n     * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.\r\n     *\r\n     * By default entities use deferred removal\r\n     * @param deferred\r\n     */ clear(deferred = true) {\n            for (const entity of this.entities)this.world.remove(entity, deferred);\n            for (const timer of this.timers)this.removeTimer(timer);\n        }\n        /**\r\n     * Adds a [[Timer]] to the scene\r\n     * @param timer  The timer to add\r\n     */ addTimer(timer) {\n            this._timers.push(timer);\n            timer.scene = this;\n            return timer;\n        }\n        /**\r\n     * Removes a [[Timer]] from the scene.\r\n     * @warning Can be dangerous, use [[cancelTimer]] instead\r\n     * @param timer  The timer to remove\r\n     */ removeTimer(timer) {\n            const i = this._timers.indexOf(timer);\n            if (i !== -1) this._timers.splice(i, 1);\n            return timer;\n        }\n        /**\r\n     * Cancels a [[Timer]], removing it from the scene nicely\r\n     * @param timer  The timer to cancel\r\n     */ cancelTimer(timer) {\n            this._cancelQueue.push(timer);\n            return timer;\n        }\n        /**\r\n     * Tests whether a [[Timer]] is active in the scene\r\n     */ isTimerActive(timer) {\n            return this._timers.indexOf(timer) > -1 && !timer.complete;\n        }\n        isCurrentScene() {\n            if (this.engine) return this.engine.currentScene === this;\n            return false;\n        }\n        _collectActorStats(engine) {\n            const screenElements = this.actors.filter((a)=>a instanceof ScreenElement);\n            for (const _ui of screenElements)engine.stats.currFrame.actors.ui++;\n            for (const actor of this.actors){\n                engine.stats.currFrame.actors.alive++;\n                for (const child of actor.children)if (isScreenElement(child)) // TODO not true\n                engine.stats.currFrame.actors.ui++;\n                else engine.stats.currFrame.actors.alive++;\n            }\n        }\n    }\n    var ColorBlindnessMode;\n    (function(ColorBlindnessMode) {\n        ColorBlindnessMode[\"Protanope\"] = \"Protanope\";\n        ColorBlindnessMode[\"Deuteranope\"] = \"Deuteranope\";\n        ColorBlindnessMode[\"Tritanope\"] = \"Tritanope\";\n    })(ColorBlindnessMode || (ColorBlindnessMode = {}));\n    /* harmony default export */ const color_blind_fragment = \"#version 300 es\\r\\nprecision mediump float;\\r\\n// our texture\\r\\nuniform sampler2D u_image;\\r\\n// the texCoords passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// color blind type\\r\\nuniform int u_type;\\r\\n\\r\\n// simulation?\\r\\nuniform bool u_simulate;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  vec4 o =  texture(u_image, v_texcoord);\\r\\n  // RGB to LMS matrix conversion\\r\\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\\r\\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\\r\\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\\r\\n  // Simulate color blindness\\r\\n  float l;\\r\\n  float m;\\r\\n  float s;\\r\\n  //MODE CODE//\\r\\n  if (u_type == 0) {\\r\\n    // Protanope\\r\\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\\r\\n  } else if (u_type == 1) {\\r\\n    // Deuteranope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\\r\\n  } else if (u_type == 2) {\\r\\n    // Tritanope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\\r\\n  }\\r\\n\\r\\n  // LMS to RGB matrix conversion\\r\\n  vec4 error; // simulate the colors\\r\\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\\r\\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\\r\\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\\r\\n  error.a = 1.0;\\r\\n  vec4 diff = o - error;\\r\\n  vec4 correction; // correct the colors\\r\\n  correction.r = 0.0;\\r\\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\\r\\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\\r\\n  correction = o + correction;\\r\\n  correction.a = o.a;\\r\\n  //SIMULATE//\\r\\n\\r\\n  // sim \\r\\n  if (u_simulate) {\\r\\n    fragColor = error.rgba;\\r\\n  } else {\\r\\n    fragColor = correction.rgba;\\r\\n  }\\r\\n}\";\n    /**\r\n * Helper that defines a whole screen renderer, just provide a fragment source!\r\n *\r\n * Currently supports 1 varying\r\n * - vec2 a_texcoord between 0-1 which corresponds to screen position\r\n */ class ScreenShader {\n        constructor(fragmentSource){\n            this._shader = new Shader({\n                vertexSource: `#version 300 es\r\n      in vec2 a_position;\r\n      in vec2 a_texcoord;\r\n      out vec2 v_texcoord;\r\n\r\n      void main() {\r\n        gl_Position = vec4(a_position, 0.0, 1.0);\r\n        // Pass the texcoord to the fragment shader.\r\n        v_texcoord = a_texcoord;\r\n      }`,\n                fragmentSource: fragmentSource\n            });\n            this._shader.compile();\n            // Setup memory layout\n            this._buffer = new VertexBuffer({\n                type: \"static\",\n                // clip space quad + uv since we don't need a camera\n                data: new Float32Array([\n                    -1,\n                    -1,\n                    0,\n                    0,\n                    -1,\n                    1,\n                    0,\n                    1,\n                    1,\n                    -1,\n                    1,\n                    0,\n                    1,\n                    -1,\n                    1,\n                    0,\n                    -1,\n                    1,\n                    0,\n                    1,\n                    1,\n                    1,\n                    1,\n                    1\n                ])\n            });\n            this._layout = new VertexLayout({\n                shader: this._shader,\n                vertexBuffer: this._buffer,\n                attributes: [\n                    [\n                        \"a_position\",\n                        2\n                    ],\n                    [\n                        \"a_texcoord\",\n                        2\n                    ]\n                ]\n            });\n            this._buffer.upload();\n        }\n        getShader() {\n            return this._shader;\n        }\n        getLayout() {\n            return this._layout;\n        }\n    }\n    class ColorBlindnessPostProcessor {\n        constructor(_colorBlindnessMode, simulate = false){\n            this._colorBlindnessMode = _colorBlindnessMode;\n            this._simulate = false;\n            this._simulate = simulate;\n        }\n        initialize(_gl) {\n            this._shader = new ScreenShader(color_blind_fragment);\n            this.simulate = this._simulate;\n            this.colorBlindnessMode = this._colorBlindnessMode;\n        }\n        getShader() {\n            return this._shader.getShader();\n        }\n        getLayout() {\n            return this._shader.getLayout();\n        }\n        set colorBlindnessMode(colorBlindMode) {\n            this._colorBlindnessMode = colorBlindMode;\n            if (this._shader) {\n                const shader = this._shader.getShader();\n                shader.use();\n                if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) shader.setUniformInt(\"u_type\", 0);\n                else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) shader.setUniformInt(\"u_type\", 1);\n                else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) shader.setUniformInt(\"u_type\", 2);\n            }\n        }\n        get colorBlindnessMode() {\n            return this._colorBlindnessMode;\n        }\n        set simulate(value) {\n            this._simulate = value;\n            if (this._shader) {\n                const shader = this._shader.getShader();\n                shader.use();\n                shader.setUniformBoolean(\"u_simulate\", value);\n            }\n        }\n        get simulate() {\n            return this._simulate;\n        }\n    }\n    class ColorBlindFlags {\n        constructor(engine){\n            this._engine = engine;\n            this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);\n        }\n        /**\r\n     * Correct colors for a specified color blindness\r\n     * @param colorBlindness\r\n     */ correct(colorBlindness) {\n            if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\n                this.clear();\n                this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\n                this._colorBlindPostProcessor.simulate = false;\n                this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\n            }\n        }\n        /**\r\n     * Simulate colors for a specified color blindness\r\n     * @param colorBlindness\r\n     */ simulate(colorBlindness) {\n            if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\n                this.clear();\n                this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\n                this._colorBlindPostProcessor.simulate = true;\n                this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\n            }\n        }\n        /**\r\n     * Remove color blindness post processor\r\n     */ clear() {\n            this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);\n        }\n    }\n    /**\r\n * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n * updated during a frame.\r\n */ class Debug {\n        constructor(engine){\n            /**\r\n         * Performance statistics\r\n         */ this.stats = {\n                /**\r\n             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n             * Best accessed on [[postframe]] event. See [[FrameStats]]\r\n             */ currFrame: new FrameStats(),\n                /**\r\n             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]\r\n             */ prevFrame: new FrameStats()\n            };\n            /**\r\n         * Filter debug context to named entities or entity ids\r\n         */ this.filter = {\n                /**\r\n             * Toggle filter on or off (default off) must be on for DebugDraw to use filters\r\n             */ useFilter: false,\n                /**\r\n             * Query for entities by name, if the entity name contains `nameQuery` it will be included\r\n             */ nameQuery: \"\",\n                /**\r\n             * Query for Entity ids, if the id matches it will be included\r\n             */ ids: []\n            };\n            /**\r\n         * Entity debug settings\r\n         */ this.entity = {\n                showAll: false,\n                showId: true,\n                showName: false\n            };\n            /**\r\n         * Transform component debug settings\r\n         */ this.transform = {\n                showAll: false,\n                showPosition: false,\n                showPositionLabel: false,\n                positionColor: Color.Yellow,\n                showZIndex: false,\n                showScale: false,\n                scaleColor: Color.Green,\n                showRotation: false,\n                rotationColor: Color.Blue\n            };\n            /**\r\n         * Graphics component debug settings\r\n         */ this.graphics = {\n                showAll: false,\n                showBounds: true,\n                boundsColor: Color.Yellow\n            };\n            /**\r\n         * Collider component debug settings\r\n         */ this.collider = {\n                showAll: false,\n                showBounds: true,\n                boundsColor: Color.Blue,\n                showOwner: false,\n                showGeometry: true,\n                geometryColor: Color.Green\n            };\n            /**\r\n         * Physics simulation debug settings\r\n         */ this.physics = {\n                showAll: false,\n                showBroadphaseSpacePartitionDebug: false,\n                showCollisionNormals: false,\n                collisionNormalColor: Color.Cyan,\n                showCollisionContacts: true,\n                collisionContactColor: Color.Red\n            };\n            /**\r\n         * Motion component debug settings\r\n         */ this.motion = {\n                showAll: false,\n                showVelocity: false,\n                velocityColor: Color.Yellow,\n                showAcceleration: false,\n                accelerationColor: Color.Red\n            };\n            /**\r\n         * Body component debug settings\r\n         */ this.body = {\n                showAll: false,\n                showCollisionGroup: false,\n                showCollisionType: false,\n                showSleeping: false,\n                showMotion: false,\n                showMass: false\n            };\n            /**\r\n         * Camera debug settings\r\n         */ this.camera = {\n                showAll: false,\n                showFocus: false,\n                focusColor: Color.Red,\n                showZoom: false\n            };\n            this._engine = engine;\n            this.colorBlindMode = new ColorBlindFlags(this._engine);\n        }\n        /**\r\n     * Switch the current excalibur clock with the [[TestClock]] and return\r\n     * it in the same running state.\r\n     *\r\n     * This is useful when you need to debug frame by frame.\r\n     */ useTestClock() {\n            const clock = this._engine.clock;\n            const wasRunning = clock.isRunning();\n            clock.stop();\n            const testClock = clock.toTestClock();\n            if (wasRunning) testClock.start();\n            this._engine.clock = testClock;\n            return testClock;\n        }\n        /**\r\n     * Switch the current excalibur clock with the [[StandardClock]] and\r\n     * return it in the same running state.\r\n     *\r\n     * This is useful when you need to switch back to normal mode after\r\n     * debugging.\r\n     */ useStandardClock() {\n            const currentClock = this._engine.clock;\n            const wasRunning = currentClock.isRunning();\n            currentClock.stop();\n            const standardClock = currentClock.toStandardClock();\n            if (wasRunning) standardClock.start();\n            this._engine.clock = standardClock;\n            return standardClock;\n        }\n    }\n    /**\r\n * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n * creating instances of this every frame.\r\n */ class FrameStats {\n        constructor(){\n            this._id = 0;\n            this._delta = 0;\n            this._fps = 0;\n            this._actorStats = {\n                alive: 0,\n                killed: 0,\n                ui: 0,\n                get remaining () {\n                    return this.alive - this.killed;\n                },\n                get total () {\n                    return this.remaining + this.ui;\n                }\n            };\n            this._durationStats = {\n                update: 0,\n                draw: 0,\n                get total () {\n                    return this.update + this.draw;\n                }\n            };\n            this._physicsStats = new PhysicsStats();\n            this._graphicsStats = {\n                drawCalls: 0,\n                drawnImages: 0\n            };\n        }\n        /**\r\n     * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n     *\r\n     * @param [otherStats] Optional stats to clone\r\n     */ reset(otherStats) {\n            if (otherStats) {\n                this.id = otherStats.id;\n                this.delta = otherStats.delta;\n                this.fps = otherStats.fps;\n                this.actors.alive = otherStats.actors.alive;\n                this.actors.killed = otherStats.actors.killed;\n                this.actors.ui = otherStats.actors.ui;\n                this.duration.update = otherStats.duration.update;\n                this.duration.draw = otherStats.duration.draw;\n                this._physicsStats.reset(otherStats.physics);\n                this.graphics.drawCalls = otherStats.graphics.drawCalls;\n                this.graphics.drawnImages = otherStats.graphics.drawnImages;\n            } else {\n                this.id = this.delta = this.fps = 0;\n                this.actors.alive = this.actors.killed = this.actors.ui = 0;\n                this.duration.update = this.duration.draw = 0;\n                this._physicsStats.reset();\n                this.graphics.drawnImages = this.graphics.drawCalls = 0;\n            }\n        }\n        /**\r\n     * Provides a clone of this instance.\r\n     */ clone() {\n            const fs = new FrameStats();\n            fs.reset(this);\n            return fs;\n        }\n        /**\r\n     * Gets the frame's id\r\n     */ get id() {\n            return this._id;\n        }\n        /**\r\n     * Sets the frame's id\r\n     */ set id(value) {\n            this._id = value;\n        }\n        /**\r\n     * Gets the frame's delta (time since last frame)\r\n     */ get delta() {\n            return this._delta;\n        }\n        /**\r\n     * Sets the frame's delta (time since last frame). Internal use only.\r\n     * @internal\r\n     */ set delta(value) {\n            this._delta = value;\n        }\n        /**\r\n     * Gets the frame's frames-per-second (FPS)\r\n     */ get fps() {\n            return this._fps;\n        }\n        /**\r\n     * Sets the frame's frames-per-second (FPS). Internal use only.\r\n     * @internal\r\n     */ set fps(value) {\n            this._fps = value;\n        }\n        /**\r\n     * Gets the frame's actor statistics\r\n     */ get actors() {\n            return this._actorStats;\n        }\n        /**\r\n     * Gets the frame's duration statistics\r\n     */ get duration() {\n            return this._durationStats;\n        }\n        /**\r\n     * Gets the frame's physics statistics\r\n     */ get physics() {\n            return this._physicsStats;\n        }\n        /**\r\n     * Gets the frame's graphics statistics\r\n     */ get graphics() {\n            return this._graphicsStats;\n        }\n    }\n    class PhysicsStats {\n        constructor(){\n            this._pairs = 0;\n            this._collisions = 0;\n            this._contacts = new Map();\n            this._fastBodies = 0;\n            this._fastBodyCollisions = 0;\n            this._broadphase = 0;\n            this._narrowphase = 0;\n        }\n        /**\r\n     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n     *\r\n     * @param [otherStats] Optional stats to clone\r\n     */ reset(otherStats) {\n            if (otherStats) {\n                this.pairs = otherStats.pairs;\n                this.collisions = otherStats.collisions;\n                this.contacts = otherStats.contacts;\n                this.fastBodies = otherStats.fastBodies;\n                this.fastBodyCollisions = otherStats.fastBodyCollisions;\n                this.broadphase = otherStats.broadphase;\n                this.narrowphase = otherStats.narrowphase;\n            } else {\n                this.pairs = this.collisions = this.fastBodies = 0;\n                this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\n                this.contacts.clear();\n            }\n        }\n        /**\r\n     * Provides a clone of this instance.\r\n     */ clone() {\n            const ps = new PhysicsStats();\n            ps.reset(this);\n            return ps;\n        }\n        get pairs() {\n            return this._pairs;\n        }\n        set pairs(value) {\n            this._pairs = value;\n        }\n        get collisions() {\n            return this._collisions;\n        }\n        set collisions(value) {\n            this._collisions = value;\n        }\n        get contacts() {\n            return this._contacts;\n        }\n        set contacts(contacts) {\n            this._contacts = contacts;\n        }\n        get fastBodies() {\n            return this._fastBodies;\n        }\n        set fastBodies(value) {\n            this._fastBodies = value;\n        }\n        get fastBodyCollisions() {\n            return this._fastBodyCollisions;\n        }\n        set fastBodyCollisions(value) {\n            this._fastBodyCollisions = value;\n        }\n        get broadphase() {\n            return this._broadphase;\n        }\n        set broadphase(value) {\n            this._broadphase = value;\n        }\n        get narrowphase() {\n            return this._narrowphase;\n        }\n        set narrowphase(value) {\n            this._narrowphase = value;\n        }\n    }\n    /**\r\n * Determines the scope of handling mouse/touch events.\r\n */ var PointerScope;\n    (function(PointerScope) {\n        /**\r\n     * Handle events on the `canvas` element only. Events originating outside the\r\n     * `canvas` will not be handled.\r\n     */ PointerScope[\"Canvas\"] = \"Canvas\";\n        /**\r\n     * Handles events on the entire document. All events will be handled by Excalibur.\r\n     */ PointerScope[\"Document\"] = \"Document\";\n    })(PointerScope || (PointerScope = {}));\n    /**\r\n * Enum representing physical input key codes\r\n */ var Keys;\n    (function(Keys) {\n        // NUMPAD\n        Keys[\"Num0\"] = \"Numpad0\";\n        Keys[\"Num1\"] = \"Numpad1\";\n        Keys[\"Num2\"] = \"Numpad2\";\n        Keys[\"Num3\"] = \"Numpad3\";\n        Keys[\"Num4\"] = \"Numpad4\";\n        Keys[\"Num5\"] = \"Numpad5\";\n        Keys[\"Num6\"] = \"Numpad6\";\n        Keys[\"Num7\"] = \"Numpad7\";\n        Keys[\"Num8\"] = \"Numpad8\";\n        Keys[\"Num9\"] = \"Numpad9\";\n        Keys[\"NumAdd\"] = \"NumpadAdd\";\n        Keys[\"NumSubtract\"] = \"NumpadSubtract\";\n        Keys[\"NumMultiply\"] = \"NumpadMultiply\";\n        Keys[\"NumDivide\"] = \"NumpadDivide\";\n        // NumComma = 'NumpadComma', // not x-browser\n        Keys[\"NumDecimal\"] = \"NumpadDecimal\";\n        Keys[\"Numpad0\"] = \"Numpad0\";\n        Keys[\"Numpad1\"] = \"Numpad1\";\n        Keys[\"Numpad2\"] = \"Numpad2\";\n        Keys[\"Numpad3\"] = \"Numpad3\";\n        Keys[\"Numpad4\"] = \"Numpad4\";\n        Keys[\"Numpad5\"] = \"Numpad5\";\n        Keys[\"Numpad6\"] = \"Numpad6\";\n        Keys[\"Numpad7\"] = \"Numpad7\";\n        Keys[\"Numpad8\"] = \"Numpad8\";\n        Keys[\"Numpad9\"] = \"Numpad9\";\n        Keys[\"NumpadAdd\"] = \"NumpadAdd\";\n        Keys[\"NumpadSubtract\"] = \"NumpadSubtract\";\n        Keys[\"NumpadMultiply\"] = \"NumpadMultiply\";\n        Keys[\"NumpadDivide\"] = \"NumpadDivide\";\n        // NumpadComma = 'NumpadComma', // not x-browser\n        Keys[\"NumpadDecimal\"] = \"NumpadDecimal\";\n        // MODIFIERS\n        Keys[\"NumLock\"] = \"NumLock\";\n        Keys[\"ShiftLeft\"] = \"ShiftLeft\";\n        Keys[\"ShiftRight\"] = \"ShiftRight\";\n        Keys[\"AltLeft\"] = \"AltLeft\";\n        Keys[\"AltRight\"] = \"AltRight\";\n        Keys[\"ControlLeft\"] = \"ControlLeft\";\n        Keys[\"ControlRight\"] = \"ControlRight\";\n        Keys[\"MetaLeft\"] = \"MetaLeft\";\n        Keys[\"MetaRight\"] = \"MetaRight\";\n        // NUMBERS\n        Keys[\"Key0\"] = \"Digit0\";\n        Keys[\"Key1\"] = \"Digit1\";\n        Keys[\"Key2\"] = \"Digit2\";\n        Keys[\"Key3\"] = \"Digit3\";\n        Keys[\"Key4\"] = \"Digit4\";\n        Keys[\"Key5\"] = \"Digit5\";\n        Keys[\"Key6\"] = \"Digit6\";\n        Keys[\"Key7\"] = \"Digit7\";\n        Keys[\"Key8\"] = \"Digit8\";\n        Keys[\"Key9\"] = \"Digit9\";\n        Keys[\"Digit0\"] = \"Digit0\";\n        Keys[\"Digit1\"] = \"Digit1\";\n        Keys[\"Digit2\"] = \"Digit2\";\n        Keys[\"Digit3\"] = \"Digit3\";\n        Keys[\"Digit4\"] = \"Digit4\";\n        Keys[\"Digit5\"] = \"Digit5\";\n        Keys[\"Digit6\"] = \"Digit6\";\n        Keys[\"Digit7\"] = \"Digit7\";\n        Keys[\"Digit8\"] = \"Digit8\";\n        Keys[\"Digit9\"] = \"Digit9\";\n        // FUNCTION KEYS\n        Keys[\"F1\"] = \"F1\";\n        Keys[\"F2\"] = \"F2\";\n        Keys[\"F3\"] = \"F3\";\n        Keys[\"F4\"] = \"F4\";\n        Keys[\"F5\"] = \"F5\";\n        Keys[\"F6\"] = \"F6\";\n        Keys[\"F7\"] = \"F7\";\n        Keys[\"F8\"] = \"F8\";\n        Keys[\"F9\"] = \"F9\";\n        Keys[\"F10\"] = \"F10\";\n        Keys[\"F11\"] = \"F11\";\n        Keys[\"F12\"] = \"F12\";\n        // LETTERS\n        Keys[\"A\"] = \"KeyA\";\n        Keys[\"B\"] = \"KeyB\";\n        Keys[\"C\"] = \"KeyC\";\n        Keys[\"D\"] = \"KeyD\";\n        Keys[\"E\"] = \"KeyE\";\n        Keys[\"F\"] = \"KeyF\";\n        Keys[\"G\"] = \"KeyG\";\n        Keys[\"H\"] = \"KeyH\";\n        Keys[\"I\"] = \"KeyI\";\n        Keys[\"J\"] = \"KeyJ\";\n        Keys[\"K\"] = \"KeyK\";\n        Keys[\"L\"] = \"KeyL\";\n        Keys[\"M\"] = \"KeyM\";\n        Keys[\"N\"] = \"KeyN\";\n        Keys[\"O\"] = \"KeyO\";\n        Keys[\"P\"] = \"KeyP\";\n        Keys[\"Q\"] = \"KeyQ\";\n        Keys[\"R\"] = \"KeyR\";\n        Keys[\"S\"] = \"KeyS\";\n        Keys[\"T\"] = \"KeyT\";\n        Keys[\"U\"] = \"KeyU\";\n        Keys[\"V\"] = \"KeyV\";\n        Keys[\"W\"] = \"KeyW\";\n        Keys[\"X\"] = \"KeyX\";\n        Keys[\"Y\"] = \"KeyY\";\n        Keys[\"Z\"] = \"KeyZ\";\n        Keys[\"KeyA\"] = \"KeyA\";\n        Keys[\"KeyB\"] = \"KeyB\";\n        Keys[\"KeyC\"] = \"KeyC\";\n        Keys[\"KeyD\"] = \"KeyD\";\n        Keys[\"KeyE\"] = \"KeyE\";\n        Keys[\"KeyF\"] = \"KeyF\";\n        Keys[\"KeyG\"] = \"KeyG\";\n        Keys[\"KeyH\"] = \"KeyH\";\n        Keys[\"KeyI\"] = \"KeyI\";\n        Keys[\"KeyJ\"] = \"KeyJ\";\n        Keys[\"KeyK\"] = \"KeyK\";\n        Keys[\"KeyL\"] = \"KeyL\";\n        Keys[\"KeyM\"] = \"KeyM\";\n        Keys[\"KeyN\"] = \"KeyN\";\n        Keys[\"KeyO\"] = \"KeyO\";\n        Keys[\"KeyP\"] = \"KeyP\";\n        Keys[\"KeyQ\"] = \"KeyQ\";\n        Keys[\"KeyR\"] = \"KeyR\";\n        Keys[\"KeyS\"] = \"KeyS\";\n        Keys[\"KeyT\"] = \"KeyT\";\n        Keys[\"KeyU\"] = \"KeyU\";\n        Keys[\"KeyV\"] = \"KeyV\";\n        Keys[\"KeyW\"] = \"KeyW\";\n        Keys[\"KeyX\"] = \"KeyX\";\n        Keys[\"KeyY\"] = \"KeyY\";\n        Keys[\"KeyZ\"] = \"KeyZ\";\n        // SYMBOLS\n        Keys[\"Semicolon\"] = \"Semicolon\";\n        Keys[\"Quote\"] = \"Quote\";\n        Keys[\"Comma\"] = \"Comma\";\n        Keys[\"Minus\"] = \"Minus\";\n        Keys[\"Period\"] = \"Period\";\n        Keys[\"Slash\"] = \"Slash\";\n        Keys[\"Equal\"] = \"Equal\";\n        Keys[\"BracketLeft\"] = \"BracketLeft\";\n        Keys[\"Backslash\"] = \"Backslash\";\n        Keys[\"BracketRight\"] = \"BracketRight\";\n        Keys[\"Backquote\"] = \"Backquote\";\n        // DIRECTIONS\n        Keys[\"Up\"] = \"ArrowUp\";\n        Keys[\"Down\"] = \"ArrowDown\";\n        Keys[\"Left\"] = \"ArrowLeft\";\n        Keys[\"Right\"] = \"ArrowRight\";\n        Keys[\"ArrowUp\"] = \"ArrowUp\";\n        Keys[\"ArrowDown\"] = \"ArrowDown\";\n        Keys[\"ArrowLeft\"] = \"ArrowLeft\";\n        Keys[\"ArrowRight\"] = \"ArrowRight\";\n        // OTHER\n        Keys[\"Space\"] = \"Space\";\n        Keys[\"Backspace\"] = \"Backspace\";\n        Keys[\"Delete\"] = \"Delete\";\n        Keys[\"Esc\"] = \"Escape\";\n        Keys[\"Escape\"] = \"Escape\";\n        Keys[\"Enter\"] = \"Enter\";\n        Keys[\"NumpadEnter\"] = \"NumpadEnter\";\n        Keys[\"ContextMenu\"] = \"ContextMenu\";\n    })(Keys || (Keys = {}));\n    /**\r\n * Event thrown on a game object for a key event\r\n */ class KeyEvent extends GameEvent {\n        /**\r\n     * @param key  The key responsible for throwing the event\r\n     * @param value The key's typed value the browser detected\r\n     * @param originalEvent The original keyboard event that Excalibur handled\r\n     */ constructor(key, value, originalEvent){\n            super();\n            this.key = key;\n            this.value = value;\n            this.originalEvent = originalEvent;\n        }\n    }\n    /**\r\n * Provides keyboard support for Excalibur.\r\n */ class Keyboard extends Class {\n        constructor(){\n            super();\n            this._keys = [];\n            this._keysUp = [];\n            this._keysDown = [];\n            this._handleKeyDown = (ev)=>{\n                const code = ev.code;\n                if (this._keys.indexOf(code) === -1) {\n                    this._keys.push(code);\n                    this._keysDown.push(code);\n                    const keyEvent = new KeyEvent(code, ev.key, ev);\n                    this.eventDispatcher.emit(\"down\", keyEvent);\n                    this.eventDispatcher.emit(\"press\", keyEvent);\n                }\n            };\n            this._handleKeyUp = (ev)=>{\n                const code = ev.code;\n                const key = this._keys.indexOf(code);\n                this._keys.splice(key, 1);\n                this._keysUp.push(code);\n                const keyEvent = new KeyEvent(code, ev.key, ev);\n                // alias the old api, we may want to deprecate this in the future\n                this.eventDispatcher.emit(\"up\", keyEvent);\n                this.eventDispatcher.emit(\"release\", keyEvent);\n            };\n        }\n        on(eventName, handler) {\n            super.on(eventName, handler);\n        }\n        /**\r\n     * Initialize Keyboard event listeners\r\n     */ init(global) {\n            if (!global) try {\n                // Try and listen to events on top window frame if within an iframe.\n                //\n                // See https://github.com/excaliburjs/Excalibur/issues/1294\n                //\n                // Attempt to add an event listener, which triggers a DOMException on\n                // cross-origin iframes\n                const noop = ()=>{\n                    return;\n                };\n                window.top.addEventListener(\"blur\", noop);\n                window.top.removeEventListener(\"blur\", noop);\n                // this will be the same as window if not embedded within an iframe\n                global = window.top;\n            } catch (_a) {\n                // fallback to current frame\n                global = window;\n                Logger.getInstance().warn(\"Failed to bind to keyboard events to top frame. If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.\");\n            }\n            global.addEventListener(\"blur\", ()=>{\n                this._keys.length = 0; // empties array efficiently\n            });\n            // key up is on window because canvas cannot have focus\n            global.addEventListener(\"keyup\", this._handleKeyUp);\n            // key down is on window because canvas cannot have focus\n            global.addEventListener(\"keydown\", this._handleKeyDown);\n        }\n        update() {\n            // Reset keysDown and keysUp after update is complete\n            this._keysDown.length = 0;\n            this._keysUp.length = 0;\n            // Emit synthetic \"hold\" event\n            for(let i = 0; i < this._keys.length; i++)this.eventDispatcher.emit(\"hold\", new KeyEvent(this._keys[i]));\n        }\n        /**\r\n     * Gets list of keys being pressed down\r\n     */ getKeys() {\n            return this._keys;\n        }\n        /**\r\n     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n     * @param key Test whether a key was just pressed\r\n     */ wasPressed(key) {\n            return this._keysDown.indexOf(key) > -1;\n        }\n        /**\r\n     * Tests if a certain key is held down. This is persisted between frames.\r\n     * @param key  Test whether a key is held down\r\n     */ isHeld(key) {\n            return this._keys.indexOf(key) > -1;\n        }\n        /**\r\n     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n     * @param key  Test whether a key was just released\r\n     */ wasReleased(key) {\n            return this._keysUp.indexOf(key) > -1;\n        }\n        /**\r\n     * Trigger a manual key event\r\n     * @param type\r\n     * @param key\r\n     * @param character\r\n     */ triggerEvent(type, key, character) {\n            if (type === \"down\") this._handleKeyDown(new KeyboardEvent(\"keydown\", {\n                code: key,\n                key: character !== null && character !== void 0 ? character : null\n            }));\n            if (type === \"up\") this._handleKeyUp(new KeyboardEvent(\"keyup\", {\n                code: key,\n                key: character !== null && character !== void 0 ? character : null\n            }));\n        }\n    }\n    /**\r\n * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n * to provide controller support for your games.\r\n */ class Gamepads extends Class {\n        constructor(){\n            super();\n            /**\r\n         * Whether or not to poll for Gamepad input (default: `false`)\r\n         */ this.enabled = false;\n            /**\r\n         * Whether or not Gamepad API is supported\r\n         */ this.supported = !!navigator.getGamepads;\n            this._gamePadTimeStamps = [\n                0,\n                0,\n                0,\n                0\n            ];\n            this._oldPads = [];\n            this._pads = [];\n            this._initSuccess = false;\n            this._navigator = navigator;\n            this._minimumConfiguration = null;\n        }\n        init() {\n            if (!this.supported) return;\n            if (this._initSuccess) return;\n            // In Chrome, this will return 4 undefined items until a button is pressed\n            // In FF, this will not return any items until a button is pressed\n            this._oldPads = this._clonePads(this._navigator.getGamepads());\n            if (this._oldPads.length && this._oldPads[0]) this._initSuccess = true;\n        }\n        /**\r\n     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n     * all other controllers with more axis or buttons are valid as well. If no minimum\r\n     * configuration is set all pads are valid.\r\n     */ setMinimumGamepadConfiguration(config) {\n            this._enableAndUpdate(); // if config is used, implicitly enable\n            this._minimumConfiguration = config;\n        }\n        /**\r\n     * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n     */ _enableAndUpdate() {\n            if (!this.enabled) {\n                this.enabled = true;\n                this.update();\n            }\n        }\n        /**\r\n     * Checks a navigator gamepad against the minimum configuration if present.\r\n     */ _isGamepadValid(pad) {\n            if (!this._minimumConfiguration) return true;\n            if (!pad) return false;\n            const axesLength = pad.axes.filter((value)=>{\n                return true;\n            }).length;\n            const buttonLength = pad.buttons.filter((value)=>{\n                return true;\n            }).length;\n            return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;\n        }\n        on(eventName, handler) {\n            this._enableAndUpdate(); // implicitly enable\n            super.on(eventName, handler);\n        }\n        off(eventName, handler) {\n            this._enableAndUpdate(); // implicitly enable\n            super.off(eventName, handler);\n        }\n        /**\r\n     * Updates Gamepad state and publishes Gamepad events\r\n     */ update() {\n            if (!this.enabled || !this.supported) return;\n            this.init();\n            const gamepads = this._navigator.getGamepads();\n            for(let i = 0; i < gamepads.length; i++){\n                if (!gamepads[i]) {\n                    const gamepad = this.at(i);\n                    // If was connected, but now isn't emit the disconnect event\n                    if (gamepad.connected) this.eventDispatcher.emit(\"disconnect\", new GamepadDisconnectEvent(i, gamepad));\n                    // Reset connection status\n                    gamepad.connected = false;\n                    continue;\n                } else {\n                    if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) this.eventDispatcher.emit(\"connect\", new GamepadConnectEvent(i, this.at(i)));\n                    // Set connection status\n                    this.at(i).connected = true;\n                }\n                // Only supported in Chrome\n                if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) continue;\n                this._gamePadTimeStamps[i] = gamepads[i].timestamp;\n                // Add reference to navigator gamepad\n                this.at(i).navigatorGamepad = gamepads[i];\n                // Buttons\n                let b, bi, a, ai, value;\n                for(b in Buttons){\n                    bi = Buttons[b];\n                    if (typeof bi === \"number\") {\n                        if (gamepads[i].buttons[bi]) {\n                            value = gamepads[i].buttons[bi].value;\n                            if (value !== this._oldPads[i].getButton(bi)) {\n                                if (gamepads[i].buttons[bi].pressed) {\n                                    this.at(i).updateButton(bi, value);\n                                    this.at(i).eventDispatcher.emit(\"button\", new GamepadButtonEvent(bi, value, this.at(i)));\n                                } else this.at(i).updateButton(bi, 0);\n                            }\n                        }\n                    }\n                }\n                // Axes\n                for(a in Axes){\n                    ai = Axes[a];\n                    if (typeof ai === \"number\") {\n                        value = gamepads[i].axes[ai];\n                        if (value !== this._oldPads[i].getAxes(ai)) {\n                            this.at(i).updateAxes(ai, value);\n                            this.at(i).eventDispatcher.emit(\"axis\", new GamepadAxisEvent(ai, value, this.at(i)));\n                        }\n                    }\n                }\n                this._oldPads[i] = this._clonePad(gamepads[i]);\n            }\n        }\n        /**\r\n     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist\r\n     */ at(index) {\n            this._enableAndUpdate(); // implicitly enable gamepads when at() is called\n            if (index >= this._pads.length) // Ensure there is a pad to retrieve\n            for(let i = this._pads.length - 1, max = index; i < max; i++){\n                this._pads.push(new Gamepad());\n                this._oldPads.push(new Gamepad());\n            }\n            return this._pads[index];\n        }\n        /**\r\n     * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n     */ getValidGamepads() {\n            this._enableAndUpdate();\n            const result = [];\n            for(let i = 0; i < this._pads.length; i++)if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) result.push(this.at(i));\n            return result;\n        }\n        /**\r\n     * Gets the number of connected gamepads\r\n     */ count() {\n            return this._pads.filter((p)=>p.connected).length;\n        }\n        _clonePads(pads) {\n            const arr = [];\n            for(let i = 0, len = pads.length; i < len; i++)arr.push(this._clonePad(pads[i]));\n            return arr;\n        }\n        /**\r\n     * Fastest way to clone a known object is to do it yourself\r\n     */ _clonePad(pad) {\n            let i, len;\n            const clonedPad = new Gamepad();\n            if (!pad) return clonedPad;\n            for(i = 0, len = pad.buttons.length; i < len; i++)if (pad.buttons[i]) clonedPad.updateButton(i, pad.buttons[i].value);\n            for(i = 0, len = pad.axes.length; i < len; i++)clonedPad.updateAxes(i, pad.axes[i]);\n            return clonedPad;\n        }\n    }\n    /**\r\n * The minimum value an axis has to move before considering it a change\r\n */ Gamepads.MinAxisMoveThreshold = 0.05;\n    /**\r\n * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n * for more information on handling controller input.\r\n */ class Gamepad extends Class {\n        constructor(){\n            super();\n            this.connected = false;\n            this._buttons = new Array(16);\n            this._axes = new Array(4);\n            for(let i = 0; i < this._buttons.length; i++)this._buttons[i] = 0;\n            for(let i = 0; i < this._axes.length; i++)this._axes[i] = 0;\n        }\n        /**\r\n     * Whether or not the given button is pressed\r\n     * @param button     The button to query\r\n     * @param threshold  The threshold over which the button is considered to be pressed\r\n     */ isButtonPressed(button, threshold = 1) {\n            return this._buttons[button] >= threshold;\n        }\n        /**\r\n     * Gets the given button value between 0 and 1\r\n     */ getButton(button) {\n            return this._buttons[button];\n        }\n        /**\r\n     * Gets the given axis value between -1 and 1. Values below\r\n     * [[MinAxisMoveThreshold]] are considered 0.\r\n     */ getAxes(axes) {\n            const value = this._axes[axes];\n            if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) return 0;\n            else return value;\n        }\n        updateButton(buttonIndex, value) {\n            this._buttons[buttonIndex] = value;\n        }\n        updateAxes(axesIndex, value) {\n            this._axes[axesIndex] = value;\n        }\n    }\n    /**\r\n * Gamepad Buttons enumeration\r\n */ var Buttons;\n    (function(Buttons) {\n        /**\r\n     * Face 1 button (e.g. A)\r\n     */ Buttons[Buttons[\"Face1\"] = 0] = \"Face1\";\n        /**\r\n     * Face 2 button (e.g. B)\r\n     */ Buttons[Buttons[\"Face2\"] = 1] = \"Face2\";\n        /**\r\n     * Face 3 button (e.g. X)\r\n     */ Buttons[Buttons[\"Face3\"] = 2] = \"Face3\";\n        /**\r\n     * Face 4 button (e.g. Y)\r\n     */ Buttons[Buttons[\"Face4\"] = 3] = \"Face4\";\n        /**\r\n     * Left bumper button\r\n     */ Buttons[Buttons[\"LeftBumper\"] = 4] = \"LeftBumper\";\n        /**\r\n     * Right bumper button\r\n     */ Buttons[Buttons[\"RightBumper\"] = 5] = \"RightBumper\";\n        /**\r\n     * Left trigger button\r\n     */ Buttons[Buttons[\"LeftTrigger\"] = 6] = \"LeftTrigger\";\n        /**\r\n     * Right trigger button\r\n     */ Buttons[Buttons[\"RightTrigger\"] = 7] = \"RightTrigger\";\n        /**\r\n     * Select button\r\n     */ Buttons[Buttons[\"Select\"] = 8] = \"Select\";\n        /**\r\n     * Start button\r\n     */ Buttons[Buttons[\"Start\"] = 9] = \"Start\";\n        /**\r\n     * Left analog stick press (e.g. L3)\r\n     */ Buttons[Buttons[\"LeftStick\"] = 10] = \"LeftStick\";\n        /**\r\n     * Right analog stick press (e.g. R3)\r\n     */ Buttons[Buttons[\"RightStick\"] = 11] = \"RightStick\";\n        /**\r\n     * D-pad up\r\n     */ Buttons[Buttons[\"DpadUp\"] = 12] = \"DpadUp\";\n        /**\r\n     * D-pad down\r\n     */ Buttons[Buttons[\"DpadDown\"] = 13] = \"DpadDown\";\n        /**\r\n     * D-pad left\r\n     */ Buttons[Buttons[\"DpadLeft\"] = 14] = \"DpadLeft\";\n        /**\r\n     * D-pad right\r\n     */ Buttons[Buttons[\"DpadRight\"] = 15] = \"DpadRight\";\n    })(Buttons || (Buttons = {}));\n    /**\r\n * Gamepad Axes enumeration\r\n */ var Axes;\n    (function(Axes) {\n        /**\r\n     * Left analogue stick X direction\r\n     */ Axes[Axes[\"LeftStickX\"] = 0] = \"LeftStickX\";\n        /**\r\n     * Left analogue stick Y direction\r\n     */ Axes[Axes[\"LeftStickY\"] = 1] = \"LeftStickY\";\n        /**\r\n     * Right analogue stick X direction\r\n     */ Axes[Axes[\"RightStickX\"] = 2] = \"RightStickX\";\n        /**\r\n     * Right analogue stick Y direction\r\n     */ Axes[Axes[\"RightStickY\"] = 3] = \"RightStickY\";\n    })(Axes || (Axes = {}));\n    class BrowserComponent {\n        constructor(nativeComponent){\n            this.nativeComponent = nativeComponent;\n            this._paused = false;\n            this._nativeHandlers = {};\n        }\n        on(eventName, handler) {\n            if (this._nativeHandlers[eventName]) this.off(eventName, this._nativeHandlers[eventName]);\n            this._nativeHandlers[eventName] = this._decorate(handler);\n            this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);\n        }\n        off(eventName, handler) {\n            if (!handler) handler = this._nativeHandlers[eventName];\n            this.nativeComponent.removeEventListener(eventName, handler);\n            this._nativeHandlers[eventName] = null;\n        }\n        _decorate(handler) {\n            return (evt)=>{\n                if (!this._paused) handler(evt);\n            };\n        }\n        pause() {\n            this._paused = true;\n        }\n        resume() {\n            this._paused = false;\n        }\n        clear() {\n            for(const event in this._nativeHandlers)this.off(event);\n        }\n    }\n    class BrowserEvents {\n        constructor(_windowGlobal, _documentGlobal){\n            this._windowGlobal = _windowGlobal;\n            this._documentGlobal = _documentGlobal;\n            this._windowComponent = new BrowserComponent(this._windowGlobal);\n            this._documentComponent = new BrowserComponent(this._documentGlobal);\n        }\n        get window() {\n            return this._windowComponent;\n        }\n        get document() {\n            return this._documentComponent;\n        }\n        pause() {\n            this.window.pause();\n            this.document.pause();\n        }\n        resume() {\n            this.window.resume();\n            this.document.resume();\n        }\n        clear() {\n            this.window.clear();\n            this.document.clear();\n        }\n    }\n    class GlobalCoordinates {\n        constructor(worldPos, pagePos, screenPos){\n            this.worldPos = worldPos;\n            this.pagePos = pagePos;\n            this.screenPos = screenPos;\n        }\n        static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {\n            let pageX;\n            let pageY;\n            let pagePos;\n            let engine;\n            if (arguments.length === 3) {\n                pageX = xOrPos;\n                pageY = yOrEngine;\n                pagePos = new Vector(pageX, pageY);\n                engine = engineOrUndefined;\n            } else {\n                pagePos = xOrPos;\n                pageX = pagePos.x;\n                pageY = pagePos.y;\n                engine = yOrEngine;\n            }\n            const screenPos = engine.screen.pageToScreenCoordinates(pagePos);\n            const worldPos = engine.screen.screenToWorldCoordinates(screenPos);\n            return new GlobalCoordinates(worldPos, pagePos, screenPos);\n        }\n    }\n    class PointerEvent {\n        constructor(type, pointerId, button, pointerType, coordinates, nativeEvent){\n            this.type = type;\n            this.pointerId = pointerId;\n            this.button = button;\n            this.pointerType = pointerType;\n            this.coordinates = coordinates;\n            this.nativeEvent = nativeEvent;\n            this.active = true;\n        }\n        cancel() {\n            this.active = false;\n        }\n        get pagePos() {\n            return this.coordinates.pagePos;\n        }\n        get screenPos() {\n            return this.coordinates.screenPos;\n        }\n        get worldPos() {\n            return this.coordinates.worldPos;\n        }\n    }\n    class WheelEvent {\n        constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev){\n            this.x = x;\n            this.y = y;\n            this.pageX = pageX;\n            this.pageY = pageY;\n            this.screenX = screenX;\n            this.screenY = screenY;\n            this.index = index;\n            this.deltaX = deltaX;\n            this.deltaY = deltaY;\n            this.deltaZ = deltaZ;\n            this.deltaMode = deltaMode;\n            this.ev = ev;\n            this.active = true;\n        }\n        cancel() {\n            this.active = false;\n        }\n    }\n    class PointerAbstraction extends Class {\n        constructor(){\n            super();\n            /**\r\n         * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n         */ this.lastPagePos = Vector.Zero;\n            /**\r\n         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n         */ this.lastScreenPos = Vector.Zero;\n            /**\r\n         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n         */ this.lastWorldPos = Vector.Zero;\n            this._onPointerMove = (ev)=>{\n                this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\n                this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\n                this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\n            };\n            this._onPointerDown = (ev)=>{\n                this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\n                this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\n                this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\n            };\n            this.on(\"move\", this._onPointerMove);\n            this.on(\"down\", this._onPointerDown);\n        }\n        on(event, handler) {\n            super.on(event, handler);\n        }\n        once(event, handler) {\n            super.once(event, handler);\n        }\n        off(event, handler) {\n            super.off(event, handler);\n        }\n    }\n    var WheelDeltaMode;\n    (function(WheelDeltaMode) {\n        WheelDeltaMode[\"Pixel\"] = \"Pixel\";\n        WheelDeltaMode[\"Line\"] = \"Line\";\n        WheelDeltaMode[\"Page\"] = \"Page\";\n    })(WheelDeltaMode || (WheelDeltaMode = {}));\n    /**\r\n * Native browser button enumeration\r\n */ var NativePointerButton;\n    (function(NativePointerButton) {\n        NativePointerButton[NativePointerButton[\"NoButton\"] = -1] = \"NoButton\";\n        NativePointerButton[NativePointerButton[\"Left\"] = 0] = \"Left\";\n        NativePointerButton[NativePointerButton[\"Middle\"] = 1] = \"Middle\";\n        NativePointerButton[NativePointerButton[\"Right\"] = 2] = \"Right\";\n        NativePointerButton[NativePointerButton[\"Unknown\"] = 3] = \"Unknown\";\n    })(NativePointerButton || (NativePointerButton = {}));\n    /**\r\n * The mouse button being pressed.\r\n */ var PointerButton;\n    (function(PointerButton) {\n        PointerButton[\"Left\"] = \"Left\";\n        PointerButton[\"Middle\"] = \"Middle\";\n        PointerButton[\"Right\"] = \"Right\";\n        PointerButton[\"Unknown\"] = \"Unknown\";\n        PointerButton[\"NoButton\"] = \"NoButton\";\n    })(PointerButton || (PointerButton = {}));\n    /**\r\n * The type of pointer for a [[PointerEvent]].\r\n */ var PointerType;\n    (function(PointerType) {\n        PointerType[\"Touch\"] = \"Touch\";\n        PointerType[\"Mouse\"] = \"Mouse\";\n        PointerType[\"Pen\"] = \"Pen\";\n        PointerType[\"Unknown\"] = \"Unknown\";\n    })(PointerType || (PointerType = {}));\n    /**\r\n * Is this event a native touch event?\r\n */ function isTouchEvent(value) {\n        // Guard for Safari <= 13.1\n        return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;\n    }\n    /**\r\n * Is this event a native pointer event\r\n */ function isPointerEvent(value) {\n        // Guard for Safari <= 13.1\n        return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;\n    }\n    /**\r\n * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates\r\n */ class PointerEventReceiver extends Class {\n        constructor(target, engine){\n            super();\n            this.target = target;\n            this.engine = engine;\n            this.primary = new PointerAbstraction();\n            this._activeNativePointerIdsToNormalized = new Map();\n            this.lastFramePointerCoords = new Map();\n            this.currentFramePointerCoords = new Map();\n            this.currentFramePointerDown = new Map();\n            this.lastFramePointerDown = new Map();\n            this.currentFrameDown = [];\n            this.currentFrameUp = [];\n            this.currentFrameMove = [];\n            this.currentFrameCancel = [];\n            this.currentFrameWheel = [];\n            this._pointers = [\n                this.primary\n            ];\n            this._boundHandle = this._handle.bind(this);\n            this._boundWheel = this._handleWheel.bind(this);\n        }\n        /**\r\n     * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event\r\n     * handlers.\r\n     * @param target\r\n     * @param engine\r\n     */ recreate(target, engine) {\n            const eventReceiver = new PointerEventReceiver(target, engine);\n            eventReceiver.primary = this.primary;\n            eventReceiver._pointers = this._pointers;\n            return eventReceiver;\n        }\n        /**\r\n     * Locates a specific pointer by id, creates it if it doesn't exist\r\n     * @param index\r\n     */ at(index) {\n            if (index >= this._pointers.length) // Ensure there is a pointer to retrieve\n            for(let i = this._pointers.length - 1, max = index; i < max; i++)this._pointers.push(new PointerAbstraction());\n            return this._pointers[index];\n        }\n        /**\r\n     * The number of pointers currently being tracked by excalibur\r\n     */ count() {\n            return this._pointers.length;\n        }\n        /**\r\n     * Is the specified pointer id down this frame\r\n     * @param pointerId\r\n     */ isDown(pointerId) {\n            var _a;\n            return (_a = this.currentFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;\n        }\n        /**\r\n     * Was the specified pointer id down last frame\r\n     * @param pointerId\r\n     */ wasDown(pointerId) {\n            var _a;\n            return (_a = this.lastFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;\n        }\n        /**\r\n     * Whether the Pointer is currently dragging.\r\n     */ isDragging(pointerId) {\n            return this.isDown(pointerId);\n        }\n        /**\r\n     * Whether the Pointer just started dragging.\r\n     */ isDragStart(pointerId) {\n            return this.isDown(pointerId) && !this.wasDown(pointerId);\n        }\n        /**\r\n     * Whether the Pointer just ended dragging.\r\n     */ isDragEnd(pointerId) {\n            return !this.isDown(pointerId) && this.wasDown(pointerId);\n        }\n        on(event, handler) {\n            super.on(event, handler);\n        }\n        once(event, handler) {\n            super.once(event, handler);\n        }\n        off(event, handler) {\n            super.off(event, handler);\n        }\n        /**\r\n     * Called internally by excalibur\r\n     *\r\n     * Updates the current frame pointer info and emits raw pointer events\r\n     *\r\n     * This does not emit events to entities, see PointerSystem\r\n     */ update() {\n            this.lastFramePointerDown = new Map(this.currentFramePointerDown);\n            this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);\n            for (const event of this.currentFrameDown){\n                this.emit(\"down\", event);\n                const pointer = this.at(event.pointerId);\n                pointer.emit(\"down\", event);\n                this.primary.emit(\"pointerdown\", event);\n            }\n            for (const event of this.currentFrameUp){\n                this.emit(\"up\", event);\n                const pointer = this.at(event.pointerId);\n                pointer.emit(\"up\", event);\n            }\n            for (const event of this.currentFrameMove){\n                this.emit(\"move\", event);\n                const pointer = this.at(event.pointerId);\n                pointer.emit(\"move\", event);\n            }\n            for (const event of this.currentFrameCancel){\n                this.emit(\"cancel\", event);\n                const pointer = this.at(event.pointerId);\n                pointer.emit(\"cancel\", event);\n            }\n            for (const event of this.currentFrameWheel){\n                this.emit(\"wheel\", event);\n                this.primary.emit(\"pointerwheel\", event);\n            }\n        }\n        /**\r\n     * Clears the current frame event and pointer data\r\n     */ clear() {\n            for (const event of this.currentFrameUp){\n                this.currentFramePointerCoords.delete(event.pointerId);\n                const ids = this._activeNativePointerIdsToNormalized.entries();\n                for (const [native, normalized] of ids)if (normalized === event.pointerId) this._activeNativePointerIdsToNormalized.delete(native);\n            }\n            this.currentFrameDown.length = 0;\n            this.currentFrameUp.length = 0;\n            this.currentFrameMove.length = 0;\n            this.currentFrameCancel.length = 0;\n            this.currentFrameWheel.length = 0;\n        }\n        /**\r\n     * Initializes the pointer event receiver so that it can start listening to native\r\n     * browser events.\r\n     */ init() {\n            // Disabling the touch action avoids browser/platform gestures from firing on the canvas\n            // It is important on mobile to have touch action 'none'\n            // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not\n            if (this.target === this.engine.canvas) this.engine.canvas.style.touchAction = \"none\";\n            else document.body.style.touchAction = \"none\";\n            // Preferred pointer events\n            if (window.PointerEvent) {\n                this.target.addEventListener(\"pointerdown\", this._boundHandle);\n                this.target.addEventListener(\"pointerup\", this._boundHandle);\n                this.target.addEventListener(\"pointermove\", this._boundHandle);\n                this.target.addEventListener(\"pointercancel\", this._boundHandle);\n            } else {\n                // Touch Events\n                this.target.addEventListener(\"touchstart\", this._boundHandle);\n                this.target.addEventListener(\"touchend\", this._boundHandle);\n                this.target.addEventListener(\"touchmove\", this._boundHandle);\n                this.target.addEventListener(\"touchcancel\", this._boundHandle);\n                // Mouse Events\n                this.target.addEventListener(\"mousedown\", this._boundHandle);\n                this.target.addEventListener(\"mouseup\", this._boundHandle);\n                this.target.addEventListener(\"mousemove\", this._boundHandle);\n            }\n            // MDN MouseWheelEvent\n            const wheelOptions = {\n                passive: !(this.engine.pageScrollPreventionMode === ScrollPreventionMode.All || this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)\n            };\n            if (\"onwheel\" in document.createElement(\"div\")) // Modern Browsers\n            this.target.addEventListener(\"wheel\", this._boundWheel, wheelOptions);\n            else if (document.onmousewheel !== undefined) // Webkit and IE\n            this.target.addEventListener(\"mousewheel\", this._boundWheel, wheelOptions);\n            else // Remaining browser and older Firefox\n            this.target.addEventListener(\"MozMousePixelScroll\", this._boundWheel, wheelOptions);\n        }\n        detach() {\n            // Preferred pointer events\n            if (window.PointerEvent) {\n                this.target.removeEventListener(\"pointerdown\", this._boundHandle);\n                this.target.removeEventListener(\"pointerup\", this._boundHandle);\n                this.target.removeEventListener(\"pointermove\", this._boundHandle);\n                this.target.removeEventListener(\"pointercancel\", this._boundHandle);\n            } else {\n                // Touch Events\n                this.target.removeEventListener(\"touchstart\", this._boundHandle);\n                this.target.removeEventListener(\"touchend\", this._boundHandle);\n                this.target.removeEventListener(\"touchmove\", this._boundHandle);\n                this.target.removeEventListener(\"touchcancel\", this._boundHandle);\n                // Mouse Events\n                this.target.removeEventListener(\"mousedown\", this._boundHandle);\n                this.target.removeEventListener(\"mouseup\", this._boundHandle);\n                this.target.removeEventListener(\"mousemove\", this._boundHandle);\n            }\n            if (\"onwheel\" in document.createElement(\"div\")) // Modern Browsers\n            this.target.removeEventListener(\"wheel\", this._boundWheel);\n            else if (document.onmousewheel !== undefined) // Webkit and IE\n            this.target.addEventListener(\"mousewheel\", this._boundWheel);\n            else // Remaining browser and older Firefox\n            this.target.addEventListener(\"MozMousePixelScroll\", this._boundWheel);\n        }\n        /**\r\n     * Take native pointer id and map it to index in active pointers\r\n     * @param nativePointerId\r\n     */ _normalizePointerId(nativePointerId) {\n            // Add to the the native pointer set id\n            this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);\n            // Native pointer ids in ascending order\n            const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b)=>a - b);\n            // The index into sorted ids will be the new id, will always have an id\n            const id = currentPointerIds.findIndex((p)=>p === nativePointerId);\n            // Save the mapping so we can reverse it later\n            this._activeNativePointerIdsToNormalized.set(nativePointerId, id);\n            // ignore pointer because game isn't watching\n            return id;\n        }\n        /**\r\n     * Responsible for handling and parsing pointer events\r\n     */ _handle(ev) {\n            ev.preventDefault();\n            const eventCoords = new Map();\n            let button;\n            let pointerType;\n            if (isTouchEvent(ev)) {\n                button = PointerButton.Unknown;\n                pointerType = PointerType.Touch;\n                // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n                for(let i = 0; i < ev.changedTouches.length; i++){\n                    const touch = ev.changedTouches[i];\n                    const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);\n                    const nativePointerId = i + 1;\n                    const pointerId = this._normalizePointerId(nativePointerId);\n                    this.currentFramePointerCoords.set(pointerId, coordinates);\n                    eventCoords.set(pointerId, coordinates);\n                }\n            } else {\n                button = this._nativeButtonToPointerButton(ev.button);\n                pointerType = PointerType.Mouse;\n                const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);\n                let nativePointerId = 1;\n                if (isPointerEvent(ev)) {\n                    nativePointerId = ev.pointerId;\n                    pointerType = this._stringToPointerType(ev.pointerType);\n                }\n                const pointerId = this._normalizePointerId(nativePointerId);\n                this.currentFramePointerCoords.set(pointerId, coordinates);\n                eventCoords.set(pointerId, coordinates);\n            }\n            for (const [pointerId, coord] of eventCoords.entries())switch(ev.type){\n                case \"mousedown\":\n                case \"pointerdown\":\n                case \"touchstart\":\n                    this.currentFrameDown.push(new PointerEvent(\"down\", pointerId, button, pointerType, coord, ev));\n                    this.currentFramePointerDown.set(pointerId, true);\n                    break;\n                case \"mouseup\":\n                case \"pointerup\":\n                case \"touchend\":\n                    this.currentFrameUp.push(new PointerEvent(\"up\", pointerId, button, pointerType, coord, ev));\n                    this.currentFramePointerDown.set(pointerId, false);\n                    break;\n                case \"mousemove\":\n                case \"pointermove\":\n                case \"touchmove\":\n                    this.currentFrameMove.push(new PointerEvent(\"move\", pointerId, button, pointerType, coord, ev));\n                    break;\n                case \"touchcancel\":\n                case \"pointercancel\":\n                    this.currentFrameCancel.push(new PointerEvent(\"cancel\", pointerId, button, pointerType, coord, ev));\n                    break;\n            }\n        }\n        _handleWheel(ev) {\n            // Should we prevent page scroll because of this event\n            if (this.engine.pageScrollPreventionMode === ScrollPreventionMode.All || this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas) ev.preventDefault();\n            const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));\n            const world = this.engine.screen.screenToWorldCoordinates(screen);\n            /**\r\n         * A constant used to normalize wheel events across different browsers\r\n         *\r\n         * This normalization factor is pulled from\r\n         * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n         */ const ScrollWheelNormalizationFactor = -1 / 40;\n            const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;\n            const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;\n            const deltaZ = ev.deltaZ || 0;\n            let deltaMode = WheelDeltaMode.Pixel;\n            if (ev.deltaMode) {\n                if (ev.deltaMode === 1) deltaMode = WheelDeltaMode.Line;\n                else if (ev.deltaMode === 2) deltaMode = WheelDeltaMode.Page;\n            }\n            const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);\n            this.currentFrameWheel.push(we);\n        }\n        /**\r\n     * Triggers an excalibur pointer event in a world space pos\r\n     *\r\n     * Useful for testing pointers in excalibur\r\n     * @param type\r\n     * @param pos\r\n     */ triggerEvent(type, pos) {\n            const page = this.engine.screen.worldToPageCoordinates(pos);\n            // Send an event to the event receiver\n            if (window.PointerEvent) this._handle(new window.PointerEvent(\"pointer\" + type, {\n                pointerId: 0,\n                clientX: page.x,\n                clientY: page.y\n            }));\n            else // Safari hack\n            this._handle(new window.MouseEvent(\"mouse\" + type, {\n                clientX: page.x,\n                clientY: page.y\n            }));\n            // Force update pointer system\n            const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);\n            const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);\n            pointerSystem.preupdate();\n            pointerSystem.update(transformEntities.getEntities());\n        }\n        _nativeButtonToPointerButton(s) {\n            switch(s){\n                case NativePointerButton.NoButton:\n                    return PointerButton.NoButton;\n                case NativePointerButton.Left:\n                    return PointerButton.Left;\n                case NativePointerButton.Middle:\n                    return PointerButton.Middle;\n                case NativePointerButton.Right:\n                    return PointerButton.Right;\n                case NativePointerButton.Unknown:\n                    return PointerButton.Unknown;\n                default:\n                    return fail(s);\n            }\n        }\n        _stringToPointerType(s) {\n            switch(s){\n                case \"touch\":\n                    return PointerType.Touch;\n                case \"mouse\":\n                    return PointerType.Mouse;\n                case \"pen\":\n                    return PointerType.Pen;\n                default:\n                    return PointerType.Unknown;\n            }\n        }\n    }\n    class FpsSampler {\n        constructor(options){\n            var _a;\n            this._samplePeriod = 100;\n            this._currentFrameTime = 0;\n            this._frames = 0;\n            this._previousSampleTime = 0;\n            this._beginFrameTime = 0;\n            this._fps = options.initialFps;\n            this._samplePeriod = (_a = options.samplePeriod) !== null && _a !== void 0 ? _a : this._samplePeriod;\n            this._currentFrameTime = 1000 / options.initialFps;\n            this._nowFn = options.nowFn;\n            this._previousSampleTime = this._nowFn();\n        }\n        /**\r\n     * Start of code block to sample FPS for\r\n     */ start() {\n            this._beginFrameTime = this._nowFn();\n        }\n        /**\r\n     * End of code block to sample FPS for\r\n     */ end() {\n            this._frames++;\n            const time = this._nowFn();\n            this._currentFrameTime = time - this._beginFrameTime;\n            if (time >= this._previousSampleTime + this._samplePeriod) {\n                this._fps = this._frames * 1000 / (time - this._previousSampleTime);\n                this._previousSampleTime = time;\n                this._frames = 0;\n            }\n        }\n        /**\r\n     * Return the currently sampled fps over the last sample period, by default every 100ms\r\n     */ get fps() {\n            return this._fps;\n        }\n        /**\r\n     * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time\r\n     */ get instant() {\n            return 1000 / this._currentFrameTime;\n        }\n    }\n    /**\r\n * Abstract Clock is the base type of all Clocks\r\n *\r\n * It has a few opinions\r\n * 1. It manages the calculation of what \"elapsed\" time means and thus maximum fps\r\n * 2. The default timing api is implemented in now()\r\n *\r\n * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever\r\n * method is unique to your clock implementation.\r\n */ class Clock {\n        constructor(options){\n            var _a, _b, _c;\n            this._onFatalException = ()=>{};\n            this._maxFps = Infinity;\n            this._lastTime = 0;\n            this._elapsed = 1;\n            this._scheduledCbs = [];\n            this._totalElapsed = 0;\n            this._options = options;\n            this.tick = options.tick;\n            this._lastTime = (_a = this.now()) !== null && _a !== void 0 ? _a : 0;\n            this._maxFps = (_b = options.maxFps) !== null && _b !== void 0 ? _b : this._maxFps;\n            this._onFatalException = (_c = options.onFatalException) !== null && _c !== void 0 ? _c : this._onFatalException;\n            this.fpsSampler = new FpsSampler({\n                initialFps: 60,\n                nowFn: ()=>this.now()\n            });\n        }\n        /**\r\n     * Get the elapsed time for the last completed frame\r\n     */ elapsed() {\n            return this._elapsed;\n        }\n        /**\r\n     * Get the current time in milliseconds\r\n     */ now() {\n            return performance.now();\n        }\n        toTestClock() {\n            const testClock = new TestClock({\n                ...this._options,\n                defaultUpdateMs: 16.6\n            });\n            return testClock;\n        }\n        toStandardClock() {\n            const clock = new StandardClock({\n                ...this._options\n            });\n            return clock;\n        }\n        setFatalExceptionHandler(handler) {\n            this._onFatalException = handler;\n        }\n        /**\r\n     * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]\r\n     *\r\n     * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the\r\n     * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is\r\n     * stopped or paused.\r\n     *\r\n     * @param cb callback to fire\r\n     * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick\r\n     */ schedule(cb, timeoutMs = 0) {\n            // Scheduled based on internal elapsed time\n            const scheduledTime = this._totalElapsed + timeoutMs;\n            this._scheduledCbs.push([\n                cb,\n                scheduledTime\n            ]);\n        }\n        _runScheduledCbs() {\n            // walk backwards to delete items as we loop\n            for(let i = this._scheduledCbs.length - 1; i > -1; i--)if (this._scheduledCbs[i][1] <= this._totalElapsed) {\n                this._scheduledCbs[i][0]();\n                this._scheduledCbs.splice(i, 1);\n            }\n        }\n        update(overrideUpdateMs) {\n            try {\n                this.fpsSampler.start();\n                // Get the time to calculate time-elapsed\n                const now = this.now();\n                let elapsed = now - this._lastTime || 1; // first frame\n                // Constrain fps\n                const fpsInterval = 1000 / this._maxFps;\n                // only run frame if enough time has elapsed\n                if (elapsed >= fpsInterval) {\n                    let leftover = 0;\n                    if (fpsInterval !== 0) {\n                        leftover = elapsed % fpsInterval;\n                        elapsed = elapsed - leftover; // shift elapsed to be \"in phase\" with the current loop fps\n                    }\n                    // Resolves issue #138 if the game has been paused, or blurred for\n                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability\n                    // and provides more expected behavior when the engine comes back\n                    // into focus\n                    if (elapsed > 200) elapsed = 1;\n                    // tick the mainloop and run scheduled callbacks\n                    this._elapsed = overrideUpdateMs || elapsed;\n                    this._totalElapsed += this._elapsed;\n                    this._runScheduledCbs();\n                    this.tick(overrideUpdateMs || elapsed);\n                    if (fpsInterval !== 0) this._lastTime = now - leftover;\n                    else this._lastTime = now;\n                    this.fpsSampler.end();\n                }\n            } catch (e) {\n                this._onFatalException(e);\n                this.stop();\n            }\n        }\n    }\n    /**\r\n * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()\r\n */ class StandardClock extends Clock {\n        constructor(options){\n            super(options);\n            this._running = false;\n        }\n        isRunning() {\n            return this._running;\n        }\n        start() {\n            if (this._running) return;\n            this._running = true;\n            const mainloop = ()=>{\n                // stop the loop\n                if (!this._running) return;\n                try {\n                    // request next loop\n                    this._requestId = window.requestAnimationFrame(mainloop);\n                    this.update();\n                } catch (e) {\n                    window.cancelAnimationFrame(this._requestId);\n                    throw e;\n                }\n            };\n            // begin the first frame\n            mainloop();\n        }\n        stop() {\n            this._running = false;\n        }\n    }\n    /**\r\n * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test\r\n */ class TestClock extends Clock {\n        constructor(options){\n            super({\n                ...options\n            });\n            this._logger = Logger.getInstance();\n            this._running = false;\n            this._currentTime = 0;\n            this._updateMs = options.defaultUpdateMs;\n        }\n        /**\r\n     * Get the current time in milliseconds\r\n     */ now() {\n            var _a;\n            return (_a = this._currentTime) !== null && _a !== void 0 ? _a : 0;\n        }\n        isRunning() {\n            return this._running;\n        }\n        start() {\n            this._running = true;\n        }\n        stop() {\n            this._running = false;\n        }\n        /**\r\n     * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds\r\n     * @param overrideUpdateMs\r\n     */ step(overrideUpdateMs) {\n            const time = overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs;\n            if (this._running) {\n                // to be comparable to RAF this needs to be a full blown Task\n                // For example, images cannot decode synchronously in a single step\n                this.update(time);\n                this._currentTime += time;\n            } else this._logger.warn(\"The clock is not running, no step will be performed\");\n        }\n        /**\r\n     * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds\r\n     * @param numberOfSteps\r\n     * @param overrideUpdateMs\r\n     */ run(numberOfSteps, overrideUpdateMs) {\n            for(let i = 0; i < numberOfSteps; i++)this.step(overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs);\n        }\n    }\n    // EXTERNAL MODULE: ./Util/Toaster.css\n    var Util_Toaster = $2c23f148d58cd887$var$__webpack_require__(7379);\n    /**\r\n * The Toaster is only meant to be called from inside Excalibur to display messages to players\r\n */ class Toaster {\n        constructor(){\n            this._toasterCss = Util_Toaster /* default.toString */ .Z.toString();\n            this._isInitialized = false;\n        }\n        _initialize() {\n            if (!this._isInitialized) {\n                this._container = document.createElement(\"div\");\n                this._container.id = \"ex-toast-container\";\n                document.body.appendChild(this._container);\n                this._isInitialized = true;\n                this._styleBlock = document.createElement(\"style\");\n                this._styleBlock.textContent = this._toasterCss;\n                document.head.appendChild(this._styleBlock);\n            }\n        }\n        dispose() {\n            this._container.parentElement.removeChild(this._container);\n            this._styleBlock.parentElement.removeChild(this._styleBlock);\n            this._isInitialized = false;\n        }\n        _createFragment(message) {\n            const toastMessage = document.createElement(\"span\");\n            toastMessage.innerText = message;\n            return toastMessage;\n        }\n        /**\r\n     * Display a toast message to a player\r\n     * @param message Text of the message, messages may have a single \"[LINK]\" to influence placement\r\n     * @param linkTarget Optionally specify a link location\r\n     * @param linkName Optionally specify a name for that link location\r\n     */ toast(message, linkTarget, linkName) {\n            this._initialize();\n            const toast = document.createElement(\"div\");\n            toast.className = \"ex-toast-message\";\n            const messageFragments = message.split(\"[LINK]\").map((message)=>this._createFragment(message));\n            if (linkTarget) {\n                const link = document.createElement(\"a\");\n                link.href = linkTarget;\n                if (linkName) link.innerText = linkName;\n                else link.innerText = linkTarget;\n                messageFragments.splice(1, 0, link);\n            }\n            // Assembly message\n            const finalMessage = document.createElement(\"div\");\n            messageFragments.forEach((message)=>{\n                finalMessage.appendChild(message);\n            });\n            toast.appendChild(finalMessage);\n            // Dismiss button\n            const dismissBtn = document.createElement(\"button\");\n            dismissBtn.innerText = \"x\";\n            dismissBtn.addEventListener(\"click\", ()=>{\n                this._container.removeChild(toast);\n            });\n            toast.appendChild(dismissBtn);\n            // Escape to dismiss\n            const keydownHandler = (evt)=>{\n                if (evt.key === \"Escape\") try {\n                    this._container.removeChild(toast);\n                } catch (_a) {\n                // pass\n                }\n                document.removeEventListener(\"keydown\", keydownHandler);\n            };\n            document.addEventListener(\"keydown\", keydownHandler);\n            // Insert into container\n            const first = this._container.firstChild;\n            this._container.insertBefore(toast, first);\n        }\n    }\n    polyfill();\n    /**\r\n * Enum representing the different mousewheel event bubble prevention\r\n */ var ScrollPreventionMode;\n    (function(ScrollPreventionMode) {\n        /**\r\n     * Do not prevent any page scrolling\r\n     */ ScrollPreventionMode[ScrollPreventionMode[\"None\"] = 0] = \"None\";\n        /**\r\n     * Prevent page scroll if mouse is over the game canvas\r\n     */ ScrollPreventionMode[ScrollPreventionMode[\"Canvas\"] = 1] = \"Canvas\";\n        /**\r\n     * Prevent all page scrolling via mouse wheel\r\n     */ ScrollPreventionMode[ScrollPreventionMode[\"All\"] = 2] = \"All\";\n    })(ScrollPreventionMode || (ScrollPreventionMode = {}));\n    /**\r\n * The Excalibur Engine\r\n *\r\n * The [[Engine]] is the main driver for a game. It is responsible for\r\n * starting/stopping the game, maintaining state, transmitting events,\r\n * loading resources, and managing the scene.\r\n */ class Engine extends Class {\n        /**\r\n     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,\r\n     * the game will be rendered full screen (taking up all available browser window space).\r\n     * You can customize the game rendering through [[EngineOptions]].\r\n     *\r\n     * Example:\r\n     *\r\n     * ```js\r\n     * var game = new ex.Engine({\r\n     *   width: 0, // the width of the canvas\r\n     *   height: 0, // the height of the canvas\r\n     *   enableCanvasTransparency: true, // the transparencySection of the canvas\r\n     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own\r\n     *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine\r\n     * });\r\n     *\r\n     * // call game.start, which is a Promise\r\n     * game.start().then(function () {\r\n     *   // ready, set, go!\r\n     * });\r\n     * ```\r\n     */ constructor(options){\n            var _a, _b, _c, _d, _e, _f;\n            super();\n            /**\r\n         * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n         *\r\n         * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n         * one that bounces between 30fps and 60fps\r\n         */ this.maxFps = Number.POSITIVE_INFINITY;\n            /**\r\n         * Contains all the scenes currently registered with Excalibur\r\n         */ this.scenes = {};\n            this._suppressPlayButton = false;\n            /**\r\n         * Indicates whether audio should be paused when the game is no longer visible.\r\n         */ this.pauseAudioWhenHidden = true;\n            /**\r\n         * Indicates whether the engine should draw with debug information\r\n         */ this._isDebug = false;\n            /**\r\n         * Sets the Transparency for the engine.\r\n         */ this.enableCanvasTransparency = true;\n            /**\r\n         * The action to take when a fatal exception is thrown\r\n         */ this.onFatalException = (e)=>{\n                Logger.getInstance().fatal(e);\n            };\n            this._toaster = new Toaster();\n            this._timescale = 1.0;\n            this._isInitialized = false;\n            this._deferredGoTo = null;\n            this._originalOptions = {};\n            this._performanceThresholdTriggered = false;\n            this._fpsSamples = [];\n            this._loadingComplete = false;\n            this._isReady = false;\n            this._isReadyPromise = new Promise((resolve)=>{\n                this._isReadyResolve = resolve;\n            });\n            /**\r\n         * Returns the current frames elapsed milliseconds\r\n         */ this.currentFrameElapsedMs = 0;\n            /**\r\n         * Returns the current frame lag when in fixed update mode\r\n         */ this.currentFrameLagMs = 0;\n            this._lagMs = 0;\n            this._screenShotRequests = [];\n            options = {\n                ...Engine._DEFAULT_ENGINE_OPTIONS,\n                ...options\n            };\n            this._originalOptions = options;\n            Flags.freeze();\n            // Initialize browser events facade\n            this.browser = new BrowserEvents(window, document);\n            // Check compatibility\n            const detector = new Detector();\n            if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {\n                const message = document.createElement(\"div\");\n                message.innerText = \"Sorry, your browser does not support all the features needed for Excalibur\";\n                document.body.appendChild(message);\n                detector.failedTests.forEach(function(test) {\n                    const testMessage = document.createElement(\"div\");\n                    testMessage.innerText = \"Browser feature missing \" + test;\n                    document.body.appendChild(testMessage);\n                });\n                if (options.canvasElementId) {\n                    const canvas = document.getElementById(options.canvasElementId);\n                    if (canvas) canvas.parentElement.removeChild(canvas);\n                }\n                return;\n            } else this._compatible = true;\n            // Use native console API for color fun\n            // eslint-disable-next-line no-console\n            if (console.log && !options.suppressConsoleBootMessage) {\n                // eslint-disable-next-line no-console\n                console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, \"background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;\");\n                // eslint-disable-next-line no-console\n                console.log(\"\\n      /| ________________\\nO|===|* >________________>\\n      \\\\|\");\n                // eslint-disable-next-line no-console\n                console.log(\"Visit\", \"http://excaliburjs.com\", \"for more information\");\n            }\n            // Suppress play button\n            if (options.suppressPlayButton) this._suppressPlayButton = true;\n            this._logger = Logger.getInstance();\n            // If debug is enabled, let's log browser features to the console.\n            if (this._logger.defaultLevel === LogLevel.Debug) detector.logBrowserFeatures();\n            this._logger.debug(\"Building engine...\");\n            this.canvasElementId = options.canvasElementId;\n            if (options.canvasElementId) {\n                this._logger.debug(\"Using Canvas element specified: \" + options.canvasElementId);\n                this.canvas = document.getElementById(options.canvasElementId);\n            } else if (options.canvasElement) {\n                this._logger.debug(\"Using Canvas element specified:\", options.canvasElement);\n                this.canvas = options.canvasElement;\n            } else {\n                this._logger.debug(\"Using generated canvas element\");\n                this.canvas = document.createElement(\"canvas\");\n            }\n            let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;\n            if (options.width && options.height || options.viewport) {\n                if (options.displayMode === undefined) displayMode = DisplayMode.Fixed;\n                this._logger.debug(\"Engine viewport is size \" + options.width + \" x \" + options.height);\n            } else if (!options.displayMode) {\n                this._logger.debug(\"Engine viewport is fit\");\n                displayMode = DisplayMode.FitScreen;\n            }\n            this._originalDisplayMode = displayMode;\n            // Canvas 2D fallback can be flagged on\n            let useCanvasGraphicsContext = Flags.isEnabled(\"use-canvas-context\");\n            if (!useCanvasGraphicsContext) // Attempt webgl first\n            try {\n                this.graphicsContext = new ExcaliburGraphicsContextWebGL({\n                    canvasElement: this.canvas,\n                    enableTransparency: this.enableCanvasTransparency,\n                    smoothing: options.antialiasing,\n                    backgroundColor: options.backgroundColor,\n                    snapToPixel: options.snapToPixel,\n                    useDrawSorting: options.useDrawSorting\n                });\n            } catch (e) {\n                this._logger.warn(`Excalibur could not load webgl for some reason (${e.message}) and loaded a Canvas 2D fallback. ` + `Some features of Excalibur will not work in this mode. \\n\\n` + \"Read more about this issue at https://excaliburjs.com/docs/webgl\");\n                // fallback to canvas in case of failure\n                useCanvasGraphicsContext = true;\n            }\n            if (useCanvasGraphicsContext) this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\n                canvasElement: this.canvas,\n                enableTransparency: this.enableCanvasTransparency,\n                smoothing: options.antialiasing,\n                backgroundColor: options.backgroundColor,\n                snapToPixel: options.snapToPixel,\n                useDrawSorting: options.useDrawSorting\n            });\n            this.screen = new Screen({\n                canvas: this.canvas,\n                context: this.graphicsContext,\n                antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,\n                browser: this.browser,\n                viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : options.width && options.height ? {\n                    width: options.width,\n                    height: options.height\n                } : Resolution.SVGA,\n                resolution: options.resolution,\n                displayMode: displayMode,\n                pixelRatio: options.suppressHiDPIScaling ? 1 : (_d = options.pixelRatio) !== null && _d !== void 0 ? _d : null\n            });\n            // Set default filtering based on antialiasing\n            TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;\n            if (options.backgroundColor) this.backgroundColor = options.backgroundColor.clone();\n            this.maxFps = (_e = options.maxFps) !== null && _e !== void 0 ? _e : this.maxFps;\n            this.fixedUpdateFps = (_f = options.fixedUpdateFps) !== null && _f !== void 0 ? _f : this.fixedUpdateFps;\n            this.clock = new StandardClock({\n                maxFps: this.maxFps,\n                tick: this._mainloop.bind(this),\n                onFatalException: (e)=>this.onFatalException(e)\n            });\n            this.enableCanvasTransparency = options.enableCanvasTransparency;\n            this._loader = new Loader();\n            this._loader.wireEngine(this);\n            this.debug = new Debug(this);\n            this._initialize(options);\n            this.rootScene = this.currentScene = new Scene();\n            this.addScene(\"root\", this.rootScene);\n            window.___EXCALIBUR_DEVTOOL = this;\n        }\n        /**\r\n     * The width of the game canvas in pixels (physical width component of the\r\n     * resolution of the canvas element)\r\n     */ get canvasWidth() {\n            return this.screen.canvasWidth;\n        }\n        /**\r\n     * Returns half width of the game canvas in pixels (half physical width component)\r\n     */ get halfCanvasWidth() {\n            return this.screen.halfCanvasWidth;\n        }\n        /**\r\n     * The height of the game canvas in pixels, (physical height component of\r\n     * the resolution of the canvas element)\r\n     */ get canvasHeight() {\n            return this.screen.canvasHeight;\n        }\n        /**\r\n     * Returns half height of the game canvas in pixels (half physical height component)\r\n     */ get halfCanvasHeight() {\n            return this.screen.halfCanvasHeight;\n        }\n        /**\r\n     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get drawWidth() {\n            return this.screen.drawWidth;\n        }\n        /**\r\n     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get halfDrawWidth() {\n            return this.screen.halfDrawWidth;\n        }\n        /**\r\n     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get drawHeight() {\n            return this.screen.drawHeight;\n        }\n        /**\r\n     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */ get halfDrawHeight() {\n            return this.screen.halfDrawHeight;\n        }\n        /**\r\n     * Returns whether excalibur detects the current screen to be HiDPI\r\n     */ get isHiDpi() {\n            return this.screen.isHiDpi;\n        }\n        /**\r\n     * Access [[stats]] that holds frame statistics.\r\n     */ get stats() {\n            return this.debug.stats;\n        }\n        /**\r\n     * Indicates whether the engine is set to fullscreen or not\r\n     */ get isFullscreen() {\n            return this.screen.isFullScreen;\n        }\n        /**\r\n     * Indicates the current [[DisplayMode]] of the engine.\r\n     */ get displayMode() {\n            return this.screen.displayMode;\n        }\n        /**\r\n     * Returns the calculated pixel ration for use in rendering\r\n     */ get pixelRatio() {\n            return this.screen.pixelRatio;\n        }\n        get isDebug() {\n            return this._isDebug;\n        }\n        /**\r\n     * Hints the graphics context to truncate fractional world space coordinates\r\n     */ get snapToPixel() {\n            return this.graphicsContext.snapToPixel;\n        }\n        set snapToPixel(shouldSnapToPixel) {\n            this.graphicsContext.snapToPixel = shouldSnapToPixel;\n        }\n        on(eventName, handler) {\n            super.on(eventName, handler);\n        }\n        once(eventName, handler) {\n            super.once(eventName, handler);\n        }\n        off(eventName, handler) {\n            super.off(eventName, handler);\n        }\n        _monitorPerformanceThresholdAndTriggerFallback() {\n            const { allow: allow  } = this._originalOptions.configurePerformanceCanvas2DFallback;\n            let { threshold: threshold , showPlayerMessage: showPlayerMessage  } = this._originalOptions.configurePerformanceCanvas2DFallback;\n            if (threshold === undefined) threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;\n            if (showPlayerMessage === undefined) showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;\n            if (!Flags.isEnabled(\"use-canvas-context\") && allow && this.ready && !this._performanceThresholdTriggered) {\n                // Calculate Average fps for last X number of frames after start\n                if (this._fpsSamples.length === threshold.numberOfFrames) this._fpsSamples.splice(0, 1);\n                this._fpsSamples.push(this.clock.fpsSampler.fps);\n                let total = 0;\n                for(let i = 0; i < this._fpsSamples.length; i++)total += this._fpsSamples[i];\n                const average = total / this._fpsSamples.length;\n                if (this._fpsSamples.length === threshold.numberOfFrames) {\n                    if (average <= threshold.fps) {\n                        this._performanceThresholdTriggered = true;\n                        this._logger.warn(`Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\\n` + \"this might mean your browser doesn't have webgl enabled or hardware acceleration is unavailable.\\n\\n\" + \"If in Chrome:\\n\" + '  * Visit Settings > Advanced > System, and ensure \"Use Hardware Acceleration\" is checked.\\n' + '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure \"Override software rendering list\" is \"enabled\"\\n' + \"If in Firefox, visit about:config\\n\" + \"  * Ensure webgl.disabled = false\\n\" + \"  * Ensure webgl.force-enabled = true\\n\" + \"  * Ensure layers.acceleration.force-enabled = true\\n\\n\" + \"Read more about this issue at https://excaliburjs.com/docs/performance\");\n                        if (showPlayerMessage) this._toaster.toast(\"Excalibur is encountering performance issues. It's possible that your browser doesn't have hardware acceleration enabled. Visit [LINK] for more information and potential solutions.\", \"https://excaliburjs.com/docs/performance\");\n                        this.useCanvas2DFallback();\n                        this.emit(\"fallbackgraphicscontext\", this.graphicsContext);\n                    }\n                }\n            }\n        }\n        /**\r\n     * Switches the engine's graphics context to the 2D Canvas.\r\n     * @warning Some features of Excalibur will not work in this mode.\r\n     */ useCanvas2DFallback() {\n            var _a, _b, _c;\n            // Swap out the canvas\n            const newCanvas = this.canvas.cloneNode(false);\n            this.canvas.parentNode.replaceChild(newCanvas, this.canvas);\n            this.canvas = newCanvas;\n            const options = this._originalOptions;\n            const displayMode = this._originalDisplayMode;\n            // New graphics context\n            this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\n                canvasElement: this.canvas,\n                enableTransparency: this.enableCanvasTransparency,\n                smoothing: options.antialiasing,\n                backgroundColor: options.backgroundColor,\n                snapToPixel: options.snapToPixel,\n                useDrawSorting: options.useDrawSorting\n            });\n            // Reset screen\n            if (this.screen) this.screen.dispose();\n            this.screen = new Screen({\n                canvas: this.canvas,\n                context: this.graphicsContext,\n                antialiasing: (_a = options.antialiasing) !== null && _a !== void 0 ? _a : true,\n                browser: this.browser,\n                viewport: (_b = options.viewport) !== null && _b !== void 0 ? _b : options.width && options.height ? {\n                    width: options.width,\n                    height: options.height\n                } : Resolution.SVGA,\n                resolution: options.resolution,\n                displayMode: displayMode,\n                pixelRatio: options.suppressHiDPIScaling ? 1 : (_c = options.pixelRatio) !== null && _c !== void 0 ? _c : null\n            });\n            this.screen.setCurrentCamera(this.currentScene.camera);\n            // Reset pointers\n            this.input.pointers.detach();\n            const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;\n            this.input.pointers = this.input.pointers.recreate(pointerTarget, this);\n            this.input.pointers.init();\n        }\n        /**\r\n     * Returns a BoundingBox of the top left corner of the screen\r\n     * and the bottom right corner of the screen.\r\n     */ getWorldBounds() {\n            return this.screen.getWorldBounds();\n        }\n        /**\r\n     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n     */ get timescale() {\n            return this._timescale;\n        }\n        /**\r\n     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n     * when using time-based movement.\r\n     */ set timescale(value) {\n            if (value <= 0) {\n                Logger.getInstance().error(\"Cannot set engine.timescale to a value of 0 or less than 0.\");\n                return;\n            }\n            this._timescale = value;\n        }\n        /**\r\n     * Adds a [[Timer]] to the [[currentScene]].\r\n     * @param timer  The timer to add to the [[currentScene]].\r\n     */ addTimer(timer) {\n            return this.currentScene.addTimer(timer);\n        }\n        /**\r\n     * Removes a [[Timer]] from the [[currentScene]].\r\n     * @param timer  The timer to remove to the [[currentScene]].\r\n     */ removeTimer(timer) {\n            return this.currentScene.removeTimer(timer);\n        }\n        /**\r\n     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n     * would levels or menus.\r\n     *\r\n     * @param key  The name of the scene, must be unique\r\n     * @param scene The scene to add to the engine\r\n     */ addScene(key, scene) {\n            if (this.scenes[key]) this._logger.warn(\"Scene\", key, \"already exists overwriting\");\n            this.scenes[key] = scene;\n        }\n        /**\r\n     * @internal\r\n     */ removeScene(entity) {\n            if (entity instanceof Scene) // remove scene\n            for(const key in this.scenes){\n                if (this.scenes.hasOwnProperty(key)) {\n                    if (this.scenes[key] === entity) delete this.scenes[key];\n                }\n            }\n            if (typeof entity === \"string\") // remove scene\n            delete this.scenes[entity];\n        }\n        add(entity) {\n            if (arguments.length === 2) {\n                this.addScene(arguments[0], arguments[1]);\n                return;\n            }\n            if (this._deferredGoTo && this.scenes[this._deferredGoTo]) this.scenes[this._deferredGoTo].add(entity);\n            else this.currentScene.add(entity);\n        }\n        remove(entity) {\n            if (entity instanceof Entity) this.currentScene.remove(entity);\n            if (entity instanceof Scene) this.removeScene(entity);\n            if (typeof entity === \"string\") this.removeScene(entity);\n        }\n        /**\r\n     * Changes the currently updating and drawing scene to a different,\r\n     * named scene. Calls the [[Scene]] lifecycle events.\r\n     * @param key  The key of the scene to transition to.\r\n     * @param data Optional data to send to the scene's onActivate method\r\n     */ goToScene(key, data) {\n            // if not yet initialized defer goToScene\n            if (!this.isInitialized) {\n                this._deferredGoTo = key;\n                return;\n            }\n            if (this.scenes[key]) {\n                const previousScene = this.currentScene;\n                const nextScene = this.scenes[key];\n                this._logger.debug(\"Going to scene:\", key);\n                // only deactivate when initialized\n                if (this.currentScene.isInitialized) {\n                    const context = {\n                        engine: this,\n                        previousScene: previousScene,\n                        nextScene: nextScene\n                    };\n                    this.currentScene._deactivate.apply(this.currentScene, [\n                        context,\n                        nextScene\n                    ]);\n                    this.currentScene.eventDispatcher.emit(\"deactivate\", new DeactivateEvent(context, this.currentScene));\n                }\n                // set current scene to new one\n                this.currentScene = nextScene;\n                this.screen.setCurrentCamera(nextScene.camera);\n                // initialize the current scene if has not been already\n                this.currentScene._initialize(this);\n                const context = {\n                    engine: this,\n                    previousScene: previousScene,\n                    nextScene: nextScene,\n                    data: data\n                };\n                this.currentScene._activate.apply(this.currentScene, [\n                    context,\n                    nextScene\n                ]);\n                this.currentScene.eventDispatcher.emit(\"activate\", new ActivateEvent(context, this.currentScene));\n            } else this._logger.error(\"Scene\", key, \"does not exist!\");\n        }\n        /**\r\n     * Transforms the current x, y from screen coordinates to world coordinates\r\n     * @param point  Screen coordinate to convert\r\n     */ screenToWorldCoordinates(point) {\n            return this.screen.screenToWorldCoordinates(point);\n        }\n        /**\r\n     * Transforms a world coordinate, to a screen coordinate\r\n     * @param point  World coordinate to convert\r\n     */ worldToScreenCoordinates(point) {\n            return this.screen.worldToScreenCoordinates(point);\n        }\n        /**\r\n     * Initializes the internal canvas, rendering context, display mode, and native event listeners\r\n     */ _initialize(options) {\n            this.pageScrollPreventionMode = options.scrollPreventionMode;\n            // initialize inputs\n            const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;\n            this.input = {\n                keyboard: new Keyboard(),\n                pointers: new PointerEventReceiver(pointerTarget, this),\n                gamepads: new Gamepads()\n            };\n            this.input.keyboard.init();\n            this.input.pointers.init();\n            this.input.gamepads.init();\n            // Issue #385 make use of the visibility api\n            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\n            let hidden, visibilityChange;\n            if (typeof document.hidden !== \"undefined\") {\n                // Opera 12.10 and Firefox 18 and later support\n                hidden = \"hidden\";\n                visibilityChange = \"visibilitychange\";\n            } else if (\"msHidden\" in document) {\n                hidden = \"msHidden\";\n                visibilityChange = \"msvisibilitychange\";\n            } else if (\"webkitHidden\" in document) {\n                hidden = \"webkitHidden\";\n                visibilityChange = \"webkitvisibilitychange\";\n            }\n            this.browser.document.on(visibilityChange, ()=>{\n                if (document[hidden]) {\n                    this.eventDispatcher.emit(\"hidden\", new HiddenEvent(this));\n                    this._logger.debug(\"Window hidden\");\n                } else {\n                    this.eventDispatcher.emit(\"visible\", new VisibleEvent(this));\n                    this._logger.debug(\"Window visible\");\n                }\n            });\n            if (!this.canvasElementId && !options.canvasElement) document.body.appendChild(this.canvas);\n        }\n        onInitialize(_engine) {\n        // Override me\n        }\n        /**\r\n     * If supported by the browser, this will set the antialiasing flag on the\r\n     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your\r\n     * image resources.\r\n     * @param isSmooth  Set smoothing to true or false\r\n     */ setAntialiasing(isSmooth) {\n            this.screen.antialiasing = isSmooth;\n        }\n        /**\r\n     * Return the current smoothing status of the canvas\r\n     */ getAntialiasing() {\n            return this.screen.antialiasing;\n        }\n        /**\r\n     * Gets whether the actor is Initialized\r\n     */ get isInitialized() {\n            return this._isInitialized;\n        }\n        _overrideInitialize(engine) {\n            if (!this.isInitialized) {\n                this.onInitialize(engine);\n                super.emit(\"initialize\", new InitializeEvent(engine, this));\n                this._isInitialized = true;\n                if (this._deferredGoTo) {\n                    const deferredScene = this._deferredGoTo;\n                    this._deferredGoTo = null;\n                    this.goToScene(deferredScene);\n                } else this.goToScene(\"root\");\n            }\n        }\n        /**\r\n     * Updates the entire state of the game\r\n     * @param delta  Number of milliseconds elapsed since the last update.\r\n     */ _update(delta) {\n            if (!this.ready) {\n                // suspend updates until loading is finished\n                this._loader.update(this, delta);\n                // Update input listeners\n                this.input.keyboard.update();\n                this.input.gamepads.update();\n                return;\n            }\n            // Publish preupdate events\n            this._preupdate(delta);\n            // process engine level events\n            this.currentScene.update(this, delta);\n            // Publish update event\n            this._postupdate(delta);\n            // Update input listeners\n            this.input.keyboard.update();\n            this.input.gamepads.update();\n        }\n        /**\r\n     * @internal\r\n     */ _preupdate(delta) {\n            this.emit(\"preupdate\", new PreUpdateEvent(this, delta, this));\n            this.onPreUpdate(this, delta);\n        }\n        onPreUpdate(_engine, _delta) {\n        // Override me\n        }\n        /**\r\n     * @internal\r\n     */ _postupdate(delta) {\n            this.emit(\"postupdate\", new PostUpdateEvent(this, delta, this));\n            this.onPostUpdate(this, delta);\n        }\n        onPostUpdate(_engine, _delta) {\n        // Override me\n        }\n        /**\r\n     * Draws the entire game\r\n     * @param delta  Number of milliseconds elapsed since the last draw.\r\n     */ _draw(delta) {\n            this.graphicsContext.beginDrawLifecycle();\n            this.graphicsContext.clear();\n            this._predraw(this.graphicsContext, delta);\n            // Drawing nothing else while loading\n            if (!this._isReady) {\n                this._loader.canvas.draw(this.graphicsContext, 0, 0);\n                this.graphicsContext.flush();\n                return;\n            }\n            this.graphicsContext.backgroundColor = this.backgroundColor;\n            this.currentScene.draw(this.graphicsContext, delta);\n            this._postdraw(this.graphicsContext, delta);\n            // Flush any pending drawings\n            this.graphicsContext.flush();\n            this.graphicsContext.endDrawLifecycle();\n            this._checkForScreenShots();\n        }\n        /**\r\n     * @internal\r\n     */ _predraw(_ctx, delta) {\n            this.emit(\"predraw\", new PreDrawEvent(_ctx, delta, this));\n            this.onPreDraw(_ctx, delta);\n        }\n        onPreDraw(_ctx, _delta) {\n        // Override me\n        }\n        /**\r\n     * @internal\r\n     */ _postdraw(_ctx, delta) {\n            this.emit(\"postdraw\", new PostDrawEvent(_ctx, delta, this));\n            this.onPostDraw(_ctx, delta);\n        }\n        onPostDraw(_ctx, _delta) {\n        // Override me\n        }\n        /**\r\n     * Enable or disable Excalibur debugging functionality.\r\n     * @param toggle a value that debug drawing will be changed to\r\n     */ showDebug(toggle) {\n            this._isDebug = toggle;\n        }\n        /**\r\n     * Toggle Excalibur debugging functionality.\r\n     */ toggleDebug() {\n            this._isDebug = !this._isDebug;\n            return this._isDebug;\n        }\n        /**\r\n     * Returns true when loading is totally complete and the player has clicked start\r\n     */ get loadingComplete() {\n            return this._loadingComplete;\n        }\n        get ready() {\n            return this._isReady;\n        }\n        isReady() {\n            return this._isReadyPromise;\n        }\n        /**\r\n     * Starts the internal game loop for Excalibur after loading\r\n     * any provided assets.\r\n     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n     * custom loader.\r\n     *\r\n     * Note: start() only resolves AFTER the user has clicked the play button\r\n     */ async start(loader) {\n            if (!this._compatible) throw new Error(\"Excalibur is incompatible with your browser\");\n            // Wire loader if we have it\n            if (loader) {\n                // Push the current user entered resolution/viewport\n                this.screen.pushResolutionAndViewport();\n                // Configure resolution for loader, it expects resolution === viewport\n                this.screen.resolution = this.screen.viewport;\n                this.screen.applyResolutionAndViewport();\n                this._loader = loader;\n                this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;\n                this._loader.wireEngine(this);\n            }\n            // Start the excalibur clock which drives the mainloop\n            // has started is a slight misnomer, it's really mainloop started\n            this._logger.debug(\"Starting game clock...\");\n            this.browser.resume();\n            this.clock.start();\n            this._logger.debug(\"Game clock started\");\n            if (loader) {\n                await this.load(this._loader);\n                this._loadingComplete = true;\n                // reset back to previous user resolution/viewport\n                this.screen.popResolutionAndViewport();\n                this.screen.applyResolutionAndViewport();\n            }\n            this._loadingComplete = true;\n            // Initialize before ready\n            this._overrideInitialize(this);\n            this._isReady = true;\n            this._isReadyResolve();\n            this.emit(\"start\", new GameStartEvent(this));\n            return this._isReadyPromise;\n        }\n        _mainloop(elapsed) {\n            this.emit(\"preframe\", new PreFrameEvent(this, this.stats.prevFrame));\n            const delta = elapsed * this.timescale;\n            this.currentFrameElapsedMs = delta;\n            // reset frame stats (reuse existing instances)\n            const frameId = this.stats.prevFrame.id + 1;\n            this.stats.currFrame.reset();\n            this.stats.currFrame.id = frameId;\n            this.stats.currFrame.delta = delta;\n            this.stats.currFrame.fps = this.clock.fpsSampler.fps;\n            GraphicsDiagnostics.clear();\n            const beforeUpdate = this.clock.now();\n            const fixedTimestepMs = 1000 / this.fixedUpdateFps;\n            if (this.fixedUpdateFps) {\n                this._lagMs += delta;\n                while(this._lagMs >= fixedTimestepMs){\n                    this._update(fixedTimestepMs);\n                    this._lagMs -= fixedTimestepMs;\n                }\n            } else this._update(delta);\n            const afterUpdate = this.clock.now();\n            this.currentFrameLagMs = this._lagMs;\n            this._draw(delta);\n            const afterDraw = this.clock.now();\n            this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\n            this.stats.currFrame.duration.draw = afterDraw - afterUpdate;\n            this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\n            this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\n            this.emit(\"postframe\", new PostFrameEvent(this, this.stats.currFrame));\n            this.stats.prevFrame.reset(this.stats.currFrame);\n            this._monitorPerformanceThresholdAndTriggerFallback();\n        }\n        /**\r\n     * Stops Excalibur's main loop, useful for pausing the game.\r\n     */ stop() {\n            if (this.clock.isRunning()) {\n                this.emit(\"stop\", new GameStopEvent(this));\n                this.browser.pause();\n                this.clock.stop();\n                this._logger.debug(\"Game stopped\");\n            }\n        }\n        /**\r\n     * Returns the Engine's running status, Useful for checking whether engine is running or paused.\r\n     */ isRunning() {\n            return this.clock.isRunning();\n        }\n        /**\r\n     * Takes a screen shot of the current viewport and returns it as an\r\n     * HTML Image Element.\r\n     * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false\r\n     */ screenshot(preserveHiDPIResolution = false) {\n            const screenShotPromise = new Promise((resolve)=>{\n                this._screenShotRequests.push({\n                    preserveHiDPIResolution: preserveHiDPIResolution,\n                    resolve: resolve\n                });\n            });\n            return screenShotPromise;\n        }\n        _checkForScreenShots() {\n            // We must grab the draw buffer before we yield to the browser\n            // the draw buffer is cleared after compositing\n            // the reason for the asynchrony is setting `preserveDrawingBuffer: true`\n            // forces the browser to copy buffers which can have a mass perf impact on mobile\n            for (const request of this._screenShotRequests){\n                const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;\n                const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;\n                const screenshot = document.createElement(\"canvas\");\n                screenshot.width = finalWidth;\n                screenshot.height = finalHeight;\n                const ctx = screenshot.getContext(\"2d\");\n                ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);\n                const result = new Image();\n                const raw = screenshot.toDataURL(\"image/png\");\n                result.src = raw;\n                request.resolve(result);\n            }\n            // Reset state\n            this._screenShotRequests.length = 0;\n        }\n        /**\r\n     * Another option available to you to load resources into the game.\r\n     * Immediately after calling this the game will pause and the loading screen\r\n     * will appear.\r\n     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n     */ async load(loader) {\n            try {\n                await loader.load();\n            } catch (e) {\n                this._logger.error(\"Error loading resources, things may not behave properly\", e);\n                await Promise.resolve();\n            }\n        }\n    }\n    /**\r\n * Default [[EngineOptions]]\r\n */ Engine._DEFAULT_ENGINE_OPTIONS = {\n        width: 0,\n        height: 0,\n        enableCanvasTransparency: true,\n        useDrawSorting: true,\n        configurePerformanceCanvas2DFallback: {\n            allow: true,\n            showPlayerMessage: false,\n            threshold: {\n                fps: 20,\n                numberOfFrames: 100\n            }\n        },\n        canvasElementId: \"\",\n        canvasElement: undefined,\n        snapToPixel: false,\n        pointerScope: PointerScope.Canvas,\n        suppressConsoleBootMessage: null,\n        suppressMinimumBrowserFeatureDetection: null,\n        suppressHiDPIScaling: null,\n        suppressPlayButton: null,\n        scrollPreventionMode: ScrollPreventionMode.Canvas,\n        backgroundColor: Color.fromHex(\"#2185d0\") // Excalibur blue\n    };\n    /**\r\n * Labels are the way to draw small amounts of text to the screen. They are\r\n * actors and inherit all of the benefits and capabilities.\r\n */ class Label extends Actor {\n        /**\r\n     * Build a new label\r\n     * @param options\r\n     */ constructor(options){\n            super(options);\n            this._font = new Font();\n            this._text = new Text({\n                text: \"\",\n                font: this._font\n            });\n            const { text: text , pos: pos , x: x , y: y , spriteFont: spriteFont , font: font , color: color  } = options;\n            this.pos = pos !== null && pos !== void 0 ? pos : x && y ? vec(x, y) : this.pos;\n            this.text = text !== null && text !== void 0 ? text : this.text;\n            this.font = font !== null && font !== void 0 ? font : this.font;\n            this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;\n            this._text.color = color !== null && color !== void 0 ? color : this.color;\n            const gfx = this.get(GraphicsComponent);\n            gfx.anchor = Vector.Zero;\n            gfx.use(this._text);\n        }\n        get font() {\n            return this._font;\n        }\n        set font(newFont) {\n            this._font = newFont;\n            this._text.font = newFont;\n        }\n        /**\r\n     * The text to draw.\r\n     */ get text() {\n            return this._text.text;\n        }\n        set text(text) {\n            this._text.text = text;\n        }\n        get color() {\n            return this._text.color;\n        }\n        set color(color) {\n            if (this._text) this._text.color = color;\n        }\n        get opacity() {\n            return this._text.opacity;\n        }\n        set opacity(opacity) {\n            this._text.opacity = opacity;\n        }\n        /**\r\n     * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.\r\n     */ get spriteFont() {\n            return this._spriteFont;\n        }\n        set spriteFont(sf) {\n            if (sf) {\n                this._spriteFont = sf;\n                this._text.font = this._spriteFont;\n            }\n        }\n        _initialize(engine) {\n            super._initialize(engine);\n        }\n        /**\r\n     * Returns the width of the text in the label (in pixels);\r\n     */ getTextWidth() {\n            return this._text.width;\n        }\n    }\n    class IsometricTile extends Entity {\n        /**\r\n     * Construct a new IsometricTile\r\n     * @param x tile coordinate in x (not world position)\r\n     * @param y tile coordinate in y (not world position)\r\n     * @param graphicsOffset offset that tile should be shifted by (default (0, 0))\r\n     * @param map reference to owning IsometricMap\r\n     */ constructor(x, y, graphicsOffset, map){\n            super([\n                new TransformComponent(),\n                new GraphicsComponent({\n                    offset: graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : Vector.Zero,\n                    onPostDraw: (gfx, elapsed)=>this.draw(gfx, elapsed)\n                }),\n                new IsometricEntityComponent(map)\n            ]);\n            /**\r\n         * Indicates whether this tile is solid\r\n         */ this.solid = false;\n            this._tileBounds = new BoundingBox();\n            this._graphics = [];\n            /**\r\n         * Tile colliders\r\n         */ this._colliders = [];\n            this.x = x;\n            this.y = y;\n            this.map = map;\n            this._transform = this.get(TransformComponent);\n            this._isometricEntityComponent = this.get(IsometricEntityComponent);\n            const halfTileWidth = this.map.tileWidth / 2;\n            const halfTileHeight = this.map.tileHeight / 2;\n            // See https://clintbellanger.net/articles/isometric_math/ for formula\n            // The x position shifts left with every y step\n            const xPos = (this.x - this.y) * halfTileWidth;\n            // The y position needs to go down with every x step\n            const yPos = (this.x + this.y) * halfTileHeight;\n            this._transform.pos = vec(xPos, yPos);\n            this._isometricEntityComponent.elevation = 0;\n            this._gfx = this.get(GraphicsComponent);\n            this._gfx.visible = false; // start not visible\n            const totalWidth = this.map.tileWidth;\n            const totalHeight = this.map.tileHeight;\n            // initial guess at gfx bounds based on the tile\n            const offset = vec(0, this.map.renderFromTopOfGraphic ? totalHeight : 0);\n            this._gfx.localBounds = this._tileBounds = new BoundingBox({\n                left: -totalWidth / 2,\n                top: -totalHeight,\n                right: totalWidth / 2,\n                bottom: totalHeight\n            }).translate(offset);\n        }\n        getGraphics() {\n            return this._graphics;\n        }\n        /**\r\n     * Tile graphics\r\n     */ addGraphic(graphic) {\n            this._graphics.push(graphic);\n            this._gfx.visible = true;\n            this._gfx.localBounds = this._recalculateBounds();\n        }\n        _recalculateBounds() {\n            let bounds = this._tileBounds.clone();\n            for (const graphic of this._graphics){\n                const offset = vec(this.map.graphicsOffset.x - this.map.tileWidth / 2, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight));\n                bounds = bounds.combine(graphic.localBounds.translate(offset));\n            }\n            return bounds;\n        }\n        removeGraphic(graphic) {\n            const index = this._graphics.indexOf(graphic);\n            if (index > -1) this._graphics.splice(index, 1);\n            this._gfx.localBounds = this._recalculateBounds();\n        }\n        clearGraphics() {\n            this._graphics.length = 0;\n            this._gfx.visible = false;\n            this._gfx.localBounds = this._recalculateBounds();\n        }\n        getColliders() {\n            return this._colliders;\n        }\n        /**\r\n     * Adds a collider to the IsometricTile\r\n     *\r\n     * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n     * @param collider\r\n     */ addCollider(collider) {\n            this._colliders.push(collider);\n            this.map.flagCollidersDirty();\n        }\n        /**\r\n     * Removes a collider from the IsometricTile\r\n     * @param collider\r\n     */ removeCollider(collider) {\n            const index = this._colliders.indexOf(collider);\n            if (index > -1) this._colliders.splice(index, 1);\n            this.map.flagCollidersDirty();\n        }\n        /**\r\n     * Clears all colliders from the IsometricTile\r\n     */ clearColliders() {\n            this._colliders.length = 0;\n            this.map.flagCollidersDirty();\n        }\n        /**\r\n     * Returns the top left corner of the [[IsometricTile]] in world space\r\n     */ get pos() {\n            return this.map.tileToWorld(vec(this.x, this.y));\n        }\n        /**\r\n     * Returns the center of the [[IsometricTile]]\r\n     */ get center() {\n            return this.pos.add(vec(0, this.map.tileHeight / 2));\n        }\n        draw(gfx, _elapsed) {\n            const halfTileWidth = this.map.tileWidth / 2;\n            gfx.save();\n            // shift left origin to corner of map, not the left corner of the first sprite\n            gfx.translate(-halfTileWidth, 0);\n            for (const graphic of this._graphics)graphic.draw(gfx, this.map.graphicsOffset.x, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight));\n            gfx.restore();\n        }\n    }\n    /**\r\n * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur\r\n *\r\n * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.\r\n * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.\r\n *\r\n * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given\r\n * your art assets.\r\n */ class IsometricMap extends Entity {\n        constructor(options){\n            super([\n                new TransformComponent(),\n                new BodyComponent({\n                    type: CollisionType.Fixed\n                }),\n                new ColliderComponent(),\n                new DebugGraphicsComponent((ctx)=>this.debug(ctx), false)\n            ], options.name);\n            /**\r\n         * Render the tile graphic from the top instead of the bottom\r\n         *\r\n         * default is `false` meaning rendering from the bottom\r\n         */ this.renderFromTopOfGraphic = false;\n            this.graphicsOffset = vec(0, 0);\n            this._collidersDirty = false;\n            this._originalOffsets = new WeakMap();\n            const { pos: pos , tileWidth: tileWidth , tileHeight: tileHeight , columns: width , rows: height , renderFromTopOfGraphic: renderFromTopOfGraphic , graphicsOffset: graphicsOffset  } = options;\n            this.transform = this.get(TransformComponent);\n            if (pos) this.transform.pos = pos;\n            this.collider = this.get(ColliderComponent);\n            if (this.collider) this.collider.set(this._composite = new CompositeCollider([]));\n            this.renderFromTopOfGraphic = renderFromTopOfGraphic !== null && renderFromTopOfGraphic !== void 0 ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;\n            this.graphicsOffset = graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : this.graphicsOffset;\n            this.tileWidth = tileWidth;\n            this.tileHeight = tileHeight;\n            this.columns = width;\n            this.rows = height;\n            this.tiles = new Array(width * height);\n            // build up tile representation\n            for(let y = 0; y < height; y++)for(let x = 0; x < width; x++){\n                const tile = new IsometricTile(x, y, this.graphicsOffset, this);\n                this.tiles[x + y * width] = tile;\n                this.addChild(tile);\n            // TODO row/columns helpers\n            }\n        }\n        update() {\n            if (this._collidersDirty) {\n                this.updateColliders();\n                this._collidersDirty = false;\n            }\n        }\n        flagCollidersDirty() {\n            this._collidersDirty = true;\n        }\n        _getOrSetColliderOriginalOffset(collider) {\n            if (!this._originalOffsets.has(collider)) {\n                const originalOffset = collider.offset;\n                this._originalOffsets.set(collider, originalOffset);\n                return originalOffset;\n            } else return this._originalOffsets.get(collider);\n        }\n        updateColliders() {\n            this._composite.clearColliders();\n            const pos = this.get(TransformComponent).pos;\n            for (const tile of this.tiles){\n                if (tile.solid) for (const collider of tile.getColliders()){\n                    const originalOffset = this._getOrSetColliderOriginalOffset(collider);\n                    collider.offset = this.tileToWorld(vec(tile.x, tile.y)).sub(pos).add(originalOffset).sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing\n                    collider.owner = this;\n                    this._composite.addCollider(collider);\n                }\n            }\n            this.collider.update();\n        }\n        /**\r\n     * Convert world space coordinates to the tile x, y coordinate\r\n     * @param worldCoordinate\r\n     */ worldToTile(worldCoordinate) {\n            worldCoordinate = worldCoordinate.sub(this.transform.globalPos);\n            const halfTileWidth = this.tileWidth / 2;\n            const halfTileHeight = this.tileHeight / 2;\n            // See https://clintbellanger.net/articles/isometric_math/ for formula\n            return vec(~~((worldCoordinate.x / halfTileWidth + worldCoordinate.y / halfTileHeight) / 2), ~~((worldCoordinate.y / halfTileHeight - worldCoordinate.x / halfTileWidth) / 2));\n        }\n        /**\r\n     * Given a tile coordinate, return the top left corner in world space\r\n     * @param tileCoordinate\r\n     */ tileToWorld(tileCoordinate) {\n            const halfTileWidth = this.tileWidth / 2;\n            const halfTileHeight = this.tileHeight / 2;\n            // The x position shifts left with every y step\n            const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;\n            // The y position needs to go down with every x step\n            const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;\n            return vec(xPos, yPos).add(this.transform.pos);\n        }\n        /**\r\n     * Returns the [[IsometricTile]] by its x and y coordinates\r\n     */ getTile(x, y) {\n            if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) return null;\n            return this.tiles[x + y * this.columns];\n        }\n        /**\r\n     * Returns the [[IsometricTile]] by testing a point in world coordinates,\r\n     * returns `null` if no Tile was found.\r\n     */ getTileByPoint(point) {\n            const tileCoord = this.worldToTile(point);\n            const tile = this.getTile(tileCoord.x, tileCoord.y);\n            return tile;\n        }\n        _getMaxZIndex() {\n            let maxZ = Number.NEGATIVE_INFINITY;\n            for (const tile of this.tiles){\n                const currentZ = tile.get(TransformComponent).z;\n                if (currentZ > maxZ) maxZ = currentZ;\n            }\n            return maxZ;\n        }\n        /**\r\n     * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on\r\n     * @param gfx\r\n     */ debug(gfx) {\n            gfx.save();\n            gfx.z = this._getMaxZIndex() + 0.5;\n            for(let y = 0; y < this.rows + 1; y++){\n                const left = this.tileToWorld(vec(0, y));\n                const right = this.tileToWorld(vec(this.columns, y));\n                gfx.drawLine(left, right, Color.Red, 2);\n            }\n            for(let x = 0; x < this.columns + 1; x++){\n                const top = this.tileToWorld(vec(x, 0));\n                const bottom = this.tileToWorld(vec(x, this.rows));\n                gfx.drawLine(top, bottom, Color.Red, 2);\n            }\n            for (const tile of this.tiles)gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);\n            gfx.restore();\n        }\n    }\n    /**\r\n * Action that can represent a sequence of actions, this can be useful in conjunction with\r\n * [[ParallelActions]] to run multiple sequences in parallel.\r\n */ class ActionSequence {\n        constructor(entity, actionBuilder){\n            this._stopped = false;\n            this._sequenceBuilder = actionBuilder;\n            this._sequenceContext = new ActionContext(entity);\n            this._actionQueue = this._sequenceContext.getQueue();\n            this._sequenceBuilder(this._sequenceContext);\n        }\n        update(delta) {\n            this._actionQueue.update(delta);\n        }\n        isComplete() {\n            return this._stopped || this._actionQueue.isComplete();\n        }\n        stop() {\n            this._stopped = true;\n        }\n        reset() {\n            this._stopped = false;\n            this._actionQueue.reset();\n        }\n        clone(entity) {\n            return new ActionSequence(entity, this._sequenceBuilder);\n        }\n    }\n    /**\r\n * Action that can run multiple [[Action]]s or [[ActionSequence]]s at the same time\r\n */ class ParallelActions {\n        constructor(parallelActions){\n            this._actions = parallelActions;\n        }\n        update(delta) {\n            for(let i = 0; i < this._actions.length; i++)this._actions[i].update(delta);\n        }\n        isComplete(entity) {\n            return this._actions.every((a)=>a.isComplete(entity));\n        }\n        reset() {\n            this._actions.forEach((a)=>a.reset());\n        }\n        stop() {\n            this._actions.forEach((a)=>a.stop());\n        }\n    }\n    /**\r\n * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur\r\n */ class CollisionGroupManager {\n        /**\r\n     * Create a new named collision group up to a max of 32.\r\n     * @param name Name for the collision group\r\n     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one\r\n     */ static create(name, mask) {\n            if (this._CURRENT_GROUP > this._MAX_GROUPS) throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);\n            if (this._GROUPS.get(name)) throw new Error(`Collision group ${name} already exists`);\n            const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);\n            this._CURRENT_BIT = this._CURRENT_BIT << 1 | 0;\n            this._CURRENT_GROUP++;\n            this._GROUPS.set(name, group);\n            return group;\n        }\n        /**\r\n     * Get all collision groups currently tracked by excalibur\r\n     */ static get groups() {\n            return Array.from(this._GROUPS.values());\n        }\n        /**\r\n     * Get a collision group by it's name\r\n     * @param name\r\n     */ static groupByName(name) {\n            return this._GROUPS.get(name);\n        }\n        /**\r\n     * Resets the managers internal group management state\r\n     */ static reset() {\n            this._GROUPS = new Map();\n            this._CURRENT_BIT = this._STARTING_BIT;\n            this._CURRENT_GROUP = 1;\n        }\n    }\n    // using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.\n    CollisionGroupManager._STARTING_BIT = 1;\n    CollisionGroupManager._MAX_GROUPS = 32;\n    CollisionGroupManager._CURRENT_GROUP = 1;\n    CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;\n    CollisionGroupManager._GROUPS = new Map();\n    /**\r\n * Type guard checking for internal initialize method\r\n * @internal\r\n * @param a\r\n */ function has_initialize(a) {\n        return !!a._initialize;\n    }\n    /**\r\n *\r\n */ function hasOnInitialize(a) {\n        return !!a.onInitialize;\n    }\n    /**\r\n *\r\n */ function has_preupdate(a) {\n        return !!a._preupdate;\n    }\n    /**\r\n *\r\n */ function hasOnPreUpdate(a) {\n        return !!a.onPreUpdate;\n    }\n    /**\r\n *\r\n */ function has_postupdate(a) {\n        return !!a.onPostUpdate;\n    }\n    /**\r\n *\r\n */ function hasOnPostUpdate(a) {\n        return !!a.onPostUpdate;\n    }\n    /**\r\n *\r\n */ function hasPreDraw(a) {\n        return !!a.onPreDraw;\n    }\n    /**\r\n *\r\n */ function hasPostDraw(a) {\n        return !!a.onPostDraw;\n    }\n    /**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n */ class Gif {\n        /**\r\n     * @param path       Path to the image resource\r\n     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]\r\n     * @param bustCache  Optionally load texture with cache busting\r\n     */ constructor(path, color = Color.Magenta, bustCache = true){\n            this.path = path;\n            this.color = color;\n            this.bustCache = bustCache;\n            this._stream = null;\n            this._gif = null;\n            this._textures = [];\n            this._animation = null;\n            this._transparentColor = null;\n            this._resource = new Resource(path, \"arraybuffer\", bustCache);\n            this._transparentColor = color;\n        }\n        /**\r\n     * Begins loading the texture and returns a promise to be resolved on completion\r\n     */ async load() {\n            const arraybuffer = await this._resource.load();\n            this._stream = new Stream(arraybuffer);\n            this._gif = new ParseGif(this._stream, this._transparentColor);\n            const images = this._gif.images.map((i)=>new ImageSource(i.src, false));\n            // Load all textures\n            await Promise.all(images.map((t)=>t.load()));\n            return this.data = this._textures = images;\n        }\n        isLoaded() {\n            return !!this.data;\n        }\n        /**\r\n     * Return a frame of the gif as a sprite by id\r\n     * @param id\r\n     */ toSprite(id = 0) {\n            const sprite = this._textures[id].toSprite();\n            return sprite;\n        }\n        /**\r\n     * Return the gif as a spritesheet\r\n     */ toSpriteSheet() {\n            const sprites = this._textures.map((image)=>{\n                return image.toSprite();\n            });\n            return new SpriteSheet({\n                sprites: sprites\n            });\n        }\n        /**\r\n     * Transform the GIF into an animation with duration per frame\r\n     */ toAnimation(durationPerFrameMs) {\n            const spriteSheet = this.toSpriteSheet();\n            const length = spriteSheet.sprites.length;\n            this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);\n            return this._animation;\n        }\n        get readCheckBytes() {\n            return this._gif.checkBytes;\n        }\n    }\n    const bitsToNum = (ba)=>{\n        return ba.reduce(function(s, n) {\n            return s * 2 + n;\n        }, 0);\n    };\n    const byteToBitArr = (bite)=>{\n        const a = [];\n        for(let i = 7; i >= 0; i--)a.push(!!(bite & 1 << i));\n        return a;\n    };\n    class Stream {\n        constructor(dataArray){\n            this.data = null;\n            this.len = 0;\n            this.position = 0;\n            this.readByte = ()=>{\n                if (this.position >= this.data.byteLength) throw new Error(\"Attempted to read past end of stream.\");\n                return this.data[this.position++];\n            };\n            this.readBytes = (n)=>{\n                const bytes = [];\n                for(let i = 0; i < n; i++)bytes.push(this.readByte());\n                return bytes;\n            };\n            this.read = (n)=>{\n                let s = \"\";\n                for(let i = 0; i < n; i++)s += String.fromCharCode(this.readByte());\n                return s;\n            };\n            this.readUnsigned = ()=>{\n                // Little-endian.\n                const a = this.readBytes(2);\n                return (a[1] << 8) + a[0];\n            };\n            this.data = new Uint8Array(dataArray);\n            this.len = this.data.byteLength;\n            if (this.len === 0) throw new Error(\"No data loaded from file\");\n        }\n    }\n    const lzwDecode = function(minCodeSize, data) {\n        // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\n        let pos = 0; // Maybe this streaming thing should be merged with the Stream?\n        const readCode = function(size) {\n            let code = 0;\n            for(let i = 0; i < size; i++){\n                if (data.charCodeAt(pos >> 3) & 1 << (pos & 7)) code |= 1 << i;\n                pos++;\n            }\n            return code;\n        };\n        const output = [];\n        const clearCode = 1 << minCodeSize;\n        const eoiCode = clearCode + 1;\n        let codeSize = minCodeSize + 1;\n        let dict = [];\n        const clear = function() {\n            dict = [];\n            codeSize = minCodeSize + 1;\n            for(let i = 0; i < clearCode; i++)dict[i] = [\n                i\n            ];\n            dict[clearCode] = [];\n            dict[eoiCode] = null;\n        };\n        let code;\n        let last;\n        while(true){\n            last = code;\n            code = readCode(codeSize);\n            if (code === clearCode) {\n                clear();\n                continue;\n            }\n            if (code === eoiCode) break;\n            if (code < dict.length) {\n                if (last !== clearCode) dict.push(dict[last].concat(dict[code][0]));\n            } else {\n                if (code !== dict.length) throw new Error(\"Invalid LZW code.\");\n                dict.push(dict[last].concat(dict[last][0]));\n            }\n            output.push.apply(output, dict[code]);\n            if (dict.length === 1 << codeSize && codeSize < 12) // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\n            codeSize++;\n        }\n        // I don't know if this is technically an error, but some GIFs do it.\n        //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\n        return output;\n    };\n    // The actual parsing; returns an object with properties.\n    class ParseGif {\n        constructor(stream, color = Color.Magenta){\n            this._st = null;\n            this._handler = {};\n            this._transparentColor = null;\n            this.frames = [];\n            this.images = [];\n            this.globalColorTable = [];\n            this.checkBytes = [];\n            // LZW (GIF-specific)\n            this.parseColorTable = (entries)=>{\n                // Each entry is 3 bytes, for RGB.\n                const ct = [];\n                for(let i = 0; i < entries; i++){\n                    const rgb = this._st.readBytes(3);\n                    const rgba = \"#\" + rgb.map((x)=>{\n                        const hex = x.toString(16);\n                        return hex.length === 1 ? \"0\" + hex : hex;\n                    }).join(\"\");\n                    ct.push(rgba);\n                }\n                return ct;\n            };\n            this.readSubBlocks = ()=>{\n                let size, data;\n                data = \"\";\n                do {\n                    size = this._st.readByte();\n                    data += this._st.read(size);\n                }while (size !== 0);\n                return data;\n            };\n            this.parseHeader = ()=>{\n                const hdr = {\n                    sig: null,\n                    ver: null,\n                    width: null,\n                    height: null,\n                    colorRes: null,\n                    globalColorTableSize: null,\n                    gctFlag: null,\n                    sorted: null,\n                    globalColorTable: [],\n                    bgColor: null,\n                    pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\n                };\n                hdr.sig = this._st.read(3);\n                hdr.ver = this._st.read(3);\n                if (hdr.sig !== \"GIF\") throw new Error(\"Not a GIF file.\"); // XXX: This should probably be handled more nicely.\n                hdr.width = this._st.readUnsigned();\n                hdr.height = this._st.readUnsigned();\n                const bits = byteToBitArr(this._st.readByte());\n                hdr.gctFlag = bits.shift();\n                hdr.colorRes = bitsToNum(bits.splice(0, 3));\n                hdr.sorted = bits.shift();\n                hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));\n                hdr.bgColor = this._st.readByte();\n                hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\n                if (hdr.gctFlag) {\n                    hdr.globalColorTable = this.parseColorTable(1 << hdr.globalColorTableSize + 1);\n                    this.globalColorTable = hdr.globalColorTable;\n                }\n                if (this._handler.hdr && this._handler.hdr(hdr)) this.checkBytes.push(this._handler.hdr);\n            };\n            this.parseExt = (block)=>{\n                const parseGCExt = (block)=>{\n                    this.checkBytes.push(this._st.readByte()); // Always 4\n                    const bits = byteToBitArr(this._st.readByte());\n                    block.reserved = bits.splice(0, 3); // Reserved; should be 000.\n                    block.disposalMethod = bitsToNum(bits.splice(0, 3));\n                    block.userInput = bits.shift();\n                    block.transparencyGiven = bits.shift();\n                    block.delayTime = this._st.readUnsigned();\n                    block.transparencyIndex = this._st.readByte();\n                    block.terminator = this._st.readByte();\n                    if (this._handler.gce && this._handler.gce(block)) this.checkBytes.push(this._handler.gce);\n                };\n                const parseComExt = (block)=>{\n                    block.comment = this.readSubBlocks();\n                    if (this._handler.com && this._handler.com(block)) this.checkBytes.push(this._handler.com);\n                };\n                const parsePTExt = (block)=>{\n                    this.checkBytes.push(this._st.readByte()); // Always 12\n                    block.ptHeader = this._st.readBytes(12);\n                    block.ptData = this.readSubBlocks();\n                    if (this._handler.pte && this._handler.pte(block)) this.checkBytes.push(this._handler.pte);\n                };\n                const parseAppExt = (block)=>{\n                    const parseNetscapeExt = (block)=>{\n                        this.checkBytes.push(this._st.readByte()); // Always 3\n                        block.unknown = this._st.readByte(); // Q: Always 1? What is this?\n                        block.iterations = this._st.readUnsigned();\n                        block.terminator = this._st.readByte();\n                        if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) this.checkBytes.push(this._handler.app);\n                    };\n                    const parseUnknownAppExt = (block)=>{\n                        block.appData = this.readSubBlocks();\n                        // FIXME: This won't work if a handler wants to match on any identifier.\n                        if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) this.checkBytes.push(this._handler.app[block.identifier]);\n                    };\n                    this.checkBytes.push(this._st.readByte()); // Always 11\n                    block.identifier = this._st.read(8);\n                    block.authCode = this._st.read(3);\n                    switch(block.identifier){\n                        case \"NETSCAPE\":\n                            parseNetscapeExt(block);\n                            break;\n                        default:\n                            parseUnknownAppExt(block);\n                            break;\n                    }\n                };\n                const parseUnknownExt = (block)=>{\n                    block.data = this.readSubBlocks();\n                    if (this._handler.unknown && this._handler.unknown(block)) this.checkBytes.push(this._handler.unknown);\n                };\n                block.label = this._st.readByte();\n                switch(block.label){\n                    case 0xf9:\n                        block.extType = \"gce\";\n                        parseGCExt(block);\n                        break;\n                    case 0xfe:\n                        block.extType = \"com\";\n                        parseComExt(block);\n                        break;\n                    case 0x01:\n                        block.extType = \"pte\";\n                        parsePTExt(block);\n                        break;\n                    case 0xff:\n                        block.extType = \"app\";\n                        parseAppExt(block);\n                        break;\n                    default:\n                        block.extType = \"unknown\";\n                        parseUnknownExt(block);\n                        break;\n                }\n            };\n            this.parseImg = (img)=>{\n                const deinterlace = (pixels, width)=>{\n                    // Of course this defeats the purpose of interlacing. And it's *probably*\n                    // the least efficient way it's ever been implemented. But nevertheless...\n                    const newPixels = new Array(pixels.length);\n                    const rows = pixels.length / width;\n                    const cpRow = (toRow, fromRow)=>{\n                        const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n                        newPixels.splice.apply(newPixels, [\n                            toRow * width,\n                            width\n                        ].concat(fromPixels));\n                    };\n                    const offsets = [\n                        0,\n                        4,\n                        2,\n                        1\n                    ];\n                    const steps = [\n                        8,\n                        8,\n                        4,\n                        2\n                    ];\n                    let fromRow = 0;\n                    for(let pass = 0; pass < 4; pass++)for(let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]){\n                        cpRow(toRow, fromRow);\n                        fromRow++;\n                    }\n                    return newPixels;\n                };\n                img.leftPos = this._st.readUnsigned();\n                img.topPos = this._st.readUnsigned();\n                img.width = this._st.readUnsigned();\n                img.height = this._st.readUnsigned();\n                const bits = byteToBitArr(this._st.readByte());\n                img.lctFlag = bits.shift();\n                img.interlaced = bits.shift();\n                img.sorted = bits.shift();\n                img.reserved = bits.splice(0, 2);\n                img.lctSize = bitsToNum(bits.splice(0, 3));\n                if (img.lctFlag) img.lct = this.parseColorTable(1 << img.lctSize + 1);\n                img.lzwMinCodeSize = this._st.readByte();\n                const lzwData = this.readSubBlocks();\n                img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\n                if (img.interlaced) // Move\n                img.pixels = deinterlace(img.pixels, img.width);\n                this.frames.push(img);\n                this.arrayToImage(img);\n                if (this._handler.img && this._handler.img(img)) this.checkBytes.push(this._handler);\n            };\n            this.parseBlock = ()=>{\n                const block = {\n                    sentinel: this._st.readByte(),\n                    type: \"\"\n                };\n                const blockChar = String.fromCharCode(block.sentinel);\n                switch(blockChar){\n                    case \"!\":\n                        block.type = \"ext\";\n                        this.parseExt(block);\n                        break;\n                    case \",\":\n                        block.type = \"img\";\n                        this.parseImg(block);\n                        break;\n                    case \";\":\n                        block.type = \"eof\";\n                        if (this._handler.eof && this._handler.eof(block)) this.checkBytes.push(this._handler.eof);\n                        break;\n                    default:\n                        throw new Error(\"Unknown block: 0x\" + block.sentinel.toString(16));\n                }\n                if (block.type !== \"eof\") this.parseBlock();\n            };\n            this.arrayToImage = (frame)=>{\n                let count = 0;\n                const c = document.createElement(\"canvas\");\n                c.id = count.toString();\n                c.width = frame.width;\n                c.height = frame.height;\n                count++;\n                const context = c.getContext(\"2d\");\n                const pixSize = 1;\n                let y = 0;\n                let x = 0;\n                for(let i = 0; i < frame.pixels.length; i++){\n                    if (x % frame.width === 0) {\n                        y++;\n                        x = 0;\n                    }\n                    if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) context.fillStyle = `rgba(0, 0, 0, 0)`;\n                    else context.fillStyle = this.globalColorTable[frame.pixels[i]];\n                    context.fillRect(x, y, pixSize, pixSize);\n                    x++;\n                }\n                const img = new Image();\n                img.src = c.toDataURL();\n                this.images.push(img);\n            };\n            this._st = stream;\n            this._handler = {};\n            this._transparentColor = color;\n            this.parseHeader();\n            this.parseBlock();\n        }\n    }\n    class Line extends Graphic {\n        constructor(options){\n            super();\n            this.color = Color.Black;\n            this.thickness = 1;\n            const { start: start , end: end , color: color , thickness: thickness  } = options;\n            this.start = start;\n            this.end = end;\n            this.color = color !== null && color !== void 0 ? color : this.color;\n            this.thickness = thickness !== null && thickness !== void 0 ? thickness : this.thickness;\n            const { width: width , height: height  } = BoundingBox.fromPoints([\n                start,\n                end\n            ]);\n            this.width = width;\n            this.height = height;\n        }\n        _drawImage(ctx, _x, _y) {\n            ctx.drawLine(this.start, this.end, this.color, this.thickness);\n        }\n        clone() {\n            return new Line({\n                start: this.start,\n                end: this.end,\n                color: this.color,\n                thickness: this.thickness\n            });\n        }\n    }\n    /**\r\n * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Polygons default to [[ImageFiltering.Blended]]\r\n */ class Polygon extends Raster {\n        constructor(options){\n            super(options);\n            this.points = options.points;\n            this.filtering = ImageFiltering.Blended;\n            this.rasterize();\n        }\n        get points() {\n            return this._points;\n        }\n        set points(points) {\n            this._points = points;\n            const min = this.minPoint;\n            this.width = this._points.reduce((max, p)=>Math.max(p.x, max), 0) - min.x;\n            this.height = this._points.reduce((max, p)=>Math.max(p.y, max), 0) - min.y;\n            this.flagDirty();\n        }\n        get minPoint() {\n            const minX = this._points.reduce((min, p)=>Math.min(p.x, min), Infinity);\n            const minY = this._points.reduce((min, p)=>Math.min(p.y, min), Infinity);\n            return vec(minX, minY);\n        }\n        clone() {\n            return new Polygon({\n                points: this.points.map((p)=>p.clone()),\n                ...this.cloneGraphicOptions(),\n                ...this.cloneRasterOptions()\n            });\n        }\n        execute(ctx) {\n            if (this.points && this.points.length) {\n                ctx.beginPath();\n                // Iterate through the supplied points and construct a 'polygon'\n                const min = this.minPoint.negate();\n                const firstPoint = this.points[0].add(min);\n                ctx.moveTo(firstPoint.x, firstPoint.y);\n                this.points.forEach((point)=>{\n                    ctx.lineTo(point.x + min.x, point.y + min.y);\n                });\n                ctx.lineTo(firstPoint.x, firstPoint.y);\n                ctx.closePath();\n                if (this.color) ctx.fill();\n                if (this.strokeColor) ctx.stroke();\n            }\n        }\n    }\n    class AsyncWaitQueue {\n        constructor(){\n            // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e\n            this._queue = [];\n        }\n        get length() {\n            return this._queue.length;\n        }\n        enqueue() {\n            const future = new Future();\n            this._queue.push(future);\n            return future.promise;\n        }\n        dequeue(value) {\n            const future = this._queue.shift();\n            future.resolve(value);\n        }\n    }\n    /**\r\n * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`\r\n *\r\n * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work\r\n * around browser limitations like max Image.decode() calls in chromium being 256.\r\n */ class Semaphore {\n        constructor(_count){\n            this._count = _count;\n            this._waitQueue = new AsyncWaitQueue();\n        }\n        get count() {\n            return this._count;\n        }\n        get waiting() {\n            return this._waitQueue.length;\n        }\n        async enter() {\n            if (this._count !== 0) {\n                this._count--;\n                return Promise.resolve();\n            }\n            return this._waitQueue.enqueue();\n        }\n        exit(count = 1) {\n            if (count === 0) return;\n            while(count !== 0 && this._waitQueue.length !== 0){\n                this._waitQueue.dequeue(null);\n                count--;\n            }\n            this._count += count;\n        }\n    }\n    /**\r\n * The current Excalibur version string\r\n * @description `process.env.__EX_VERSION` gets replaced by Webpack on build\r\n */ const EX_VERSION = \"0.27.0\";\n    polyfill();\n// This file is used as the bundle entry point and exports everything\n// that will be exposed as the `ex` global variable.\n// ex.Events namespace\n// ex.Input namespace\n// ex.Util namespaces\n// ex.Deprecated\n// import * as deprecated from './Deprecated';\n// export { deprecated as Deprecated };\n// export * from './Deprecated';\n})();\nvar $2c23f148d58cd887$export$e04e17a44f37debc = $2c23f148d58cd887$var$__webpack_exports__.fWn;\nvar $2c23f148d58cd887$export$dfcd1bb88f6d711b = $2c23f148d58cd887$var$__webpack_exports__.Ia8;\nvar $2c23f148d58cd887$export$89f31cec7c284d42 = $2c23f148d58cd887$var$__webpack_exports__.rqv;\nvar $2c23f148d58cd887$export$856e7d6d9d698871 = $2c23f148d58cd887$var$__webpack_exports__.hLI;\nvar $2c23f148d58cd887$export$caffe607ed29fca1 = $2c23f148d58cd887$var$__webpack_exports__.yyv;\nvar $2c23f148d58cd887$export$adc62e83dbcda319 = $2c23f148d58cd887$var$__webpack_exports__.tX5;\nvar $2c23f148d58cd887$export$f73d3eb6fd876d80 = $2c23f148d58cd887$var$__webpack_exports__.vtX;\nvar $2c23f148d58cd887$export$da248c61eea53296 = $2c23f148d58cd887$var$__webpack_exports__.r7K;\nvar $2c23f148d58cd887$export$a314202b9f383ad4 = $2c23f148d58cd887$var$__webpack_exports__.lCh;\nvar $2c23f148d58cd887$export$f0455ab08e3fbd0e = $2c23f148d58cd887$var$__webpack_exports__.cE4;\nvar $2c23f148d58cd887$export$c35d437ae5945fcd = $2c23f148d58cd887$var$__webpack_exports__.fwF;\nvar $2c23f148d58cd887$export$67ee29bab3792d4c = $2c23f148d58cd887$var$__webpack_exports__.sce;\nvar $2c23f148d58cd887$export$6cfd78ddb48c90c6 = $2c23f148d58cd887$var$__webpack_exports__._c7;\nvar $2c23f148d58cd887$export$3769e64eb87b5ecc = $2c23f148d58cd887$var$__webpack_exports__.KUs;\nvar $2c23f148d58cd887$export$54dc36bc2fac5425 = $2c23f148d58cd887$var$__webpack_exports__.Ajp;\nvar $2c23f148d58cd887$export$d06866a9fb0606da = $2c23f148d58cd887$var$__webpack_exports__.RDh;\nvar $2c23f148d58cd887$export$83c931ba0d3bbaf5 = $2c23f148d58cd887$var$__webpack_exports__._H9;\nvar $2c23f148d58cd887$export$1a553341cd0b8415 = $2c23f148d58cd887$var$__webpack_exports__.mxs;\nvar $2c23f148d58cd887$export$43416332cf06b1f = $2c23f148d58cd887$var$__webpack_exports__.OmD;\nvar $2c23f148d58cd887$export$63080c4de6cfc362 = $2c23f148d58cd887$var$__webpack_exports__.kBf;\nvar $2c23f148d58cd887$export$fa45ecb18b97ae89 = $2c23f148d58cd887$var$__webpack_exports__.C4F;\nvar $2c23f148d58cd887$export$c24f8f35353a1e26 = $2c23f148d58cd887$var$__webpack_exports__.NQt;\nvar $2c23f148d58cd887$export$8688def55452cbca = $2c23f148d58cd887$var$__webpack_exports__.JjN;\nvar $2c23f148d58cd887$export$79f141de891a5fed = $2c23f148d58cd887$var$__webpack_exports__.V1s;\nvar $2c23f148d58cd887$export$8d01c972ee8b14a9 = $2c23f148d58cd887$var$__webpack_exports__.Xz7;\nvar $2c23f148d58cd887$export$c89a927ffc67e6fa = $2c23f148d58cd887$var$__webpack_exports__.Cdc;\nvar $2c23f148d58cd887$export$e2395b697f5a931f = $2c23f148d58cd887$var$__webpack_exports__.FKn;\nvar $2c23f148d58cd887$export$4c85e640eb41c31b = $2c23f148d58cd887$var$__webpack_exports__.wTW;\nvar $2c23f148d58cd887$export$9735c82c4bae3302 = $2c23f148d58cd887$var$__webpack_exports__.SUY;\nvar $2c23f148d58cd887$export$44e6803d1d57f89a = $2c23f148d58cd887$var$__webpack_exports__.ab2;\nvar $2c23f148d58cd887$export$1ed419d47673a225 = $2c23f148d58cd887$var$__webpack_exports__.GfZ;\nvar $2c23f148d58cd887$export$b7c6eef0ebb06133 = $2c23f148d58cd887$var$__webpack_exports__.YMS;\nvar $2c23f148d58cd887$export$3c9e91dc1b611d2e = $2c23f148d58cd887$var$__webpack_exports__.oyv;\nvar $2c23f148d58cd887$export$ce0ca64520c7bfd2 = $2c23f148d58cd887$var$__webpack_exports__.aUb;\nvar $2c23f148d58cd887$export$83caf30c40e9d4b8 = $2c23f148d58cd887$var$__webpack_exports__.SdD;\nvar $2c23f148d58cd887$export$4df0464d8c812c98 = $2c23f148d58cd887$var$__webpack_exports__.JUv;\nvar $2c23f148d58cd887$export$55e924fc640a8405 = $2c23f148d58cd887$var$__webpack_exports__.jEj;\nvar $2c23f148d58cd887$export$fbd6eb86d6a3f08 = $2c23f148d58cd887$var$__webpack_exports__.TFq;\nvar $2c23f148d58cd887$export$7cd2649c3408da6c = $2c23f148d58cd887$var$__webpack_exports__.HDU;\nvar $2c23f148d58cd887$export$897cd666d936ac4c = $2c23f148d58cd887$var$__webpack_exports__.R_y;\nvar $2c23f148d58cd887$export$cd81a0bc3006f9ff = $2c23f148d58cd887$var$__webpack_exports__.ydN;\nvar $2c23f148d58cd887$export$cf976780b3106589 = $2c23f148d58cd887$var$__webpack_exports__.t50;\nvar $2c23f148d58cd887$export$5dcfde0f6b96512b = $2c23f148d58cd887$var$__webpack_exports__.s$$;\nvar $2c23f148d58cd887$export$ddb2ed749236e720 = $2c23f148d58cd887$var$__webpack_exports__.v2G;\nvar $2c23f148d58cd887$export$892596cec99bc70e = $2c23f148d58cd887$var$__webpack_exports__.Ilk;\nvar $2c23f148d58cd887$export$8ed4b5bb5352fe14 = $2c23f148d58cd887$var$__webpack_exports__.s9i;\nvar $2c23f148d58cd887$export$c46090c9df657074 = $2c23f148d58cd887$var$__webpack_exports__.dxL;\nvar $2c23f148d58cd887$export$b3bf2ffaa538264b = $2c23f148d58cd887$var$__webpack_exports__.LLX;\nvar $2c23f148d58cd887$export$16fa2f45be04daa8 = $2c23f148d58cd887$var$__webpack_exports__.wA2;\nvar $2c23f148d58cd887$export$d16a7c95008e315d = $2c23f148d58cd887$var$__webpack_exports__.R_p;\nvar $2c23f148d58cd887$export$abda45806f5adbae = $2c23f148d58cd887$var$__webpack_exports__.IQ$;\nvar $2c23f148d58cd887$export$e5a30aa3d28b26e2 = $2c23f148d58cd887$var$__webpack_exports__.I5F;\nvar $2c23f148d58cd887$export$de7807bd8bd828df = $2c23f148d58cd887$var$__webpack_exports__.X8$;\nvar $2c23f148d58cd887$export$1bdfb0c7c42d632d = $2c23f148d58cd887$var$__webpack_exports__.FR6;\nvar $2c23f148d58cd887$export$71de6146fb6d69d2 = $2c23f148d58cd887$var$__webpack_exports__.U8o;\nvar $2c23f148d58cd887$export$71efaa2be447940c = $2c23f148d58cd887$var$__webpack_exports__.kbG;\nvar $2c23f148d58cd887$export$7d34ad93c25aa8e7 = $2c23f148d58cd887$var$__webpack_exports__.iS_;\nvar $2c23f148d58cd887$export$153e5dc2c098b35c = $2c23f148d58cd887$var$__webpack_exports__.cGG;\nvar $2c23f148d58cd887$export$c3e6e677dda8521a = $2c23f148d58cd887$var$__webpack_exports__.RPN;\nvar $2c23f148d58cd887$export$e52858e61b0ea117 = $2c23f148d58cd887$var$__webpack_exports__.skb;\nvar $2c23f148d58cd887$export$3d1f12550a40f54d = $2c23f148d58cd887$var$__webpack_exports__.SLU;\nvar $2c23f148d58cd887$export$e1545123b54f6785 = $2c23f148d58cd887$var$__webpack_exports__.RdJ;\nvar $2c23f148d58cd887$export$7419ff430885d61c = $2c23f148d58cd887$var$__webpack_exports__.cNu;\nvar $2c23f148d58cd887$export$e695250628cde35 = $2c23f148d58cd887$var$__webpack_exports__.gU7;\nvar $2c23f148d58cd887$export$c5e124f7bab3d492 = $2c23f148d58cd887$var$__webpack_exports__.LSk;\nvar $2c23f148d58cd887$export$cacd6541cfeeb6c1 = $2c23f148d58cd887$var$__webpack_exports__.Nmp;\nvar $2c23f148d58cd887$export$4b7264771109adb6 = $2c23f148d58cd887$var$__webpack_exports__.d1Y;\nvar $2c23f148d58cd887$export$62053d374d83dfb1 = $2c23f148d58cd887$var$__webpack_exports__.xrL;\nvar $2c23f148d58cd887$export$d7078bb1ea3ba3f2 = $2c23f148d58cd887$var$__webpack_exports__.sRW;\nvar $2c23f148d58cd887$export$86ae8da356d53161 = $2c23f148d58cd887$var$__webpack_exports__.cmV;\nvar $2c23f148d58cd887$export$62230588c4867d28 = $2c23f148d58cd887$var$__webpack_exports__.qWz;\nvar $2c23f148d58cd887$export$df007b1d5b86e25a = $2c23f148d58cd887$var$__webpack_exports__.N0Q;\nvar $2c23f148d58cd887$export$6ff391a2049fdf40 = $2c23f148d58cd887$var$__webpack_exports__.q8b;\nvar $2c23f148d58cd887$export$89e5ccdc4c19a8f6 = $2c23f148d58cd887$var$__webpack_exports__.ynB;\nvar $2c23f148d58cd887$export$2cbc8fe61dd10773 = $2c23f148d58cd887$var$__webpack_exports__.jT9;\nvar $2c23f148d58cd887$export$d45269226a4bbdc1 = $2c23f148d58cd887$var$__webpack_exports__.wAz;\nvar $2c23f148d58cd887$export$2c3b404bf3a77a1f = $2c23f148d58cd887$var$__webpack_exports__.D4V;\nvar $2c23f148d58cd887$export$462adefbb095232e = $2c23f148d58cd887$var$__webpack_exports__.N6H;\nvar $2c23f148d58cd887$export$83f8212621739c1f = $2c23f148d58cd887$var$__webpack_exports__.W1A;\nvar $2c23f148d58cd887$export$bc644a473284d944 = $2c23f148d58cd887$var$__webpack_exports__.JHW;\nvar $2c23f148d58cd887$export$c7b7134fd828a5 = $2c23f148d58cd887$var$__webpack_exports__.v2K;\nvar $2c23f148d58cd887$export$ec8b666c5fe2c75a = $2c23f148d58cd887$var$__webpack_exports__.pBf;\nvar $2c23f148d58cd887$export$86d9a347f2bf71d6 = $2c23f148d58cd887$var$__webpack_exports__.GMl;\nvar $2c23f148d58cd887$export$ada873a34909da65 = $2c23f148d58cd887$var$__webpack_exports__.zW2;\nvar $2c23f148d58cd887$export$afee3afd6be961ec = $2c23f148d58cd887$var$__webpack_exports__.B0K;\nvar $2c23f148d58cd887$export$c03216fb3a7a2f87 = $2c23f148d58cd887$var$__webpack_exports__.Nv7;\nvar $2c23f148d58cd887$export$81940238f313e11f = $2c23f148d58cd887$var$__webpack_exports__.C_p;\nvar $2c23f148d58cd887$export$5aeca2e36dc70f5c = $2c23f148d58cd887$var$__webpack_exports__.iqw;\nvar $2c23f148d58cd887$export$40f8f9a8f94db930 = $2c23f148d58cd887$var$__webpack_exports__.MUA;\nvar $2c23f148d58cd887$export$c579e21b95165414 = $2c23f148d58cd887$var$__webpack_exports__.xqU;\nvar $2c23f148d58cd887$export$c983850c6c9d8b0e = $2c23f148d58cd887$var$__webpack_exports__.pTp;\nvar $2c23f148d58cd887$export$434ba092ed0eee4e = $2c23f148d58cd887$var$__webpack_exports__.vUK;\nvar $2c23f148d58cd887$export$455f05776f1ba8ba = $2c23f148d58cd887$var$__webpack_exports__.j9l;\nvar $2c23f148d58cd887$export$89abf52a030e56ee = $2c23f148d58cd887$var$__webpack_exports__.Zxw;\nvar $2c23f148d58cd887$export$23b468d4ca3f8c96 = $2c23f148d58cd887$var$__webpack_exports__.Hdx;\nvar $2c23f148d58cd887$export$6976e674e6d5804c = $2c23f148d58cd887$var$__webpack_exports__.Z$d;\nvar $2c23f148d58cd887$export$420acfc1740638d3 = $2c23f148d58cd887$var$__webpack_exports__.iqV;\nvar $2c23f148d58cd887$export$e84927905accfe51 = $2c23f148d58cd887$var$__webpack_exports__.o$7;\nvar $2c23f148d58cd887$export$c9d7bf589772a8ce = $2c23f148d58cd887$var$__webpack_exports__.olM;\nvar $2c23f148d58cd887$export$d5011a4647754c9b = $2c23f148d58cd887$var$__webpack_exports__.Zm$;\nvar $2c23f148d58cd887$export$b8c6aa234afa01bc = $2c23f148d58cd887$var$__webpack_exports__.$QH;\nvar $2c23f148d58cd887$export$6c3776220abeb931 = $2c23f148d58cd887$var$__webpack_exports__.i78;\nvar $2c23f148d58cd887$export$fb1b94e06ba8ebc8 = $2c23f148d58cd887$var$__webpack_exports__.h6u;\nvar $2c23f148d58cd887$export$3d953a2d86354b5f = $2c23f148d58cd887$var$__webpack_exports__.hts;\nvar $2c23f148d58cd887$export$88528019d270f582 = $2c23f148d58cd887$var$__webpack_exports__.j88;\nvar $2c23f148d58cd887$export$402da60b1c009e43 = $2c23f148d58cd887$var$__webpack_exports__.VME;\nvar $2c23f148d58cd887$export$48ebf29bc7cb1dd7 = $2c23f148d58cd887$var$__webpack_exports__.nt;\nvar $2c23f148d58cd887$export$3c8c04bde7eed7cb = $2c23f148d58cd887$var$__webpack_exports__.Ukr;\nvar $2c23f148d58cd887$export$adfa9d260876eca5 = $2c23f148d58cd887$var$__webpack_exports__.zsu;\nvar $2c23f148d58cd887$export$6c043ed3a716859a = $2c23f148d58cd887$var$__webpack_exports__.oA6;\nvar $2c23f148d58cd887$export$9f9afb456a8bef30 = $2c23f148d58cd887$var$__webpack_exports__.TVh;\nvar $2c23f148d58cd887$export$46d098cf93b32a72 = $2c23f148d58cd887$var$__webpack_exports__.TwZ;\nvar $2c23f148d58cd887$export$2fcc9871fa09b4ce = $2c23f148d58cd887$var$__webpack_exports__.GTT;\nvar $2c23f148d58cd887$export$1033a6fa0779f4f5 = $2c23f148d58cd887$var$__webpack_exports__.xxj;\nvar $2c23f148d58cd887$export$38f8109d2b8f43ef = $2c23f148d58cd887$var$__webpack_exports__.XdK;\nvar $2c23f148d58cd887$export$5213deb2877a09f2 = $2c23f148d58cd887$var$__webpack_exports__.Jmb;\nvar $2c23f148d58cd887$export$280e9a68c3ffd919 = $2c23f148d58cd887$var$__webpack_exports__.cXo;\nvar $2c23f148d58cd887$export$49a1ecce8d203 = $2c23f148d58cd887$var$__webpack_exports__.Dm5;\nvar $2c23f148d58cd887$export$f5b8910cec6cf069 = $2c23f148d58cd887$var$__webpack_exports__.IIB;\nvar $2c23f148d58cd887$export$d379657aa3df1705 = $2c23f148d58cd887$var$__webpack_exports__.zI0;\nvar $2c23f148d58cd887$export$ffed6a4cd9a88787 = $2c23f148d58cd887$var$__webpack_exports__.LYD;\nvar $2c23f148d58cd887$export$7705889256a9371a = $2c23f148d58cd887$var$__webpack_exports__.cEG;\nvar $2c23f148d58cd887$export$539f65e788a82c62 = $2c23f148d58cd887$var$__webpack_exports__.SEl;\nvar $2c23f148d58cd887$export$851e6d93385b6ad2 = $2c23f148d58cd887$var$__webpack_exports__.t9V;\nvar $2c23f148d58cd887$export$f3a6c1ca682fd40f = $2c23f148d58cd887$var$__webpack_exports__.SKZ;\nvar $2c23f148d58cd887$export$b04be29aa201d4f5 = $2c23f148d58cd887$var$__webpack_exports__.__J;\nvar $2c23f148d58cd887$export$b3509fba7d85d294 = $2c23f148d58cd887$var$__webpack_exports__.RI$;\nvar $2c23f148d58cd887$export$17d680238e50603e = $2c23f148d58cd887$var$__webpack_exports__.x12;\nvar $2c23f148d58cd887$export$8b98feb4a2766c75 = $2c23f148d58cd887$var$__webpack_exports__.ccz;\nvar $2c23f148d58cd887$export$3b0d6d7590275603 = $2c23f148d58cd887$var$__webpack_exports__.aNw;\nvar $2c23f148d58cd887$export$1c4c6d3f8d56581 = $2c23f148d58cd887$var$__webpack_exports__.xwn;\nvar $2c23f148d58cd887$export$fc869739b2177284 = $2c23f148d58cd887$var$__webpack_exports__.dNK;\nvar $2c23f148d58cd887$export$243e62d78d3b544d = $2c23f148d58cd887$var$__webpack_exports__.ini;\nvar $2c23f148d58cd887$export$efa9a398d6368992 = $2c23f148d58cd887$var$__webpack_exports__.YdH;\nvar $2c23f148d58cd887$export$5b12bf1653c0dd85 = $2c23f148d58cd887$var$__webpack_exports__.y3G;\nvar $2c23f148d58cd887$export$9f9b2346169b00c0 = $2c23f148d58cd887$var$__webpack_exports__.l57;\nvar $2c23f148d58cd887$export$8c37b217b84d3f89 = $2c23f148d58cd887$var$__webpack_exports__.xn0;\nvar $2c23f148d58cd887$export$35624b13e79b24a9 = $2c23f148d58cd887$var$__webpack_exports__.t2V;\nvar $2c23f148d58cd887$export$f75e7304717c9cbc = $2c23f148d58cd887$var$__webpack_exports__.uxB;\nvar $2c23f148d58cd887$export$ec1251c88c8bd5c9 = $2c23f148d58cd887$var$__webpack_exports__.cpd;\nvar $2c23f148d58cd887$export$d17844835b0fe8a8 = $2c23f148d58cd887$var$__webpack_exports__.fiy;\nvar $2c23f148d58cd887$export$d1d8cb3d5c2a5671 = $2c23f148d58cd887$var$__webpack_exports__.$XZ;\nvar $2c23f148d58cd887$export$f0b55daf9f154b55 = $2c23f148d58cd887$var$__webpack_exports__.uqK;\nvar $2c23f148d58cd887$export$fa9699e41ba6faff = $2c23f148d58cd887$var$__webpack_exports__.STE;\nvar $2c23f148d58cd887$export$77cea355fa80b5f4 = $2c23f148d58cd887$var$__webpack_exports__.y$z;\nvar $2c23f148d58cd887$export$8844adde4348f85c = $2c23f148d58cd887$var$__webpack_exports__.mAD;\nvar $2c23f148d58cd887$export$d63d7cff08fe4dc9 = $2c23f148d58cd887$var$__webpack_exports__.sOq;\nvar $2c23f148d58cd887$export$a960801e47624f4f = $2c23f148d58cd887$var$__webpack_exports__.hUw;\nvar $2c23f148d58cd887$export$ed6a63ee685a4d78 = $2c23f148d58cd887$var$__webpack_exports__._0G;\nvar $2c23f148d58cd887$export$4fe52ae24ae61d51 = $2c23f148d58cd887$var$__webpack_exports__.Sqs;\nvar $2c23f148d58cd887$export$c36c68baa13912a5 = $2c23f148d58cd887$var$__webpack_exports__.hpZ;\nvar $2c23f148d58cd887$export$616c632b282478dd = $2c23f148d58cd887$var$__webpack_exports__.Vol;\nvar $2c23f148d58cd887$export$2f09efa5b67124a7 = $2c23f148d58cd887$var$__webpack_exports__.wIZ;\nvar $2c23f148d58cd887$export$618424ba3f30cd41 = $2c23f148d58cd887$var$__webpack_exports__.cBi;\nvar $2c23f148d58cd887$export$6860c0696b73f79b = $2c23f148d58cd887$var$__webpack_exports__.RFv;\nvar $2c23f148d58cd887$export$7e5ab4f7f9fd407 = $2c23f148d58cd887$var$__webpack_exports__.kfC;\nvar $2c23f148d58cd887$export$7d31b617c820d435 = $2c23f148d58cd887$var$__webpack_exports__.mgq;\nvar $2c23f148d58cd887$export$f23a2a272a8df60 = $2c23f148d58cd887$var$__webpack_exports__.YVA;\nvar $2c23f148d58cd887$export$14963ee5c8637e11 = $2c23f148d58cd887$var$__webpack_exports__.Kgp;\nvar $2c23f148d58cd887$export$1d2c184034fc4cc2 = $2c23f148d58cd887$var$__webpack_exports__.HH$;\nvar $2c23f148d58cd887$export$fea21a521a6360c1 = $2c23f148d58cd887$var$__webpack_exports__.M_d;\nvar $2c23f148d58cd887$export$8c15bdf7e3727f73 = $2c23f148d58cd887$var$__webpack_exports__.rgh;\nvar $2c23f148d58cd887$export$6eb043bf81d89752 = $2c23f148d58cd887$var$__webpack_exports__.Ra6;\nvar $2c23f148d58cd887$export$e390b859365a3d5b = $2c23f148d58cd887$var$__webpack_exports__.KhR;\nvar $2c23f148d58cd887$export$1ec85152758537e0 = $2c23f148d58cd887$var$__webpack_exports__.BS5;\nvar $2c23f148d58cd887$export$a8584993858a18df = $2c23f148d58cd887$var$__webpack_exports__.xhz;\nvar $2c23f148d58cd887$export$906049a3747337a6 = $2c23f148d58cd887$var$__webpack_exports__.xOq;\nvar $2c23f148d58cd887$export$dbd8a6303ac26a42 = $2c23f148d58cd887$var$__webpack_exports__.a9j;\nvar $2c23f148d58cd887$export$9f68b6f37a444556 = $2c23f148d58cd887$var$__webpack_exports__.bHk;\nvar $2c23f148d58cd887$export$fe2b6ac465da985d = $2c23f148d58cd887$var$__webpack_exports__.CgK;\nvar $2c23f148d58cd887$export$e44279b5c44add28 = $2c23f148d58cd887$var$__webpack_exports__.cuY;\nvar $2c23f148d58cd887$export$dfa3a012bb2ef2e1 = $2c23f148d58cd887$var$__webpack_exports__.kvE;\nvar $2c23f148d58cd887$export$8201b979875baf73 = $2c23f148d58cd887$var$__webpack_exports__.SBu;\nvar $2c23f148d58cd887$export$62297b13309008b2 = $2c23f148d58cd887$var$__webpack_exports__.AE_;\nvar $2c23f148d58cd887$export$b986383a50b53ea4 = $2c23f148d58cd887$var$__webpack_exports__.ctO;\nvar $2c23f148d58cd887$export$ad5b3d166367714c = $2c23f148d58cd887$var$__webpack_exports__.OLH;\nvar $2c23f148d58cd887$export$a92776769f460054 = $2c23f148d58cd887$var$__webpack_exports__.kky;\nvar $2c23f148d58cd887$export$eeb71495ca594706 = $2c23f148d58cd887$var$__webpack_exports__.nSF;\nvar $2c23f148d58cd887$export$a186db52eed6d40e = $2c23f148d58cd887$var$__webpack_exports__.zHn;\nvar $2c23f148d58cd887$export$c07ce6d13c46df49 = $2c23f148d58cd887$var$__webpack_exports__.zwx;\nvar $2c23f148d58cd887$export$4617fb02663045ef = $2c23f148d58cd887$var$__webpack_exports__.AeJ;\nvar $2c23f148d58cd887$export$32437fc39ad02208 = $2c23f148d58cd887$var$__webpack_exports__.hLz;\nvar $2c23f148d58cd887$export$1f63032528469f52 = $2c23f148d58cd887$var$__webpack_exports__.D9g;\nvar $2c23f148d58cd887$export$f9d61a2a6155ab51 = $2c23f148d58cd887$var$__webpack_exports__.wA;\nvar $2c23f148d58cd887$export$9bd81f7d9b69ccb3 = $2c23f148d58cd887$var$__webpack_exports__.jhr;\nvar $2c23f148d58cd887$export$3e4ff2216a90b8a4 = $2c23f148d58cd887$var$__webpack_exports__.GVs;\nvar $2c23f148d58cd887$export$39a853cfb5a94a63 = $2c23f148d58cd887$var$__webpack_exports__._zO;\nvar $2c23f148d58cd887$export$a43177620e7a9310 = $2c23f148d58cd887$var$__webpack_exports__.w6$;\nvar $2c23f148d58cd887$export$a16b6ef1fd362a19 = $2c23f148d58cd887$var$__webpack_exports__.mhV;\nvar $2c23f148d58cd887$export$91397be43fc980cc = $2c23f148d58cd887$var$__webpack_exports__.MOD;\nvar $2c23f148d58cd887$export$23b9d128e61caefd = $2c23f148d58cd887$var$__webpack_exports__.kwd;\nvar $2c23f148d58cd887$export$ab681471d41eeddc = $2c23f148d58cd887$var$__webpack_exports__.Lmr;\nvar $2c23f148d58cd887$export$38af1803e3442a7f = $2c23f148d58cd887$var$__webpack_exports__.xsS;\nvar $2c23f148d58cd887$export$a98515d67472a41f = $2c23f148d58cd887$var$__webpack_exports__.lLr;\nvar $2c23f148d58cd887$export$57486627f01aaaf3 = $2c23f148d58cd887$var$__webpack_exports__.Z$r;\nvar $2c23f148d58cd887$export$77630fcd7c3f2eb6 = $2c23f148d58cd887$var$__webpack_exports__.IXb;\nvar $2c23f148d58cd887$export$2f3ac66e390c188b = $2c23f148d58cd887$var$__webpack_exports__.SGH;\nvar $2c23f148d58cd887$export$d160a188872e1e4e = $2c23f148d58cd887$var$__webpack_exports__.SMj;\nvar $2c23f148d58cd887$export$5c7bd08c630c970c = $2c23f148d58cd887$var$__webpack_exports__.L34;\nvar $2c23f148d58cd887$export$462bb059fed9d9e5 = $2c23f148d58cd887$var$__webpack_exports__.exe;\nvar $2c23f148d58cd887$export$6428a7f2611ef1fa = $2c23f148d58cd887$var$__webpack_exports__.bnF;\nvar $2c23f148d58cd887$export$80a00690bda7f17e = $2c23f148d58cd887$var$__webpack_exports__.MFA;\nvar $2c23f148d58cd887$export$85990f0f98a390bb = $2c23f148d58cd887$var$__webpack_exports__.$uU;\nvar $2c23f148d58cd887$export$3075603db8e6204c = $2c23f148d58cd887$var$__webpack_exports__.jyi;\nvar $2c23f148d58cd887$export$e1896ac0c4970221 = $2c23f148d58cd887$var$__webpack_exports__.E03;\nvar $2c23f148d58cd887$export$bd73ddfe5f8475d8 = $2c23f148d58cd887$var$__webpack_exports__.V6q;\nvar $2c23f148d58cd887$export$f62bb2892382b3dd = $2c23f148d58cd887$var$__webpack_exports__.rg2;\nvar $2c23f148d58cd887$export$cbf2d83d1eab018a = $2c23f148d58cd887$var$__webpack_exports__.DVW;\nvar $2c23f148d58cd887$export$9ad53eded130cce4 = $2c23f148d58cd887$var$__webpack_exports__.nVo;\nvar $2c23f148d58cd887$export$6a4eb2e7fc9e8903 = $2c23f148d58cd887$var$__webpack_exports__.F6N;\nvar $2c23f148d58cd887$export$e1dae5660003ffa7 = $2c23f148d58cd887$var$__webpack_exports__.xP7;\nvar $2c23f148d58cd887$export$a12e67a4b4590901 = $2c23f148d58cd887$var$__webpack_exports__.Odq;\nvar $2c23f148d58cd887$export$c586aa7b67d94d19 = $2c23f148d58cd887$var$__webpack_exports__.Zif;\nvar $2c23f148d58cd887$export$b06669ac5ed603e = $2c23f148d58cd887$var$__webpack_exports__.ZGJ;\nvar $2c23f148d58cd887$export$9440a22058545f9a = $2c23f148d58cd887$var$__webpack_exports__.MJk;\nvar $2c23f148d58cd887$export$5f1af8db9871e1d6 = $2c23f148d58cd887$var$__webpack_exports__.xvT;\nvar $2c23f148d58cd887$export$3720eb13f948f394 = $2c23f148d58cd887$var$__webpack_exports__.PHM;\nvar $2c23f148d58cd887$export$fd1bfc71f64c538c = $2c23f148d58cd887$var$__webpack_exports__.dpR;\nvar $2c23f148d58cd887$export$235cb65c20ad2b7 = $2c23f148d58cd887$var$__webpack_exports__.n9L;\nvar $2c23f148d58cd887$export$16ec26812de3ce7a = $2c23f148d58cd887$var$__webpack_exports__.KwO;\nvar $2c23f148d58cd887$export$c57e9b2d8b9e4de = $2c23f148d58cd887$var$__webpack_exports__.B7y;\nvar $2c23f148d58cd887$export$fb98e3a2a4cd92d7 = $2c23f148d58cd887$var$__webpack_exports__.x7r;\nvar $2c23f148d58cd887$export$563a914cafbdc389 = $2c23f148d58cd887$var$__webpack_exports__.wx7;\nvar $2c23f148d58cd887$export$1def2aa75b7c7fe0 = $2c23f148d58cd887$var$__webpack_exports__.Uvn;\nvar $2c23f148d58cd887$export$2eba8ec3a333fdbb = $2c23f148d58cd887$var$__webpack_exports__.OFT;\nvar $2c23f148d58cd887$export$41fb9f06171c75f4 = $2c23f148d58cd887$var$__webpack_exports__.xzN;\nvar $2c23f148d58cd887$export$ba8651401a8a2b84 = $2c23f148d58cd887$var$__webpack_exports__.M5Z;\nvar $2c23f148d58cd887$export$f8f26dd395d7e1bd = $2c23f148d58cd887$var$__webpack_exports__.ZrN;\nvar $2c23f148d58cd887$export$9b781de7bf37bf48 = $2c23f148d58cd887$var$__webpack_exports__.OWs;\nvar $2c23f148d58cd887$export$ab650c8e5b9b9f2c = $2c23f148d58cd887$var$__webpack_exports__.dF9;\nvar $2c23f148d58cd887$export$41825a1ed6473903 = $2c23f148d58cd887$var$__webpack_exports__.oZy;\nvar $2c23f148d58cd887$export$f5ae2f144b95ebf4 = $2c23f148d58cd887$var$__webpack_exports__.rD2;\nvar $2c23f148d58cd887$export$d5c6f73f7a77b9d = $2c23f148d58cd887$var$__webpack_exports__.VHo;\nvar $2c23f148d58cd887$export$8bfbf00b5dba81f6 = $2c23f148d58cd887$var$__webpack_exports__.ohE;\nvar $2c23f148d58cd887$export$2af5ef044257da25 = $2c23f148d58cd887$var$__webpack_exports__.R$E;\nvar $2c23f148d58cd887$export$812cd9544993280d = $2c23f148d58cd887$var$__webpack_exports__.q3I;\nvar $2c23f148d58cd887$export$a4913eafbb02ceb4 = $2c23f148d58cd887$var$__webpack_exports__.Pab;\nvar $2c23f148d58cd887$export$7d15b64cf5a3a4c4 = $2c23f148d58cd887$var$__webpack_exports__.uZ5;\nvar $2c23f148d58cd887$export$7149c6ffc9994c32 = $2c23f148d58cd887$var$__webpack_exports__.McK;\nvar $2c23f148d58cd887$export$d436988b04cb99a5 = $2c23f148d58cd887$var$__webpack_exports__.F9c;\nvar $2c23f148d58cd887$export$3ba9f2e94585ecc6 = $2c23f148d58cd887$var$__webpack_exports__.k0b;\nvar $2c23f148d58cd887$export$25dac40984956196 = $2c23f148d58cd887$var$__webpack_exports__.hnT;\nvar $2c23f148d58cd887$export$57932b71da6538b7 = $2c23f148d58cd887$var$__webpack_exports__.RSJ;\nvar $2c23f148d58cd887$export$a17402ef5f32064d = $2c23f148d58cd887$var$__webpack_exports__.Mku;\nvar $2c23f148d58cd887$export$d5dea09620a858fd = $2c23f148d58cd887$var$__webpack_exports__.h90;\nvar $2c23f148d58cd887$export$1377812d73ae3cab = $2c23f148d58cd887$var$__webpack_exports__.rms;\nvar $2c23f148d58cd887$export$331f4c7ef74a9752 = $2c23f148d58cd887$var$__webpack_exports__.ErP;\nvar $2c23f148d58cd887$export$5f4e18965661d41f = $2c23f148d58cd887$var$__webpack_exports__.aVg;\nvar $2c23f148d58cd887$export$817667946f51142b = $2c23f148d58cd887$var$__webpack_exports__.lPc;\nvar $2c23f148d58cd887$export$adc479603c39b28 = $2c23f148d58cd887$var$__webpack_exports__.Z8E;\nvar $2c23f148d58cd887$export$af0aa2f45005ee8e = $2c23f148d58cd887$var$__webpack_exports__._N2;\nvar $2c23f148d58cd887$export$6ef10647aef84ad9 = $2c23f148d58cd887$var$__webpack_exports__.yFn;\nvar $2c23f148d58cd887$export$256576ea924e6c90 = $2c23f148d58cd887$var$__webpack_exports__.lNv;\nvar $2c23f148d58cd887$export$e87630d8ef35465d = $2c23f148d58cd887$var$__webpack_exports__.cu9;\nvar $2c23f148d58cd887$export$5a62d8eea226ddc = $2c23f148d58cd887$var$__webpack_exports__.MZQ;\nvar $2c23f148d58cd887$export$640d107500a3202a = $2c23f148d58cd887$var$__webpack_exports__.FUM;\nvar $2c23f148d58cd887$export$506bf22710a79182 = $2c23f148d58cd887$var$__webpack_exports__.BxR;\nvar $2c23f148d58cd887$export$8b958c8ecd94a804 = $2c23f148d58cd887$var$__webpack_exports__.vdf;\nvar $2c23f148d58cd887$export$816343276f749e02 = $2c23f148d58cd887$var$__webpack_exports__.iaL;\nvar $2c23f148d58cd887$export$d02631cccf789723 = $2c23f148d58cd887$var$__webpack_exports__.w6H;\nvar $2c23f148d58cd887$export$5dc5812d8b390c43 = $2c23f148d58cd887$var$__webpack_exports__.Q4c;\nvar $2c23f148d58cd887$export$c5552dfdbc7cec71 = $2c23f148d58cd887$var$__webpack_exports__.Xxe;\nvar $2c23f148d58cd887$export$56cb859c01fa134d = $2c23f148d58cd887$var$__webpack_exports__.Uxb;\nvar $2c23f148d58cd887$export$cba01ba138429a1d = $2c23f148d58cd887$var$__webpack_exports__.Yr5;\nvar $2c23f148d58cd887$export$202e0172ed3c7be0 = $2c23f148d58cd887$var$__webpack_exports__.Bhw;\nvar $2c23f148d58cd887$export$d55298c9efc5ed14 = $2c23f148d58cd887$var$__webpack_exports__.yOA;\n\n\n// game.js\n// start-snippet{create-engine}\n// Create an instance of the engine.\n// I'm specifying that the game be 800 pixels wide by 600 pixels tall.\n// If no dimensions are specified the game will fit to the screen.\nconst $ad2bcec7a0192558$var$game = new (0, $2c23f148d58cd887$export$2c3b404bf3a77a1f)({\n    width: 800,\n    height: 600\n});\n// end-snippet{create-engine}\n// start-snippet{create-paddle}\n// Create an actor with x position of 150px,\n// y position of 40px from the bottom of the screen,\n// width of 200px, height and a height of 20px\nconst $ad2bcec7a0192558$var$paddle = new (0, $2c23f148d58cd887$export$f73d3eb6fd876d80)({\n    x: 150,\n    y: $ad2bcec7a0192558$var$game.drawHeight - 40,\n    width: 200,\n    height: 20,\n    // Let's give it some color with one of the predefined\n    // color constants\n    color: (0, $2c23f148d58cd887$export$892596cec99bc70e).Chartreuse\n});\n// Make sure the paddle can partipate in collisions, by default excalibur actors do not collide with each other\n// CollisionType.Fixed is like an object with infinite mass, and cannot be moved, but does participate in collision.\n$ad2bcec7a0192558$var$paddle.body.collisionType = (0, $2c23f148d58cd887$export$ddb2ed749236e720).Fixed;\n// `game.add` is the same as calling\n// `game.currentScene.add`\n$ad2bcec7a0192558$var$game.add($ad2bcec7a0192558$var$paddle);\n// end-snippet{create-paddle}\n// start-snippet{mouse-move}\n// Add a mouse move listener\n$ad2bcec7a0192558$var$game.input.pointers.primary.on(\"move\", (evt)=>{\n    $ad2bcec7a0192558$var$paddle.pos.x = evt.worldPos.x;\n});\n// end-snippet{mouse-move}\n// start-snippet{create-ball}\n// Create a ball at pos (100, 300) to start\nconst $ad2bcec7a0192558$var$ball = new (0, $2c23f148d58cd887$export$f73d3eb6fd876d80)({\n    x: 100,\n    y: 300,\n    // Use a circle collider with radius 10\n    radius: 10,\n    // Set the color\n    color: (0, $2c23f148d58cd887$export$892596cec99bc70e).Red\n});\n// Start the serve after a second\nconst $ad2bcec7a0192558$var$ballSpeed = (0, $2c23f148d58cd887$export$202e0172ed3c7be0)(100, 100);\nsetTimeout(()=>{\n    // Set the velocity in pixels per second\n    $ad2bcec7a0192558$var$ball.vel = $ad2bcec7a0192558$var$ballSpeed;\n}, 1000);\n// Set the collision Type to passive\n// This means \"tell me when I collide with an emitted event, but don't let excalibur do anything automatically\"\n$ad2bcec7a0192558$var$ball.body.collisionType = (0, $2c23f148d58cd887$export$ddb2ed749236e720).Passive;\n// Other possible collision types:\n// \"ex.CollisionType.PreventCollision - this means do not participate in any collision notification at all\"\n// \"ex.CollisionType.Active - this means participate and let excalibur resolve the positions/velocities of actors after collision\"\n// \"ex.CollisionType.Fixed - this means participate, but this object is unmovable\"\n// Add the ball to the current scene\n$ad2bcec7a0192558$var$game.add($ad2bcec7a0192558$var$ball);\n// end-snippet{create-ball}\n// start-snippet{screen-collision}\n// Wire up to the postupdate event\n$ad2bcec7a0192558$var$ball.on(\"postupdate\", ()=>{\n    // If the ball collides with the left side\n    // of the screen reverse the x velocity\n    if ($ad2bcec7a0192558$var$ball.pos.x < $ad2bcec7a0192558$var$ball.width / 2) $ad2bcec7a0192558$var$ball.vel.x = $ad2bcec7a0192558$var$ballSpeed.x;\n    // If the ball collides with the right side\n    // of the screen reverse the x velocity\n    if ($ad2bcec7a0192558$var$ball.pos.x + $ad2bcec7a0192558$var$ball.width / 2 > $ad2bcec7a0192558$var$game.drawWidth) $ad2bcec7a0192558$var$ball.vel.x = $ad2bcec7a0192558$var$ballSpeed.x * -1;\n    // If the ball collides with the top\n    // of the screen reverse the y velocity\n    if ($ad2bcec7a0192558$var$ball.pos.y < $ad2bcec7a0192558$var$ball.height / 2) $ad2bcec7a0192558$var$ball.vel.y = $ad2bcec7a0192558$var$ballSpeed.y;\n});\n// end-snippet{screen-collision}\n// start-snippet{create-bricks}\n// Build Bricks\n// Padding between bricks\nconst $ad2bcec7a0192558$var$padding = 20; // px\nconst $ad2bcec7a0192558$var$xoffset = 65; // x-offset\nconst $ad2bcec7a0192558$var$yoffset = 20; // y-offset\nconst $ad2bcec7a0192558$var$columns = 5;\nconst $ad2bcec7a0192558$var$rows = 3;\nconst $ad2bcec7a0192558$var$brickColor = [\n    (0, $2c23f148d58cd887$export$892596cec99bc70e).Violet,\n    (0, $2c23f148d58cd887$export$892596cec99bc70e).Orange,\n    (0, $2c23f148d58cd887$export$892596cec99bc70e).Yellow\n];\n// Individual brick width with padding factored in\nconst $ad2bcec7a0192558$var$brickWidth = $ad2bcec7a0192558$var$game.drawWidth / $ad2bcec7a0192558$var$columns - $ad2bcec7a0192558$var$padding - $ad2bcec7a0192558$var$padding / $ad2bcec7a0192558$var$columns; // px\nconst $ad2bcec7a0192558$var$brickHeight = 30; // px\nconst $ad2bcec7a0192558$var$bricks = [];\nfor(let j = 0; j < $ad2bcec7a0192558$var$rows; j++)for(let i = 0; i < $ad2bcec7a0192558$var$columns; i++)$ad2bcec7a0192558$var$bricks.push(new (0, $2c23f148d58cd887$export$f73d3eb6fd876d80)({\n    x: $ad2bcec7a0192558$var$xoffset + i * ($ad2bcec7a0192558$var$brickWidth + $ad2bcec7a0192558$var$padding) + $ad2bcec7a0192558$var$padding,\n    y: $ad2bcec7a0192558$var$yoffset + j * ($ad2bcec7a0192558$var$brickHeight + $ad2bcec7a0192558$var$padding) + $ad2bcec7a0192558$var$padding,\n    width: $ad2bcec7a0192558$var$brickWidth,\n    height: $ad2bcec7a0192558$var$brickHeight,\n    color: $ad2bcec7a0192558$var$brickColor[j % $ad2bcec7a0192558$var$brickColor.length]\n}));\n$ad2bcec7a0192558$var$bricks.forEach(function(brick) {\n    // Make sure that bricks can participate in collisions\n    brick.body.collisionType = (0, $2c23f148d58cd887$export$ddb2ed749236e720).Active;\n    // Add the brick to the current scene to be drawn\n    $ad2bcec7a0192558$var$game.add(brick);\n});\n// end-snippet{create-bricks}\n// start-snippet{ball-brick-collision}\n// On collision remove the brick, bounce the ball\nlet $ad2bcec7a0192558$var$colliding = false;\n$ad2bcec7a0192558$var$ball.on(\"collisionstart\", function(ev) {\n    if ($ad2bcec7a0192558$var$bricks.indexOf(ev.other) > -1) // kill removes an actor from the current scene\n    // therefore it will no longer be drawn or updated\n    ev.other.kill();\n    // reverse course after any collision\n    // intersections are the direction body A has to move to not be clipping body B\n    // `ev.content.mtv` \"minimum translation vector\" is a vector `normalize()` will make the length of it 1\n    // `negate()` flips the direction of the vector\n    var intersection = ev.contact.mtv.normalize();\n    // Only reverse direction when the collision starts\n    // Object could be colliding for multiple frames\n    if (!$ad2bcec7a0192558$var$colliding) {\n        $ad2bcec7a0192558$var$colliding = true;\n        // The largest component of intersection is our axis to flip\n        if (Math.abs(intersection.x) > Math.abs(intersection.y)) $ad2bcec7a0192558$var$ball.vel.x *= -1;\n        else $ad2bcec7a0192558$var$ball.vel.y *= -1;\n    }\n});\n$ad2bcec7a0192558$var$ball.on(\"collisionend\", ()=>{\n    // ball has separated from whatever object it was colliding with\n    $ad2bcec7a0192558$var$colliding = false;\n});\n// end-snippet{ball-brick-collision}\n// start-snippet{lose-condition}\n// Loss condition\n$ad2bcec7a0192558$var$ball.on(\"exitviewport\", ()=>{\n    alert(\"You lose!\");\n});\n// end-snippet{lose-condition}\n// start-snippet{start-game}\n// Start the engine to begin the game.\n$ad2bcec7a0192558$var$game.start(); // end-snippet{start-game}\n\n\n//# sourceMappingURL=index.dab76bea.js.map\n","import { Actor, CollisionType, Color, Engine, vec } from \"excalibur\";\n// game.js\n\n// start-snippet{create-engine}\n// Create an instance of the engine.\n// I'm specifying that the game be 800 pixels wide by 600 pixels tall.\n// If no dimensions are specified the game will fit to the screen.\nconst game = new Engine({\n  width: 800,\n  height: 600,\n});\n// end-snippet{create-engine}\n\n// start-snippet{create-paddle}\n// Create an actor with x position of 150px,\n// y position of 40px from the bottom of the screen,\n// width of 200px, height and a height of 20px\nconst paddle = new Actor({\n  x: 150,\n  y: game.drawHeight - 40,\n  width: 200,\n  height: 20,\n  // Let's give it some color with one of the predefined\n  // color constants\n  color: Color.Chartreuse,\n});\n\n// Make sure the paddle can partipate in collisions, by default excalibur actors do not collide with each other\n// CollisionType.Fixed is like an object with infinite mass, and cannot be moved, but does participate in collision.\npaddle.body.collisionType = CollisionType.Fixed;\n\n// `game.add` is the same as calling\n// `game.currentScene.add`\ngame.add(paddle);\n// end-snippet{create-paddle}\n\n// start-snippet{mouse-move}\n// Add a mouse move listener\ngame.input.pointers.primary.on(\"move\", (evt) => {\n  paddle.pos.x = evt.worldPos.x;\n});\n// end-snippet{mouse-move}\n\n// start-snippet{create-ball}\n// Create a ball at pos (100, 300) to start\nconst ball = new Actor({\n  x: 100,\n  y: 300,\n  // Use a circle collider with radius 10\n  radius: 10,\n  // Set the color\n  color: Color.Red,\n});\n// Start the serve after a second\nconst ballSpeed = vec(100, 100);\nsetTimeout(() => {\n  // Set the velocity in pixels per second\n  ball.vel = ballSpeed;\n}, 1000);\n\n// Set the collision Type to passive\n// This means \"tell me when I collide with an emitted event, but don't let excalibur do anything automatically\"\nball.body.collisionType = CollisionType.Passive;\n// Other possible collision types:\n// \"ex.CollisionType.PreventCollision - this means do not participate in any collision notification at all\"\n// \"ex.CollisionType.Active - this means participate and let excalibur resolve the positions/velocities of actors after collision\"\n// \"ex.CollisionType.Fixed - this means participate, but this object is unmovable\"\n\n// Add the ball to the current scene\ngame.add(ball);\n// end-snippet{create-ball}\n\n// start-snippet{screen-collision}\n// Wire up to the postupdate event\nball.on(\"postupdate\", () => {\n  // If the ball collides with the left side\n  // of the screen reverse the x velocity\n  if (ball.pos.x < ball.width / 2) {\n    ball.vel.x = ballSpeed.x;\n  }\n\n  // If the ball collides with the right side\n  // of the screen reverse the x velocity\n  if (ball.pos.x + ball.width / 2 > game.drawWidth) {\n    ball.vel.x = ballSpeed.x * -1;\n  }\n\n  // If the ball collides with the top\n  // of the screen reverse the y velocity\n  if (ball.pos.y < ball.height / 2) {\n    ball.vel.y = ballSpeed.y;\n  }\n});\n// end-snippet{screen-collision}\n\n// start-snippet{create-bricks}\n// Build Bricks\n\n// Padding between bricks\nconst padding = 20; // px\nconst xoffset = 65; // x-offset\nconst yoffset = 20; // y-offset\nconst columns = 5;\nconst rows = 3;\n\nconst brickColor = [Color.Violet, Color.Orange, Color.Yellow];\n\n// Individual brick width with padding factored in\nconst brickWidth = game.drawWidth / columns - padding - padding / columns; // px\nconst brickHeight = 30; // px\nconst bricks: Actor[] = [];\nfor (let j = 0; j < rows; j++) {\n  for (let i = 0; i < columns; i++) {\n    bricks.push(\n      new Actor({\n        x: xoffset + i * (brickWidth + padding) + padding,\n        y: yoffset + j * (brickHeight + padding) + padding,\n        width: brickWidth,\n        height: brickHeight,\n        color: brickColor[j % brickColor.length],\n      })\n    );\n  }\n}\n\nbricks.forEach(function (brick) {\n  // Make sure that bricks can participate in collisions\n  brick.body.collisionType = CollisionType.Active;\n\n  // Add the brick to the current scene to be drawn\n  game.add(brick);\n});\n// end-snippet{create-bricks}\n\n// start-snippet{ball-brick-collision}\n// On collision remove the brick, bounce the ball\nlet colliding = false;\nball.on(\"collisionstart\", function (ev) {\n  if (bricks.indexOf(ev.other) > -1) {\n    // kill removes an actor from the current scene\n    // therefore it will no longer be drawn or updated\n    ev.other.kill();\n  }\n\n  // reverse course after any collision\n  // intersections are the direction body A has to move to not be clipping body B\n  // `ev.content.mtv` \"minimum translation vector\" is a vector `normalize()` will make the length of it 1\n  // `negate()` flips the direction of the vector\n  var intersection = ev.contact.mtv.normalize();\n\n  // Only reverse direction when the collision starts\n  // Object could be colliding for multiple frames\n  if (!colliding) {\n    colliding = true;\n    // The largest component of intersection is our axis to flip\n    if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\n      ball.vel.x *= -1;\n    } else {\n      ball.vel.y *= -1;\n    }\n  }\n});\n\nball.on(\"collisionend\", () => {\n  // ball has separated from whatever object it was colliding with\n  colliding = false;\n});\n\n// end-snippet{ball-brick-collision}\n\n// start-snippet{lose-condition}\n// Loss condition\nball.on(\"exitviewport\", () => {\n  alert(\"You lose!\");\n});\n// end-snippet{lose-condition}\n\n// start-snippet{start-game}\n// Start the engine to begin the game.\ngame.start();\n// end-snippet{start-game}\n","/*!\n * excalibur - 0.27.0 - 2022-7-8\n * https://github.com/excaliburjs/Excalibur\n * Copyright (c) 2022 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>\n * Licensed BSD-2-Clause\n * @preserve\n */\n/******/ var __webpack_modules__ = ({\n\n/***/ 4662:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n__webpack_require__(3430);\nvar entryUnbind = __webpack_require__(8791);\n\nmodule.exports = entryUnbind('Array', 'sort');\n\n\n/***/ }),\n\n/***/ 8343:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n__webpack_require__(4769);\nvar path = __webpack_require__(9276);\n\nmodule.exports = path.Object.keys;\n\n\n/***/ }),\n\n/***/ 7111:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isCallable = __webpack_require__(6733);\nvar tryToString = __webpack_require__(9821);\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + ' is not a function');\n};\n\n\n/***/ }),\n\n/***/ 1176:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isObject = __webpack_require__(5052);\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n\n\n/***/ }),\n\n/***/ 9540:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar toIndexedObject = __webpack_require__(905);\nvar toAbsoluteIndex = __webpack_require__(3231);\nvar lengthOfArrayLike = __webpack_require__(9646);\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n/***/ }),\n\n/***/ 6038:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\nvar fails = __webpack_require__(4229);\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\n\n/***/ }),\n\n/***/ 9794:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar toAbsoluteIndex = __webpack_require__(3231);\nvar lengthOfArrayLike = __webpack_require__(9646);\nvar createProperty = __webpack_require__(2324);\n\nvar $Array = Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 3867:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar arraySlice = __webpack_require__(9794);\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice(array, 0, middle), comparefn),\n    mergeSort(arraySlice(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nmodule.exports = mergeSort;\n\n\n/***/ }),\n\n/***/ 7079:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n\n\n/***/ }),\n\n/***/ 1589:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(1601);\nvar isCallable = __webpack_require__(6733);\nvar classofRaw = __webpack_require__(7079);\nvar wellKnownSymbol = __webpack_require__(95);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n\n/***/ }),\n\n/***/ 7081:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar hasOwn = __webpack_require__(8270);\nvar ownKeys = __webpack_require__(4826);\nvar getOwnPropertyDescriptorModule = __webpack_require__(7933);\nvar definePropertyModule = __webpack_require__(1787);\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\n\n/***/ }),\n\n/***/ 5762:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar DESCRIPTORS = __webpack_require__(7400);\nvar definePropertyModule = __webpack_require__(1787);\nvar createPropertyDescriptor = __webpack_require__(5358);\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ 5358:\n/***/ ((module) => {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ 2324:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\nvar toPropertyKey = __webpack_require__(9310);\nvar definePropertyModule = __webpack_require__(1787);\nvar createPropertyDescriptor = __webpack_require__(5358);\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n/***/ }),\n\n/***/ 4768:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isCallable = __webpack_require__(6733);\nvar definePropertyModule = __webpack_require__(1787);\nvar makeBuiltIn = __webpack_require__(6039);\nvar defineGlobalProperty = __webpack_require__(8400);\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\n\n/***/ }),\n\n/***/ 8400:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n\n/***/ 9563:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\nvar tryToString = __webpack_require__(9821);\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (O, P) {\n  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));\n};\n\n\n/***/ }),\n\n/***/ 7400:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar fails = __webpack_require__(4229);\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n/***/ }),\n\n/***/ 2635:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar isObject = __webpack_require__(5052);\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ 2671:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar userAgent = __webpack_require__(598);\n\nvar firefox = userAgent.match(/firefox\\/(\\d+)/i);\n\nmodule.exports = !!firefox && +firefox[1];\n\n\n/***/ }),\n\n/***/ 8506:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar UA = __webpack_require__(598);\n\nmodule.exports = /MSIE|Trident/.test(UA);\n\n\n/***/ }),\n\n/***/ 598:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getBuiltIn = __webpack_require__(1333);\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n/***/ }),\n\n/***/ 6358:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar userAgent = __webpack_require__(598);\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n\n\n/***/ }),\n\n/***/ 9811:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar userAgent = __webpack_require__(598);\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nmodule.exports = !!webkit && +webkit[1];\n\n\n/***/ }),\n\n/***/ 8791:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar uncurryThis = __webpack_require__(5968);\n\nmodule.exports = function (CONSTRUCTOR, METHOD) {\n  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);\n};\n\n\n/***/ }),\n\n/***/ 3837:\n/***/ ((module) => {\n\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n/***/ }),\n\n/***/ 3103:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar getOwnPropertyDescriptor = (__webpack_require__(7933).f);\nvar createNonEnumerableProperty = __webpack_require__(5762);\nvar defineBuiltIn = __webpack_require__(4768);\nvar defineGlobalProperty = __webpack_require__(8400);\nvar copyConstructorProperties = __webpack_require__(7081);\nvar isForced = __webpack_require__(6541);\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n\n/***/ 4229:\n/***/ ((module) => {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ 7188:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar fails = __webpack_require__(4229);\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\n\n/***/ }),\n\n/***/ 266:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar NATIVE_BIND = __webpack_require__(7188);\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n\n\n/***/ }),\n\n/***/ 1805:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar DESCRIPTORS = __webpack_require__(7400);\nvar hasOwn = __webpack_require__(8270);\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\n\n/***/ }),\n\n/***/ 5968:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar NATIVE_BIND = __webpack_require__(7188);\n\nvar FunctionPrototype = Function.prototype;\nvar bind = FunctionPrototype.bind;\nvar call = FunctionPrototype.call;\nvar uncurryThis = NATIVE_BIND && bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis(fn);\n} : function (fn) {\n  return fn && function () {\n    return call.apply(fn, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ 1333:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar isCallable = __webpack_require__(6733);\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n/***/ }),\n\n/***/ 5300:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar aCallable = __webpack_require__(7111);\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n\n\n/***/ }),\n\n/***/ 9859:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n\n/***/ }),\n\n/***/ 8270:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\nvar toObject = __webpack_require__(2991);\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n\n\n/***/ }),\n\n/***/ 5977:\n/***/ ((module) => {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ 4394:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar DESCRIPTORS = __webpack_require__(7400);\nvar fails = __webpack_require__(4229);\nvar createElement = __webpack_require__(2635);\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ 9337:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\nvar fails = __webpack_require__(4229);\nvar classof = __webpack_require__(7079);\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n\n\n/***/ }),\n\n/***/ 8511:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\nvar isCallable = __webpack_require__(6733);\nvar store = __webpack_require__(5353);\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n/***/ }),\n\n/***/ 6407:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(8694);\nvar global = __webpack_require__(9859);\nvar uncurryThis = __webpack_require__(5968);\nvar isObject = __webpack_require__(5052);\nvar createNonEnumerableProperty = __webpack_require__(5762);\nvar hasOwn = __webpack_require__(8270);\nvar shared = __webpack_require__(5353);\nvar sharedKey = __webpack_require__(4399);\nvar hiddenKeys = __webpack_require__(5977);\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis(store.get);\n  var wmhas = uncurryThis(store.has);\n  var wmset = uncurryThis(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n\n/***/ 6733:\n/***/ ((module) => {\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument == 'function';\n};\n\n\n/***/ }),\n\n/***/ 6541:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar fails = __webpack_require__(4229);\nvar isCallable = __webpack_require__(6733);\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n/***/ }),\n\n/***/ 5052:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isCallable = __webpack_require__(6733);\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n\n/***/ }),\n\n/***/ 4231:\n/***/ ((module) => {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ 9395:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getBuiltIn = __webpack_require__(1333);\nvar isCallable = __webpack_require__(6733);\nvar isPrototypeOf = __webpack_require__(1321);\nvar USE_SYMBOL_AS_UID = __webpack_require__(6969);\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n\n\n/***/ }),\n\n/***/ 9646:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar toLength = __webpack_require__(4237);\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n\n\n/***/ }),\n\n/***/ 6039:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar fails = __webpack_require__(4229);\nvar isCallable = __webpack_require__(6733);\nvar hasOwn = __webpack_require__(8270);\nvar DESCRIPTORS = __webpack_require__(7400);\nvar CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(1805).CONFIGURABLE);\nvar inspectSource = __webpack_require__(8511);\nvar InternalStateModule = __webpack_require__(6407);\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\n\n/***/ }),\n\n/***/ 917:\n/***/ ((module) => {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\n\n/***/ }),\n\n/***/ 3839:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n/* eslint-disable es-x/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(6358);\nvar fails = __webpack_require__(4229);\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n/***/ }),\n\n/***/ 8694:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar isCallable = __webpack_require__(6733);\nvar inspectSource = __webpack_require__(8511);\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n\n\n/***/ }),\n\n/***/ 1787:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\nvar DESCRIPTORS = __webpack_require__(7400);\nvar IE8_DOM_DEFINE = __webpack_require__(4394);\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(7137);\nvar anObject = __webpack_require__(1176);\nvar toPropertyKey = __webpack_require__(9310);\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ 7933:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\nvar DESCRIPTORS = __webpack_require__(7400);\nvar call = __webpack_require__(266);\nvar propertyIsEnumerableModule = __webpack_require__(9195);\nvar createPropertyDescriptor = __webpack_require__(5358);\nvar toIndexedObject = __webpack_require__(905);\nvar toPropertyKey = __webpack_require__(9310);\nvar hasOwn = __webpack_require__(8270);\nvar IE8_DOM_DEFINE = __webpack_require__(4394);\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ 8151:\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\nvar internalObjectKeys = __webpack_require__(140);\nvar enumBugKeys = __webpack_require__(3837);\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ 894:\n/***/ ((__unused_webpack_module, exports) => {\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ 1321:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\nvar hasOwn = __webpack_require__(8270);\nvar toIndexedObject = __webpack_require__(905);\nvar indexOf = (__webpack_require__(9540).indexOf);\nvar hiddenKeys = __webpack_require__(5977);\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 5632:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar internalObjectKeys = __webpack_require__(140);\nvar enumBugKeys = __webpack_require__(3837);\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ 9195:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ 2914:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar call = __webpack_require__(266);\nvar isCallable = __webpack_require__(6733);\nvar isObject = __webpack_require__(5052);\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ 4826:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getBuiltIn = __webpack_require__(1333);\nvar uncurryThis = __webpack_require__(5968);\nvar getOwnPropertyNamesModule = __webpack_require__(8151);\nvar getOwnPropertySymbolsModule = __webpack_require__(894);\nvar anObject = __webpack_require__(1176);\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n\n/***/ 9276:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\n\nmodule.exports = global;\n\n\n/***/ }),\n\n/***/ 8885:\n/***/ ((module) => {\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw $TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ 4399:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar shared = __webpack_require__(3036);\nvar uid = __webpack_require__(1441);\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ 5353:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar defineGlobalProperty = __webpack_require__(8400);\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n\n\n/***/ }),\n\n/***/ 3036:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar IS_PURE = __webpack_require__(4231);\nvar store = __webpack_require__(5353);\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\n\n/***/ }),\n\n/***/ 3231:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar toIntegerOrInfinity = __webpack_require__(3329);\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n\n/***/ 905:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(9337);\nvar requireObjectCoercible = __webpack_require__(8885);\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n\n/***/ 3329:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar trunc = __webpack_require__(917);\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\n\n/***/ }),\n\n/***/ 4237:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar toIntegerOrInfinity = __webpack_require__(3329);\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ 2991:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar requireObjectCoercible = __webpack_require__(8885);\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n\n/***/ 2066:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar call = __webpack_require__(266);\nvar isObject = __webpack_require__(5052);\nvar isSymbol = __webpack_require__(9395);\nvar getMethod = __webpack_require__(5300);\nvar ordinaryToPrimitive = __webpack_require__(2914);\nvar wellKnownSymbol = __webpack_require__(95);\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n/***/ }),\n\n/***/ 9310:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar toPrimitive = __webpack_require__(2066);\nvar isSymbol = __webpack_require__(9395);\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\n\n/***/ }),\n\n/***/ 1601:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar wellKnownSymbol = __webpack_require__(95);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n/***/ }),\n\n/***/ 3326:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar classof = __webpack_require__(1589);\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\n\n/***/ }),\n\n/***/ 9821:\n/***/ ((module) => {\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\n\n/***/ }),\n\n/***/ 1441:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar uncurryThis = __webpack_require__(5968);\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n\n/***/ }),\n\n/***/ 6969:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n/* eslint-disable es-x/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(3839);\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n/***/ }),\n\n/***/ 7137:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar DESCRIPTORS = __webpack_require__(7400);\nvar fails = __webpack_require__(4229);\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\n\n/***/ }),\n\n/***/ 95:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar global = __webpack_require__(9859);\nvar shared = __webpack_require__(3036);\nvar hasOwn = __webpack_require__(8270);\nvar uid = __webpack_require__(1441);\nvar NATIVE_SYMBOL = __webpack_require__(3839);\nvar USE_SYMBOL_AS_UID = __webpack_require__(6969);\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n/***/ }),\n\n/***/ 3430:\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\n\n\nvar $ = __webpack_require__(3103);\nvar uncurryThis = __webpack_require__(5968);\nvar aCallable = __webpack_require__(7111);\nvar toObject = __webpack_require__(2991);\nvar lengthOfArrayLike = __webpack_require__(9646);\nvar deletePropertyOrThrow = __webpack_require__(9563);\nvar toString = __webpack_require__(3326);\nvar fails = __webpack_require__(4229);\nvar internalSort = __webpack_require__(3867);\nvar arrayMethodIsStrict = __webpack_require__(6038);\nvar FF = __webpack_require__(2671);\nvar IE_OR_EDGE = __webpack_require__(8506);\nvar V8 = __webpack_require__(6358);\nvar WEBKIT = __webpack_require__(9811);\n\nvar test = [];\nvar un$Sort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD = arrayMethodIsStrict('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable(comparefn);\n\n    var array = toObject(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n\n\n/***/ }),\n\n/***/ 4769:\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\n\nvar $ = __webpack_require__(3103);\nvar toObject = __webpack_require__(2991);\nvar nativeKeys = __webpack_require__(5632);\nvar fails = __webpack_require__(4229);\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject(it));\n  }\n});\n\n\n/***/ }),\n\n/***/ 1388:\n/***/ ((module, __webpack_exports__, __webpack_require__) => {\n\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./Loader.css\"],\"names\":[],\"mappings\":\"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF\",\"sourcesContent\":[\"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n/***/ }),\n\n/***/ 7379:\n/***/ ((module, __webpack_exports__, __webpack_require__) => {\n\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./Util/Toaster.css\"],\"names\":[],\"mappings\":\";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB\",\"sourcesContent\":[\"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n/***/ }),\n\n/***/ 2609:\n/***/ ((module) => {\n\n\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n/***/ }),\n\n/***/ 272:\n/***/ ((module) => {\n\n\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};\n\n/***/ })\n\n/******/ });\n/************************************************************************/\n/******/ // The module cache\n/******/ var __webpack_module_cache__ = {};\n/******/ \n/******/ // The require function\n/******/ function __webpack_require__(moduleId) {\n/******/ \t// Check if module is in cache\n/******/ \tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \tif (cachedModule !== undefined) {\n/******/ \t\treturn cachedModule.exports;\n/******/ \t}\n/******/ \t// Create a new module (and put it into the cache)\n/******/ \tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\tid: moduleId,\n/******/ \t\t// no module.loaded needed\n/******/ \t\texports: {}\n/******/ \t};\n/******/ \n/******/ \t// Execute the module function\n/******/ \t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \n/******/ \t// Return the exports of the module\n/******/ \treturn module.exports;\n/******/ }\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/compat get default export */\n/******/ (() => {\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = (module) => {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t() => (module['default']) :\n/******/ \t\t\t() => (module);\n/******/ \t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\treturn getter;\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__webpack_require__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/global */\n/******/ (() => {\n/******/ \t__webpack_require__.g = (function() {\n/******/ \t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\ttry {\n/******/ \t\t\treturn this || new Function('return this')();\n/******/ \t\t} catch (e) {\n/******/ \t\t\tif (typeof window === 'object') return window;\n/******/ \t\t}\n/******/ \t})();\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/make namespace object */\n/******/ (() => {\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = (exports) => {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/ })();\n/******/ \n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"fWn\": () => (/* reexport */ ActionContext),\n  \"Ia8\": () => (/* reexport */ ActionQueue),\n  \"rqv\": () => (/* reexport */ ActionSequence),\n  \"hLI\": () => (/* reexport */ ActionsComponent),\n  \"yyv\": () => (/* reexport */ ActionsSystem),\n  \"tX5\": () => (/* reexport */ ActivateEvent),\n  \"vtX\": () => (/* reexport */ Actor),\n  \"r7K\": () => (/* reexport */ AddedComponent),\n  \"lCh\": () => (/* reexport */ AddedEntity),\n  \"cE4\": () => (/* reexport */ AffineMatrix),\n  \"fwF\": () => (/* reexport */ Animation),\n  \"sce\": () => (/* reexport */ AnimationDirection),\n  \"_c7\": () => (/* reexport */ AnimationStrategy),\n  \"KUs\": () => (/* reexport */ ArcadeSolver),\n  \"Ajp\": () => (/* reexport */ AudioContextFactory),\n  \"RDh\": () => (/* reexport */ Axis),\n  \"_H9\": () => (/* reexport */ BaseAlign),\n  \"mxs\": () => (/* reexport */ Blink),\n  \"OmD\": () => (/* reexport */ BodyComponent),\n  \"kBf\": () => (/* reexport */ BoundingBox),\n  \"C4F\": () => (/* reexport */ BroadphaseStrategy),\n  \"NQt\": () => (/* reexport */ BrowserComponent),\n  \"JjN\": () => (/* reexport */ BrowserEvents),\n  \"V1s\": () => (/* reexport */ Camera),\n  \"Xz7\": () => (/* reexport */ Canvas),\n  \"Cdc\": () => (/* reexport */ Circle),\n  \"FKn\": () => (/* reexport */ CircleCollider),\n  \"wTW\": () => (/* reexport */ Class),\n  \"SUY\": () => (/* reexport */ Clock),\n  \"ab2\": () => (/* reexport */ ClosestLine),\n  \"GfZ\": () => (/* reexport */ ClosestLineJumpTable),\n  \"YMS\": () => (/* reexport */ Collider),\n  \"oyv\": () => (/* reexport */ ColliderComponent),\n  \"aUb\": () => (/* reexport */ CollisionContact),\n  \"SdD\": () => (/* reexport */ CollisionEndEvent),\n  \"JUv\": () => (/* reexport */ CollisionGroup),\n  \"jEj\": () => (/* reexport */ CollisionGroupManager),\n  \"TFq\": () => (/* reexport */ CollisionJumpTable),\n  \"HDU\": () => (/* reexport */ CollisionPostSolveEvent),\n  \"R_y\": () => (/* reexport */ CollisionPreSolveEvent),\n  \"ydN\": () => (/* reexport */ CollisionResolutionStrategy),\n  \"t50\": () => (/* reexport */ CollisionStartEvent),\n  \"s$$\": () => (/* reexport */ CollisionSystem),\n  \"v2G\": () => (/* reexport */ CollisionType),\n  \"Ilk\": () => (/* reexport */ Color),\n  \"s9i\": () => (/* reexport */ ColorBlindFlags),\n  \"dxL\": () => (/* reexport */ ColorBlindnessMode),\n  \"LLX\": () => (/* reexport */ ColorBlindnessPostProcessor),\n  \"wA2\": () => (/* reexport */ Component),\n  \"R_p\": () => (/* reexport */ CompositeCollider),\n  \"IQ$\": () => (/* reexport */ Configurable),\n  \"I5F\": () => (/* reexport */ ConsoleAppender),\n  \"X8$\": () => (/* reexport */ ContactConstraintPoint),\n  \"FR6\": () => (/* reexport */ ContactEndEvent),\n  \"U8o\": () => (/* reexport */ ContactStartEvent),\n  \"kbG\": () => (/* reexport */ CoordPlane),\n  \"iS_\": () => (/* reexport */ DeactivateEvent),\n  \"cGG\": () => (/* reexport */ Debug),\n  \"RPN\": () => (/* reexport */ DebugGraphicsComponent),\n  \"skb\": () => (/* reexport */ DebugSystem),\n  \"SLU\": () => (/* reexport */ DebugText),\n  \"RdJ\": () => (/* reexport */ DegreeOfFreedom),\n  \"cNu\": () => (/* reexport */ Delay),\n  \"gU7\": () => (/* reexport */ Detector),\n  \"LSk\": () => (/* reexport */ Die),\n  \"Nmp\": () => (/* reexport */ Direction),\n  \"d1Y\": () => (/* reexport */ DisplayMode),\n  \"xrL\": () => (/* reexport */ DynamicTree),\n  \"sRW\": () => (/* reexport */ DynamicTreeCollisionProcessor),\n  \"cmV\": () => (/* binding */ EX_VERSION),\n  \"qWz\": () => (/* reexport */ EaseBy),\n  \"N0Q\": () => (/* reexport */ EaseTo),\n  \"q8b\": () => (/* reexport */ EasingFunctions),\n  \"ynB\": () => (/* reexport */ EdgeCollider),\n  \"jT9\": () => (/* reexport */ ElasticToActorStrategy),\n  \"wAz\": () => (/* reexport */ EmitterType),\n  \"D4V\": () => (/* reexport */ Engine),\n  \"N6H\": () => (/* reexport */ EnterTriggerEvent),\n  \"W1A\": () => (/* reexport */ EnterViewPortEvent),\n  \"JHW\": () => (/* reexport */ Entity),\n  \"v2K\": () => (/* reexport */ EntityManager),\n  \"pBf\": () => (/* reexport */ EventDispatcher),\n  \"GMl\": () => (/* reexport */ EventTypes),\n  \"zW2\": () => (/* reexport */ Events_namespaceObject),\n  \"B0K\": () => (/* reexport */ ExResponse),\n  \"Nv7\": () => (/* reexport */ ExcaliburGraphicsContext2DCanvas),\n  \"C_p\": () => (/* reexport */ ExcaliburGraphicsContextWebGL),\n  \"iqw\": () => (/* reexport */ ExcaliburWebGLContextAccessor),\n  \"MUA\": () => (/* reexport */ ExitTriggerEvent),\n  \"xqU\": () => (/* reexport */ ExitViewPortEvent),\n  \"pTp\": () => (/* reexport */ Fade),\n  \"vUK\": () => (/* reexport */ Flags),\n  \"j9l\": () => (/* reexport */ Follow),\n  \"Zxw\": () => (/* reexport */ Font),\n  \"Hdx\": () => (/* reexport */ FontStyle),\n  \"Z$d\": () => (/* reexport */ FontUnit),\n  \"iqV\": () => (/* reexport */ FpsSampler),\n  \"o$7\": () => (/* reexport */ FrameStats),\n  \"olM\": () => (/* reexport */ Future),\n  \"Zm$\": () => (/* reexport */ GameEvent),\n  \"$QH\": () => (/* reexport */ GameStartEvent),\n  \"i78\": () => (/* reexport */ GameStopEvent),\n  \"h6u\": () => (/* reexport */ GamepadAxisEvent),\n  \"hts\": () => (/* reexport */ GamepadButtonEvent),\n  \"j88\": () => (/* reexport */ GamepadConnectEvent),\n  \"VME\": () => (/* reexport */ GamepadDisconnectEvent),\n  \"nt\": () => (/* reexport */ Gif),\n  \"Ukr\": () => (/* reexport */ GlobalCoordinates),\n  \"zsu\": () => (/* reexport */ Graphic),\n  \"oA6\": () => (/* reexport */ GraphicsComponent),\n  \"TVh\": () => (/* reexport */ GraphicsGroup),\n  \"TwZ\": () => (/* reexport */ GraphicsLayer),\n  \"GTT\": () => (/* reexport */ GraphicsLayers),\n  \"xxj\": () => (/* reexport */ GraphicsSystem),\n  \"XdK\": () => (/* reexport */ HiddenEvent),\n  \"Jmb\": () => (/* reexport */ ImageFiltering),\n  \"cXo\": () => (/* reexport */ ImageSource),\n  \"Dm5\": () => (/* reexport */ InitializeEvent),\n  \"IIB\": () => (/* reexport */ Input_Index_namespaceObject),\n  \"zI0\": () => (/* reexport */ Integrator),\n  \"LYD\": () => (/* reexport */ IsometricEntityComponent),\n  \"cEG\": () => (/* reexport */ IsometricEntitySystem),\n  \"SEl\": () => (/* reexport */ IsometricMap),\n  \"t9V\": () => (/* reexport */ IsometricTile),\n  \"SKZ\": () => (/* reexport */ KillEvent),\n  \"__J\": () => (/* reexport */ Label),\n  \"RI$\": () => (/* reexport */ LimitCameraBoundsStrategy),\n  \"x12\": () => (/* reexport */ Line),\n  \"ccz\": () => (/* reexport */ LineSegment),\n  \"aNw\": () => (/* reexport */ Loader),\n  \"xwn\": () => (/* reexport */ LockCameraToActorAxisStrategy),\n  \"dNK\": () => (/* reexport */ LockCameraToActorStrategy),\n  \"ini\": () => (/* reexport */ LogLevel),\n  \"YdH\": () => (/* reexport */ Logger),\n  \"y3G\": () => (/* reexport */ Matrix),\n  \"l57\": () => (/* reexport */ MatrixLocations),\n  \"xn0\": () => (/* reexport */ MediaEvent),\n  \"t2V\": () => (/* reexport */ Meet),\n  \"uxB\": () => (/* reexport */ MotionComponent),\n  \"cpd\": () => (/* reexport */ MotionSystem),\n  \"fiy\": () => (/* reexport */ MoveBy),\n  \"$XZ\": () => (/* reexport */ MoveTo),\n  \"uqK\": () => (/* reexport */ NativeSoundEvent),\n  \"STE\": () => (/* reexport */ NativeSoundProcessedEvent),\n  \"y$z\": () => (/* reexport */ Observable),\n  \"mAD\": () => (/* reexport */ OffscreenSystem),\n  \"sOq\": () => (/* reexport */ Pair),\n  \"hUw\": () => (/* reexport */ ParallaxComponent),\n  \"_0G\": () => (/* reexport */ ParallelActions),\n  \"Sqs\": () => (/* reexport */ ParseGif),\n  \"hpZ\": () => (/* reexport */ Particle),\n  \"Vol\": () => (/* reexport */ ParticleEmitter),\n  \"wIZ\": () => (/* reexport */ Physics),\n  \"cBi\": () => (/* reexport */ PhysicsStats),\n  \"RFv\": () => (/* reexport */ PointerComponent),\n  \"kfC\": () => (/* reexport */ PointerSystem),\n  \"mgq\": () => (/* reexport */ Polygon),\n  \"YVA\": () => (/* reexport */ PolygonCollider),\n  \"Kgp\": () => (/* reexport */ Pool),\n  \"HH$\": () => (/* reexport */ PostCollisionEvent),\n  \"M_d\": () => (/* reexport */ PostDebugDrawEvent),\n  \"rgh\": () => (/* reexport */ PostDrawEvent),\n  \"Ra6\": () => (/* reexport */ PostFrameEvent),\n  \"KhR\": () => (/* reexport */ PostKillEvent),\n  \"BS5\": () => (/* reexport */ PostUpdateEvent),\n  \"xhz\": () => (/* reexport */ PreCollisionEvent),\n  \"xOq\": () => (/* reexport */ PreDebugDrawEvent),\n  \"a9j\": () => (/* reexport */ PreDrawEvent),\n  \"bHk\": () => (/* reexport */ PreFrameEvent),\n  \"CgK\": () => (/* reexport */ PreKillEvent),\n  \"cuY\": () => (/* reexport */ PreUpdateEvent),\n  \"kvE\": () => (/* reexport */ Projection),\n  \"SBu\": () => (/* reexport */ QuadIndexBuffer),\n  \"AE_\": () => (/* reexport */ Query),\n  \"ctO\": () => (/* reexport */ QueryManager),\n  \"OLH\": () => (/* reexport */ RadiusAroundActorStrategy),\n  \"kky\": () => (/* reexport */ Random),\n  \"nSF\": () => (/* reexport */ Raster),\n  \"zHn\": () => (/* reexport */ Ray),\n  \"zwx\": () => (/* reexport */ RealisticSolver),\n  \"AeJ\": () => (/* reexport */ Rectangle),\n  \"hLz\": () => (/* reexport */ RemovedComponent),\n  \"D9g\": () => (/* reexport */ RemovedEntity),\n  \"wA\": () => (/* reexport */ Repeat),\n  \"jhr\": () => (/* reexport */ RepeatForever),\n  \"GVs\": () => (/* reexport */ Resolution),\n  \"_zO\": () => (/* reexport */ Resource),\n  \"w6$\": () => (/* reexport */ RotateBy),\n  \"mhV\": () => (/* reexport */ RotateTo),\n  \"MOD\": () => (/* reexport */ RotationType),\n  \"kwd\": () => (/* reexport */ ScaleBy),\n  \"Lmr\": () => (/* reexport */ ScaleTo),\n  \"xsS\": () => (/* reexport */ Scene),\n  \"lLr\": () => (/* reexport */ Screen),\n  \"Z$r\": () => (/* reexport */ ScreenAppender),\n  \"IXb\": () => (/* reexport */ ScreenElement),\n  \"SGH\": () => (/* reexport */ ScreenShader),\n  \"SMj\": () => (/* reexport */ ScrollPreventionMode),\n  \"L34\": () => (/* reexport */ Semaphore),\n  \"exe\": () => (/* reexport */ Shader),\n  \"bnF\": () => (/* reexport */ Shape),\n  \"MFA\": () => (/* reexport */ Side),\n  \"$uU\": () => (/* reexport */ Sound),\n  \"jyi\": () => (/* reexport */ Sprite),\n  \"E03\": () => (/* reexport */ SpriteFont),\n  \"V6q\": () => (/* reexport */ SpriteSheet),\n  \"rg2\": () => (/* reexport */ StandardClock),\n  \"DVW\": () => (/* reexport */ StateMachine),\n  \"nVo\": () => (/* reexport */ StrategyContainer),\n  \"F6N\": () => (/* reexport */ Stream),\n  \"xP7\": () => (/* reexport */ System),\n  \"Odq\": () => (/* reexport */ SystemManager),\n  \"Zif\": () => (/* reexport */ SystemType),\n  \"ZGJ\": () => (/* reexport */ TagComponent),\n  \"MJk\": () => (/* reexport */ TestClock),\n  \"xvT\": () => (/* reexport */ Text),\n  \"PHM\": () => (/* reexport */ TextAlign),\n  \"dpR\": () => (/* reexport */ TextureLoader),\n  \"n9L\": () => (/* reexport */ Tile),\n  \"KwO\": () => (/* reexport */ TileMap),\n  \"B7y\": () => (/* reexport */ Timer),\n  \"x7r\": () => (/* reexport */ Toaster),\n  \"wx7\": () => (/* reexport */ Transform),\n  \"Uvn\": () => (/* reexport */ TransformComponent),\n  \"OFT\": () => (/* reexport */ TreeNode),\n  \"xzN\": () => (/* reexport */ Trigger),\n  \"M5Z\": () => (/* reexport */ TwoPI),\n  \"ZrN\": () => (/* reexport */ Util_Index_namespaceObject),\n  \"OWs\": () => (/* reexport */ Vector),\n  \"dF9\": () => (/* reexport */ VectorView),\n  \"oZy\": () => (/* reexport */ VertexBuffer),\n  \"rD2\": () => (/* reexport */ VertexLayout),\n  \"VHo\": () => (/* reexport */ VisibleEvent),\n  \"ohE\": () => (/* reexport */ WebAudio),\n  \"R$E\": () => (/* reexport */ WebAudioInstance),\n  \"q3I\": () => (/* reexport */ World),\n  \"Pab\": () => (/* reexport */ canonicalizeAngle),\n  \"uZ5\": () => (/* reexport */ clamp),\n  \"McK\": () => (/* reexport */ createId),\n  \"F9c\": () => (/* reexport */ frac),\n  \"k0b\": () => (/* reexport */ hasGraphicsTick),\n  \"hnT\": () => (/* reexport */ hasOnInitialize),\n  \"RSJ\": () => (/* reexport */ hasOnPostUpdate),\n  \"Mku\": () => (/* reexport */ hasOnPreUpdate),\n  \"h90\": () => (/* reexport */ hasPostDraw),\n  \"rms\": () => (/* reexport */ hasPreDraw),\n  \"ErP\": () => (/* reexport */ has_initialize),\n  \"aVg\": () => (/* reexport */ has_postupdate),\n  \"lPc\": () => (/* reexport */ has_preupdate),\n  \"Z8E\": () => (/* reexport */ isAddedComponent),\n  \"_N2\": () => (/* reexport */ isAddedSystemEntity),\n  \"yFn\": () => (/* reexport */ isRemoveSystemEntity),\n  \"lNv\": () => (/* reexport */ isRemovedComponent),\n  \"cu9\": () => (/* reexport */ isScreenElement),\n  \"MZQ\": () => (/* reexport */ maxMessages),\n  \"FUM\": () => (/* reexport */ obsolete),\n  \"BxR\": () => (/* reexport */ pixelSnapEpsilon),\n  \"vdf\": () => (/* reexport */ randomInRange),\n  \"iaL\": () => (/* reexport */ randomIntInRange),\n  \"w6H\": () => (/* reexport */ range),\n  \"Q4c\": () => (/* reexport */ resetObsoleteCounter),\n  \"Xxe\": () => (/* reexport */ sign),\n  \"Uxb\": () => (/* reexport */ toDegrees),\n  \"Yr5\": () => (/* reexport */ toRadians),\n  \"Bhw\": () => (/* reexport */ vec),\n  \"yOA\": () => (/* reexport */ webgl_util_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./Events.ts\nvar Events_namespaceObject = {};\n__webpack_require__.r(Events_namespaceObject);\n__webpack_require__.d(Events_namespaceObject, {\n  \"ActivateEvent\": () => (ActivateEvent),\n  \"CollisionEndEvent\": () => (CollisionEndEvent),\n  \"CollisionPostSolveEvent\": () => (CollisionPostSolveEvent),\n  \"CollisionPreSolveEvent\": () => (CollisionPreSolveEvent),\n  \"CollisionStartEvent\": () => (CollisionStartEvent),\n  \"ContactEndEvent\": () => (ContactEndEvent),\n  \"ContactStartEvent\": () => (ContactStartEvent),\n  \"DeactivateEvent\": () => (DeactivateEvent),\n  \"EnterTriggerEvent\": () => (EnterTriggerEvent),\n  \"EnterViewPortEvent\": () => (EnterViewPortEvent),\n  \"EventTypes\": () => (EventTypes),\n  \"ExitTriggerEvent\": () => (ExitTriggerEvent),\n  \"ExitViewPortEvent\": () => (ExitViewPortEvent),\n  \"GameEvent\": () => (GameEvent),\n  \"GameStartEvent\": () => (GameStartEvent),\n  \"GameStopEvent\": () => (GameStopEvent),\n  \"GamepadAxisEvent\": () => (GamepadAxisEvent),\n  \"GamepadButtonEvent\": () => (GamepadButtonEvent),\n  \"GamepadConnectEvent\": () => (GamepadConnectEvent),\n  \"GamepadDisconnectEvent\": () => (GamepadDisconnectEvent),\n  \"HiddenEvent\": () => (HiddenEvent),\n  \"InitializeEvent\": () => (InitializeEvent),\n  \"KillEvent\": () => (KillEvent),\n  \"PostCollisionEvent\": () => (PostCollisionEvent),\n  \"PostDebugDrawEvent\": () => (PostDebugDrawEvent),\n  \"PostDrawEvent\": () => (PostDrawEvent),\n  \"PostFrameEvent\": () => (PostFrameEvent),\n  \"PostKillEvent\": () => (PostKillEvent),\n  \"PostUpdateEvent\": () => (PostUpdateEvent),\n  \"PreCollisionEvent\": () => (PreCollisionEvent),\n  \"PreDebugDrawEvent\": () => (PreDebugDrawEvent),\n  \"PreDrawEvent\": () => (PreDrawEvent),\n  \"PreFrameEvent\": () => (PreFrameEvent),\n  \"PreKillEvent\": () => (PreKillEvent),\n  \"PreUpdateEvent\": () => (PreUpdateEvent),\n  \"VisibleEvent\": () => (VisibleEvent)\n});\n\n// NAMESPACE OBJECT: ./Graphics/Context/webgl-util.ts\nvar webgl_util_namespaceObject = {};\n__webpack_require__.r(webgl_util_namespaceObject);\n__webpack_require__.d(webgl_util_namespaceObject, {\n  \"getAttributeComponentSize\": () => (getAttributeComponentSize),\n  \"getAttributePointerType\": () => (getAttributePointerType),\n  \"getGlTypeSizeBytes\": () => (getGlTypeSizeBytes)\n});\n\n// NAMESPACE OBJECT: ./Util/DrawUtil.ts\nvar DrawUtil_namespaceObject = {};\n__webpack_require__.r(DrawUtil_namespaceObject);\n__webpack_require__.d(DrawUtil_namespaceObject, {\n  \"circle\": () => (circle),\n  \"line\": () => (line),\n  \"point\": () => (point),\n  \"roundRect\": () => (roundRect),\n  \"vector\": () => (vector)\n});\n\n// NAMESPACE OBJECT: ./Input/Index.ts\nvar Input_Index_namespaceObject = {};\n__webpack_require__.r(Input_Index_namespaceObject);\n__webpack_require__.d(Input_Index_namespaceObject, {\n  \"Axes\": () => (Axes),\n  \"Buttons\": () => (Buttons),\n  \"Gamepad\": () => (Gamepad),\n  \"Gamepads\": () => (Gamepads),\n  \"KeyEvent\": () => (KeyEvent),\n  \"Keyboard\": () => (Keyboard),\n  \"Keys\": () => (Keys),\n  \"NativePointerButton\": () => (NativePointerButton),\n  \"PointerButton\": () => (PointerButton),\n  \"PointerComponent\": () => (PointerComponent),\n  \"PointerEvent\": () => (PointerEvent),\n  \"PointerEventReceiver\": () => (PointerEventReceiver),\n  \"PointerScope\": () => (PointerScope),\n  \"PointerSystem\": () => (PointerSystem),\n  \"PointerType\": () => (PointerType),\n  \"WheelDeltaMode\": () => (WheelDeltaMode),\n  \"WheelEvent\": () => (WheelEvent)\n});\n\n// NAMESPACE OBJECT: ./Util/Index.ts\nvar Util_Index_namespaceObject = {};\n__webpack_require__.r(Util_Index_namespaceObject);\n__webpack_require__.d(Util_Index_namespaceObject, {\n  \"ConsoleAppender\": () => (ConsoleAppender),\n  \"DrawUtil\": () => (DrawUtil_namespaceObject),\n  \"EasingFunctions\": () => (EasingFunctions),\n  \"LogLevel\": () => (LogLevel),\n  \"Logger\": () => (Logger),\n  \"Observable\": () => (Observable),\n  \"ScreenAppender\": () => (ScreenAppender),\n  \"addItemToArray\": () => (addItemToArray),\n  \"contains\": () => (contains),\n  \"delay\": () => (delay),\n  \"fail\": () => (fail),\n  \"getPosition\": () => (getPosition),\n  \"removeItemFromArray\": () => (removeItemFromArray)\n});\n\n// EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js\nvar sort = __webpack_require__(4662);\n// EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js\nvar keys = __webpack_require__(8343);\n;// CONCATENATED MODULE: ./Polyfill.ts\n\r\n\r\n/**\r\n * Polyfill adding function\r\n */\r\nfunction polyfill() {\r\n    /* istanbul ignore next */\r\n    if (typeof window === 'undefined') {\r\n        window = {\r\n            audioContext: function () {\r\n                return;\r\n            }\r\n        };\r\n    }\r\n    /* istanbul ignore next */\r\n    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {\r\n        window.requestAnimationFrame =\r\n            window.webkitRequestAnimationFrame ||\r\n                window.mozRequestAnimationFrame ||\r\n                function (callback) {\r\n                    window.setInterval(callback, 1000 / 60);\r\n                };\r\n    }\r\n    /* istanbul ignore next */\r\n    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {\r\n        window.cancelAnimationFrame =\r\n            window.webkitCancelAnimationFrame ||\r\n                window.mozCancelAnimationFrame ||\r\n                function () {\r\n                    return;\r\n                };\r\n    }\r\n    /* istanbul ignore next */\r\n    if (typeof window !== 'undefined' && !window.AudioContext) {\r\n        if (window.webkitAudioContext) {\r\n            const ctx = window.webkitAudioContext;\r\n            const replaceMe = ctx.prototype.decodeAudioData;\r\n            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {\r\n                return new Promise((resolve, reject) => {\r\n                    replaceMe.call(this, arrayBuffer, resolve, reject);\r\n                });\r\n            };\r\n        }\r\n        window.AudioContext =\r\n            window.AudioContext ||\r\n                window.webkitAudioContext ||\r\n                window.mozAudioContext ||\r\n                window.msAudioContext ||\r\n                window.oAudioContext;\r\n    }\r\n    /* istanbul ignore next */\r\n    if (typeof window !== 'undefined' && !window.devicePixelRatio) {\r\n        window.devicePixelRatio = window.devicePixelRatio || 1;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Flags.ts\n/**\r\n * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**\r\n * after which they are frozen and are read-only.\r\n *\r\n * Flags are used to enable experimental or preview features in Excalibur.\r\n */\r\nclass Flags {\r\n    /**\r\n     * Force excalibur to load the Canvas 2D graphics context fallback\r\n     *\r\n     * @warning not all features of excalibur are supported in the Canvas 2D fallback\r\n     */\r\n    static useCanvasGraphicsContext() {\r\n        Flags.enable('use-canvas-context');\r\n    }\r\n    /**\r\n     * Freeze all flag modifications making them readonly\r\n     */\r\n    static freeze() {\r\n        Flags._FROZEN = true;\r\n    }\r\n    /**\r\n     * Resets internal flag state, not meant to be called by users. Only used for testing.\r\n     *\r\n     * Calling this in your game is UNSUPPORTED\r\n     * @internal\r\n     */\r\n    static _reset() {\r\n        Flags._FROZEN = false;\r\n        Flags._FLAGS = {};\r\n    }\r\n    /**\r\n     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n     * @param flagName\r\n     */\r\n    static enable(flagName) {\r\n        if (this._FROZEN) {\r\n            throw Error('Feature flags can only be enabled before Engine constructor time');\r\n        }\r\n        Flags._FLAGS[flagName] = true;\r\n    }\r\n    /**\r\n     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n     * @param flagName\r\n     */\r\n    static disable(flagName) {\r\n        if (this._FROZEN) {\r\n            throw Error('Feature flags can only be disabled before Engine constructor time');\r\n        }\r\n        Flags._FLAGS[flagName] = false;\r\n    }\r\n    /**\r\n     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned\r\n     * @param flagName\r\n     */\r\n    static isEnabled(flagName) {\r\n        return !!Flags._FLAGS[flagName];\r\n    }\r\n    /**\r\n     * Show a list of currently known flags\r\n     */\r\n    static show() {\r\n        return Object.keys(Flags._FLAGS);\r\n    }\r\n}\r\nFlags._FROZEN = false;\r\nFlags._FLAGS = {};\r\n\n;// CONCATENATED MODULE: ./Id.ts\n/**\r\n * Create a branded ID type from a number\r\n */\r\nfunction createId(type, value) {\r\n    return { type, value };\r\n}\r\n;\r\n\n;// CONCATENATED MODULE: ./Math/Random.ts\n/**\r\n * @module\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n */\r\n/**\r\n * 32-bit mask\r\n */\r\nconst BITMASK32 = 0xffffffff;\r\n/**\r\n * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n * of numbers each time it is called.\r\n * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n *\r\n * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n */\r\nclass Random {\r\n    /**\r\n     * If no seed is specified, the Date.now() is used\r\n     */\r\n    constructor(seed) {\r\n        this.seed = seed;\r\n        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\r\n        this._lowerMask = 0x7fffffff; // 31 bits same as _r\r\n        this._upperMask = 0x80000000; // 34 high bits\r\n        // Word size, 64 bits\r\n        this._w = 32;\r\n        // Degree of recurrence\r\n        this._n = 624;\r\n        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n\r\n        this._m = 397;\r\n        // coefficients of teh rational normal form twist matrix\r\n        this._a = 0x9908b0df;\r\n        // tempering bit shifts and masks\r\n        this._u = 11;\r\n        this._s = 7;\r\n        this._b = 0x9d2c5680;\r\n        this._t = 15;\r\n        this._c = 0xefc60000;\r\n        this._l = 18;\r\n        this._f = 1812433253;\r\n        this._mt = new Array(this._n);\r\n        // need to mask to support higher bit machines\r\n        this._mt[0] = (seed || Date.now()) >>> 0;\r\n        for (let i = 1; i < this._n; i++) {\r\n            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));\r\n            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits\r\n            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;\r\n        }\r\n        this._index = this._n;\r\n    }\r\n    /**\r\n     * Apply the twist\r\n     */\r\n    _twist() {\r\n        const mag01 = [0x0, this._a];\r\n        let y = 0, i = 0;\r\n        for (; i < this._n - this._m; i++) {\r\n            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n        }\r\n        for (; i < this._n - 1; i++) {\r\n            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n        }\r\n        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);\r\n        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n        this._index = 0;\r\n    }\r\n    /**\r\n     * Return next 32 bit integer number in sequence\r\n     */\r\n    nextInt() {\r\n        if (this._index >= this._n) {\r\n            this._twist();\r\n        }\r\n        let y = this._mt[this._index++];\r\n        y ^= y >>> this._u;\r\n        y ^= (y << this._s) & this._b;\r\n        y ^= (y << this._t) & this._c;\r\n        y ^= y >>> this._l;\r\n        return y >>> 0;\r\n    }\r\n    /**\r\n     * Return a random floating point number between [0, 1)\r\n     */\r\n    next() {\r\n        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\r\n    }\r\n    /**\r\n     * Return a random floating point in range [min, max) min is included, max is not included\r\n     */\r\n    floating(min, max) {\r\n        return (max - min) * this.next() + min;\r\n    }\r\n    /**\r\n     * Return a random integer in range [min, max] min is included, max is included.\r\n     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n     */\r\n    integer(min, max) {\r\n        return Math.floor((max - min + 1) * this.next() + min);\r\n    }\r\n    /**\r\n     * Returns true or false randomly with 50/50 odds by default.\r\n     * By default the likelihood of returning a true is .5 (50%).\r\n     * @param likelihood takes values between [0, 1]\r\n     */\r\n    bool(likelihood = 0.5) {\r\n        return this.next() <= likelihood;\r\n    }\r\n    /**\r\n     * Returns one element from an array at random\r\n     */\r\n    pickOne(array) {\r\n        return array[this.integer(0, array.length - 1)];\r\n    }\r\n    /**\r\n     * Returns a new array random picking elements from the original\r\n     * @param array Original array to pick from\r\n     * @param numPicks can be any positive number\r\n     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n     * just that it is possible)\r\n     */\r\n    pickSet(array, numPicks, allowDuplicates = false) {\r\n        if (allowDuplicates) {\r\n            return this._pickSetWithDuplicates(array, numPicks);\r\n        }\r\n        else {\r\n            return this._pickSetWithoutDuplicates(array, numPicks);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a new array randomly picking elements in the original (not reused)\r\n     * @param array Array to pick elements out of\r\n     * @param numPicks must be less than or equal to the number of elements in the array.\r\n     */\r\n    _pickSetWithoutDuplicates(array, numPicks) {\r\n        if (numPicks > array.length || numPicks < 0) {\r\n            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');\r\n        }\r\n        if (numPicks === array.length) {\r\n            return array;\r\n        }\r\n        const result = new Array(numPicks);\r\n        let currentPick = 0;\r\n        const tempArray = array.slice(0);\r\n        while (currentPick < numPicks) {\r\n            const index = this.integer(0, tempArray.length - 1);\r\n            result[currentPick++] = tempArray[index];\r\n            tempArray.splice(index, 1);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns a new array random picking elements from the original allowing duplicates\r\n     * @param array Array to pick elements out of\r\n     * @param numPicks can be any positive number\r\n     */\r\n    _pickSetWithDuplicates(array, numPicks) {\r\n        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\r\n        if (numPicks < 0) {\r\n            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');\r\n        }\r\n        const result = new Array(numPicks);\r\n        for (let i = 0; i < numPicks; i++) {\r\n            result[i] = this.pickOne(array);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n     */\r\n    shuffle(array) {\r\n        const tempArray = array.slice(0);\r\n        let swap = null;\r\n        for (let i = 0; i < tempArray.length - 2; i++) {\r\n            const randomIndex = this.integer(i, tempArray.length - 1);\r\n            swap = tempArray[i];\r\n            tempArray[i] = tempArray[randomIndex];\r\n            tempArray[randomIndex] = swap;\r\n        }\r\n        return tempArray;\r\n    }\r\n    /**\r\n     * Generate a list of random integer numbers\r\n     * @param length the length of the final array\r\n     * @param min the minimum integer number to generate inclusive\r\n     * @param max the maximum integer number to generate inclusive\r\n     */\r\n    range(length, min, max) {\r\n        const result = new Array(length);\r\n        for (let i = 0; i < length; i++) {\r\n            result[i] = this.integer(min, max);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns the result of a d4 dice roll\r\n     */\r\n    d4() {\r\n        return this.integer(1, 4);\r\n    }\r\n    /**\r\n     * Returns the result of a d6 dice roll\r\n     */\r\n    d6() {\r\n        return this.integer(1, 6);\r\n    }\r\n    /**\r\n     * Returns the result of a d8 dice roll\r\n     */\r\n    d8() {\r\n        return this.integer(1, 8);\r\n    }\r\n    /**\r\n     * Returns the result of a d10 dice roll\r\n     */\r\n    d10() {\r\n        return this.integer(1, 10);\r\n    }\r\n    /**\r\n     * Returns the result of a d12 dice roll\r\n     */\r\n    d12() {\r\n        return this.integer(1, 12);\r\n    }\r\n    /**\r\n     * Returns the result of a d20 dice roll\r\n     */\r\n    d20() {\r\n        return this.integer(1, 20);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/util.ts\n\r\n/**\r\n * Two PI constant\r\n */\r\nconst TwoPI = Math.PI * 2;\r\n/**\r\n * Returns the fractional part of a number\r\n * @param x\r\n */\r\nfunction frac(x) {\r\n    if (x >= 0) {\r\n        return x - Math.floor(x);\r\n    }\r\n    else {\r\n        return x - Math.ceil(x);\r\n    }\r\n}\r\n/**\r\n * Returns the sign of a number, if 0 returns 0\r\n */\r\nfunction sign(val) {\r\n    if (val === 0) {\r\n        return 0;\r\n    }\r\n    return val < 0 ? -1 : 1;\r\n}\r\n;\r\n/**\r\n * Clamps a value between a min and max inclusive\r\n */\r\nfunction clamp(val, min, max) {\r\n    return Math.min(Math.max(min, val), max);\r\n}\r\n/**\r\n * Convert an angle to be the equivalent in the range [0, 2PI]\r\n */\r\nfunction canonicalizeAngle(angle) {\r\n    let tmpAngle = angle;\r\n    if (angle > TwoPI) {\r\n        while (tmpAngle > TwoPI) {\r\n            tmpAngle -= TwoPI;\r\n        }\r\n    }\r\n    if (angle < 0) {\r\n        while (tmpAngle < 0) {\r\n            tmpAngle += TwoPI;\r\n        }\r\n    }\r\n    return tmpAngle;\r\n}\r\n/**\r\n * Convert radians to degrees\r\n */\r\nfunction toDegrees(radians) {\r\n    return (180 / Math.PI) * radians;\r\n}\r\n/**\r\n * Convert degrees to radians\r\n */\r\nfunction toRadians(degrees) {\r\n    return (degrees / 180) * Math.PI;\r\n}\r\n/**\r\n * Generate a range of numbers\r\n * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]\r\n * @param from inclusive\r\n * @param to inclusive\r\n */\r\nconst range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);\r\n/**\r\n * Find a random floating point number in range\r\n */\r\nfunction randomInRange(min, max, random = new Random()) {\r\n    return random ? random.floating(min, max) : min + Math.random() * (max - min);\r\n}\r\n/**\r\n * Find a random integer in a range\r\n */\r\nfunction randomIntInRange(min, max, random = new Random()) {\r\n    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/vector.ts\n\r\n/**\r\n * A 2D vector on a plane.\r\n */\r\nclass Vector {\r\n    /**\r\n     * @param x  X component of the Vector\r\n     * @param y  Y component of the Vector\r\n     */\r\n    constructor(x, y) {\r\n        this._x = 0;\r\n        this._y = 0;\r\n        this._x = x;\r\n        this._y = y;\r\n    }\r\n    /**\r\n     * A (0, 0) vector\r\n     */\r\n    static get Zero() {\r\n        return new Vector(0, 0);\r\n    }\r\n    /**\r\n     * A (1, 1) vector\r\n     */\r\n    static get One() {\r\n        return new Vector(1, 1);\r\n    }\r\n    /**\r\n     * A (0.5, 0.5) vector\r\n     */\r\n    static get Half() {\r\n        return new Vector(0.5, 0.5);\r\n    }\r\n    /**\r\n     * A unit vector pointing up (0, -1)\r\n     */\r\n    static get Up() {\r\n        return new Vector(0, -1);\r\n    }\r\n    /**\r\n     * A unit vector pointing down (0, 1)\r\n     */\r\n    static get Down() {\r\n        return new Vector(0, 1);\r\n    }\r\n    /**\r\n     * A unit vector pointing left (-1, 0)\r\n     */\r\n    static get Left() {\r\n        return new Vector(-1, 0);\r\n    }\r\n    /**\r\n     * A unit vector pointing right (1, 0)\r\n     */\r\n    static get Right() {\r\n        return new Vector(1, 0);\r\n    }\r\n    /**\r\n     * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n     * @param angle The angle to generate the vector\r\n     */\r\n    static fromAngle(angle) {\r\n        return new Vector(Math.cos(angle), Math.sin(angle));\r\n    }\r\n    /**\r\n     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n     */\r\n    static isValid(vec) {\r\n        if (vec === null || vec === undefined) {\r\n            return false;\r\n        }\r\n        if (isNaN(vec.x) || isNaN(vec.y)) {\r\n            return false;\r\n        }\r\n        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Calculates distance between two Vectors\r\n     * @param vec1\r\n     * @param vec2\r\n     */\r\n    static distance(vec1, vec2) {\r\n        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\r\n    }\r\n    static min(vec1, vec2) {\r\n        return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));\r\n    }\r\n    static max(vec1, vec2) {\r\n        return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));\r\n    }\r\n    /**\r\n     * Get the x component of the vector\r\n     */\r\n    get x() {\r\n        return this._x;\r\n    }\r\n    /**\r\n     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n     */\r\n    set x(val) {\r\n        this._x = val;\r\n    }\r\n    /**\r\n     * Get the y component of the vector\r\n     */\r\n    get y() {\r\n        return this._y;\r\n    }\r\n    /**\r\n     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n     */\r\n    set y(val) {\r\n        this._y = val;\r\n    }\r\n    /**\r\n     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n     *\r\n     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**\r\n     */\r\n    setTo(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    /**\r\n     * Compares this point against another and tests for equality\r\n     * @param vector The other point to compare to\r\n     * @param tolerance Amount of euclidean distance off we are willing to tolerate\r\n     */\r\n    equals(vector, tolerance = 0.001) {\r\n        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\r\n    }\r\n    /**\r\n     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n     * @param v  The other vector. Leave blank to use origin vector.\r\n     */\r\n    distance(v) {\r\n        if (!v) {\r\n            return Math.sqrt(this.x * this.x + this.y * this.y);\r\n        }\r\n        const deltaX = this.x - v.x;\r\n        const deltaY = this.y - v.y;\r\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n    }\r\n    squareDistance(v) {\r\n        if (!v) {\r\n            v = Vector.Zero;\r\n        }\r\n        const deltaX = this.x - v.x;\r\n        const deltaY = this.y - v.y;\r\n        return deltaX * deltaX + deltaY * deltaY;\r\n    }\r\n    /**\r\n     * Clamps the current vector's magnitude mutating it\r\n     * @param magnitude\r\n     */\r\n    clampMagnitude(magnitude) {\r\n        const size = this.size;\r\n        const newSize = clamp(size, 0, magnitude);\r\n        this.size = newSize;\r\n        return this;\r\n    }\r\n    /**\r\n     * The size (magnitude) of the Vector\r\n     */\r\n    get size() {\r\n        return this.distance();\r\n    }\r\n    /**\r\n     * Setting the size mutates the current vector\r\n     *\r\n     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**\r\n     */\r\n    set size(newLength) {\r\n        const v = this.normalize().scale(newLength);\r\n        this.setTo(v.x, v.y);\r\n    }\r\n    /**\r\n     * Normalizes a vector to have a magnitude of 1.\r\n     */\r\n    normalize() {\r\n        const d = this.distance();\r\n        if (d > 0) {\r\n            return new Vector(this.x / d, this.y / d);\r\n        }\r\n        else {\r\n            return new Vector(0, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the average (midpoint) between the current point and the specified\r\n     */\r\n    average(vec) {\r\n        return this.add(vec).scale(0.5);\r\n    }\r\n    scale(sizeOrScale, dest) {\r\n        const result = dest || new Vector(0, 0);\r\n        if (sizeOrScale instanceof Vector) {\r\n            result.x = this.x * sizeOrScale.x;\r\n            result.y = this.y * sizeOrScale.y;\r\n        }\r\n        else {\r\n            result.x = this.x * sizeOrScale;\r\n            result.y = this.y * sizeOrScale;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Adds one vector to another\r\n     * @param v The vector to add\r\n     * @param dest Optionally copy the result into a provided vector\r\n     */\r\n    add(v, dest) {\r\n        if (dest) {\r\n            dest.x = this.x + v.x;\r\n            dest.y = this.y + v.y;\r\n            return dest;\r\n        }\r\n        return new Vector(this.x + v.x, this.y + v.y);\r\n    }\r\n    /**\r\n     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B\r\n     * @param v The vector to subtract\r\n     */\r\n    sub(v) {\r\n        return new Vector(this.x - v.x, this.y - v.y);\r\n    }\r\n    /**\r\n     * Adds one vector to this one modifying the original\r\n     * @param v The vector to add\r\n     * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n     */\r\n    addEqual(v) {\r\n        this.setTo(this.x + v.x, this.y + v.y);\r\n        return this;\r\n    }\r\n    /**\r\n     * Subtracts a vector from this one modifying the original\r\n     * @param v The vector to subtract\r\n     * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n     */\r\n    subEqual(v) {\r\n        this.setTo(this.x - v.x, this.y - v.y);\r\n        return this;\r\n    }\r\n    /**\r\n     * Scales this vector by a factor of size and modifies the original\r\n     * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n     */\r\n    scaleEqual(size) {\r\n        this.setTo(this.x * size, this.y * size);\r\n        return this;\r\n    }\r\n    /**\r\n     * Performs a dot product with another vector\r\n     * @param v  The vector to dot\r\n     */\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y;\r\n    }\r\n    cross(v) {\r\n        if (v instanceof Vector) {\r\n            return this.x * v.y - this.y * v.x;\r\n        }\r\n        else if (typeof v === 'number') {\r\n            return new Vector(v * this.y, -v * this.x);\r\n        }\r\n    }\r\n    static cross(num, vec) {\r\n        return new Vector(-num * vec.y, num * vec.x);\r\n    }\r\n    /**\r\n     * Returns the perpendicular vector to this one\r\n     */\r\n    perpendicular() {\r\n        return new Vector(this.y, -this.x);\r\n    }\r\n    /**\r\n     * Returns the normal vector to this one, same as the perpendicular of length 1\r\n     */\r\n    normal() {\r\n        return this.perpendicular().normalize();\r\n    }\r\n    /**\r\n     * Negate the current vector\r\n     */\r\n    negate() {\r\n        return this.scale(-1);\r\n    }\r\n    /**\r\n     * Returns the angle of this vector.\r\n     */\r\n    toAngle() {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n    /**\r\n     * Rotates the current vector around a point by a certain number of\r\n     * degrees in radians\r\n     */\r\n    rotate(angle, anchor) {\r\n        if (!anchor) {\r\n            anchor = new Vector(0, 0);\r\n        }\r\n        const sinAngle = Math.sin(angle);\r\n        const cosAngle = Math.cos(angle);\r\n        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n        return new Vector(x, y);\r\n    }\r\n    /**\r\n     * Creates new vector that has the same values as the previous.\r\n     */\r\n    clone(dest) {\r\n        const v = dest !== null && dest !== void 0 ? dest : new Vector(0, 0);\r\n        v.x = this.x;\r\n        v.y = this.y;\r\n        return v;\r\n    }\r\n    /**\r\n     * Returns a string representation of the vector.\r\n     */\r\n    toString(fixed) {\r\n        if (fixed) {\r\n            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;\r\n        }\r\n        return `(${this.x}, ${this.y})`;\r\n    }\r\n}\r\n/**\r\n * Shorthand for creating new Vectors - returns a new Vector instance with the\r\n * provided X and Y components.\r\n *\r\n * @param x  X component of the Vector\r\n * @param y  Y component of the Vector\r\n */\r\nfunction vec(x, y) {\r\n    return new Vector(x, y);\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Log.ts\n/* eslint-disable no-console */\r\n/**\r\n * Logging level that Excalibur will tag\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"Debug\"] = 0] = \"Debug\";\r\n    LogLevel[LogLevel[\"Info\"] = 1] = \"Info\";\r\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n    LogLevel[LogLevel[\"Fatal\"] = 4] = \"Fatal\";\r\n})(LogLevel || (LogLevel = {}));\r\n/**\r\n * Static singleton that represents the logging facility for Excalibur.\r\n * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n * Derive from [[Appender]] to create your own logging appenders.\r\n */\r\nclass Logger {\r\n    constructor() {\r\n        this._appenders = [];\r\n        /**\r\n         * Gets or sets the default logging level. Excalibur will only log\r\n         * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n         */\r\n        this.defaultLevel = LogLevel.Info;\r\n        if (Logger._INSTANCE) {\r\n            throw new Error('Logger is a singleton');\r\n        }\r\n        Logger._INSTANCE = this;\r\n        // Default console appender\r\n        Logger._INSTANCE.addAppender(new ConsoleAppender());\r\n        return Logger._INSTANCE;\r\n    }\r\n    /**\r\n     * Gets the current static instance of Logger\r\n     */\r\n    static getInstance() {\r\n        if (Logger._INSTANCE == null) {\r\n            Logger._INSTANCE = new Logger();\r\n        }\r\n        return Logger._INSTANCE;\r\n    }\r\n    /**\r\n     * Adds a new [[Appender]] to the list of appenders to write to\r\n     */\r\n    addAppender(appender) {\r\n        this._appenders.push(appender);\r\n    }\r\n    /**\r\n     * Clears all appenders from the logger\r\n     */\r\n    clearAppenders() {\r\n        this._appenders.length = 0;\r\n    }\r\n    /**\r\n     * Logs a message at a given LogLevel\r\n     * @param level  The LogLevel`to log the message at\r\n     * @param args   An array of arguments to write to an appender\r\n     */\r\n    _log(level, args) {\r\n        if (level == null) {\r\n            level = this.defaultLevel;\r\n        }\r\n        const len = this._appenders.length;\r\n        for (let i = 0; i < len; i++) {\r\n            if (level >= this.defaultLevel) {\r\n                this._appenders[i].log(level, args);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Writes a log message at the [[LogLevel.Debug]] level\r\n     * @param args  Accepts any number of arguments\r\n     */\r\n    debug(...args) {\r\n        this._log(LogLevel.Debug, args);\r\n    }\r\n    /**\r\n     * Writes a log message at the [[LogLevel.Info]] level\r\n     * @param args  Accepts any number of arguments\r\n     */\r\n    info(...args) {\r\n        this._log(LogLevel.Info, args);\r\n    }\r\n    /**\r\n     * Writes a log message at the [[LogLevel.Warn]] level\r\n     * @param args  Accepts any number of arguments\r\n     */\r\n    warn(...args) {\r\n        this._log(LogLevel.Warn, args);\r\n    }\r\n    /**\r\n     * Writes a log message at the [[LogLevel.Error]] level\r\n     * @param args  Accepts any number of arguments\r\n     */\r\n    error(...args) {\r\n        this._log(LogLevel.Error, args);\r\n    }\r\n    /**\r\n     * Writes a log message at the [[LogLevel.Fatal]] level\r\n     * @param args  Accepts any number of arguments\r\n     */\r\n    fatal(...args) {\r\n        this._log(LogLevel.Fatal, args);\r\n    }\r\n}\r\nLogger._INSTANCE = null;\r\n/**\r\n * Console appender for browsers (i.e. `console.log`)\r\n */\r\nclass ConsoleAppender {\r\n    /**\r\n     * Logs a message at the given [[LogLevel]]\r\n     * @param level  Level to log at\r\n     * @param args   Arguments to log\r\n     */\r\n    log(level, args) {\r\n        // Check for console support\r\n        if (!console && !console.log && console.warn && console.error) {\r\n            // todo maybe do something better than nothing\r\n            return;\r\n        }\r\n        // Create a new console args array\r\n        const consoleArgs = [];\r\n        consoleArgs.unshift.apply(consoleArgs, args);\r\n        consoleArgs.unshift('[' + LogLevel[level] + '] : ');\r\n        if (level < LogLevel.Warn) {\r\n            // Call .log for Debug/Info\r\n            if (console.log.apply) {\r\n                // this is required on some older browsers that don't support apply on console.log :(\r\n                console.log.apply(console, consoleArgs);\r\n            }\r\n            else {\r\n                console.log(consoleArgs.join(' '));\r\n            }\r\n        }\r\n        else if (level < LogLevel.Error) {\r\n            // Call .warn for Warn\r\n            if (console.warn.apply) {\r\n                console.warn.apply(console, consoleArgs);\r\n            }\r\n            else {\r\n                console.warn(consoleArgs.join(' '));\r\n            }\r\n        }\r\n        else {\r\n            // Call .error for Error/Fatal\r\n            if (console.error.apply) {\r\n                console.error.apply(console, consoleArgs);\r\n            }\r\n            else {\r\n                console.error(consoleArgs.join(' '));\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * On-screen (canvas) appender\r\n */\r\nclass ScreenAppender {\r\n    /**\r\n     * @param width   Width of the screen appender in pixels\r\n     * @param height  Height of the screen appender in pixels\r\n     */\r\n    constructor(width, height) {\r\n        // @todo Clean this up\r\n        this._messages = [];\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.width = width || window.innerWidth;\r\n        this._canvas.height = height || window.innerHeight;\r\n        this._canvas.style.position = 'absolute';\r\n        // eslint-disable-next-line\r\n        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line\r\n        document.body.appendChild(this._canvas);\r\n    }\r\n    /**\r\n     * Logs a message at the given [[LogLevel]]\r\n     * @param level  Level to log at\r\n     * @param args   Arguments to log\r\n     */\r\n    log(level, args) {\r\n        const message = args.join(',');\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);\r\n        let pos = 10;\r\n        let opacity = 1.0;\r\n        for (let i = 0; i < this._messages.length; i++) {\r\n            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';\r\n            this._ctx.fillText(this._messages[i], 200, pos);\r\n            pos += 10;\r\n            opacity = opacity > 0 ? opacity - 0.05 : 0;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Color.ts\n/**\r\n * Provides standard colors (e.g. [[Color.Black]])\r\n * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n */\r\nclass Color {\r\n    /**\r\n     * Creates a new instance of Color from an r, g, b, a\r\n     *\r\n     * @param r  The red component of color (0-255)\r\n     * @param g  The green component of color (0-255)\r\n     * @param b  The blue component of color (0-255)\r\n     * @param a  The alpha component of color (0-1.0)\r\n     */\r\n    constructor(r, g, b, a) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a != null ? a : 1;\r\n    }\r\n    /**\r\n     * Creates a new instance of Color from an r, g, b, a\r\n     *\r\n     * @param r  The red component of color (0-255)\r\n     * @param g  The green component of color (0-255)\r\n     * @param b  The blue component of color (0-255)\r\n     * @param a  The alpha component of color (0-1.0)\r\n     */\r\n    static fromRGB(r, g, b, a) {\r\n        return new Color(r, g, b, a);\r\n    }\r\n    /**\r\n     * Creates a new instance of Color from a rgb string\r\n     *\r\n     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)\r\n     */\r\n    static fromRGBString(string) {\r\n        const rgbaRegEx = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/i;\r\n        let match = null;\r\n        if ((match = string.match(rgbaRegEx))) {\r\n            const r = parseInt(match[1], 10);\r\n            const g = parseInt(match[2], 10);\r\n            const b = parseInt(match[3], 10);\r\n            let a = 1;\r\n            if (match[4]) {\r\n                a = parseFloat(match[4]);\r\n            }\r\n            return new Color(r, g, b, a);\r\n        }\r\n        else {\r\n            throw new Error('Invalid rgb/a string: ' + string);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new instance of Color from a hex string\r\n     *\r\n     * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n     */\r\n    static fromHex(hex) {\r\n        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\r\n        let match = null;\r\n        if ((match = hex.match(hexRegEx))) {\r\n            const r = parseInt(match[1], 16);\r\n            const g = parseInt(match[2], 16);\r\n            const b = parseInt(match[3], 16);\r\n            let a = 1;\r\n            if (match[4]) {\r\n                a = parseInt(match[4], 16) / 255;\r\n            }\r\n            return new Color(r, g, b, a);\r\n        }\r\n        else {\r\n            throw new Error('Invalid hex string: ' + hex);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new instance of Color from hsla values\r\n     *\r\n     * @param h  Hue is represented [0-1]\r\n     * @param s  Saturation is represented [0-1]\r\n     * @param l  Luminance is represented [0-1]\r\n     * @param a  Alpha is represented [0-1]\r\n     */\r\n    static fromHSL(h, s, l, a = 1.0) {\r\n        const temp = new HSLColor(h, s, l, a);\r\n        return temp.toRGBA();\r\n    }\r\n    /**\r\n     * Lightens the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to lighten by [0-1]\r\n     */\r\n    lighten(factor = 0.1) {\r\n        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n        temp.l += (1 - temp.l) * factor;\r\n        return temp.toRGBA();\r\n    }\r\n    /**\r\n     * Darkens the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to darken by [0-1]\r\n     */\r\n    darken(factor = 0.1) {\r\n        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n        temp.l -= temp.l * factor;\r\n        return temp.toRGBA();\r\n    }\r\n    /**\r\n     * Saturates the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to saturate by [0-1]\r\n     */\r\n    saturate(factor = 0.1) {\r\n        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n        temp.s += temp.s * factor;\r\n        return temp.toRGBA();\r\n    }\r\n    /**\r\n     * Desaturates the current color by a specified amount\r\n     *\r\n     * @param factor  The amount to desaturate by [0-1]\r\n     */\r\n    desaturate(factor = 0.1) {\r\n        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n        temp.s -= temp.s * factor;\r\n        return temp.toRGBA();\r\n    }\r\n    /**\r\n     * Multiplies a color by another, results in a darker color\r\n     *\r\n     * @param color  The other color\r\n     */\r\n    multiply(color) {\r\n        const newR = (((color.r / 255) * this.r) / 255) * 255;\r\n        const newG = (((color.g / 255) * this.g) / 255) * 255;\r\n        const newB = (((color.b / 255) * this.b) / 255) * 255;\r\n        const newA = color.a * this.a;\r\n        return new Color(newR, newG, newB, newA);\r\n    }\r\n    /**\r\n     * Screens a color by another, results in a lighter color\r\n     *\r\n     * @param color  The other color\r\n     */\r\n    screen(color) {\r\n        const color1 = color.invert();\r\n        const color2 = color.invert();\r\n        return color1.multiply(color2).invert();\r\n    }\r\n    /**\r\n     * Inverts the current color\r\n     */\r\n    invert() {\r\n        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\r\n    }\r\n    /**\r\n     * Averages the current color with another\r\n     *\r\n     * @param color  The other color\r\n     */\r\n    average(color) {\r\n        const newR = (color.r + this.r) / 2;\r\n        const newG = (color.g + this.g) / 2;\r\n        const newB = (color.b + this.b) / 2;\r\n        const newA = (color.a + this.a) / 2;\r\n        return new Color(newR, newG, newB, newA);\r\n    }\r\n    equal(color) {\r\n        return this.toString() === color.toString();\r\n    }\r\n    /**\r\n     * Returns a CSS string representation of a color.\r\n     *\r\n     * @param format Color representation, accepts: rgb, hsl, or hex\r\n     */\r\n    toString(format = 'rgb') {\r\n        switch (format) {\r\n            case 'rgb':\r\n                return this.toRGBA();\r\n            case 'hsl':\r\n                return this.toHSLA();\r\n            case 'hex':\r\n                return this.toHex();\r\n            default:\r\n                throw new Error('Invalid Color format');\r\n        }\r\n    }\r\n    /**\r\n     * Returns Hex Value of a color component\r\n     * @param c color component\r\n     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n     */\r\n    _componentToHex(c) {\r\n        const hex = c.toString(16);\r\n        return hex.length === 1 ? '0' + hex : hex;\r\n    }\r\n    /**\r\n     * Return Hex representation of a color.\r\n     */\r\n    toHex() {\r\n        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\r\n    }\r\n    /**\r\n     * Return RGBA representation of a color.\r\n     */\r\n    toRGBA() {\r\n        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));\r\n        if (this.a !== undefined || this.a !== null) {\r\n            return 'rgba(' + result + ', ' + String(this.a) + ')';\r\n        }\r\n        return 'rgb(' + result + ')';\r\n    }\r\n    /**\r\n     * Return HSLA representation of a color.\r\n     */\r\n    toHSLA() {\r\n        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\r\n    }\r\n    /**\r\n     * Returns a CSS string representation of a color.\r\n     */\r\n    fillStyle() {\r\n        return this.toString();\r\n    }\r\n    /**\r\n     * Returns a clone of the current color.\r\n     */\r\n    clone() {\r\n        return new Color(this.r, this.g, this.b, this.a);\r\n    }\r\n    /**\r\n     * Black (#000000)\r\n     */\r\n    static get Black() {\r\n        return Color.fromHex('#000000');\r\n    }\r\n    /**\r\n     * White (#FFFFFF)\r\n     */\r\n    static get White() {\r\n        return Color.fromHex('#FFFFFF');\r\n    }\r\n    /**\r\n     * Gray (#808080)\r\n     */\r\n    static get Gray() {\r\n        return Color.fromHex('#808080');\r\n    }\r\n    /**\r\n     * Light gray (#D3D3D3)\r\n     */\r\n    static get LightGray() {\r\n        return Color.fromHex('#D3D3D3');\r\n    }\r\n    /**\r\n     * Dark gray (#A9A9A9)\r\n     */\r\n    static get DarkGray() {\r\n        return Color.fromHex('#A9A9A9');\r\n    }\r\n    /**\r\n     * Yellow (#FFFF00)\r\n     */\r\n    static get Yellow() {\r\n        return Color.fromHex('#FFFF00');\r\n    }\r\n    /**\r\n     * Orange (#FFA500)\r\n     */\r\n    static get Orange() {\r\n        return Color.fromHex('#FFA500');\r\n    }\r\n    /**\r\n     * Red (#FF0000)\r\n     */\r\n    static get Red() {\r\n        return Color.fromHex('#FF0000');\r\n    }\r\n    /**\r\n     * Vermilion (#FF5B31)\r\n     */\r\n    static get Vermilion() {\r\n        return Color.fromHex('#FF5B31');\r\n    }\r\n    /**\r\n     * Rose (#FF007F)\r\n     */\r\n    static get Rose() {\r\n        return Color.fromHex('#FF007F');\r\n    }\r\n    /**\r\n     * Magenta (#FF00FF)\r\n     */\r\n    static get Magenta() {\r\n        return Color.fromHex('#FF00FF');\r\n    }\r\n    /**\r\n     * Violet (#7F00FF)\r\n     */\r\n    static get Violet() {\r\n        return Color.fromHex('#7F00FF');\r\n    }\r\n    /**\r\n     * Blue (#0000FF)\r\n     */\r\n    static get Blue() {\r\n        return Color.fromHex('#0000FF');\r\n    }\r\n    /**\r\n     * Azure (#007FFF)\r\n     */\r\n    static get Azure() {\r\n        return Color.fromHex('#007FFF');\r\n    }\r\n    /**\r\n     * Cyan (#00FFFF)\r\n     */\r\n    static get Cyan() {\r\n        return Color.fromHex('#00FFFF');\r\n    }\r\n    /**\r\n     * Viridian (#59978F)\r\n     */\r\n    static get Viridian() {\r\n        return Color.fromHex('#59978F');\r\n    }\r\n    /**\r\n     * Green (#00FF00)\r\n     */\r\n    static get Green() {\r\n        return Color.fromHex('#00FF00');\r\n    }\r\n    /**\r\n     * Chartreuse (#7FFF00)\r\n     */\r\n    static get Chartreuse() {\r\n        return Color.fromHex('#7FFF00');\r\n    }\r\n    /**\r\n     * Transparent (#FFFFFF00)\r\n     */\r\n    static get Transparent() {\r\n        return Color.fromHex('#FFFFFF00');\r\n    }\r\n    /**\r\n     * ExcaliburBlue (#176BAA)\r\n     */\r\n    static get ExcaliburBlue() {\r\n        return Color.fromHex('#176BAA');\r\n    }\r\n}\r\n/**\r\n * Internal HSL Color representation\r\n *\r\n * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n */\r\nclass HSLColor {\r\n    constructor(h, s, l, a) {\r\n        this.h = h;\r\n        this.s = s;\r\n        this.l = l;\r\n        this.a = a;\r\n    }\r\n    static hue2rgb(p, q, t) {\r\n        if (t < 0) {\r\n            t += 1;\r\n        }\r\n        if (t > 1) {\r\n            t -= 1;\r\n        }\r\n        if (t < 1 / 6) {\r\n            return p + (q - p) * 6 * t;\r\n        }\r\n        if (t < 1 / 2) {\r\n            return q;\r\n        }\r\n        if (t < 2 / 3) {\r\n            return p + (q - p) * (2 / 3 - t) * 6;\r\n        }\r\n        return p;\r\n    }\r\n    static fromRGBA(r, g, b, a) {\r\n        r /= 255;\r\n        g /= 255;\r\n        b /= 255;\r\n        const max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n        let h, s;\r\n        const l = (max + min) / 2;\r\n        if (max === min) {\r\n            h = s = 0; // achromatic\r\n        }\r\n        else {\r\n            const d = max - min;\r\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n            switch (max) {\r\n                case r:\r\n                    h = (g - b) / d + (g < b ? 6 : 0);\r\n                    break;\r\n                case g:\r\n                    h = (b - r) / d + 2;\r\n                    break;\r\n                case b:\r\n                    h = (r - g) / d + 4;\r\n                    break;\r\n            }\r\n            h /= 6;\r\n        }\r\n        return new HSLColor(h, s, l, a);\r\n    }\r\n    toRGBA() {\r\n        let r, g, b;\r\n        if (this.s === 0) {\r\n            r = g = b = this.l; // achromatic\r\n        }\r\n        else {\r\n            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\r\n            const p = 2 * this.l - q;\r\n            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\r\n            g = HSLColor.hue2rgb(p, q, this.h);\r\n            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\r\n        }\r\n        return new Color(r * 255, g * 255, b * 255, this.a);\r\n    }\r\n    toString() {\r\n        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);\r\n        return `hsla(${h}, ${s}, ${l}, ${a})`;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Side.ts\n\r\n/**\r\n * An enum that describes the sides of an axis aligned box for collision\r\n */\r\nvar Side;\r\n(function (Side) {\r\n    Side[\"None\"] = \"None\";\r\n    Side[\"Top\"] = \"Top\";\r\n    Side[\"Bottom\"] = \"Bottom\";\r\n    Side[\"Left\"] = \"Left\";\r\n    Side[\"Right\"] = \"Right\";\r\n})(Side || (Side = {}));\r\n(function (Side) {\r\n    /**\r\n     * Returns the opposite side from the current\r\n     */\r\n    function getOpposite(side) {\r\n        if (side === Side.Top) {\r\n            return Side.Bottom;\r\n        }\r\n        if (side === Side.Bottom) {\r\n            return Side.Top;\r\n        }\r\n        if (side === Side.Left) {\r\n            return Side.Right;\r\n        }\r\n        if (side === Side.Right) {\r\n            return Side.Left;\r\n        }\r\n        return Side.None;\r\n    }\r\n    Side.getOpposite = getOpposite;\r\n    /**\r\n     * Given a vector, return the Side most in that direction (via dot product)\r\n     */\r\n    function fromDirection(direction) {\r\n        const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];\r\n        const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];\r\n        let max = -Number.MAX_VALUE;\r\n        let maxIndex = -1;\r\n        for (let i = 0; i < directions.length; i++) {\r\n            if (directions[i].dot(direction) > max) {\r\n                max = directions[i].dot(direction);\r\n                maxIndex = i;\r\n            }\r\n        }\r\n        return directionEnum[maxIndex];\r\n    }\r\n    Side.fromDirection = fromDirection;\r\n})(Side || (Side = {}));\r\n\n;// CONCATENATED MODULE: ./Collision/BoundingBox.ts\n\r\n\r\n\r\n/**\r\n * Axis Aligned collision primitive for Excalibur.\r\n */\r\nclass BoundingBox {\r\n    /**\r\n     * Constructor allows passing of either an object with all coordinate components,\r\n     * or the coordinate components passed separately.\r\n     * @param leftOrOptions    Either x coordinate of the left edge or an options object\r\n     * containing the four coordinate components.\r\n     * @param top     y coordinate of the top edge\r\n     * @param right   x coordinate of the right edge\r\n     * @param bottom  y coordinate of the bottom edge\r\n     */\r\n    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {\r\n        if (typeof leftOrOptions === 'object') {\r\n            this.left = leftOrOptions.left;\r\n            this.top = leftOrOptions.top;\r\n            this.right = leftOrOptions.right;\r\n            this.bottom = leftOrOptions.bottom;\r\n        }\r\n        else if (typeof leftOrOptions === 'number') {\r\n            this.left = leftOrOptions;\r\n            this.top = top;\r\n            this.right = right;\r\n            this.bottom = bottom;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a new instance of [[BoundingBox]] that is a copy of the current instance\r\n     */\r\n    clone() {\r\n        return new BoundingBox(this.left, this.top, this.right, this.bottom);\r\n    }\r\n    /**\r\n     * Given bounding box A & B, returns the side relative to A when intersection is performed.\r\n     * @param intersection Intersection vector between 2 bounding boxes\r\n     */\r\n    static getSideFromIntersection(intersection) {\r\n        if (!intersection) {\r\n            return Side.None;\r\n        }\r\n        if (intersection) {\r\n            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\r\n                if (intersection.x < 0) {\r\n                    return Side.Right;\r\n                }\r\n                return Side.Left;\r\n            }\r\n            else {\r\n                if (intersection.y < 0) {\r\n                    return Side.Bottom;\r\n                }\r\n                return Side.Top;\r\n            }\r\n        }\r\n        return Side.None;\r\n    }\r\n    static fromPoints(points) {\r\n        let minX = Infinity;\r\n        let minY = Infinity;\r\n        let maxX = -Infinity;\r\n        let maxY = -Infinity;\r\n        for (let i = 0; i < points.length; i++) {\r\n            if (points[i].x < minX) {\r\n                minX = points[i].x;\r\n            }\r\n            if (points[i].x > maxX) {\r\n                maxX = points[i].x;\r\n            }\r\n            if (points[i].y < minY) {\r\n                minY = points[i].y;\r\n            }\r\n            if (points[i].y > maxY) {\r\n                maxY = points[i].y;\r\n            }\r\n        }\r\n        return new BoundingBox(minX, minY, maxX, maxY);\r\n    }\r\n    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {\r\n        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);\r\n    }\r\n    /**\r\n     * Returns the calculated width of the bounding box\r\n     */\r\n    get width() {\r\n        return this.right - this.left;\r\n    }\r\n    /**\r\n     * Returns the calculated height of the bounding box\r\n     */\r\n    get height() {\r\n        return this.bottom - this.top;\r\n    }\r\n    /**\r\n     * Return whether the bounding box has zero dimensions in height,width or both\r\n     */\r\n    hasZeroDimensions() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n    /**\r\n     * Returns the center of the bounding box\r\n     */\r\n    get center() {\r\n        return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n    }\r\n    translate(pos) {\r\n        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);\r\n    }\r\n    /**\r\n     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding\r\n     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.\r\n     */\r\n    rotate(angle, point = Vector.Zero) {\r\n        const points = this.getPoints().map((p) => p.rotate(angle, point));\r\n        return BoundingBox.fromPoints(points);\r\n    }\r\n    /**\r\n     * Scale a bounding box by a scale factor, optionally provide a point\r\n     * @param scale\r\n     * @param point\r\n     */\r\n    scale(scale, point = Vector.Zero) {\r\n        const shifted = this.translate(point);\r\n        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);\r\n    }\r\n    /**\r\n     * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box\r\n     * @param matrix\r\n     */\r\n    transform(matrix) {\r\n        // inlined these calculations to not use vectors would speed it up slightly\r\n        // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);\r\n        // const xa = matFirstColumn.scale(this.left);\r\n        const xa1 = matrix.data[0] * this.left;\r\n        const xa2 = matrix.data[1] * this.left;\r\n        // const xb = matFirstColumn.scale(this.right);\r\n        const xb1 = matrix.data[0] * this.right;\r\n        const xb2 = matrix.data[1] * this.right;\r\n        // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);\r\n        // const ya = matSecondColumn.scale(this.top);\r\n        const ya1 = matrix.data[2] * this.top;\r\n        const ya2 = matrix.data[3] * this.top;\r\n        // const yb = matSecondColumn.scale(this.bottom);\r\n        const yb1 = matrix.data[2] * this.bottom;\r\n        const yb2 = matrix.data[3] * this.bottom;\r\n        const matrixPos = matrix.getPosition();\r\n        // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);\r\n        // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);\r\n        const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;\r\n        const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;\r\n        const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;\r\n        const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;\r\n        return new BoundingBox({\r\n            left,\r\n            top,\r\n            right,\r\n            bottom //: bottomRight.y\r\n        });\r\n    }\r\n    /**\r\n     * Returns the perimeter of the bounding box\r\n     */\r\n    getPerimeter() {\r\n        const wx = this.width;\r\n        const wy = this.height;\r\n        return 2 * (wx + wy);\r\n    }\r\n    getPoints() {\r\n        const results = [];\r\n        results.push(new Vector(this.left, this.top));\r\n        results.push(new Vector(this.right, this.top));\r\n        results.push(new Vector(this.right, this.bottom));\r\n        results.push(new Vector(this.left, this.bottom));\r\n        return results;\r\n    }\r\n    /**\r\n     * Determines whether a ray intersects with a bounding box\r\n     */\r\n    rayCast(ray, farClipDistance = Infinity) {\r\n        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n        let tmin = -Infinity;\r\n        let tmax = +Infinity;\r\n        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n        const tx1 = (this.left - ray.pos.x) * xinv;\r\n        const tx2 = (this.right - ray.pos.x) * xinv;\r\n        tmin = Math.min(tx1, tx2);\r\n        tmax = Math.max(tx1, tx2);\r\n        const ty1 = (this.top - ray.pos.y) * yinv;\r\n        const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n        tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n        tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\r\n    }\r\n    rayCastTime(ray, farClipDistance = Infinity) {\r\n        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n        let tmin = -Infinity;\r\n        let tmax = +Infinity;\r\n        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n        const tx1 = (this.left - ray.pos.x) * xinv;\r\n        const tx2 = (this.right - ray.pos.x) * xinv;\r\n        tmin = Math.min(tx1, tx2);\r\n        tmax = Math.max(tx1, tx2);\r\n        const ty1 = (this.top - ray.pos.y) * yinv;\r\n        const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n        tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n        tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {\r\n            return tmin;\r\n        }\r\n        return -1;\r\n    }\r\n    contains(val) {\r\n        if (val instanceof Vector) {\r\n            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;\r\n        }\r\n        else if (val instanceof BoundingBox) {\r\n            if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Combines this bounding box and another together returning a new bounding box\r\n     * @param other  The bounding box to combine\r\n     */\r\n    combine(other) {\r\n        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));\r\n        return compositeBB;\r\n    }\r\n    get dimensions() {\r\n        return new Vector(this.width, this.height);\r\n    }\r\n    /**\r\n     * Returns true if the bounding boxes overlap.\r\n     * @param other\r\n     * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.\r\n     * This epsilon is useful in stable collision simulations.\r\n     */\r\n    overlaps(other, epsilon) {\r\n        const e = epsilon || 0;\r\n        if (other.hasZeroDimensions()) {\r\n            return this.contains(other);\r\n        }\r\n        if (this.hasZeroDimensions()) {\r\n            return other.contains(this);\r\n        }\r\n        const totalBoundingBox = this.combine(other);\r\n        return totalBoundingBox.width + e < other.width + this.width &&\r\n            totalBoundingBox.height + e < other.height + this.height;\r\n    }\r\n    /**\r\n     * Test wether this bounding box intersects with another returning\r\n     * the intersection vector that can be used to resolve the collision. If there\r\n     * is no intersection null is returned.\r\n     *\r\n     * @param other  Other [[BoundingBox]] to test intersection with\r\n     * @returns A Vector in the direction of the current BoundingBox, this <- other\r\n     */\r\n    intersect(other) {\r\n        const totalBoundingBox = this.combine(other);\r\n        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision\r\n        if (totalBoundingBox.width < other.width + this.width &&\r\n            totalBoundingBox.height < other.height + this.height &&\r\n            !totalBoundingBox.dimensions.equals(other.dimensions) &&\r\n            !totalBoundingBox.dimensions.equals(this.dimensions)) {\r\n            // collision\r\n            let overlapX = 0;\r\n            // right edge is between the other's left and right edge\r\n            /**\r\n             *     +-this-+\r\n             *     |      |\r\n             *     |    +-other-+\r\n             *     +----|-+     |\r\n             *          |       |\r\n             *          +-------+\r\n             *         <---\r\n             *          ^ overlap\r\n             */\r\n            if (this.right >= other.left && this.right <= other.right) {\r\n                overlapX = other.left - this.right;\r\n                // right edge is past the other's right edge\r\n                /**\r\n                 *     +-other-+\r\n                 *     |       |\r\n                 *     |    +-this-+\r\n                 *     +----|--+   |\r\n                 *          |      |\r\n                 *          +------+\r\n                 *          --->\r\n                 *          ^ overlap\r\n                 */\r\n            }\r\n            else {\r\n                overlapX = other.right - this.left;\r\n            }\r\n            let overlapY = 0;\r\n            // top edge is between the other's top and bottom edge\r\n            /**\r\n             *     +-other-+\r\n             *     |       |\r\n             *     |    +-this-+   | <- overlap\r\n             *     +----|--+   |   |\r\n             *          |      |  \\ /\r\n             *          +------+   '\r\n             */\r\n            if (this.top <= other.bottom && this.top >= other.top) {\r\n                overlapY = other.bottom - this.top;\r\n                // top edge is above the other top edge\r\n                /**\r\n                 *     +-this-+         .\r\n                 *     |      |        / \\\r\n                 *     |    +-other-+   | <- overlap\r\n                 *     +----|-+     |   |\r\n                 *          |       |\r\n                 *          +-------+\r\n                 */\r\n            }\r\n            else {\r\n                overlapY = other.top - this.bottom;\r\n            }\r\n            if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n                return new Vector(overlapX, 0);\r\n            }\r\n            else {\r\n                return new Vector(0, overlapY);\r\n            }\r\n            // Case of total containment of one bounding box by another\r\n        }\r\n        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {\r\n            let overlapX = 0;\r\n            // this is wider than the other\r\n            if (this.width - other.width >= 0) {\r\n                // This right edge is closest to the others right edge\r\n                if (this.right - other.right <= other.left - this.left) {\r\n                    overlapX = other.left - this.right;\r\n                    // This left edge is closest to the others left edge\r\n                }\r\n                else {\r\n                    overlapX = other.right - this.left;\r\n                }\r\n                // other is wider than this\r\n            }\r\n            else {\r\n                // This right edge is closest to the others right edge\r\n                if (other.right - this.right <= this.left - other.left) {\r\n                    overlapX = this.left - other.right;\r\n                    // This left edge is closest to the others left edge\r\n                }\r\n                else {\r\n                    overlapX = this.right - other.left;\r\n                }\r\n            }\r\n            let overlapY = 0;\r\n            // this is taller than other\r\n            if (this.height - other.height >= 0) {\r\n                // The bottom edge is closest to the others bottom edge\r\n                if (this.bottom - other.bottom <= other.top - this.top) {\r\n                    overlapY = other.top - this.bottom;\r\n                }\r\n                else {\r\n                    overlapY = other.bottom - this.top;\r\n                }\r\n                // other is taller than this\r\n            }\r\n            else {\r\n                // The bottom edge is closest to the others bottom edge\r\n                if (other.bottom - this.bottom <= this.top - other.top) {\r\n                    overlapY = this.top - other.bottom;\r\n                }\r\n                else {\r\n                    overlapY = this.bottom - other.top;\r\n                }\r\n            }\r\n            if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n                return new Vector(overlapX, 0);\r\n            }\r\n            else {\r\n                return new Vector(0, overlapY);\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.\r\n     * @param bb The other actor to test\r\n     */\r\n    intersectWithSide(bb) {\r\n        const intersect = this.intersect(bb);\r\n        return BoundingBox.getSideFromIntersection(intersect);\r\n    }\r\n    /**\r\n     * Draw a debug bounding box\r\n     * @param ex\r\n     * @param color\r\n     */\r\n    draw(ex, color = Color.Yellow) {\r\n        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Future.ts\n/**\r\n * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time\r\n */\r\nclass Future {\r\n    constructor() {\r\n        this._isCompleted = false;\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this._resolver = resolve;\r\n            this._rejecter = reject;\r\n        });\r\n    }\r\n    get isCompleted() {\r\n        return this._isCompleted;\r\n    }\r\n    resolve(value) {\r\n        if (this._isCompleted) {\r\n            return;\r\n        }\r\n        this._isCompleted = true;\r\n        this._resolver(value);\r\n    }\r\n    reject(error) {\r\n        if (this._isCompleted) {\r\n            return;\r\n        }\r\n        this._isCompleted = true;\r\n        this._rejecter(error);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Util.ts\n\r\n\r\n/**\r\n * Find the screen position of an HTML element\r\n */\r\nfunction getPosition(el) {\r\n    let oLeft = 0, oTop = 0;\r\n    const calcOffsetLeft = (parent) => {\r\n        oLeft += parent.offsetLeft;\r\n        if (parent.offsetParent) {\r\n            calcOffsetLeft(parent.offsetParent);\r\n        }\r\n    };\r\n    const calcOffsetTop = (parent) => {\r\n        oTop += parent.offsetTop;\r\n        if (parent.offsetParent) {\r\n            calcOffsetTop(parent.offsetParent);\r\n        }\r\n    };\r\n    calcOffsetLeft(el);\r\n    calcOffsetTop(el);\r\n    return new Vector(oLeft, oTop);\r\n}\r\n/**\r\n * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nfunction addItemToArray(item, array) {\r\n    if (array.indexOf(item) === -1) {\r\n        array.push(item);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Remove an item from an list\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nfunction removeItemFromArray(item, array) {\r\n    let index = -1;\r\n    if ((index = array.indexOf(item)) > -1) {\r\n        array.splice(index, 1);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * See if an array contains something\r\n */\r\nfunction contains(array, obj) {\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (array[i] === obj) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Used for exhaustive checks at compile time\r\n */\r\nfunction fail(message) {\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Create a promise that resolves after a certain number of milliseconds\r\n *\r\n * It is strongly recommended you pass the excalibur clock so delays are bound to the\r\n * excalibur clock which would be unaffected by stop/pause.\r\n * @param milliseconds\r\n * @param clock\r\n */\r\nfunction delay(milliseconds, clock) {\r\n    var _a;\r\n    const future = new Future();\r\n    const schedule = (_a = clock === null || clock === void 0 ? void 0 : clock.schedule.bind(clock)) !== null && _a !== void 0 ? _a : setTimeout;\r\n    schedule(() => {\r\n        future.resolve();\r\n    }, milliseconds);\r\n    return future.promise;\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/matrix.ts\n\r\n\r\n\r\nvar MatrixLocations;\r\n(function (MatrixLocations) {\r\n    MatrixLocations[MatrixLocations[\"X\"] = 12] = \"X\";\r\n    MatrixLocations[MatrixLocations[\"Y\"] = 13] = \"Y\";\r\n})(MatrixLocations || (MatrixLocations = {}));\r\n/**\r\n * Excalibur Matrix helper for 4x4 matrices\r\n *\r\n * Useful for webgl 4x4 matrices\r\n */\r\nclass Matrix {\r\n    constructor() {\r\n        /**\r\n         *  4x4 matrix in column major order\r\n         *\r\n         * |         |         |          |          |\r\n         * | ------- | ------- | -------- | -------- |\r\n         * | data[0] | data[4] | data[8]  | data[12] |\r\n         * | data[1] | data[5] | data[9]  | data[13] |\r\n         * | data[2] | data[6] | data[10] | data[14] |\r\n         * | data[3] | data[7] | data[11] | data[15] |\r\n         *\r\n         */\r\n        this.data = new Float32Array(16);\r\n        this._scaleX = 1;\r\n        this._scaleSignX = 1;\r\n        this._scaleY = 1;\r\n        this._scaleSignY = 1;\r\n    }\r\n    /**\r\n     * Creates an orthographic (flat non-perspective) projection\r\n     * https://en.wikipedia.org/wiki/Orthographic_projection\r\n     * @param left\r\n     * @param right\r\n     * @param bottom\r\n     * @param top\r\n     * @param near\r\n     * @param far\r\n     */\r\n    static ortho(left, right, bottom, top, near, far) {\r\n        const mat = new Matrix();\r\n        mat.data[0] = 2 / (right - left);\r\n        mat.data[1] = 0;\r\n        mat.data[2] = 0;\r\n        mat.data[3] = 0;\r\n        mat.data[4] = 0;\r\n        mat.data[5] = 2 / (top - bottom);\r\n        mat.data[6] = 0;\r\n        mat.data[7] = 0;\r\n        mat.data[8] = 0;\r\n        mat.data[9] = 0;\r\n        mat.data[10] = -2 / (far - near);\r\n        mat.data[11] = 0;\r\n        mat.data[12] = -(right + left) / (right - left);\r\n        mat.data[13] = -(top + bottom) / (top - bottom);\r\n        mat.data[14] = -(far + near) / (far - near);\r\n        mat.data[15] = 1;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a new Matrix with the same data as the current 4x4\r\n     */\r\n    clone(dest) {\r\n        const mat = dest || new Matrix();\r\n        mat.data[0] = this.data[0];\r\n        mat.data[1] = this.data[1];\r\n        mat.data[2] = this.data[2];\r\n        mat.data[3] = this.data[3];\r\n        mat.data[4] = this.data[4];\r\n        mat.data[5] = this.data[5];\r\n        mat.data[6] = this.data[6];\r\n        mat.data[7] = this.data[7];\r\n        mat.data[8] = this.data[8];\r\n        mat.data[9] = this.data[9];\r\n        mat.data[10] = this.data[10];\r\n        mat.data[11] = this.data[11];\r\n        mat.data[12] = this.data[12];\r\n        mat.data[13] = this.data[13];\r\n        mat.data[14] = this.data[14];\r\n        mat.data[15] = this.data[15];\r\n        return mat;\r\n    }\r\n    /**\r\n     * Converts the current matrix into a DOMMatrix\r\n     *\r\n     * This is useful when working with the browser Canvas context\r\n     * @returns {DOMMatrix} DOMMatrix\r\n     */\r\n    toDOMMatrix() {\r\n        return new DOMMatrix([...this.data]);\r\n    }\r\n    static fromFloat32Array(data) {\r\n        const matrix = new Matrix();\r\n        matrix.data = data;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Creates a new identity matrix (a matrix that when applied does nothing)\r\n     */\r\n    static identity() {\r\n        const mat = new Matrix();\r\n        mat.data[0] = 1;\r\n        mat.data[1] = 0;\r\n        mat.data[2] = 0;\r\n        mat.data[3] = 0;\r\n        mat.data[4] = 0;\r\n        mat.data[5] = 1;\r\n        mat.data[6] = 0;\r\n        mat.data[7] = 0;\r\n        mat.data[8] = 0;\r\n        mat.data[9] = 0;\r\n        mat.data[10] = 1;\r\n        mat.data[11] = 0;\r\n        mat.data[12] = 0;\r\n        mat.data[13] = 0;\r\n        mat.data[14] = 0;\r\n        mat.data[15] = 1;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Resets the current matrix to the identity matrix, mutating it\r\n     * @returns {Matrix} Current matrix as identity\r\n     */\r\n    reset() {\r\n        const mat = this;\r\n        mat.data[0] = 1;\r\n        mat.data[1] = 0;\r\n        mat.data[2] = 0;\r\n        mat.data[3] = 0;\r\n        mat.data[4] = 0;\r\n        mat.data[5] = 1;\r\n        mat.data[6] = 0;\r\n        mat.data[7] = 0;\r\n        mat.data[8] = 0;\r\n        mat.data[9] = 0;\r\n        mat.data[10] = 1;\r\n        mat.data[11] = 0;\r\n        mat.data[12] = 0;\r\n        mat.data[13] = 0;\r\n        mat.data[14] = 0;\r\n        mat.data[15] = 1;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a brand new translation matrix at the specified 3d point\r\n     * @param x\r\n     * @param y\r\n     */\r\n    static translation(x, y) {\r\n        const mat = Matrix.identity();\r\n        mat.data[12] = x;\r\n        mat.data[13] = y;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a brand new scaling matrix with the specified scaling factor\r\n     * @param sx\r\n     * @param sy\r\n     */\r\n    static scale(sx, sy) {\r\n        const mat = Matrix.identity();\r\n        mat.data[0] = sx;\r\n        mat.data[5] = sy;\r\n        mat.data[10] = 1;\r\n        mat.data[15] = 1;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a brand new rotation matrix with the specified angle\r\n     * @param angleRadians\r\n     */\r\n    static rotation(angleRadians) {\r\n        const mat = Matrix.identity();\r\n        mat.data[0] = Math.cos(angleRadians);\r\n        mat.data[4] = -Math.sin(angleRadians);\r\n        mat.data[1] = Math.sin(angleRadians);\r\n        mat.data[5] = Math.cos(angleRadians);\r\n        return mat;\r\n    }\r\n    multiply(vectorOrMatrix, dest) {\r\n        if (vectorOrMatrix instanceof Vector) {\r\n            const result = dest || new Vector(0, 0);\r\n            const vector = vectorOrMatrix;\r\n            // these shenanigans are to allow dest and vector to be the same instance\r\n            const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];\r\n            const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];\r\n            result.x = resultX;\r\n            result.y = resultY;\r\n            return result;\r\n        }\r\n        else {\r\n            const result = dest || new Matrix();\r\n            const other = vectorOrMatrix;\r\n            const a11 = this.data[0];\r\n            const a21 = this.data[1];\r\n            const a31 = this.data[2];\r\n            const a41 = this.data[3];\r\n            const a12 = this.data[4];\r\n            const a22 = this.data[5];\r\n            const a32 = this.data[6];\r\n            const a42 = this.data[7];\r\n            const a13 = this.data[8];\r\n            const a23 = this.data[9];\r\n            const a33 = this.data[10];\r\n            const a43 = this.data[11];\r\n            const a14 = this.data[12];\r\n            const a24 = this.data[13];\r\n            const a34 = this.data[14];\r\n            const a44 = this.data[15];\r\n            const b11 = other.data[0];\r\n            const b21 = other.data[1];\r\n            const b31 = other.data[2];\r\n            const b41 = other.data[3];\r\n            const b12 = other.data[4];\r\n            const b22 = other.data[5];\r\n            const b32 = other.data[6];\r\n            const b42 = other.data[7];\r\n            const b13 = other.data[8];\r\n            const b23 = other.data[9];\r\n            const b33 = other.data[10];\r\n            const b43 = other.data[11];\r\n            const b14 = other.data[12];\r\n            const b24 = other.data[13];\r\n            const b34 = other.data[14];\r\n            const b44 = other.data[15];\r\n            result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n            result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n            result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n            result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n            result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n            result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n            result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n            result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n            result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n            result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n            result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n            result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n            result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n            result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n            result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n            result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n            const s = this.getScale();\r\n            result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n            result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n            return result;\r\n        }\r\n    }\r\n    /**\r\n     * Applies translation to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */\r\n    translate(x, y) {\r\n        const a11 = this.data[0];\r\n        const a21 = this.data[1];\r\n        const a31 = this.data[2];\r\n        const a41 = this.data[3];\r\n        const a12 = this.data[4];\r\n        const a22 = this.data[5];\r\n        const a32 = this.data[6];\r\n        const a42 = this.data[7];\r\n        const a13 = this.data[8];\r\n        const a23 = this.data[9];\r\n        const a33 = this.data[10];\r\n        const a43 = this.data[11];\r\n        const a14 = this.data[12];\r\n        const a24 = this.data[13];\r\n        const a34 = this.data[14];\r\n        const a44 = this.data[15];\r\n        // Doesn't change z\r\n        const z = 0;\r\n        const w = 1;\r\n        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;\r\n        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;\r\n        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;\r\n        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;\r\n        return this;\r\n    }\r\n    setPosition(x, y) {\r\n        this.data[12] = x;\r\n        this.data[13] = y;\r\n    }\r\n    getPosition() {\r\n        return vec(this.data[12], this.data[13]);\r\n    }\r\n    /**\r\n     * Applies rotation to the current matrix mutating it\r\n     * @param angle in Radians\r\n     */\r\n    rotate(angle) {\r\n        const a11 = this.data[0];\r\n        const a21 = this.data[1];\r\n        const a31 = this.data[2];\r\n        const a41 = this.data[3];\r\n        const a12 = this.data[4];\r\n        const a22 = this.data[5];\r\n        const a32 = this.data[6];\r\n        const a42 = this.data[7];\r\n        const sine = Math.sin(angle);\r\n        const cosine = Math.cos(angle);\r\n        this.data[0] = cosine * a11 + sine * a12;\r\n        this.data[1] = cosine * a21 + sine * a22;\r\n        this.data[2] = cosine * a31 + sine * a32;\r\n        this.data[3] = cosine * a41 + sine * a42;\r\n        this.data[4] = cosine * a12 - sine * a11;\r\n        this.data[5] = cosine * a22 - sine * a21;\r\n        this.data[6] = cosine * a32 - sine * a31;\r\n        this.data[7] = cosine * a42 - sine * a41;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies scaling to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */\r\n    scale(x, y) {\r\n        const a11 = this.data[0];\r\n        const a21 = this.data[1];\r\n        const a31 = this.data[2];\r\n        const a41 = this.data[3];\r\n        const a12 = this.data[4];\r\n        const a22 = this.data[5];\r\n        const a32 = this.data[6];\r\n        const a42 = this.data[7];\r\n        this.data[0] = a11 * x;\r\n        this.data[1] = a21 * x;\r\n        this.data[2] = a31 * x;\r\n        this.data[3] = a41 * x;\r\n        this.data[4] = a12 * y;\r\n        this.data[5] = a22 * y;\r\n        this.data[6] = a32 * y;\r\n        this.data[7] = a42 * y;\r\n        return this;\r\n    }\r\n    setRotation(angle) {\r\n        const currentScale = this.getScale();\r\n        const sine = Math.sin(angle);\r\n        const cosine = Math.cos(angle);\r\n        this.data[0] = cosine * currentScale.x;\r\n        this.data[1] = sine * currentScale.y;\r\n        this.data[4] = -sine * currentScale.x;\r\n        this.data[5] = cosine * currentScale.y;\r\n    }\r\n    getRotation() {\r\n        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n        return canonicalizeAngle(angle);\r\n    }\r\n    getScaleX() {\r\n        // absolute scale of the matrix (we lose sign so need to add it back)\r\n        const xscale = vec(this.data[0], this.data[4]).size;\r\n        return this._scaleSignX * xscale;\r\n    }\r\n    getScaleY() {\r\n        // absolute scale of the matrix (we lose sign so need to add it back)\r\n        const yscale = vec(this.data[1], this.data[5]).size;\r\n        return this._scaleSignY * yscale;\r\n    }\r\n    /**\r\n     * Get the scale of the matrix\r\n     */\r\n    getScale() {\r\n        return vec(this.getScaleX(), this.getScaleY());\r\n    }\r\n    setScaleX(val) {\r\n        if (this._scaleX === val) {\r\n            return;\r\n        }\r\n        this._scaleSignX = sign(val);\r\n        // negative scale acts like a 180 rotation, so flip\r\n        const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();\r\n        this.data[0] = xscale.x * val;\r\n        this.data[4] = xscale.y * val;\r\n        this._scaleX = val;\r\n    }\r\n    setScaleY(val) {\r\n        if (this._scaleY === val) {\r\n            return;\r\n        }\r\n        this._scaleSignY = sign(val);\r\n        // negative scale acts like a 180 rotation, so flip\r\n        const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();\r\n        this.data[1] = yscale.x * val;\r\n        this.data[5] = yscale.y * val;\r\n        this._scaleY = val;\r\n    }\r\n    setScale(scale) {\r\n        this.setScaleX(scale.x);\r\n        this.setScaleY(scale.y);\r\n    }\r\n    /**\r\n     * Determinant of the upper left 2x2 matrix\r\n     */\r\n    getBasisDeterminant() {\r\n        return this.data[0] * this.data[5] - this.data[1] * this.data[4];\r\n    }\r\n    /**\r\n     * Return the affine inverse, optionally store it in a target matrix.\r\n     *\r\n     * It's recommended you call .reset() the target unless you know what you're doing\r\n     * @param target\r\n     */\r\n    getAffineInverse(target) {\r\n        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n        // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n        // Since we are actually only doing 2D transformations we can use this hack\r\n        // We don't actually use the 3rd or 4th dimension\r\n        const det = this.getBasisDeterminant();\r\n        const inverseDet = 1 / det; // todo zero check\r\n        const a = this.data[0];\r\n        const b = this.data[4];\r\n        const c = this.data[1];\r\n        const d = this.data[5];\r\n        const m = target || Matrix.identity();\r\n        // inverts rotation and scale\r\n        m.data[0] = d * inverseDet;\r\n        m.data[1] = -c * inverseDet;\r\n        m.data[4] = -b * inverseDet;\r\n        m.data[5] = a * inverseDet;\r\n        const tx = this.data[12];\r\n        const ty = this.data[13];\r\n        // invert translation\r\n        // transform translation into the matrix basis created by rot/scale\r\n        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);\r\n        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);\r\n        return m;\r\n    }\r\n    isIdentity() {\r\n        return (this.data[0] === 1 &&\r\n            this.data[1] === 0 &&\r\n            this.data[2] === 0 &&\r\n            this.data[3] === 0 &&\r\n            this.data[4] === 0 &&\r\n            this.data[5] === 1 &&\r\n            this.data[6] === 0 &&\r\n            this.data[7] === 0 &&\r\n            this.data[8] === 0 &&\r\n            this.data[9] === 0 &&\r\n            this.data[10] === 1 &&\r\n            this.data[11] === 0 &&\r\n            this.data[12] === 0 &&\r\n            this.data[13] === 0 &&\r\n            this.data[14] === 0 &&\r\n            this.data[15] === 1);\r\n    }\r\n    toString() {\r\n        return `\r\n[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]\r\n[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]\r\n[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]\r\n[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]\r\n`;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/affine-matrix.ts\n\r\n\r\n\r\nclass AffineMatrix {\r\n    constructor() {\r\n        /**\r\n         * |         |         |          |\r\n         * | ------- | ------- | -------- |\r\n         * | data[0] | data[2] | data[4]  |\r\n         * | data[1] | data[3] | data[5]  |\r\n         * |   0     |    0    |    1     |\r\n         */\r\n        this.data = new Float64Array(6);\r\n        this._scale = new Float64Array([1, 1]);\r\n        this._scaleSignX = 1;\r\n        this._scaleSignY = 1;\r\n    }\r\n    /**\r\n     * Converts the current matrix into a DOMMatrix\r\n     *\r\n     * This is useful when working with the browser Canvas context\r\n     * @returns {DOMMatrix} DOMMatrix\r\n     */\r\n    toDOMMatrix() {\r\n        return new DOMMatrix([...this.data]);\r\n    }\r\n    static identity() {\r\n        const mat = new AffineMatrix();\r\n        mat.data[0] = 1;\r\n        mat.data[1] = 0;\r\n        mat.data[2] = 0;\r\n        mat.data[3] = 1;\r\n        mat.data[4] = 0;\r\n        mat.data[5] = 0;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a brand new translation matrix at the specified 3d point\r\n     * @param x\r\n     * @param y\r\n     */\r\n    static translation(x, y) {\r\n        const mat = AffineMatrix.identity();\r\n        mat.data[4] = x;\r\n        mat.data[5] = y;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a brand new scaling matrix with the specified scaling factor\r\n     * @param sx\r\n     * @param sy\r\n     */\r\n    static scale(sx, sy) {\r\n        const mat = AffineMatrix.identity();\r\n        mat.data[0] = sx;\r\n        mat.data[3] = sy;\r\n        mat._scale[0] = sx;\r\n        mat._scale[1] = sy;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a brand new rotation matrix with the specified angle\r\n     * @param angleRadians\r\n     */\r\n    static rotation(angleRadians) {\r\n        const mat = AffineMatrix.identity();\r\n        mat.data[0] = Math.cos(angleRadians);\r\n        mat.data[1] = Math.sin(angleRadians);\r\n        mat.data[2] = -Math.sin(angleRadians);\r\n        mat.data[3] = Math.cos(angleRadians);\r\n        return mat;\r\n    }\r\n    setPosition(x, y) {\r\n        this.data[4] = x;\r\n        this.data[5] = y;\r\n    }\r\n    getPosition() {\r\n        return vec(this.data[4], this.data[5]);\r\n    }\r\n    /**\r\n     * Applies rotation to the current matrix mutating it\r\n     * @param angle in Radians\r\n     */\r\n    rotate(angle) {\r\n        const a11 = this.data[0];\r\n        const a21 = this.data[1];\r\n        const a12 = this.data[2];\r\n        const a22 = this.data[3];\r\n        const sine = Math.sin(angle);\r\n        const cosine = Math.cos(angle);\r\n        this.data[0] = cosine * a11 + sine * a12;\r\n        this.data[1] = cosine * a21 + sine * a22;\r\n        this.data[2] = cosine * a12 - sine * a11;\r\n        this.data[3] = cosine * a22 - sine * a21;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies translation to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */\r\n    translate(x, y) {\r\n        const a11 = this.data[0];\r\n        const a21 = this.data[1];\r\n        // const a31 = 0;\r\n        const a12 = this.data[2];\r\n        const a22 = this.data[3];\r\n        // const a32 = 0;\r\n        const a13 = this.data[4];\r\n        const a23 = this.data[5];\r\n        // const a33 = 1;\r\n        // Doesn't change z\r\n        this.data[4] = a11 * x + a12 * y + a13;\r\n        this.data[5] = a21 * x + a22 * y + a23;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies scaling to the current matrix mutating it\r\n     * @param x\r\n     * @param y\r\n     */\r\n    scale(x, y) {\r\n        const a11 = this.data[0];\r\n        const a21 = this.data[1];\r\n        const a12 = this.data[2];\r\n        const a22 = this.data[3];\r\n        this.data[0] = a11 * x;\r\n        this.data[1] = a21 * x;\r\n        this.data[2] = a12 * y;\r\n        this.data[3] = a22 * y;\r\n        this._scale[0] = x;\r\n        this._scale[1] = y;\r\n        return this;\r\n    }\r\n    determinant() {\r\n        return this.data[0] * this.data[3] - this.data[1] * this.data[2];\r\n    }\r\n    /**\r\n     * Return the affine inverse, optionally store it in a target matrix.\r\n     *\r\n     * It's recommended you call .reset() the target unless you know what you're doing\r\n     * @param target\r\n     */\r\n    inverse(target) {\r\n        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n        // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n        // Since we are actually only doing 2D transformations we can use this hack\r\n        // We don't actually use the 3rd or 4th dimension\r\n        const det = this.determinant();\r\n        const inverseDet = 1 / det; // TODO zero check\r\n        const a = this.data[0];\r\n        const b = this.data[2];\r\n        const c = this.data[1];\r\n        const d = this.data[3];\r\n        const m = target || AffineMatrix.identity();\r\n        // inverts rotation and scale\r\n        m.data[0] = d * inverseDet;\r\n        m.data[1] = -c * inverseDet;\r\n        m.data[2] = -b * inverseDet;\r\n        m.data[3] = a * inverseDet;\r\n        const tx = this.data[4];\r\n        const ty = this.data[5];\r\n        // invert translation\r\n        // transform translation into the matrix basis created by rot/scale\r\n        m.data[4] = -(tx * m.data[0] + ty * m.data[2]);\r\n        m.data[5] = -(tx * m.data[1] + ty * m.data[3]);\r\n        return m;\r\n    }\r\n    multiply(vectorOrMatrix, dest) {\r\n        if (vectorOrMatrix instanceof Vector) {\r\n            const result = dest || new Vector(0, 0);\r\n            const vector = vectorOrMatrix;\r\n            // these shenanigans are to allow dest and vector to be the same instance\r\n            const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];\r\n            const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];\r\n            result.x = resultX;\r\n            result.y = resultY;\r\n            return result;\r\n        }\r\n        else {\r\n            const result = dest || new AffineMatrix();\r\n            const other = vectorOrMatrix;\r\n            const a11 = this.data[0];\r\n            const a21 = this.data[1];\r\n            //  const a31 = 0;\r\n            const a12 = this.data[2];\r\n            const a22 = this.data[3];\r\n            //  const a32 = 0;\r\n            const a13 = this.data[4];\r\n            const a23 = this.data[5];\r\n            //  const a33 = 1;\r\n            const b11 = other.data[0];\r\n            const b21 = other.data[1];\r\n            //  const b31 = 0;\r\n            const b12 = other.data[2];\r\n            const b22 = other.data[3];\r\n            //  const b32 = 0;\r\n            const b13 = other.data[4];\r\n            const b23 = other.data[5];\r\n            //  const b33 = 1;\r\n            result.data[0] = a11 * b11 + a12 * b21; // + a13 * b31; // zero\r\n            result.data[1] = a21 * b11 + a22 * b21; // + a23 * b31; // zero\r\n            result.data[2] = a11 * b12 + a12 * b22; // + a13 * b32; // zero\r\n            result.data[3] = a21 * b12 + a22 * b22; // + a23 * b32; // zero\r\n            result.data[4] = a11 * b13 + a12 * b23 + a13; // * b33; // one\r\n            result.data[5] = a21 * b13 + a22 * b23 + a23; // * b33; // one\r\n            const s = this.getScale();\r\n            result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n            result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n            return result;\r\n        }\r\n    }\r\n    to4x4() {\r\n        const mat = new Matrix();\r\n        mat.data[0] = this.data[0];\r\n        mat.data[1] = this.data[1];\r\n        mat.data[2] = 0;\r\n        mat.data[3] = 0;\r\n        mat.data[4] = this.data[2];\r\n        mat.data[5] = this.data[3];\r\n        mat.data[6] = 0;\r\n        mat.data[7] = 0;\r\n        mat.data[8] = 0;\r\n        mat.data[9] = 0;\r\n        mat.data[10] = 1;\r\n        mat.data[11] = 0;\r\n        mat.data[12] = this.data[4];\r\n        mat.data[13] = this.data[5];\r\n        mat.data[14] = 0;\r\n        mat.data[15] = 1;\r\n        return mat;\r\n    }\r\n    setRotation(angle) {\r\n        const currentScale = this.getScale();\r\n        const sine = Math.sin(angle);\r\n        const cosine = Math.cos(angle);\r\n        this.data[0] = cosine * currentScale.x;\r\n        this.data[1] = sine * currentScale.y;\r\n        this.data[2] = -sine * currentScale.x;\r\n        this.data[3] = cosine * currentScale.y;\r\n    }\r\n    getRotation() {\r\n        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n        return canonicalizeAngle(angle);\r\n    }\r\n    getScaleX() {\r\n        // absolute scale of the matrix (we lose sign so need to add it back)\r\n        const xscale = vec(this.data[0], this.data[2]).distance();\r\n        return this._scaleSignX * xscale;\r\n    }\r\n    getScaleY() {\r\n        // absolute scale of the matrix (we lose sign so need to add it back)\r\n        const yscale = vec(this.data[1], this.data[3]).distance();\r\n        return this._scaleSignY * yscale;\r\n    }\r\n    /**\r\n     * Get the scale of the matrix\r\n     */\r\n    getScale() {\r\n        return vec(this.getScaleX(), this.getScaleY());\r\n    }\r\n    setScaleX(val) {\r\n        if (val === this._scale[0]) {\r\n            return;\r\n        }\r\n        this._scaleSignX = sign(val);\r\n        // negative scale acts like a 180 rotation, so flip\r\n        const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();\r\n        this.data[0] = xscale.x * val;\r\n        this.data[2] = xscale.y * val;\r\n        this._scale[0] = val;\r\n    }\r\n    setScaleY(val) {\r\n        if (val === this._scale[1]) {\r\n            return;\r\n        }\r\n        this._scaleSignY = sign(val);\r\n        // negative scale acts like a 180 rotation, so flip\r\n        const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();\r\n        this.data[1] = yscale.x * val;\r\n        this.data[3] = yscale.y * val;\r\n        this._scale[1] = val;\r\n    }\r\n    setScale(scale) {\r\n        this.setScaleX(scale.x);\r\n        this.setScaleY(scale.y);\r\n    }\r\n    isIdentity() {\r\n        return (this.data[0] === 1 &&\r\n            this.data[1] === 0 &&\r\n            this.data[2] === 0 &&\r\n            this.data[3] === 1 &&\r\n            this.data[4] === 0 &&\r\n            this.data[5] === 0);\r\n    }\r\n    /**\r\n     * Resets the current matrix to the identity matrix, mutating it\r\n     * @returns {AffineMatrix} Current matrix as identity\r\n     */\r\n    reset() {\r\n        const mat = this;\r\n        mat.data[0] = 1;\r\n        mat.data[1] = 0;\r\n        mat.data[2] = 0;\r\n        mat.data[3] = 1;\r\n        mat.data[4] = 0;\r\n        mat.data[5] = 0;\r\n        return mat;\r\n    }\r\n    /**\r\n     * Creates a new Matrix with the same data as the current 4x4\r\n     */\r\n    clone(dest) {\r\n        const mat = dest || new AffineMatrix();\r\n        mat.data[0] = this.data[0];\r\n        mat.data[1] = this.data[1];\r\n        mat.data[2] = this.data[2];\r\n        mat.data[3] = this.data[3];\r\n        mat.data[4] = this.data[4];\r\n        mat.data[5] = this.data[5];\r\n        return mat;\r\n    }\r\n    toString() {\r\n        return `\r\n[${this.data[0]} ${this.data[2]} ${this.data[4]}]\r\n[${this.data[1]} ${this.data[3]} ${this.data[5]}]\r\n[0 0 1]\r\n`;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/transform-stack.ts\n\r\nclass TransformStack {\r\n    constructor() {\r\n        this._transforms = [];\r\n        this._currentTransform = AffineMatrix.identity();\r\n    }\r\n    save() {\r\n        this._transforms.push(this._currentTransform);\r\n        this._currentTransform = this._currentTransform.clone();\r\n    }\r\n    restore() {\r\n        this._currentTransform = this._transforms.pop();\r\n    }\r\n    translate(x, y) {\r\n        return this._currentTransform.translate(x, y);\r\n    }\r\n    rotate(angle) {\r\n        return this._currentTransform.rotate(angle);\r\n    }\r\n    scale(x, y) {\r\n        return this._currentTransform.scale(x, y);\r\n    }\r\n    set current(matrix) {\r\n        this._currentTransform = matrix;\r\n    }\r\n    get current() {\r\n        return this._currentTransform;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/state-stack.ts\n\r\nclass StateStack {\r\n    constructor() {\r\n        this._states = [];\r\n        this._currentState = this._getDefaultState();\r\n    }\r\n    _getDefaultState() {\r\n        return {\r\n            opacity: 1,\r\n            z: 0,\r\n            tint: Color.White\r\n        };\r\n    }\r\n    _cloneState() {\r\n        return {\r\n            opacity: this._currentState.opacity,\r\n            z: this._currentState.z,\r\n            tint: this._currentState.tint.clone()\r\n        };\r\n    }\r\n    save() {\r\n        this._states.push(this._currentState);\r\n        this._currentState = this._cloneState();\r\n    }\r\n    restore() {\r\n        this._currentState = this._states.pop();\r\n    }\r\n    get current() {\r\n        return this._currentState;\r\n    }\r\n    set current(val) {\r\n        this._currentState = val;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Events.ts\nvar EventTypes;\r\n(function (EventTypes) {\r\n    EventTypes[\"Kill\"] = \"kill\";\r\n    EventTypes[\"PreKill\"] = \"prekill\";\r\n    EventTypes[\"PostKill\"] = \"postkill\";\r\n    EventTypes[\"PreDraw\"] = \"predraw\";\r\n    EventTypes[\"PostDraw\"] = \"postdraw\";\r\n    EventTypes[\"PreDebugDraw\"] = \"predebugdraw\";\r\n    EventTypes[\"PostDebugDraw\"] = \"postdebugdraw\";\r\n    EventTypes[\"PreUpdate\"] = \"preupdate\";\r\n    EventTypes[\"PostUpdate\"] = \"postupdate\";\r\n    EventTypes[\"PreFrame\"] = \"preframe\";\r\n    EventTypes[\"PostFrame\"] = \"postframe\";\r\n    EventTypes[\"PreCollision\"] = \"precollision\";\r\n    EventTypes[\"CollisionStart\"] = \"collisionstart\";\r\n    EventTypes[\"CollisionEnd\"] = \"collisionend\";\r\n    EventTypes[\"PostCollision\"] = \"postcollision\";\r\n    EventTypes[\"Initialize\"] = \"initialize\";\r\n    EventTypes[\"Activate\"] = \"activate\";\r\n    EventTypes[\"Deactivate\"] = \"deactivate\";\r\n    EventTypes[\"ExitViewport\"] = \"exitviewport\";\r\n    EventTypes[\"EnterViewport\"] = \"enterviewport\";\r\n    EventTypes[\"ExitTrigger\"] = \"exit\";\r\n    EventTypes[\"EnterTrigger\"] = \"enter\";\r\n    EventTypes[\"Connect\"] = \"connect\";\r\n    EventTypes[\"Disconnect\"] = \"disconnect\";\r\n    EventTypes[\"Button\"] = \"button\";\r\n    EventTypes[\"Axis\"] = \"axis\";\r\n    EventTypes[\"Visible\"] = \"visible\";\r\n    EventTypes[\"Hidden\"] = \"hidden\";\r\n    EventTypes[\"Start\"] = \"start\";\r\n    EventTypes[\"Stop\"] = \"stop\";\r\n    EventTypes[\"PointerUp\"] = \"pointerup\";\r\n    EventTypes[\"PointerDown\"] = \"pointerdown\";\r\n    EventTypes[\"PointerMove\"] = \"pointermove\";\r\n    EventTypes[\"PointerEnter\"] = \"pointerenter\";\r\n    EventTypes[\"PointerLeave\"] = \"pointerleave\";\r\n    EventTypes[\"PointerCancel\"] = \"pointercancel\";\r\n    EventTypes[\"PointerWheel\"] = \"pointerwheel\";\r\n    EventTypes[\"Up\"] = \"up\";\r\n    EventTypes[\"Down\"] = \"down\";\r\n    EventTypes[\"Move\"] = \"move\";\r\n    EventTypes[\"Enter\"] = \"enter\";\r\n    EventTypes[\"Leave\"] = \"leave\";\r\n    EventTypes[\"Cancel\"] = \"cancel\";\r\n    EventTypes[\"Wheel\"] = \"wheel\";\r\n    EventTypes[\"Press\"] = \"press\";\r\n    EventTypes[\"Release\"] = \"release\";\r\n    EventTypes[\"Hold\"] = \"hold\";\r\n    EventTypes[\"PointerDragStart\"] = \"pointerdragstart\";\r\n    EventTypes[\"PointerDragEnd\"] = \"pointerdragend\";\r\n    EventTypes[\"PointerDragEnter\"] = \"pointerdragenter\";\r\n    EventTypes[\"PointerDragLeave\"] = \"pointerdragleave\";\r\n    EventTypes[\"PointerDragMove\"] = \"pointerdragmove\";\r\n})(EventTypes || (EventTypes = {}));\r\n/**\r\n * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\r\n * some events are unique to a type, others are not.\r\n *\r\n */\r\nclass GameEvent {\r\n    constructor() {\r\n        this._bubbles = true;\r\n    }\r\n    /**\r\n     * If set to false, prevents event from propagating to other actors. If true it will be propagated\r\n     * to all actors that apply.\r\n     */\r\n    get bubbles() {\r\n        return this._bubbles;\r\n    }\r\n    set bubbles(value) {\r\n        this._bubbles = value;\r\n    }\r\n    /**\r\n     * Prevents event from bubbling\r\n     */\r\n    stopPropagation() {\r\n        this.bubbles = false;\r\n    }\r\n}\r\n/**\r\n * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.\r\n */\r\nclass KillEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'prekill' event is emitted directly before an actor is killed.\r\n */\r\nclass PreKillEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'postkill' event is emitted directly after the actor is killed.\r\n */\r\nclass PostKillEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'start' event is emitted on engine when has started and is ready for interaction.\r\n */\r\nclass GameStartEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.\r\n */\r\nclass GameStopEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nclass PreDrawEvent extends GameEvent {\r\n    constructor(ctx, delta, target) {\r\n        super();\r\n        this.ctx = ctx;\r\n        this.delta = delta;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nclass PostDrawEvent extends GameEvent {\r\n    constructor(ctx, delta, target) {\r\n        super();\r\n        this.ctx = ctx;\r\n        this.delta = delta;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.\r\n */\r\nclass PreDebugDrawEvent extends GameEvent {\r\n    constructor(ctx, target) {\r\n        super();\r\n        this.ctx = ctx;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.\r\n */\r\nclass PostDebugDrawEvent extends GameEvent {\r\n    constructor(ctx, target) {\r\n        super();\r\n        this.ctx = ctx;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.\r\n */\r\nclass PreUpdateEvent extends GameEvent {\r\n    constructor(engine, delta, target) {\r\n        super();\r\n        this.engine = engine;\r\n        this.delta = delta;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.\r\n */\r\nclass PostUpdateEvent extends GameEvent {\r\n    constructor(engine, delta, target) {\r\n        super();\r\n        this.engine = engine;\r\n        this.delta = delta;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * The 'preframe' event is emitted on the engine, before the frame begins.\r\n */\r\nclass PreFrameEvent extends GameEvent {\r\n    constructor(engine, prevStats) {\r\n        super();\r\n        this.engine = engine;\r\n        this.prevStats = prevStats;\r\n        this.target = engine;\r\n    }\r\n}\r\n/**\r\n * The 'postframe' event is emitted on the engine, after a frame ends.\r\n */\r\nclass PostFrameEvent extends GameEvent {\r\n    constructor(engine, stats) {\r\n        super();\r\n        this.engine = engine;\r\n        this.stats = stats;\r\n        this.target = engine;\r\n    }\r\n}\r\n/**\r\n * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\r\n */\r\nclass GamepadConnectEvent extends GameEvent {\r\n    constructor(index, gamepad) {\r\n        super();\r\n        this.index = index;\r\n        this.gamepad = gamepad;\r\n        this.target = gamepad;\r\n    }\r\n}\r\n/**\r\n * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\r\n */\r\nclass GamepadDisconnectEvent extends GameEvent {\r\n    constructor(index, gamepad) {\r\n        super();\r\n        this.index = index;\r\n        this.gamepad = gamepad;\r\n        this.target = gamepad;\r\n    }\r\n}\r\n/**\r\n * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nclass GamepadButtonEvent extends GameEvent {\r\n    /**\r\n     * @param button  The Gamepad button\r\n     * @param value   A numeric value between 0 and 1\r\n     */\r\n    constructor(button, value, target) {\r\n        super();\r\n        this.button = button;\r\n        this.value = value;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nclass GamepadAxisEvent extends GameEvent {\r\n    /**\r\n     * @param axis  The Gamepad axis\r\n     * @param value A numeric value between -1 and 1\r\n     */\r\n    constructor(axis, value, target) {\r\n        super();\r\n        this.axis = axis;\r\n        this.value = value;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event received by the [[Engine]] when the browser window is visible on a screen.\r\n */\r\nclass VisibleEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event received by the [[Engine]] when the browser window is hidden from all screens.\r\n */\r\nclass HiddenEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\r\n */\r\nclass PreCollisionEvent extends GameEvent {\r\n    /**\r\n     * @param actor         The actor the event was thrown on\r\n     * @param other         The actor that will collided with the current actor\r\n     * @param side          The side that will be collided with the current actor\r\n     * @param intersection  Intersection vector\r\n     */\r\n    constructor(actor, other, side, intersection) {\r\n        super();\r\n        this.other = other;\r\n        this.side = side;\r\n        this.intersection = intersection;\r\n        this.target = actor;\r\n    }\r\n}\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\r\n */\r\nclass PostCollisionEvent extends GameEvent {\r\n    /**\r\n     * @param actor         The actor the event was thrown on\r\n     * @param other         The actor that did collide with the current actor\r\n     * @param side          The side that did collide with the current actor\r\n     * @param intersection  Intersection vector\r\n     */\r\n    constructor(actor, other, side, intersection) {\r\n        super();\r\n        this.other = other;\r\n        this.side = side;\r\n        this.intersection = intersection;\r\n        this.target = actor;\r\n    }\r\n    get actor() {\r\n        return this.target;\r\n    }\r\n    set actor(actor) {\r\n        this.target = actor;\r\n    }\r\n}\r\nclass ContactStartEvent {\r\n    constructor(target, other, contact) {\r\n        this.target = target;\r\n        this.other = other;\r\n        this.contact = contact;\r\n    }\r\n}\r\nclass ContactEndEvent {\r\n    constructor(target, other) {\r\n        this.target = target;\r\n        this.other = other;\r\n    }\r\n}\r\nclass CollisionPreSolveEvent {\r\n    constructor(target, other, side, intersection, contact) {\r\n        this.target = target;\r\n        this.other = other;\r\n        this.side = side;\r\n        this.intersection = intersection;\r\n        this.contact = contact;\r\n    }\r\n}\r\nclass CollisionPostSolveEvent {\r\n    constructor(target, other, side, intersection, contact) {\r\n        this.target = target;\r\n        this.other = other;\r\n        this.side = side;\r\n        this.intersection = intersection;\r\n        this.contact = contact;\r\n    }\r\n}\r\n/**\r\n * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\r\n */\r\nclass CollisionStartEvent extends GameEvent {\r\n    /**\r\n     *\r\n     * @param actor\r\n     * @param other\r\n     * @param contact\r\n     */\r\n    constructor(actor, other, contact) {\r\n        super();\r\n        this.other = other;\r\n        this.contact = contact;\r\n        this.target = actor;\r\n    }\r\n    get actor() {\r\n        return this.target;\r\n    }\r\n    set actor(actor) {\r\n        this.target = actor;\r\n    }\r\n}\r\n/**\r\n * Event thrown when the [[Actor|actor]] is no longer colliding with another\r\n */\r\nclass CollisionEndEvent extends GameEvent {\r\n    /**\r\n     *\r\n     */\r\n    constructor(actor, other) {\r\n        super();\r\n        this.other = other;\r\n        this.target = actor;\r\n    }\r\n    get actor() {\r\n        return this.target;\r\n    }\r\n    set actor(actor) {\r\n        this.target = actor;\r\n    }\r\n}\r\n/**\r\n * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\r\n */\r\nclass InitializeEvent extends GameEvent {\r\n    /**\r\n     * @param engine  The reference to the current engine\r\n     */\r\n    constructor(engine, target) {\r\n        super();\r\n        this.engine = engine;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event thrown on a [[Scene]] on activation\r\n */\r\nclass ActivateEvent extends GameEvent {\r\n    /**\r\n     * @param context  The context for the scene activation\r\n     */\r\n    constructor(context, target) {\r\n        super();\r\n        this.context = context;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event thrown on a [[Scene]] on deactivation\r\n */\r\nclass DeactivateEvent extends GameEvent {\r\n    /**\r\n     * @param context  The context for the scene deactivation\r\n     */\r\n    constructor(context, target) {\r\n        super();\r\n        this.context = context;\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nclass ExitViewPortEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nclass EnterViewPortEvent extends GameEvent {\r\n    constructor(target) {\r\n        super();\r\n        this.target = target;\r\n    }\r\n}\r\nclass EnterTriggerEvent extends GameEvent {\r\n    constructor(target, actor) {\r\n        super();\r\n        this.target = target;\r\n        this.actor = actor;\r\n    }\r\n}\r\nclass ExitTriggerEvent extends GameEvent {\r\n    constructor(target, actor) {\r\n        super();\r\n        this.target = target;\r\n        this.actor = actor;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EventDispatcher.ts\n\r\nclass EventDispatcher {\r\n    constructor() {\r\n        this._handlers = {};\r\n        this._wiredEventDispatchers = [];\r\n        this._deferedHandlerRemovals = [];\r\n    }\r\n    /**\r\n     * Clears any existing handlers or wired event dispatchers on this event dispatcher\r\n     */\r\n    clear() {\r\n        this._handlers = {};\r\n        this._wiredEventDispatchers = [];\r\n    }\r\n    _processDeferredHandlerRemovals() {\r\n        for (const eventHandler of this._deferedHandlerRemovals) {\r\n            this._removeHandler(eventHandler.name, eventHandler.handler);\r\n        }\r\n        this._deferedHandlerRemovals.length = 0;\r\n    }\r\n    /**\r\n     * Emits an event for target\r\n     * @param eventName  The name of the event to publish\r\n     * @param event      Optionally pass an event data object to the handler\r\n     */\r\n    emit(eventName, event) {\r\n        this._processDeferredHandlerRemovals();\r\n        if (!eventName) {\r\n            // key not mapped\r\n            return;\r\n        }\r\n        eventName = eventName.toLowerCase();\r\n        if (!event) {\r\n            event = new GameEvent();\r\n        }\r\n        let i, len;\r\n        if (this._handlers[eventName]) {\r\n            i = 0;\r\n            len = this._handlers[eventName].length;\r\n            for (i; i < len; i++) {\r\n                this._handlers[eventName][i](event);\r\n            }\r\n        }\r\n        i = 0;\r\n        len = this._wiredEventDispatchers.length;\r\n        for (i; i < len; i++) {\r\n            this._wiredEventDispatchers[i].emit(eventName, event);\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n     * @param eventName  The name of the event to subscribe to\r\n     * @param handler    The handler callback to fire on this event\r\n     */\r\n    on(eventName, handler) {\r\n        this._processDeferredHandlerRemovals();\r\n        eventName = eventName.toLowerCase();\r\n        if (!this._handlers[eventName]) {\r\n            this._handlers[eventName] = [];\r\n        }\r\n        this._handlers[eventName].push(handler);\r\n    }\r\n    /**\r\n     * Unsubscribe an event handler(s) from an event. If a specific handler\r\n     * is specified for an event, only that handler will be unsubscribed.\r\n     * Otherwise all handlers will be unsubscribed for that event.\r\n     *\r\n     * @param eventName  The name of the event to unsubscribe\r\n     * @param handler    Optionally the specific handler to unsubscribe\r\n     */\r\n    off(eventName, handler) {\r\n        this._deferedHandlerRemovals.push({ name: eventName, handler });\r\n    }\r\n    _removeHandler(eventName, handler) {\r\n        eventName = eventName.toLowerCase();\r\n        const eventHandlers = this._handlers[eventName];\r\n        if (eventHandlers) {\r\n            // if no explicit handler is give with the event name clear all handlers\r\n            if (!handler) {\r\n                this._handlers[eventName].length = 0;\r\n            }\r\n            else {\r\n                const index = eventHandlers.indexOf(handler);\r\n                if (index > -1) {\r\n                    this._handlers[eventName].splice(index, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Once listens to an event one time, then unsubscribes from that event\r\n     *\r\n     * @param eventName The name of the event to subscribe to once\r\n     * @param handler   The handler of the event that will be auto unsubscribed\r\n     */\r\n    once(eventName, handler) {\r\n        this._processDeferredHandlerRemovals();\r\n        const metaHandler = (event) => {\r\n            const ev = event || new GameEvent();\r\n            this.off(eventName, metaHandler);\r\n            handler(ev);\r\n        };\r\n        this.on(eventName, metaHandler);\r\n    }\r\n    /**\r\n     * Wires this event dispatcher to also receive events from another\r\n     */\r\n    wire(eventDispatcher) {\r\n        eventDispatcher._wiredEventDispatchers.push(this);\r\n    }\r\n    /**\r\n     * Unwires this event dispatcher from another\r\n     */\r\n    unwire(eventDispatcher) {\r\n        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);\r\n        if (index > -1) {\r\n            eventDispatcher._wiredEventDispatchers.splice(index, 1);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Resources/Resource.ts\n\r\n\r\n/**\r\n * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n */\r\nclass Resource {\r\n    /**\r\n     * @param path          Path to the remote resource\r\n     * @param responseType  The type to expect as a response: \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\n     * @param bustCache     Whether or not to cache-bust requests\r\n     */\r\n    constructor(path, responseType, bustCache = true) {\r\n        this.path = path;\r\n        this.responseType = responseType;\r\n        this.bustCache = bustCache;\r\n        this.data = null;\r\n        this.logger = Logger.getInstance();\r\n        this.events = new EventDispatcher();\r\n    }\r\n    /**\r\n     * Returns true if the Resource is completely loaded and is ready\r\n     * to be drawn.\r\n     */\r\n    isLoaded() {\r\n        return this.data !== null;\r\n    }\r\n    _cacheBust(uri) {\r\n        const query = /\\?\\w*=\\w*/;\r\n        if (query.test(uri)) {\r\n            uri += '&__=' + Date.now();\r\n        }\r\n        else {\r\n            uri += '?__=' + Date.now();\r\n        }\r\n        return uri;\r\n    }\r\n    /**\r\n     * Begin loading the resource and returns a promise to be resolved on completion\r\n     */\r\n    load() {\r\n        return new Promise((resolve, reject) => {\r\n            // Exit early if we already have data\r\n            if (this.data !== null) {\r\n                this.logger.debug('Already have data for resource', this.path);\r\n                this.events.emit('complete', this.data);\r\n                resolve(this.data);\r\n                return;\r\n            }\r\n            const request = new XMLHttpRequest();\r\n            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);\r\n            request.responseType = this.responseType;\r\n            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));\r\n            request.addEventListener('progress', (e) => this.events.emit('progress', e));\r\n            request.addEventListener('error', (e) => this.events.emit('error', e));\r\n            request.addEventListener('load', (e) => this.events.emit('load', e));\r\n            request.addEventListener('load', () => {\r\n                // XHR on file:// success status is 0, such as with PhantomJS\r\n                if (request.status !== 0 && request.status !== 200) {\r\n                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);\r\n                    this.events.emit('error', request.response);\r\n                    reject(new Error(request.statusText));\r\n                    return;\r\n                }\r\n                this.data = request.response;\r\n                this.events.emit('complete', this.data);\r\n                this.logger.debug('Completed loading resource', this.path);\r\n                resolve(this.data);\r\n            });\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Watch.ts\n/**\r\n * Watch an object with a proxy, only fires if property value is different\r\n */\r\nfunction watch(type, change) {\r\n    if (!type) {\r\n        return type;\r\n    }\r\n    if (type.__isProxy === undefined) {\r\n        // expando hack to mark a proxy\r\n        return new Proxy(type, {\r\n            set: (obj, prop, value) => {\r\n                // The default behavior to store the value\r\n                if (obj[prop] !== value) {\r\n                    obj[prop] = value;\r\n                    // Avoid watching private junk\r\n                    if (typeof prop === 'string') {\r\n                        if (prop[0] !== '_') {\r\n                            change(obj);\r\n                        }\r\n                    }\r\n                }\r\n                // Indicate success\r\n                return true;\r\n            },\r\n            get: (obj, prop) => {\r\n                if (prop !== '__isProxy') {\r\n                    return obj[prop];\r\n                }\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    return type;\r\n}\r\n/**\r\n * Watch an object with a proxy, fires change on any property value change\r\n */\r\nfunction watchAny(type, change) {\r\n    if (!type) {\r\n        return type;\r\n    }\r\n    if (type.__isProxy === undefined) {\r\n        // expando hack to mark a proxy\r\n        return new Proxy(type, {\r\n            set: (obj, prop, value) => {\r\n                // The default behavior to store the value\r\n                obj[prop] = value;\r\n                // Avoid watching private junk\r\n                if (typeof prop === 'string') {\r\n                    if (prop[0] !== '_') {\r\n                        change(obj);\r\n                    }\r\n                }\r\n                // Indicate success\r\n                return true;\r\n            },\r\n            get: (obj, prop) => {\r\n                if (prop !== '__isProxy') {\r\n                    return obj[prop];\r\n                }\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    return type;\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Graphic.ts\n\r\n\r\n\r\n\r\n/**\r\n * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].\r\n * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the\r\n * [[Graphic]] abstract class.\r\n *\r\n * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic\r\n * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]\r\n */\r\nclass Graphic {\r\n    constructor(options) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        this.id = Graphic._ID++;\r\n        this.transform = AffineMatrix.identity();\r\n        this.tint = null;\r\n        this._transformStale = true;\r\n        /**\r\n         * Gets or sets wether to show debug information about the graphic\r\n         */\r\n        this.showDebug = false;\r\n        this._flipHorizontal = false;\r\n        this._flipVertical = false;\r\n        this._rotation = 0;\r\n        /**\r\n         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).\r\n         */\r\n        this.opacity = 1;\r\n        this._scale = Vector.One;\r\n        this._origin = null;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        if (options) {\r\n            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;\r\n            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;\r\n            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;\r\n            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;\r\n            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;\r\n            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;\r\n        }\r\n    }\r\n    isStale() {\r\n        return this._transformStale;\r\n    }\r\n    /**\r\n     * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)\r\n     */\r\n    get flipHorizontal() {\r\n        return this._flipHorizontal;\r\n    }\r\n    set flipHorizontal(value) {\r\n        this._flipHorizontal = value;\r\n        this._transformStale = true;\r\n    }\r\n    /**\r\n     * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)\r\n     */\r\n    get flipVertical() {\r\n        return this._flipVertical;\r\n    }\r\n    set flipVertical(value) {\r\n        this._flipVertical = value;\r\n        this._transformStale = true;\r\n    }\r\n    /**\r\n     * Gets or sets the rotation of the graphic\r\n     */\r\n    get rotation() {\r\n        return this._rotation;\r\n    }\r\n    set rotation(value) {\r\n        this._rotation = value;\r\n        this._transformStale = true;\r\n    }\r\n    /**\r\n     * Gets or sets the scale of the graphic, this affects the width and\r\n     */\r\n    get scale() {\r\n        return this._scale;\r\n    }\r\n    set scale(value) {\r\n        this._scale = watch(value, () => {\r\n            this._transformStale = true;\r\n        });\r\n        this._transformStale = true;\r\n    }\r\n    /**\r\n     * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin\r\n     */\r\n    get origin() {\r\n        return this._origin;\r\n    }\r\n    set origin(value) {\r\n        this._origin = watch(value, () => {\r\n            this._transformStale = true;\r\n        });\r\n        this._transformStale = true;\r\n    }\r\n    cloneGraphicOptions() {\r\n        return {\r\n            origin: this.origin ? this.origin.clone() : null,\r\n            flipHorizontal: this.flipHorizontal,\r\n            flipVertical: this.flipVertical,\r\n            rotation: this.rotation,\r\n            opacity: this.opacity,\r\n            scale: this.scale ? this.scale.clone() : null\r\n        };\r\n    }\r\n    /**\r\n     * Gets or sets the width of the graphic (always positive)\r\n     */\r\n    get width() {\r\n        return Math.abs(this._width * this.scale.x);\r\n    }\r\n    /**\r\n     * Gets or sets the height of the graphic (always positive)\r\n     */\r\n    get height() {\r\n        return Math.abs(this._height * this.scale.y);\r\n    }\r\n    set width(value) {\r\n        this._width = value;\r\n        this._transformStale = true;\r\n    }\r\n    set height(value) {\r\n        this._height = value;\r\n        this._transformStale = true;\r\n    }\r\n    /**\r\n     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.\r\n     */\r\n    get localBounds() {\r\n        return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);\r\n    }\r\n    /**\r\n     * Draw the whole graphic to the context including transform\r\n     * @param ex The excalibur graphics context\r\n     * @param x\r\n     * @param y\r\n     */\r\n    draw(ex, x, y) {\r\n        this._preDraw(ex, x, y);\r\n        this._drawImage(ex, 0, 0);\r\n        this._postDraw(ex);\r\n    }\r\n    /**\r\n     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]\r\n     * @param ex\r\n     * @param x\r\n     * @param y\r\n     */\r\n    _preDraw(ex, x, y) {\r\n        ex.save();\r\n        ex.translate(x, y);\r\n        if (this._transformStale) {\r\n            this.transform.reset();\r\n            this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\r\n            this._rotate(this.transform);\r\n            this._flip(this.transform);\r\n            this._transformStale = false;\r\n        }\r\n        ex.multiply(this.transform);\r\n        // it is important to multiply alphas so graphics respect the current context\r\n        ex.opacity = ex.opacity * this.opacity;\r\n        if (this.tint) {\r\n            ex.tint = this.tint;\r\n        }\r\n    }\r\n    _rotate(ex) {\r\n        var _a;\r\n        const scaleDirX = this.scale.x > 0 ? 1 : -1;\r\n        const scaleDirY = this.scale.y > 0 ? 1 : -1;\r\n        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);\r\n        ex.translate(origin.x, origin.y);\r\n        ex.rotate(this.rotation);\r\n        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\r\n        ex.scale(scaleDirX, scaleDirY);\r\n        ex.translate(-origin.x, -origin.y);\r\n    }\r\n    _flip(ex) {\r\n        if (this.flipHorizontal) {\r\n            ex.translate(this.width / this.scale.x, 0);\r\n            ex.scale(-1, 1);\r\n        }\r\n        if (this.flipVertical) {\r\n            ex.translate(0, this.height / this.scale.y);\r\n            ex.scale(1, -1);\r\n        }\r\n    }\r\n    /**\r\n     * Apply any additional work after [[Graphic._drawImage]] and restore the context state.\r\n     * @param ex\r\n     */\r\n    _postDraw(ex) {\r\n        if (this.showDebug) {\r\n            ex.debug.drawRect(0, 0, this.width, this.height);\r\n        }\r\n        ex.restore();\r\n    }\r\n}\r\nGraphic._ID = 0;\r\n\n;// CONCATENATED MODULE: ./Graphics/Sprite.ts\n\r\n\r\nclass Sprite extends Graphic {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super(options);\r\n        this._logger = Logger.getInstance();\r\n        this._dirty = true;\r\n        this._logNotLoadedWarning = false;\r\n        this.image = options.image;\r\n        const { width, height } = options;\r\n        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };\r\n        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };\r\n        this._updateSpriteDimensions();\r\n        this.image.ready.then(() => {\r\n            this._updateSpriteDimensions();\r\n        });\r\n    }\r\n    static from(image) {\r\n        return new Sprite({\r\n            image: image\r\n        });\r\n    }\r\n    get width() {\r\n        return Math.abs(this.destSize.width * this.scale.x);\r\n    }\r\n    get height() {\r\n        return Math.abs(this.destSize.height * this.scale.y);\r\n    }\r\n    set width(newWidth) {\r\n        newWidth /= Math.abs(this.scale.x);\r\n        this.destSize.width = newWidth;\r\n        super.width = Math.ceil(this.destSize.width);\r\n    }\r\n    set height(newHeight) {\r\n        newHeight /= Math.abs(this.scale.y);\r\n        this.destSize.height = newHeight;\r\n        super.height = Math.ceil(this.destSize.height);\r\n    }\r\n    _updateSpriteDimensions() {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const { width: nativeWidth, height: nativeHeight } = this.image;\r\n        // This code uses || to avoid 0's\r\n        // If the source is not specified, use the native dimension\r\n        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;\r\n        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;\r\n        // If the destination is not specified, use the source if specified, then native\r\n        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;\r\n        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;\r\n        this.width = Math.ceil(this.destSize.width) * this.scale.x;\r\n        this.height = Math.ceil(this.destSize.height) * this.scale.y;\r\n    }\r\n    _preDraw(ex, x, y) {\r\n        if (this.image.isLoaded() && this._dirty) {\r\n            this._dirty = false;\r\n            this._updateSpriteDimensions();\r\n        }\r\n        super._preDraw(ex, x, y);\r\n    }\r\n    _drawImage(ex, x, y) {\r\n        if (this.image.isLoaded()) {\r\n            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);\r\n        }\r\n        else {\r\n            if (!this._logNotLoadedWarning) {\r\n                this._logger.warn(`ImageSource ${this.image.path}` +\r\n                    ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\\n\\n` +\r\n                    `Read https://excaliburjs.com/docs/imagesource for more information.`);\r\n            }\r\n            this._logNotLoadedWarning = true;\r\n        }\r\n    }\r\n    clone() {\r\n        return new Sprite({\r\n            image: this.image,\r\n            sourceView: { ...this.sourceView },\r\n            destSize: { ...this.destSize },\r\n            ...this.cloneGraphicOptions()\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Filtering.ts\n/**\r\n * Describes the different image filtering modes\r\n */\r\nvar ImageFiltering;\r\n(function (ImageFiltering) {\r\n    /**\r\n     * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.\r\n     *\r\n     * Useful for Pixel art aesthetics.\r\n     */\r\n    ImageFiltering[\"Pixel\"] = \"Pixel\";\r\n    /**\r\n     * Blended is useful when you have high resolution artwork and would like it blended and smoothed\r\n     */\r\n    ImageFiltering[\"Blended\"] = \"Blended\";\r\n})(ImageFiltering || (ImageFiltering = {}));\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/texture-loader.ts\n\r\n\r\n/**\r\n * Manages loading image sources into webgl textures, a unique id is associated with all sources\r\n */\r\nclass TextureLoader {\r\n    static register(context) {\r\n        TextureLoader._GL = context;\r\n        TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);\r\n    }\r\n    /**\r\n     * Get the WebGL Texture from a source image\r\n     * @param image\r\n     */\r\n    static get(image) {\r\n        return TextureLoader._TEXTURE_MAP.get(image);\r\n    }\r\n    /**\r\n     * Returns whether a source image has been loaded as a texture\r\n     * @param image\r\n     */\r\n    static has(image) {\r\n        return TextureLoader._TEXTURE_MAP.has(image);\r\n    }\r\n    /**\r\n     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered\r\n     * @param image Source graphic\r\n     * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture\r\n     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed\r\n     */\r\n    static load(image, filtering, forceUpdate = false) {\r\n        // Ignore loading if webgl is not registered\r\n        const gl = TextureLoader._GL;\r\n        if (!gl) {\r\n            return null;\r\n        }\r\n        let tex = null;\r\n        // If reuse the texture if it's from the same source\r\n        if (TextureLoader.has(image)) {\r\n            tex = TextureLoader.get(image);\r\n        }\r\n        // Update existing webgl texture and return early\r\n        if (tex) {\r\n            if (forceUpdate) {\r\n                gl.bindTexture(gl.TEXTURE_2D, tex);\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            }\r\n            return tex;\r\n        }\r\n        // No texture exists create a new one\r\n        tex = gl.createTexture();\r\n        TextureLoader.checkImageSizeSupportedAndLog(image);\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        // NEAREST for pixel art, LINEAR for hi-res\r\n        const filterMode = filtering !== null && filtering !== void 0 ? filtering : TextureLoader.filtering;\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        TextureLoader._TEXTURE_MAP.set(image, tex);\r\n        return tex;\r\n    }\r\n    static delete(image) {\r\n        // Ignore loading if webgl is not registered\r\n        const gl = TextureLoader._GL;\r\n        if (!gl) {\r\n            return null;\r\n        }\r\n        let tex = null;\r\n        if (TextureLoader.has(image)) {\r\n            tex = TextureLoader.get(image);\r\n            gl.deleteTexture(tex);\r\n        }\r\n    }\r\n    /**\r\n     * Takes an image and returns if it meets size criteria for hardware\r\n     * @param image\r\n     * @returns if the image will be supported at runtime\r\n     */\r\n    static checkImageSizeSupportedAndLog(image) {\r\n        var _a;\r\n        const originalSrc = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : 'internal canvas bitmap';\r\n        if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {\r\n            TextureLoader._LOGGER.error(`The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of ` +\r\n                `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image `\r\n                + `for excalibur to render properly.\\n\\nImages will likely render as black rectangles.\\n\\n` +\r\n                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n            return false;\r\n        }\r\n        else if (image.width > 4096 || image.height > 4096) {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits\r\n            TextureLoader._LOGGER.warn(`The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, ` +\r\n                `it is recommended you resize images to a maximum (4096x4096).\\n\\n` +\r\n                `Images will likely render as black rectangles on some mobile platforms.\\n\\n` +\r\n                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n        }\r\n        return true;\r\n    }\r\n}\r\nTextureLoader._LOGGER = Logger.getInstance();\r\n/**\r\n * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]\r\n */\r\nTextureLoader.filtering = ImageFiltering.Blended;\r\nTextureLoader._TEXTURE_MAP = new Map();\r\nTextureLoader._MAX_TEXTURE_SIZE = 0;\r\n\n;// CONCATENATED MODULE: ./Graphics/ImageSource.ts\n\r\n\r\n\r\n\r\n\r\nclass ImageSource {\r\n    /**\r\n     * The path to the image, can also be a data url like 'data:image/'\r\n     * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute\r\n     * @param bustCache {boolean} Should excalibur add a cache busting querystring?\r\n     * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]\r\n     */\r\n    constructor(path, bustCache = false, filtering) {\r\n        this.path = path;\r\n        this._logger = Logger.getInstance();\r\n        /**\r\n         * Access to the underlying html image element\r\n         */\r\n        this.data = new Image();\r\n        this._readyFuture = new Future();\r\n        /**\r\n         * Promise the resolves when the image is loaded and ready for use, does not initiate loading\r\n         */\r\n        this.ready = this._readyFuture.promise;\r\n        this._resource = new Resource(path, 'blob', bustCache);\r\n        this._filtering = filtering;\r\n        if (path.endsWith('.svg') || path.endsWith('.gif')) {\r\n            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);\r\n        }\r\n    }\r\n    /**\r\n     * The original size of the source image in pixels\r\n     */\r\n    get width() {\r\n        return this.image.naturalWidth;\r\n    }\r\n    /**\r\n     * The original height of the source image in pixels\r\n     */\r\n    get height() {\r\n        return this.image.naturalHeight;\r\n    }\r\n    /**\r\n     * Returns true if the Texture is completely loaded and is ready\r\n     * to be drawn.\r\n     */\r\n    isLoaded() {\r\n        if (!this._src) {\r\n            // this boosts speed of access\r\n            this._src = this.data.src;\r\n        }\r\n        return !!this._src;\r\n    }\r\n    get image() {\r\n        return this.data;\r\n    }\r\n    /**\r\n     * Begins loading the image and returns a promise that resolves when the image is loaded\r\n     */\r\n    async load() {\r\n        if (this.isLoaded()) {\r\n            return this.data;\r\n        }\r\n        try {\r\n            // Load base64 or blob if needed\r\n            let url;\r\n            if (!this.path.includes('data:image/')) {\r\n                const blob = await this._resource.load();\r\n                url = URL.createObjectURL(blob);\r\n            }\r\n            else {\r\n                url = this.path;\r\n            }\r\n            // Decode the image\r\n            const image = new Image();\r\n            // Use Image.onload over Image.decode()\r\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7\r\n            // Otherwise chrome will throw still Image.decode() failures for large textures\r\n            const loadedFuture = new Future();\r\n            image.onload = () => loadedFuture.resolve();\r\n            image.src = url;\r\n            image.setAttribute('data-original-src', this.path);\r\n            await loadedFuture.promise;\r\n            // Set results\r\n            this.data = image;\r\n        }\r\n        catch (error) {\r\n            throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;\r\n        }\r\n        TextureLoader.load(this.data, this._filtering);\r\n        // todo emit complete\r\n        this._readyFuture.resolve(this.data);\r\n        return this.data;\r\n    }\r\n    /**\r\n     * Build a sprite from this ImageSource\r\n     */\r\n    toSprite() {\r\n        return Sprite.from(this);\r\n    }\r\n    /**\r\n     * Unload images from memory\r\n     */\r\n    unload() {\r\n        this.data = new Image();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/SpriteSheet.ts\n\r\n\r\n/**\r\n * Represents a collection of sprites from a source image with some organization in a grid\r\n */\r\nclass SpriteSheet {\r\n    /**\r\n     * Build a new sprite sheet from a list of sprites\r\n     *\r\n     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n     * @param options\r\n     */\r\n    constructor(options) {\r\n        this._logger = Logger.getInstance();\r\n        this.sprites = [];\r\n        const { sprites, rows, columns } = options;\r\n        this.sprites = sprites;\r\n        this.rows = rows !== null && rows !== void 0 ? rows : 1;\r\n        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;\r\n    }\r\n    /**\r\n     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left\r\n     * @param x\r\n     * @param y\r\n     */\r\n    getSprite(x, y) {\r\n        if (x >= this.columns || x < 0) {\r\n            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);\r\n            return null;\r\n        }\r\n        if (y >= this.rows || y < 0) {\r\n            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);\r\n            return null;\r\n        }\r\n        const spriteIndex = x + y * this.columns;\r\n        return this.sprites[spriteIndex];\r\n    }\r\n    /**\r\n     * Create a sprite sheet from a sparse set of [[SourceView]] rectangles\r\n     * @param options\r\n     */\r\n    static fromImageSourceWithSourceViews(options) {\r\n        const sprites = options.sourceViews.map(sourceView => {\r\n            return new Sprite({\r\n                image: options.image,\r\n                sourceView\r\n            });\r\n        });\r\n        return new SpriteSheet({ sprites });\r\n    }\r\n    /**\r\n     * Create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n     *\r\n     * Example:\r\n     * ```\r\n     * const spriteSheet = SpriteSheet.fromImageSource({\r\n     *   image: imageSource,\r\n     *   grid: {\r\n     *     rows: 5,\r\n     *     columns: 2,\r\n     *     spriteWidth: 32, // pixels\r\n     *     spriteHeight: 32 // pixels\r\n     *   },\r\n     *   // Optionally specify spacing\r\n     *   spacing: {\r\n     *     // pixels from the top left to start the sprite parsing\r\n     *     originOffset: {\r\n     *       x: 5,\r\n     *       y: 5\r\n     *     },\r\n     *     // pixels between each sprite while parsing\r\n     *     margin: {\r\n     *       x: 1,\r\n     *       y: 1\r\n     *     }\r\n     *   }\r\n     * })\r\n     * ```\r\n     *\r\n     * @param options\r\n     */\r\n    static fromImageSource(options) {\r\n        var _a;\r\n        const sprites = [];\r\n        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};\r\n        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;\r\n        const offsetDefaults = { x: 0, y: 0, ...originOffset };\r\n        const marginDefaults = { x: 0, y: 0, ...margin };\r\n        for (let x = 0; x < cols; x++) {\r\n            for (let y = 0; y < rows; y++) {\r\n                sprites[x + y * cols] = new Sprite({\r\n                    image: image,\r\n                    sourceView: {\r\n                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,\r\n                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,\r\n                        width: spriteWidth,\r\n                        height: spriteHeight\r\n                    },\r\n                    destSize: { height: spriteHeight, width: spriteWidth }\r\n                });\r\n            }\r\n        }\r\n        return new SpriteSheet({\r\n            sprites: sprites,\r\n            rows: rows,\r\n            columns: cols\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/SpriteFont.ts\n\r\n\r\n\r\n\r\nclass SpriteFont extends Graphic {\r\n    constructor(options) {\r\n        super(options);\r\n        this._text = '';\r\n        this.alphabet = '';\r\n        this.shadow = null;\r\n        this.caseInsensitive = false;\r\n        this.spacing = 0;\r\n        this._logger = Logger.getInstance();\r\n        this._alreadyWarnedAlphabet = false;\r\n        this._alreadyWarnedSpriteSheet = false;\r\n        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;\r\n        this.alphabet = alphabet;\r\n        this.spriteSheet = spriteSheet;\r\n        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;\r\n        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;\r\n        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;\r\n    }\r\n    _getCharacterSprites(text) {\r\n        const results = [];\r\n        // handle case insensitive\r\n        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;\r\n        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;\r\n        // for each letter in text\r\n        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {\r\n            // find the sprite index in alphabet , if there is an error pick the first\r\n            const letter = textToRender[letterIndex];\r\n            let spriteIndex = alphabet.indexOf(letter);\r\n            if (spriteIndex === -1) {\r\n                spriteIndex = 0;\r\n                if (!this._alreadyWarnedAlphabet) {\r\n                    this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);\r\n                    this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n                    this._alreadyWarnedAlphabet = true;\r\n                }\r\n            }\r\n            const letterSprite = this.spriteSheet.sprites[spriteIndex];\r\n            if (letterSprite) {\r\n                results.push(letterSprite);\r\n            }\r\n            else {\r\n                if (!this._alreadyWarnedSpriteSheet) {\r\n                    this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);\r\n                    this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n                    this._alreadyWarnedSpriteSheet = true;\r\n                }\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    measureText(text) {\r\n        const lines = text.split('\\n');\r\n        const maxWidthLine = lines.reduce((a, b) => {\r\n            return a.length > b.length ? a : b;\r\n        });\r\n        const sprites = this._getCharacterSprites(maxWidthLine);\r\n        let width = 0;\r\n        let height = 0;\r\n        for (const sprite of sprites) {\r\n            width += sprite.width + this.spacing;\r\n            height = Math.max(height, sprite.height);\r\n        }\r\n        return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);\r\n    }\r\n    _drawImage(ex, x, y) {\r\n        let xCursor = 0;\r\n        let yCursor = 0;\r\n        let height = 0;\r\n        const lines = this._text.split('\\n');\r\n        for (const line of lines) {\r\n            for (const sprite of this._getCharacterSprites(line)) {\r\n                // draw it in the right spot and increase the cursor by sprite width\r\n                sprite.draw(ex, x + xCursor, y + yCursor);\r\n                xCursor += sprite.width + this.spacing;\r\n                height = Math.max(height, sprite.height);\r\n            }\r\n            xCursor = 0;\r\n            yCursor += height;\r\n        }\r\n    }\r\n    render(ex, text, _color, x, y) {\r\n        // SpriteFont doesn't support _color, yet...\r\n        this._text = text;\r\n        const bounds = this.measureText(text);\r\n        this.width = bounds.width;\r\n        this.height = bounds.height;\r\n        if (this.shadow) {\r\n            ex.save();\r\n            ex.translate(this.shadow.offset.x, this.shadow.offset.y);\r\n            this.draw(ex, x, y);\r\n            ex.restore();\r\n        }\r\n        this.draw(ex, x, y);\r\n    }\r\n    clone() {\r\n        return new SpriteFont({\r\n            alphabet: this.alphabet,\r\n            spriteSheet: this.spriteSheet,\r\n            spacing: this.spacing\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/debug-font.png\n/* harmony default export */ const debug_font = (\"data:image/png;base64,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\");\n;// CONCATENATED MODULE: ./Graphics/Context/debug-text.ts\n\r\n\r\n/**\r\n * Internal debugtext helper\r\n */\r\nclass DebugText {\r\n    constructor() {\r\n        /**\r\n         * base64 font\r\n         */\r\n        this.fontSheet = debug_font;\r\n        this.size = 16;\r\n        this.load();\r\n    }\r\n    load() {\r\n        this._imageSource = new ImageSource(this.fontSheet);\r\n        return this._imageSource.load().then(() => {\r\n            this._spriteSheet = SpriteSheet.fromImageSource({\r\n                image: this._imageSource,\r\n                grid: {\r\n                    rows: 3,\r\n                    columns: 16,\r\n                    spriteWidth: 16,\r\n                    spriteHeight: 16\r\n                }\r\n            });\r\n            this._spriteFont = new SpriteFont({\r\n                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\\'&.\"?-()+ ',\r\n                caseInsensitive: true,\r\n                spriteSheet: this._spriteSheet,\r\n                spacing: -6\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Writes debug text using the built in sprint font\r\n     * @param ctx\r\n     * @param text\r\n     * @param pos\r\n     */\r\n    write(ctx, text, pos) {\r\n        if (this._imageSource.isLoaded()) {\r\n            this._spriteFont.render(ctx, text, null, pos.x, pos.y);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/render-source.ts\nclass RenderSource {\r\n    constructor(_gl, _texture) {\r\n        this._gl = _gl;\r\n        this._texture = _texture;\r\n    }\r\n    use() {\r\n        const gl = this._gl;\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this._texture);\r\n    }\r\n    disable() {\r\n        const gl = this._gl;\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/render-target.ts\n\r\nclass RenderTarget {\r\n    constructor(options) {\r\n        this.width = options.width;\r\n        this.height = options.height;\r\n        this._gl = options.gl;\r\n        this._setupFramebuffer();\r\n    }\r\n    setResolution(width, height) {\r\n        const gl = this._gl;\r\n        this.width = width;\r\n        this.height = height;\r\n        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n    }\r\n    get frameBuffer() {\r\n        return this._frameBuffer;\r\n    }\r\n    get frameTexture() {\r\n        return this._frameTexture;\r\n    }\r\n    _setupFramebuffer() {\r\n        // Allocates frame buffer\r\n        const gl = this._gl;\r\n        this._frameTexture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n        // set the filtering so we don't need mips\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        // attach the texture as the first color attachment\r\n        const attachmentPoint = gl.COLOR_ATTACHMENT0;\r\n        // After this bind all draw calls will draw to this framebuffer texture\r\n        this._frameBuffer = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);\r\n        // Reset after initialized\r\n        this.disable();\r\n    }\r\n    toRenderSource() {\r\n        const source = new RenderSource(this._gl, this._frameTexture);\r\n        return source;\r\n    }\r\n    /**\r\n     * When called, all drawing gets redirected to this render target\r\n     */\r\n    use() {\r\n        const gl = this._gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n        // very important to set the viewport to the size of the framebuffer texture\r\n        gl.viewport(0, 0, this.width, this.height);\r\n    }\r\n    /**\r\n     * When called, all drawing is sent back to the canvas\r\n     */\r\n    disable() {\r\n        const gl = this._gl;\r\n        // passing null switches rendering back to the canvas\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/webgl-adapter.ts\n/**\r\n * Must be accessed after Engine construction time to ensure the context has been created\r\n */\r\nclass ExcaliburWebGLContextAccessor {\r\n    static clear() {\r\n        ExcaliburWebGLContextAccessor._GL = null;\r\n    }\r\n    static register(gl) {\r\n        ExcaliburWebGLContextAccessor._GL = gl;\r\n    }\r\n    // current webgl context\r\n    static get gl() {\r\n        if (!ExcaliburWebGLContextAccessor._GL) {\r\n            throw Error('Attempted gl access before init');\r\n        }\r\n        return ExcaliburWebGLContextAccessor._GL;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-vertex.glsl\n/* harmony default export */ const line_vertex = (\"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\nout lowp vec4 v_color;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Passthrough the color\\r\\n   v_color = a_color;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-fragment.glsl\n/* harmony default export */ const line_fragment = (\"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Color\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  fragColor = v_color;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/webgl-util.ts\n/**\r\n * Return the size of the GlType in bytes\r\n * @param gl\r\n * @param type\r\n */\r\nfunction getGlTypeSizeBytes(gl, type) {\r\n    switch (type) {\r\n        case gl.FLOAT:\r\n            return 4;\r\n        case gl.SHORT:\r\n            return 2;\r\n        case gl.UNSIGNED_SHORT:\r\n            return 2;\r\n        case gl.BYTE:\r\n            return 1;\r\n        case gl.UNSIGNED_BYTE:\r\n            return 1;\r\n        default:\r\n            return 1;\r\n    }\r\n}\r\n/**\r\n * Based on the type return the number of attribute components\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n * @param gl\r\n * @param type\r\n */\r\nfunction getAttributeComponentSize(gl, type) {\r\n    switch (type) {\r\n        case gl.LOW_FLOAT:\r\n        case gl.HIGH_FLOAT:\r\n        case gl.FLOAT:\r\n            return 1;\r\n        case gl.FLOAT_VEC2:\r\n            return 2;\r\n        case gl.FLOAT_VEC3:\r\n            return 3;\r\n        case gl.FLOAT_VEC4:\r\n            return 4;\r\n        case gl.BYTE:\r\n            return 1;\r\n        case gl.UNSIGNED_BYTE:\r\n            return 1;\r\n        case gl.UNSIGNED_SHORT:\r\n        case gl.SHORT:\r\n            return 1;\r\n        default:\r\n            return 1;\r\n    }\r\n}\r\n/**\r\n * Based on the attribute return the corresponding supported attrib pointer type\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n *\r\n * @param gl\r\n * @param type\r\n */\r\nfunction getAttributePointerType(gl, type) {\r\n    switch (type) {\r\n        case gl.LOW_FLOAT:\r\n        case gl.HIGH_FLOAT:\r\n        case gl.FLOAT:\r\n        case gl.FLOAT_VEC2:\r\n        case gl.FLOAT_VEC3:\r\n        case gl.FLOAT_VEC4:\r\n            return gl.FLOAT;\r\n        case gl.BYTE:\r\n            return gl.BYTE;\r\n        case gl.UNSIGNED_BYTE:\r\n            return gl.UNSIGNED_BYTE;\r\n        case gl.SHORT:\r\n            return gl.SHORT;\r\n        case gl.UNSIGNED_SHORT:\r\n            return gl.UNSIGNED_SHORT;\r\n        default:\r\n            return gl.FLOAT;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/shader.ts\n\r\n\r\nclass Shader {\r\n    /**\r\n     * Create a shader program in excalibur\r\n     * @param options specify shader vertex and fragment source\r\n     */\r\n    constructor(options) {\r\n        this._gl = ExcaliburWebGLContextAccessor.gl;\r\n        this.uniforms = {};\r\n        this.attributes = {};\r\n        this._compiled = false;\r\n        const { vertexSource, fragmentSource } = options;\r\n        this.vertexSource = vertexSource;\r\n        this.fragmentSource = fragmentSource;\r\n    }\r\n    get compiled() {\r\n        return this._compiled;\r\n    }\r\n    /**\r\n     * Binds the shader program\r\n     */\r\n    use() {\r\n        const gl = this._gl;\r\n        gl.useProgram(this.program);\r\n        Shader._ACTIVE_SHADER_INSTANCE = this;\r\n    }\r\n    isCurrentlyBound() {\r\n        return Shader._ACTIVE_SHADER_INSTANCE === this;\r\n    }\r\n    /**\r\n     * Compile the current shader against a webgl context\r\n     */\r\n    compile() {\r\n        const gl = this._gl;\r\n        const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);\r\n        const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);\r\n        this.program = this._createProgram(gl, vertexShader, fragmentShader);\r\n        const attributes = this.getAttributes();\r\n        for (const attribute of attributes) {\r\n            this.attributes[attribute.name] = attribute;\r\n        }\r\n        const uniforms = this.getUniforms();\r\n        for (const uniform of uniforms) {\r\n            this.uniforms[uniform.name] = uniform;\r\n        }\r\n        this._compiled = true;\r\n        return this.program;\r\n    }\r\n    getUniforms() {\r\n        const gl = this._gl;\r\n        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\r\n        const uniforms = [];\r\n        for (let i = 0; i < uniformCount; i++) {\r\n            const uniform = gl.getActiveUniform(this.program, i);\r\n            const uniformLocation = gl.getUniformLocation(this.program, uniform.name);\r\n            uniforms.push({\r\n                name: uniform.name,\r\n                glType: uniform.type,\r\n                location: uniformLocation\r\n            });\r\n        }\r\n        return uniforms;\r\n    }\r\n    getAttributes() {\r\n        const gl = this._gl;\r\n        const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\r\n        const attributes = [];\r\n        for (let i = 0; i < attributeCount; i++) {\r\n            const attribute = gl.getActiveAttrib(this.program, i);\r\n            const attributeLocation = gl.getAttribLocation(this.program, attribute.name);\r\n            attributes.push({\r\n                name: attribute.name,\r\n                glType: getAttributePointerType(gl, attribute.type),\r\n                size: getAttributeComponentSize(gl, attribute.type),\r\n                location: attributeLocation,\r\n                normalized: false\r\n            });\r\n        }\r\n        return attributes;\r\n    }\r\n    /**\r\n     * Set a texture in a gpu texture slot\r\n     * @param slotNumber\r\n     * @param texture\r\n     */\r\n    setTexture(slotNumber, texture) {\r\n        const gl = this._gl;\r\n        gl.activeTexture(gl.TEXTURE0 + slotNumber);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    }\r\n    /**\r\n     * Set an integer uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformInt(name, value) {\r\n        this.setUniform('uniform1i', name, ~~value);\r\n    }\r\n    /**\r\n     * Set an integer array uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformIntArray(name, value) {\r\n        this.setUniform('uniform1iv', name, value);\r\n    }\r\n    /**\r\n     * Set a boolean uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformBoolean(name, value) {\r\n        this.setUniform('uniform1i', name, value ? 1 : 0);\r\n    }\r\n    /**\r\n     * Set a float uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformFloat(name, value) {\r\n        this.setUniform('uniform1f', name, value);\r\n    }\r\n    /**\r\n     * Set a float array uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformFloatArray(name, value) {\r\n        this.setUniform('uniform1fv', name, value);\r\n    }\r\n    /**\r\n     * Set a [[Vector]] uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformFloatVector(name, value) {\r\n        this.setUniform('uniform2f', name, value.x, value.y);\r\n    }\r\n    /**\r\n     * Set an [[Matrix]] uniform for the current shader\r\n     *\r\n     * **Important** Must call ex.Shader.use() before setting a uniform!\r\n     *\r\n     * @param name\r\n     * @param value\r\n     */\r\n    setUniformMatrix(name, value) {\r\n        this.setUniform('uniformMatrix4fv', name, false, value.data);\r\n    }\r\n    /**\r\n     * Set any available uniform type in webgl\r\n     *\r\n     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);\r\n     */\r\n    setUniform(uniformType, name, ...value) {\r\n        if (!this._compiled) {\r\n            throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);\r\n        }\r\n        if (!this.isCurrentlyBound()) {\r\n            throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +\r\n                ' must call `shader.use()` before setting uniforms');\r\n        }\r\n        const gl = this._gl;\r\n        const location = gl.getUniformLocation(this.program, name);\r\n        if (location) {\r\n            const args = [location, ...value];\r\n            this._gl[uniformType].apply(this._gl, args);\r\n        }\r\n        else {\r\n            throw Error(`Uniform ${uniformType}:${name} doesn\\'t exist or is not used in the shader source code,` +\r\n                ' unused uniforms are optimized away by most browsers');\r\n        }\r\n    }\r\n    _createProgram(gl, vertexShader, fragmentShader) {\r\n        const program = gl.createProgram();\r\n        if (program === null) {\r\n            throw Error('Could not create graphics shader program');\r\n        }\r\n        // attach the shaders.\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        // link the program.\r\n        gl.linkProgram(program);\r\n        const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!success) {\r\n            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);\r\n        }\r\n        return program;\r\n    }\r\n    _compileShader(gl, source, type) {\r\n        const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';\r\n        const shader = gl.createShader(type);\r\n        if (shader === null) {\r\n            throw Error(`Could not build shader: [${source}]`);\r\n        }\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!success) {\r\n            const errorInfo = gl.getShaderInfoLog(shader);\r\n            throw Error(`Could not compile ${typeName} shader:\\n\\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);\r\n        }\r\n        return shader;\r\n    }\r\n    _processSourceForError(source, errorInfo) {\r\n        const lines = source.split('\\n');\r\n        const errorLineStart = errorInfo.search(/\\d:\\d/);\r\n        const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);\r\n        const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(':').map(v => Number(v));\r\n        for (let i = 0; i < lines.length; i++) {\r\n            lines[i] = `${i + 1}: ${lines[i]}${error2 === (i + 1) ? ' <----- ERROR!' : ''}`;\r\n        }\r\n        return '\\n\\nSource:\\n' + lines.join('\\n');\r\n    }\r\n}\r\nShader._ACTIVE_SHADER_INSTANCE = null;\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/vertex-buffer.ts\n\r\n/**\r\n * Helper around vertex buffer to simplify creating and uploading geometry\r\n *\r\n * Under the hood uses Float32Array\r\n */\r\nclass VertexBuffer {\r\n    constructor(options) {\r\n        this._gl = ExcaliburWebGLContextAccessor.gl;\r\n        /**\r\n         * If the vertices never change switching 'static' can be more efficient on the gpu\r\n         *\r\n         * Default is 'dynamic'\r\n         */\r\n        this.type = 'dynamic';\r\n        const { size, type, data } = options;\r\n        this.buffer = this._gl.createBuffer();\r\n        if (!data && !size) {\r\n            throw Error('Must either provide data or a size to the VertexBuffer');\r\n        }\r\n        if (!data) {\r\n            this.bufferData = new Float32Array(size);\r\n        }\r\n        else {\r\n            this.bufferData = data;\r\n        }\r\n        this.type = type !== null && type !== void 0 ? type : this.type;\r\n        // Allocate buffer\r\n        const gl = this._gl;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n    }\r\n    /**\r\n     * Bind this vertex buffer\r\n     */\r\n    bind() {\r\n        const gl = this._gl;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    }\r\n    /**\r\n     * Upload vertex buffer geometry to the GPU\r\n     */\r\n    upload(count) {\r\n        const gl = this._gl;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        if (count) {\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);\r\n        }\r\n        else {\r\n            // TODO always use bufferSubData? need to perf test it\r\n            gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/vertex-layout.ts\n\r\n\r\n\r\n/**\r\n * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing\r\n * the memory layout for your vertices inside a particular buffer\r\n *\r\n * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.\r\n *\r\n * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you\r\n */\r\nclass VertexLayout {\r\n    constructor(options) {\r\n        this._gl = ExcaliburWebGLContextAccessor.gl;\r\n        this._logger = Logger.getInstance();\r\n        this._layout = [];\r\n        this._attributes = [];\r\n        this._vertexTotalSizeBytes = 0;\r\n        const { shader, vertexBuffer, attributes } = options;\r\n        this._vertexBuffer = vertexBuffer;\r\n        this._attributes = attributes;\r\n        this._shader = shader;\r\n        this.initialize();\r\n    }\r\n    get vertexBuffer() {\r\n        return this._vertexBuffer;\r\n    }\r\n    get attributes() {\r\n        return this._attributes;\r\n    }\r\n    /**\r\n     * Total number of bytes that the vertex will take up\r\n     */\r\n    get totalVertexSizeBytes() {\r\n        return this._vertexTotalSizeBytes;\r\n    }\r\n    /**\r\n     * Layouts need shader locations and must be bound to a shader\r\n     */\r\n    initialize() {\r\n        if (!this._shader.compiled) {\r\n            throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');\r\n        }\r\n        this._layout.length = 0;\r\n        const shaderAttributes = this._shader.attributes;\r\n        for (const attribute of this._attributes) {\r\n            const attrib = shaderAttributes[attribute[0]];\r\n            if (!attrib) {\r\n                throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}` +\r\n                    ` not found in the shader source code:\\n ${this._shader.vertexSource}`);\r\n            }\r\n            if (attrib.size !== attribute[1]) {\r\n                throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],`\r\n                    + ` doesnt match shader source size ${attrib.size}:\\n ${this._shader.vertexSource}`);\r\n            }\r\n            this._layout.push(attrib);\r\n        }\r\n        // calc size\r\n        let componentsPerVertex = 0;\r\n        for (const vertAttribute of this._layout) {\r\n            const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);\r\n            this._vertexTotalSizeBytes += typeSize * vertAttribute.size;\r\n            componentsPerVertex += vertAttribute.size;\r\n        }\r\n        if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {\r\n            this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer`\r\n                + ` (${this._vertexBuffer.bufferData.length})`);\r\n        }\r\n    }\r\n    /**\r\n     * Bind this layout with it's associated vertex buffer\r\n     *\r\n     * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout\r\n     */\r\n    use(uploadBuffer = false, count) {\r\n        const gl = this._gl;\r\n        if (!this._shader.isCurrentlyBound()) {\r\n            throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');\r\n        }\r\n        this._vertexBuffer.bind();\r\n        if (uploadBuffer) {\r\n            this._vertexBuffer.upload(count);\r\n        }\r\n        let offset = 0;\r\n        // TODO switch to VAOs if the extension is\r\n        for (const vert of this._layout) {\r\n            gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);\r\n            gl.enableVertexAttribArray(vert.location);\r\n            offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/GraphicsDiagnostics.ts\nclass GraphicsDiagnostics {\r\n    static clear() {\r\n        GraphicsDiagnostics.DrawCallCount = 0;\r\n        GraphicsDiagnostics.DrawnImagesCount = 0;\r\n    }\r\n}\r\nGraphicsDiagnostics.DrawCallCount = 0;\r\nGraphicsDiagnostics.DrawnImagesCount = 0;\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-renderer.ts\n\r\n\r\n\r\n\r\nclass LineRenderer {\r\n    constructor() {\r\n        this.type = 'ex.line';\r\n        this.priority = 0;\r\n        this._maxLines = 10922;\r\n        this._vertexIndex = 0;\r\n        this._lineCount = 0;\r\n    }\r\n    initialize(gl, context) {\r\n        this._gl = gl;\r\n        this._context = context;\r\n        this._shader = new Shader({\r\n            vertexSource: line_vertex,\r\n            fragmentSource: line_fragment\r\n        });\r\n        this._shader.compile();\r\n        this._shader.use();\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        this._vertexBuffer = new VertexBuffer({\r\n            size: 6 * 2 * this._maxLines,\r\n            type: 'dynamic'\r\n        });\r\n        this._layout = new VertexLayout({\r\n            vertexBuffer: this._vertexBuffer,\r\n            shader: this._shader,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_color', 4]\r\n            ]\r\n        });\r\n    }\r\n    draw(start, end, color) {\r\n        // Force a render if the batch is full\r\n        if (this._isFull()) {\r\n            this.flush();\r\n        }\r\n        this._lineCount++;\r\n        const transform = this._context.getTransform();\r\n        const finalStart = transform.multiply(start);\r\n        const finalEnd = transform.multiply(end);\r\n        const vertexBuffer = this._vertexBuffer.bufferData;\r\n        // Start\r\n        vertexBuffer[this._vertexIndex++] = finalStart.x;\r\n        vertexBuffer[this._vertexIndex++] = finalStart.y;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        // End\r\n        vertexBuffer[this._vertexIndex++] = finalEnd.x;\r\n        vertexBuffer[this._vertexIndex++] = finalEnd.y;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n    }\r\n    _isFull() {\r\n        if (this._lineCount >= this._maxLines) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    hasPendingDraws() {\r\n        return this._lineCount !== 0;\r\n    }\r\n    flush() {\r\n        // nothing to draw early exit\r\n        if (this._lineCount === 0) {\r\n            return;\r\n        }\r\n        const gl = this._gl;\r\n        this._shader.use();\r\n        this._layout.use(true);\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line\r\n        GraphicsDiagnostics.DrawnImagesCount += this._lineCount;\r\n        GraphicsDiagnostics.DrawCallCount++;\r\n        // reset\r\n        this._vertexIndex = 0;\r\n        this._lineCount = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-vertex.glsl\n/* harmony default export */ const point_vertex = (\"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\nin float a_size;\\r\\nout lowp vec4 v_color;\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n  gl_PointSize = a_size * 2.0;\\r\\n  v_color = a_color;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-fragment.glsl\n/* harmony default export */ const point_fragment = (\"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  float r = 0.0, delta = 0.0, alpha = 1.0;\\r\\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\r\\n  r = dot(cxy, cxy);\\r\\n\\r\\n  delta = fwidth(r);\\r\\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\r\\n  // \\\"premultiply\\\" the color by alpha\\r\\n  vec4 color = v_color;\\r\\n  color.a = color.a * alpha;\\r\\n  color.rgb = color.rgb * color.a;\\r\\n  fragColor = color;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-renderer.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PointRenderer {\r\n    constructor() {\r\n        this.type = 'ex.point';\r\n        this.priority = 0;\r\n        this._maxPoints = 10922;\r\n        this._pointCount = 0;\r\n        this._vertexIndex = 0;\r\n    }\r\n    initialize(gl, context) {\r\n        this._gl = gl;\r\n        this._context = context;\r\n        this._shader = new Shader({\r\n            vertexSource: point_vertex,\r\n            fragmentSource: point_fragment\r\n        });\r\n        this._shader.compile();\r\n        this._shader.use();\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        this._buffer = new VertexBuffer({\r\n            size: 7 * this._maxPoints,\r\n            type: 'dynamic'\r\n        });\r\n        this._layout = new VertexLayout({\r\n            shader: this._shader,\r\n            vertexBuffer: this._buffer,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_color', 4],\r\n                ['a_size', 1]\r\n            ]\r\n        });\r\n    }\r\n    draw(point, color, size) {\r\n        // Force a render if the batch is full\r\n        if (this._isFull()) {\r\n            this.flush();\r\n        }\r\n        this._pointCount++;\r\n        const transform = this._context.getTransform();\r\n        const opacity = this._context.opacity;\r\n        const snapToPixel = this._context.snapToPixel;\r\n        const finalPoint = transform.multiply(point);\r\n        if (snapToPixel) {\r\n            finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);\r\n            finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);\r\n        }\r\n        const vertexBuffer = this._buffer.bufferData;\r\n        vertexBuffer[this._vertexIndex++] = finalPoint.x;\r\n        vertexBuffer[this._vertexIndex++] = finalPoint.y;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a * opacity;\r\n        vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());\r\n    }\r\n    _isFull() {\r\n        if (this._pointCount >= this._maxPoints) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    hasPendingDraws() {\r\n        return this._pointCount !== 0;\r\n    }\r\n    flush() {\r\n        // nothing to draw early exit\r\n        if (this._pointCount === 0) {\r\n            return;\r\n        }\r\n        const gl = this._gl;\r\n        this._shader.use();\r\n        this._layout.use(true);\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        gl.drawArrays(gl.POINTS, 0, this._pointCount);\r\n        GraphicsDiagnostics.DrawnImagesCount += this._pointCount;\r\n        GraphicsDiagnostics.DrawCallCount++;\r\n        this._pointCount = 0;\r\n        this._vertexIndex = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-vertex.glsl\n/* harmony default export */ const screen_vertex = (\"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n  // Pass the texcoord to the fragment shader.\\r\\n  v_texcoord = a_texcoord;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-fragment.glsl\n/* harmony default export */ const screen_fragment = (\"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// The texture.\\r\\nuniform sampler2D u_texture;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   fragColor = texture(u_texture, v_texcoord);\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-pass-painter.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This is responsible for painting the entire screen during the render passes\r\n */\r\nclass ScreenPassPainter {\r\n    constructor(gl) {\r\n        this._gl = gl;\r\n        this._shader = new Shader({\r\n            vertexSource: screen_vertex,\r\n            fragmentSource: screen_fragment\r\n        });\r\n        this._shader.compile();\r\n        // Setup memory layout\r\n        this._buffer = new VertexBuffer({\r\n            type: 'static',\r\n            // clip space quad + uv since we don't need a camera\r\n            data: new Float32Array([\r\n                -1, -1, 0, 0,\r\n                -1, 1, 0, 1,\r\n                1, -1, 1, 0,\r\n                1, -1, 1, 0,\r\n                -1, 1, 0, 1,\r\n                1, 1, 1, 1\r\n            ])\r\n        });\r\n        this._layout = new VertexLayout({\r\n            shader: this._shader,\r\n            vertexBuffer: this._buffer,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_texcoord', 2]\r\n            ]\r\n        });\r\n        this._buffer.upload();\r\n    }\r\n    renderWithPostProcessor(postprocessor) {\r\n        const gl = this._gl;\r\n        postprocessor.getShader().use();\r\n        postprocessor.getLayout().use();\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n    renderToScreen() {\r\n        const gl = this._gl;\r\n        this._shader.use();\r\n        this._layout.use();\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/quad-index-buffer.ts\n\r\n\r\n/**\r\n * Helper that defines and index buffer for quad geometry\r\n *\r\n * Index buffers allow you to save space in vertex buffers when you share vertices in geometry\r\n * it is almost always worth it in terms of performance to use an index buffer.\r\n */\r\nclass QuadIndexBuffer {\r\n    /**\r\n     * @param numberOfQuads Specify the max number of quads you want to draw\r\n     * @param useUint16 Optionally force a uint16 buffer\r\n     */\r\n    constructor(numberOfQuads, useUint16) {\r\n        this._gl = ExcaliburWebGLContextAccessor.gl;\r\n        this._logger = Logger.getInstance();\r\n        const gl = this._gl;\r\n        this.buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n        const totalVertices = numberOfQuads * 6;\r\n        if (!useUint16) {\r\n            this.bufferData = new Uint32Array(totalVertices);\r\n        }\r\n        else {\r\n            // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck\r\n            const maxUint16 = 65535;\r\n            const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads\r\n            this.bufferGlType = gl.UNSIGNED_SHORT;\r\n            this.bufferData = new Uint16Array(totalVertices);\r\n            // TODO Should we error if this happens?? maybe not might crash mid game\r\n            if (numberOfQuads > maxUint16Index) {\r\n                this._logger.warn(`Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);\r\n            }\r\n        }\r\n        let currentQuad = 0;\r\n        for (let i = 0; i < totalVertices; i += 6) {\r\n            // first triangle\r\n            this.bufferData[i + 0] = currentQuad + 0;\r\n            this.bufferData[i + 1] = currentQuad + 1;\r\n            this.bufferData[i + 2] = currentQuad + 2;\r\n            // second triangle\r\n            this.bufferData[i + 3] = currentQuad + 2;\r\n            this.bufferData[i + 4] = currentQuad + 1;\r\n            this.bufferData[i + 5] = currentQuad + 3;\r\n            currentQuad += 4;\r\n        }\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n    }\r\n    get size() {\r\n        return this.bufferData.length;\r\n    }\r\n    /**\r\n     * Upload data to the GPU\r\n     */\r\n    upload() {\r\n        const gl = this._gl;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n    }\r\n    /**\r\n     * Bind this index buffer\r\n     */\r\n    bind() {\r\n        const gl = this._gl;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.frag.glsl\n/* harmony default export */ const image_renderer_frag = (\"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// Texture index\\r\\nin lowp float v_textureIndex;\\r\\n\\r\\n// Textures in the current draw\\r\\nuniform sampler2D u_textures[%%count%%];\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nin vec4 v_tint;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   // In order to support the most efficient sprite batching, we have multiple\\r\\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\\r\\n   // that do not apply to a particular sprite.\\r\\n\\r\\n   vec4 color = vec4(1.0, 0, 0, 1.0);\\r\\n\\r\\n   // GLSL is templated out to pick the right texture and set the vec4 color\\r\\n   %%texture_picker%%\\r\\n\\r\\n   color.rgb = color.rgb * v_opacity;\\r\\n   color.a = color.a * v_opacity;\\r\\n   fragColor = color * v_tint;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.vert.glsl\n/* harmony default export */ const image_renderer_vert = (\"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\n// Texture number\\r\\nin lowp float a_textureIndex;\\r\\nout lowp float v_textureIndex;\\r\\n\\r\\nin vec4 a_tint;\\r\\nout vec4 v_tint;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the UV coord to the fragment shader\\r\\n   v_texcoord = a_texcoord;\\r\\n   // Pass through the texture number to the fragment shader\\r\\n   v_textureIndex = a_textureIndex;\\r\\n   // Pass through the tint\\r\\n   v_tint = a_tint;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ImageRenderer {\r\n    constructor() {\r\n        this.type = 'ex.image';\r\n        this.priority = 0;\r\n        this._maxImages = 10922; // max(uint16) / 6 verts\r\n        this._maxTextures = 0;\r\n        // Per flush vars\r\n        this._imageCount = 0;\r\n        this._textures = [];\r\n        this._vertexIndex = 0;\r\n    }\r\n    initialize(gl, context) {\r\n        this._gl = gl;\r\n        this._context = context;\r\n        // Transform shader source\r\n        // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...\r\n        this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);\r\n        const transformedFrag = this._transformFragmentSource(image_renderer_frag, this._maxTextures);\r\n        // Compile shader\r\n        this._shader = new Shader({\r\n            fragmentSource: transformedFrag,\r\n            vertexSource: image_renderer_vert\r\n        });\r\n        this._shader.compile();\r\n        // setup uniforms\r\n        this._shader.use();\r\n        this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]\r\n        this._shader.setUniformIntArray('u_textures', [...Array(this._maxTextures)].map((_, i) => i));\r\n        // Setup memory layout\r\n        this._buffer = new VertexBuffer({\r\n            size: 10 * 4 * this._maxImages,\r\n            type: 'dynamic'\r\n        });\r\n        this._layout = new VertexLayout({\r\n            shader: this._shader,\r\n            vertexBuffer: this._buffer,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_opacity', 1],\r\n                ['a_texcoord', 2],\r\n                ['a_textureIndex', 1],\r\n                ['a_tint', 4]\r\n            ]\r\n        });\r\n        // Setup index buffer\r\n        this._quads = new QuadIndexBuffer(this._maxImages, true);\r\n    }\r\n    _transformFragmentSource(source, maxTextures) {\r\n        let newSource = source.replace('%%count%%', maxTextures.toString());\r\n        let texturePickerBuilder = '';\r\n        for (let i = 0; i < maxTextures; i++) {\r\n            if (i === 0) {\r\n                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\\n`;\r\n            }\r\n            else {\r\n                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\\n`;\r\n            }\r\n            texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\\n`;\r\n            texturePickerBuilder += `   }\\n`;\r\n        }\r\n        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);\r\n        return newSource;\r\n    }\r\n    _addImageAsTexture(image) {\r\n        const texture = TextureLoader.load(image);\r\n        if (this._textures.indexOf(texture) === -1) {\r\n            this._textures.push(texture);\r\n        }\r\n    }\r\n    _bindTextures(gl) {\r\n        // Bind textures in the correct order\r\n        for (let i = 0; i < this._maxTextures; i++) {\r\n            gl.activeTexture(gl.TEXTURE0 + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);\r\n        }\r\n    }\r\n    _getTextureIdForImage(image) {\r\n        if (image) {\r\n            return this._textures.indexOf(TextureLoader.get(image));\r\n        }\r\n        return -1;\r\n    }\r\n    _isFull() {\r\n        if (this._imageCount >= this._maxImages) {\r\n            return true;\r\n        }\r\n        if (this._textures.length >= this._maxTextures) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\r\n        var _a, _b, _c, _d;\r\n        // Force a render if the batch is full\r\n        if (this._isFull()) {\r\n            this.flush();\r\n        }\r\n        this._imageCount++;\r\n        this._addImageAsTexture(image);\r\n        let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;\r\n        let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;\r\n        let view = [0, 0, (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0, (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0];\r\n        let dest = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1];\r\n        // If destination is specified, update view and dest\r\n        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {\r\n            view = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1, (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0, (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0];\r\n            dest = [dx, dy];\r\n            width = dwidth;\r\n            height = dheight;\r\n        }\r\n        sx = view[0];\r\n        sy = view[1];\r\n        const sw = view[2];\r\n        const sh = view[3];\r\n        // transform based on current context\r\n        const transform = this._context.getTransform();\r\n        const opacity = this._context.opacity;\r\n        const snapToPixel = this._context.snapToPixel;\r\n        let topLeft = vec(dest[0], dest[1]);\r\n        let topRight = vec(dest[0] + width, dest[1]);\r\n        let bottomLeft = vec(dest[0], dest[1] + height);\r\n        let bottomRight = vec(dest[0] + width, dest[1] + height);\r\n        topLeft = transform.multiply(topLeft);\r\n        topRight = transform.multiply(topRight);\r\n        bottomLeft = transform.multiply(bottomLeft);\r\n        bottomRight = transform.multiply(bottomRight);\r\n        if (snapToPixel) {\r\n            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n            topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n            topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n        }\r\n        const tint = this._context.tint;\r\n        const textureId = this._getTextureIdForImage(image);\r\n        const imageWidth = image.width || width;\r\n        const imageHeight = image.height || height;\r\n        const uvx0 = (sx) / imageWidth;\r\n        const uvy0 = (sy) / imageHeight;\r\n        const uvx1 = (sx + sw - 0.01) / imageWidth;\r\n        const uvy1 = (sy + sh - 0.01) / imageHeight;\r\n        // update data\r\n        const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n        // (0, 0) - 0\r\n        vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n        vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = textureId;\r\n        vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.a;\r\n        // (0, 1) - 1\r\n        vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n        vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = textureId;\r\n        vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.a;\r\n        // (1, 0) - 2\r\n        vertexBuffer[this._vertexIndex++] = topRight.x;\r\n        vertexBuffer[this._vertexIndex++] = topRight.y;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = textureId;\r\n        vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.a;\r\n        // (1, 1) - 3\r\n        vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n        vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = textureId;\r\n        vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = tint.a;\r\n    }\r\n    hasPendingDraws() {\r\n        return this._imageCount !== 0;\r\n    }\r\n    flush() {\r\n        // nothing to draw early exit\r\n        if (this._imageCount === 0) {\r\n            return;\r\n        }\r\n        const gl = this._gl;\r\n        // Bind the shader\r\n        this._shader.use();\r\n        // Bind the memory layout and upload data\r\n        this._layout.use(true, 4 * 10 * this._imageCount);\r\n        // Update ortho matrix uniform\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        // Bind textures to\r\n        this._bindTextures(gl);\r\n        // Bind index buffer\r\n        this._quads.bind();\r\n        // Draw all the quads\r\n        gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);\r\n        GraphicsDiagnostics.DrawnImagesCount += this._imageCount;\r\n        GraphicsDiagnostics.DrawCallCount++;\r\n        // Reset\r\n        this._imageCount = 0;\r\n        this._vertexIndex = 0;\r\n        this._textures.length = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl\n/* harmony default export */ const rectangle_renderer_frag = (\"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\nin vec2 v_size; // in pixels\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness; // in pixels\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\\r\\n    vec2 uv = v_uv;\\r\\n    vec2 fragCoord = uv * v_size;\\r\\n    float maxX = v_size.x - v_strokeThickness;\\r\\n    float minX = v_strokeThickness;\\r\\n    float maxY = v_size.y - v_strokeThickness;\\r\\n    float minY = v_strokeThickness;\\r\\n\\r\\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\\r\\n        fragCoord.y < maxY && fragCoord.y > minY) {\\r\\n      fragColor = v_color;\\r\\n    } else {\\r\\n      fragColor = v_strokeColor;\\r\\n    }\\r\\n    fragColor.a *= v_opacity;\\r\\n    fragColor.rgb *= fragColor.a;\\r\\n\\r\\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\\r\\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\\r\\n\\r\\n    // float fHalfBorderDist      = 0.0;\\r\\n    // float fHalfBorderThickness = 0.0;\\r\\n\\r\\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \\r\\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \\r\\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else\\r\\n    // {\\r\\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\\r\\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\\r\\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\\r\\n        \\r\\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\\r\\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\\r\\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \\r\\n            \\r\\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\\r\\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\\r\\n    // }\\r\\n\\r\\n    // vec4 v4FromColor = v_strokeColor;\\r\\n    // v4FromColor.rgb *= v4FromColor.a;\\r\\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\\r\\n    // if (fHalfBorderDist < 0.0) {\\r\\n    //     v4ToColor = v_color;\\r\\n    //     v4ToColor.rgb *= v4ToColor.a;\\r\\n    // }\\r\\n\\r\\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\\r\\n\\r\\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\\r\\n    // gl_FragColor = finalColor;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl\n/* harmony default export */ const rectangle_renderer_vert = (\"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\nin vec2 a_size;\\r\\nout vec2 v_size;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through size\\r\\n   v_size = a_size;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass RectangleRenderer {\r\n    constructor() {\r\n        this.type = 'ex.rectangle';\r\n        this.priority = 0;\r\n        this._maxRectangles = 10922; // max(uint16) / 6 verts\r\n        this._rectangleCount = 0;\r\n        this._vertexIndex = 0;\r\n    }\r\n    initialize(gl, context) {\r\n        this._gl = gl;\r\n        this._context = context;\r\n        // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n        this._shader = new Shader({\r\n            fragmentSource: rectangle_renderer_frag,\r\n            vertexSource: rectangle_renderer_vert\r\n        });\r\n        this._shader.compile();\r\n        // setup uniforms\r\n        this._shader.use();\r\n        this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n        this._buffer = new VertexBuffer({\r\n            size: 16 * 4 * this._maxRectangles,\r\n            type: 'dynamic'\r\n        });\r\n        this._layout = new VertexLayout({\r\n            shader: this._shader,\r\n            vertexBuffer: this._buffer,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_uv', 2],\r\n                ['a_size', 2],\r\n                ['a_opacity', 1],\r\n                ['a_color', 4],\r\n                ['a_strokeColor', 4],\r\n                ['a_strokeThickness', 1]\r\n            ]\r\n        });\r\n        this._quads = new QuadIndexBuffer(this._maxRectangles, true);\r\n    }\r\n    _isFull() {\r\n        if (this._rectangleCount >= this._maxRectangles) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    draw(...args) {\r\n        if (args[0] instanceof Vector && args[1] instanceof Vector) {\r\n            this.drawLine.apply(this, args);\r\n        }\r\n        else {\r\n            this.drawRectangle.apply(this, args);\r\n        }\r\n    }\r\n    drawLine(start, end, color, thickness = 1) {\r\n        if (this._isFull()) {\r\n            this.flush();\r\n        }\r\n        this._rectangleCount++;\r\n        // transform based on current context\r\n        const transform = this._context.getTransform();\r\n        const opacity = this._context.opacity;\r\n        const snapToPixel = this._context.snapToPixel;\r\n        const dir = end.sub(start);\r\n        const length = dir.size;\r\n        const normal = dir.normalize().perpendicular();\r\n        const halfThick = thickness / 2;\r\n        /**\r\n         *    +---------------------^----------------------+\r\n         *    |                     | (normal)             |\r\n         *   (startx, starty)------------------>(endx, endy)\r\n         *    |                                            |\r\n         *    + -------------------------------------------+\r\n         */\r\n        const startTop = transform.multiply(normal.scale(halfThick).add(start));\r\n        const startBottom = transform.multiply(normal.scale(-halfThick).add(start));\r\n        const endTop = transform.multiply(normal.scale(halfThick).add(end));\r\n        const endBottom = transform.multiply(normal.scale(-halfThick).add(end));\r\n        if (snapToPixel) {\r\n            startTop.x = ~~(startTop.x + pixelSnapEpsilon);\r\n            startTop.y = ~~(startTop.y + pixelSnapEpsilon);\r\n            endTop.x = ~~(endTop.x + pixelSnapEpsilon);\r\n            endTop.y = ~~(endTop.y + pixelSnapEpsilon);\r\n            startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);\r\n            startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);\r\n            endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);\r\n            endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);\r\n        }\r\n        // TODO uv could be static vertex buffer\r\n        const uvx0 = 0;\r\n        const uvy0 = 0;\r\n        const uvx1 = 1;\r\n        const uvy1 = 1;\r\n        const stroke = Color.Transparent;\r\n        const strokeThickness = 0;\r\n        const width = 1;\r\n        // update data\r\n        const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n        // (0, 0) - 0\r\n        vertexBuffer[this._vertexIndex++] = startTop.x;\r\n        vertexBuffer[this._vertexIndex++] = startTop.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = length;\r\n        vertexBuffer[this._vertexIndex++] = thickness;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n        // (0, 1) - 1\r\n        vertexBuffer[this._vertexIndex++] = startBottom.x;\r\n        vertexBuffer[this._vertexIndex++] = startBottom.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = length;\r\n        vertexBuffer[this._vertexIndex++] = thickness;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n        // (1, 0) - 2\r\n        vertexBuffer[this._vertexIndex++] = endTop.x;\r\n        vertexBuffer[this._vertexIndex++] = endTop.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = length;\r\n        vertexBuffer[this._vertexIndex++] = thickness;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n        // (1, 1) - 3\r\n        vertexBuffer[this._vertexIndex++] = endBottom.x;\r\n        vertexBuffer[this._vertexIndex++] = endBottom.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = length;\r\n        vertexBuffer[this._vertexIndex++] = thickness;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n    }\r\n    drawRectangle(pos, width, height, color, stroke = Color.Transparent, strokeThickness = 0) {\r\n        if (this._isFull()) {\r\n            this.flush();\r\n        }\r\n        this._rectangleCount++;\r\n        // transform based on current context\r\n        const transform = this._context.getTransform();\r\n        const opacity = this._context.opacity;\r\n        const snapToPixel = this._context.snapToPixel;\r\n        const topLeft = transform.multiply(pos.add(vec(0, 0)));\r\n        const topRight = transform.multiply(pos.add(vec(width, 0)));\r\n        const bottomRight = transform.multiply(pos.add(vec(width, height)));\r\n        const bottomLeft = transform.multiply(pos.add(vec(0, height)));\r\n        if (snapToPixel) {\r\n            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n            topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n            topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n        }\r\n        // TODO uv could be static vertex buffer\r\n        const uvx0 = 0;\r\n        const uvy0 = 0;\r\n        const uvx1 = 1;\r\n        const uvy1 = 1;\r\n        // update data\r\n        const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n        // (0, 0) - 0\r\n        vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n        vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = width;\r\n        vertexBuffer[this._vertexIndex++] = height;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n        // (0, 1) - 1\r\n        vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n        vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = width;\r\n        vertexBuffer[this._vertexIndex++] = height;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n        // (1, 0) - 2\r\n        vertexBuffer[this._vertexIndex++] = topRight.x;\r\n        vertexBuffer[this._vertexIndex++] = topRight.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = width;\r\n        vertexBuffer[this._vertexIndex++] = height;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n        // (1, 1) - 3\r\n        vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n        vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = width;\r\n        vertexBuffer[this._vertexIndex++] = height;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n    }\r\n    hasPendingDraws() {\r\n        return this._rectangleCount !== 0;\r\n    }\r\n    flush() {\r\n        // nothing to draw early exit\r\n        if (this._rectangleCount === 0) {\r\n            return;\r\n        }\r\n        const gl = this._gl;\r\n        // Bind the shader\r\n        this._shader.use();\r\n        // Bind the memory layout and upload data\r\n        this._layout.use(true);\r\n        // Update ortho matrix uniform\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        // Bind index buffer\r\n        this._quads.bind();\r\n        // Draw all the quads\r\n        gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);\r\n        GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;\r\n        GraphicsDiagnostics.DrawCallCount++;\r\n        // Reset\r\n        this._rectangleCount = 0;\r\n        this._vertexIndex = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.frag.glsl\n/* harmony default export */ const circle_renderer_frag = (\"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness;\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  // make (0, 0) the center the uv \\r\\n  vec2 uv = v_uv * 2.0 - 1.0;\\r\\n\\r\\n  vec4 color = v_color;\\r\\n  vec4 strokeColor = v_strokeColor;\\r\\n\\r\\n  // circle border is at radius 1.0 \\r\\n  // dist is > 0 when inside the circle \\r\\n  float d = length(uv);\\r\\n  float dist = 1.0 - length(uv);\\r\\n\\r\\n  // Fade based on fwidth\\r\\n  float fade = fwidth(dot(uv, uv));\\r\\n\\r\\n  // if dist is greater than 0 step to 1;\\r\\n  // when we cross this 0 threshold add a smooth fade\\r\\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\\r\\n\\r\\n  // if dist is greater than the stroke thickness step to 1\\r\\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\\r\\n\\r\\n  strokeColor.a *= fill * stroke;\\r\\n  strokeColor.rgb *= strokeColor.a;\\r\\n\\r\\n  color.a *= fill * (1.0 - stroke);\\r\\n  color.rgb *= color.a;\\r\\n\\r\\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\\r\\n  finalColor.rgb = finalColor.rgb * v_opacity;\\r\\n  finalColor.a = finalColor.a * v_opacity;\\r\\n  fragColor = finalColor;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.vert.glsl\n/* harmony default export */ const circle_renderer_vert = (\"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass CircleRenderer {\r\n    constructor() {\r\n        this.type = 'ex.circle';\r\n        this.priority = 0;\r\n        this._maxCircles = 10922; // max(uint16) / 6 verts\r\n        this._circleCount = 0;\r\n        this._vertexIndex = 0;\r\n    }\r\n    initialize(gl, context) {\r\n        this._gl = gl;\r\n        this._context = context;\r\n        this._shader = new Shader({\r\n            fragmentSource: circle_renderer_frag,\r\n            vertexSource: circle_renderer_vert\r\n        });\r\n        this._shader.compile();\r\n        // setup uniforms\r\n        this._shader.use();\r\n        this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n        this._buffer = new VertexBuffer({\r\n            size: 14 * 4 * this._maxCircles,\r\n            type: 'dynamic'\r\n        });\r\n        this._layout = new VertexLayout({\r\n            shader: this._shader,\r\n            vertexBuffer: this._buffer,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_uv', 2],\r\n                ['a_opacity', 1],\r\n                ['a_color', 4],\r\n                ['a_strokeColor', 4],\r\n                ['a_strokeThickness', 1]\r\n            ]\r\n        });\r\n        this._quads = new QuadIndexBuffer(this._maxCircles, true);\r\n    }\r\n    _isFull() {\r\n        if (this._circleCount >= this._maxCircles) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    draw(pos, radius, color, stroke = Color.Transparent, strokeThickness = 0) {\r\n        if (this._isFull()) {\r\n            this.flush();\r\n        }\r\n        this._circleCount++;\r\n        // transform based on current context\r\n        const transform = this._context.getTransform();\r\n        const opacity = this._context.opacity;\r\n        const snapToPixel = this._context.snapToPixel;\r\n        const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));\r\n        const topRight = transform.multiply(pos.add(vec(radius, -radius)));\r\n        const bottomRight = transform.multiply(pos.add(vec(radius, radius)));\r\n        const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));\r\n        if (snapToPixel) {\r\n            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n            topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n            topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n        }\r\n        // TODO UV could be static vertex buffer\r\n        const uvx0 = 0;\r\n        const uvy0 = 0;\r\n        const uvx1 = 1;\r\n        const uvy1 = 1;\r\n        // update data\r\n        const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n        // (0, 0) - 0\r\n        vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n        vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n        // (0, 1) - 1\r\n        vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n        vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx0;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n        // (1, 0) - 2\r\n        vertexBuffer[this._vertexIndex++] = topRight.x;\r\n        vertexBuffer[this._vertexIndex++] = topRight.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy0;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n        // (1, 1) - 3\r\n        vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n        vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n        vertexBuffer[this._vertexIndex++] = uvx1;\r\n        vertexBuffer[this._vertexIndex++] = uvy1;\r\n        vertexBuffer[this._vertexIndex++] = opacity;\r\n        vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = color.a;\r\n        vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n        vertexBuffer[this._vertexIndex++] = stroke.a;\r\n        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n    }\r\n    hasPendingDraws() {\r\n        return this._circleCount !== 0;\r\n    }\r\n    flush() {\r\n        // nothing to draw early exit\r\n        if (this._circleCount === 0) {\r\n            return;\r\n        }\r\n        const gl = this._gl;\r\n        // Bind the shader\r\n        this._shader.use();\r\n        // Bind the memory layout and upload data\r\n        this._layout.use(true);\r\n        // Update ortho matrix uniform\r\n        this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n        // Bind index buffer\r\n        this._quads.bind();\r\n        // Draw all the quads\r\n        gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);\r\n        GraphicsDiagnostics.DrawnImagesCount += this._circleCount;\r\n        GraphicsDiagnostics.DrawCallCount++;\r\n        // Reset\r\n        this._circleCount = 0;\r\n        this._vertexIndex = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Pool.ts\n\r\nclass Pool {\r\n    constructor(builder, recycler, maxObjects = 100) {\r\n        this.builder = builder;\r\n        this.recycler = recycler;\r\n        this.maxObjects = maxObjects;\r\n        this.totalAllocations = 0;\r\n        this.index = 0;\r\n        this.objects = [];\r\n        this.disableWarnings = false;\r\n        this._logger = Logger.getInstance();\r\n    }\r\n    preallocate() {\r\n        for (let i = 0; i < this.maxObjects; i++) {\r\n            this.objects[i] = this.builder();\r\n        }\r\n    }\r\n    /**\r\n     * Use many instances out of the in the context and return all to the pool.\r\n     *\r\n     * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers\r\n     * @param context\r\n     */\r\n    using(context) {\r\n        const result = context(this);\r\n        if (result) {\r\n            return this.done(...result);\r\n        }\r\n        return this.done();\r\n    }\r\n    /**\r\n     * Use a single instance out of th pool and immediately return it to the pool\r\n     * @param context\r\n     */\r\n    borrow(context) {\r\n        const object = this.get();\r\n        context(object);\r\n        this.index--;\r\n    }\r\n    /**\r\n     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool\r\n     * @param args\r\n     */\r\n    get(...args) {\r\n        if (this.index === this.maxObjects) {\r\n            if (!this.disableWarnings) {\r\n                this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');\r\n            }\r\n            this.maxObjects = this.maxObjects * 2;\r\n        }\r\n        if (this.objects[this.index]) {\r\n            // Pool has an available object already constructed\r\n            return this.recycler(this.objects[this.index++], ...args);\r\n        }\r\n        else {\r\n            // New allocation\r\n            this.totalAllocations++;\r\n            const object = (this.objects[this.index++] = this.builder(...args));\r\n            return object;\r\n        }\r\n    }\r\n    done(...objects) {\r\n        // All objects in pool now considered \"free\"\r\n        this.index = 0;\r\n        for (const object of objects) {\r\n            const poolIndex = this.objects.indexOf(object);\r\n            // Build a new object to take the pool place\r\n            this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support\r\n            this.totalAllocations++;\r\n        }\r\n        return objects;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/draw-call.ts\n\r\n\r\nclass DrawCall {\r\n    constructor() {\r\n        this.z = 0;\r\n        this.priority = 0;\r\n        this.transform = AffineMatrix.identity();\r\n        this.state = {\r\n            z: 0,\r\n            opacity: 1,\r\n            tint: Color.White\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// renderers\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst pixelSnapEpsilon = 0.0001;\r\nclass ExcaliburGraphicsContextWebGLDebug {\r\n    constructor(_webglCtx) {\r\n        this._webglCtx = _webglCtx;\r\n        this._debugText = new DebugText();\r\n    }\r\n    /**\r\n     * Draw a debugging rectangle to the context\r\n     * @param x\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     */\r\n    drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {\r\n        this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });\r\n        this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });\r\n        this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });\r\n        this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });\r\n    }\r\n    /**\r\n     * Draw a debugging line to the context\r\n     * @param start\r\n     * @param end\r\n     * @param lineOptions\r\n     */\r\n    drawLine(start, end, lineOptions = { color: Color.Black }) {\r\n        this._webglCtx.draw('ex.line', start, end, lineOptions.color);\r\n    }\r\n    /**\r\n     * Draw a debugging point to the context\r\n     * @param point\r\n     * @param pointOptions\r\n     */\r\n    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {\r\n        this._webglCtx.draw('ex.point', point, pointOptions.color, pointOptions.size);\r\n    }\r\n    drawText(text, pos) {\r\n        this._debugText.write(this._webglCtx, text, pos);\r\n    }\r\n}\r\nclass ExcaliburGraphicsContextWebGL {\r\n    constructor(options) {\r\n        this._logger = Logger.getInstance();\r\n        this._renderers = new Map();\r\n        this._isDrawLifecycle = false;\r\n        this.useDrawSorting = true;\r\n        this._drawCallPool = new Pool(() => new DrawCall(), (instance) => {\r\n            instance.priority = 0;\r\n            instance.z = 0;\r\n            instance.renderer = undefined;\r\n            instance.args = undefined;\r\n            return instance;\r\n        }, 4000);\r\n        this._drawCalls = [];\r\n        // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process\r\n        this._postProcessTargets = [];\r\n        this._postprocessors = [];\r\n        this._transform = new TransformStack();\r\n        this._state = new StateStack();\r\n        this.snapToPixel = false;\r\n        this.smoothing = false;\r\n        this.backgroundColor = Color.ExcaliburBlue;\r\n        this._alreadyWarnedDrawLifecycle = false;\r\n        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);\r\n        const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;\r\n        this.__gl = canvasElement.getContext('webgl2', {\r\n            antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,\r\n            premultipliedAlpha: false,\r\n            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,\r\n            depth: true,\r\n            powerPreference: 'high-performance'\r\n            // TODO Chromium fixed the bug where this didn't work now it breaks CI :(\r\n            // failIfMajorPerformanceCaveat: true\r\n        });\r\n        if (!this.__gl) {\r\n            throw Error('Failed to retrieve webgl context from browser');\r\n        }\r\n        ExcaliburWebGLContextAccessor.register(this.__gl);\r\n        TextureLoader.register(this.__gl);\r\n        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;\r\n        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;\r\n        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;\r\n        this.useDrawSorting = useDrawSorting !== null && useDrawSorting !== void 0 ? useDrawSorting : this.useDrawSorting;\r\n        this._drawCallPool.disableWarnings = true;\r\n        this._drawCallPool.preallocate();\r\n        this._init();\r\n    }\r\n    get z() {\r\n        return this._state.current.z;\r\n    }\r\n    set z(value) {\r\n        this._state.current.z = value;\r\n    }\r\n    get opacity() {\r\n        return this._state.current.opacity;\r\n    }\r\n    set opacity(value) {\r\n        this._state.current.opacity = value;\r\n    }\r\n    get tint() {\r\n        return this._state.current.tint;\r\n    }\r\n    set tint(color) {\r\n        this._state.current.tint = color;\r\n    }\r\n    get width() {\r\n        return this.__gl.canvas.width;\r\n    }\r\n    get height() {\r\n        return this.__gl.canvas.height;\r\n    }\r\n    get ortho() {\r\n        return this._ortho;\r\n    }\r\n    /**\r\n     * Checks the underlying webgl implementation if the requested internal resolution is supported\r\n     * @param dim\r\n     */\r\n    checkIfResolutionSupported(dim) {\r\n        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo\r\n        let supported = true;\r\n        if (dim.width > 4096 || dim.height > 4096) {\r\n            supported = false;\r\n        }\r\n        return supported;\r\n    }\r\n    _init() {\r\n        const gl = this.__gl;\r\n        // Setup viewport and view matrix\r\n        this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        // Clear background\r\n        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        // Enable alpha blending\r\n        // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/\r\n        gl.enable(gl.BLEND);\r\n        gl.blendEquation(gl.FUNC_ADD);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\r\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        // Setup builtin renderers\r\n        this.register(new ImageRenderer());\r\n        this.register(new RectangleRenderer());\r\n        this.register(new CircleRenderer());\r\n        this.register(new PointRenderer());\r\n        this.register(new LineRenderer());\r\n        this._screenRenderer = new ScreenPassPainter(gl);\r\n        this._renderTarget = new RenderTarget({\r\n            gl,\r\n            width: gl.canvas.width,\r\n            height: gl.canvas.height\r\n        });\r\n        this._postProcessTargets = [\r\n            new RenderTarget({\r\n                gl,\r\n                width: gl.canvas.width,\r\n                height: gl.canvas.height\r\n            }),\r\n            new RenderTarget({\r\n                gl,\r\n                width: gl.canvas.width,\r\n                height: gl.canvas.height\r\n            })\r\n        ];\r\n    }\r\n    register(renderer) {\r\n        this._renderers.set(renderer.type, renderer);\r\n        renderer.initialize(this.__gl, this);\r\n    }\r\n    get(rendererName) {\r\n        return this._renderers.get(rendererName);\r\n    }\r\n    _isCurrentRenderer(renderer) {\r\n        if (!this._currentRenderer || this._currentRenderer === renderer) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    beginDrawLifecycle() {\r\n        this._isDrawLifecycle = true;\r\n    }\r\n    endDrawLifecycle() {\r\n        this._isDrawLifecycle = false;\r\n    }\r\n    draw(rendererName, ...args) {\r\n        if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {\r\n            this._logger.warn(`Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\\n` +\r\n                `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);\r\n            this._alreadyWarnedDrawLifecycle = true;\r\n        }\r\n        const renderer = this._renderers.get(rendererName);\r\n        if (renderer) {\r\n            if (this.useDrawSorting) {\r\n                const drawCall = this._drawCallPool.get();\r\n                drawCall.z = this._state.current.z;\r\n                drawCall.priority = renderer.priority;\r\n                drawCall.renderer = rendererName;\r\n                this.getTransform().clone(drawCall.transform);\r\n                drawCall.state.z = this._state.current.z;\r\n                drawCall.state.opacity = this._state.current.opacity;\r\n                drawCall.state.tint = this._state.current.tint;\r\n                drawCall.args = args;\r\n                this._drawCalls.push(drawCall);\r\n            }\r\n            else {\r\n                // Set the current renderer if not defined\r\n                if (!this._currentRenderer) {\r\n                    this._currentRenderer = renderer;\r\n                }\r\n                if (!this._isCurrentRenderer(renderer)) {\r\n                    // switching graphics means we must flush the previous\r\n                    this._currentRenderer.flush();\r\n                }\r\n                // If we are still using the same renderer we can add to the current batch\r\n                renderer.draw(...args);\r\n                this._currentRenderer = renderer;\r\n            }\r\n        }\r\n        else {\r\n            throw Error(`No renderer with name ${rendererName} has been registered`);\r\n        }\r\n    }\r\n    resetTransform() {\r\n        this._transform.current = AffineMatrix.identity();\r\n    }\r\n    updateViewport(resolution) {\r\n        const gl = this.__gl;\r\n        this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);\r\n        this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);\r\n        this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);\r\n        this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);\r\n    }\r\n    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\r\n        if (swidth === 0 || sheight === 0) {\r\n            return; // zero dimension dest exit early\r\n        }\r\n        else if (dwidth === 0 || dheight === 0) {\r\n            return; // zero dimension dest exit early\r\n        }\r\n        else if (image.width === 0 || image.height === 0) {\r\n            return; // zero dimension source exit early\r\n        }\r\n        if (!image) {\r\n            Logger.getInstance().warn('Cannot draw a null or undefined image');\r\n            // tslint:disable-next-line: no-console\r\n            if (console.trace) {\r\n                // tslint:disable-next-line: no-console\r\n                console.trace();\r\n            }\r\n            return;\r\n        }\r\n        this.draw('ex.image', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n    }\r\n    drawLine(start, end, color, thickness = 1) {\r\n        this.draw('ex.rectangle', start, end, color, thickness);\r\n    }\r\n    drawRectangle(pos, width, height, color, stroke, strokeThickness) {\r\n        this.draw('ex.rectangle', pos, width, height, color, stroke, strokeThickness);\r\n    }\r\n    drawCircle(pos, radius, color, stroke, thickness) {\r\n        this.draw('ex.circle', pos, radius, color, stroke, thickness);\r\n    }\r\n    save() {\r\n        this._transform.save();\r\n        this._state.save();\r\n    }\r\n    restore() {\r\n        this._transform.restore();\r\n        this._state.restore();\r\n    }\r\n    translate(x, y) {\r\n        this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);\r\n    }\r\n    rotate(angle) {\r\n        this._transform.rotate(angle);\r\n    }\r\n    scale(x, y) {\r\n        this._transform.scale(x, y);\r\n    }\r\n    transform(matrix) {\r\n        this._transform.current = matrix;\r\n    }\r\n    getTransform() {\r\n        return this._transform.current;\r\n    }\r\n    multiply(m) {\r\n        this._transform.current.multiply(m, this._transform.current);\r\n    }\r\n    addPostProcessor(postprocessor) {\r\n        this._postprocessors.push(postprocessor);\r\n        postprocessor.initialize(this.__gl);\r\n    }\r\n    removePostProcessor(postprocessor) {\r\n        const index = this._postprocessors.indexOf(postprocessor);\r\n        if (index !== -1) {\r\n            this._postprocessors.splice(index, 1);\r\n        }\r\n    }\r\n    clearPostProcessors() {\r\n        this._postprocessors.length = 0;\r\n    }\r\n    clear() {\r\n        const gl = this.__gl;\r\n        this._renderTarget.use();\r\n        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n        // Clear the context with the newly set color. This is\r\n        // the function call that actually does the drawing.\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n    }\r\n    /**\r\n     * Flushes all batched rendering to the screen\r\n     */\r\n    flush() {\r\n        const gl = this.__gl;\r\n        // render target captures all draws and redirects to the render target\r\n        this._renderTarget.use();\r\n        if (this.useDrawSorting) {\r\n            // sort draw calls\r\n            // Find the original order of the first instance of the draw call\r\n            const originalSort = new Map();\r\n            for (const [name] of this._renderers) {\r\n                const firstIndex = this._drawCalls.findIndex(dc => dc.renderer === name);\r\n                originalSort.set(name, firstIndex);\r\n            }\r\n            this._drawCalls.sort((a, b) => {\r\n                const zIndex = a.z - b.z;\r\n                const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);\r\n                const priority = a.priority - b.priority;\r\n                if (zIndex === 0) { // sort by z first\r\n                    if (priority === 0) { // sort by priority\r\n                        return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order\r\n                    }\r\n                    return priority;\r\n                }\r\n                return zIndex;\r\n            });\r\n            const oldTransform = this._transform.current;\r\n            const oldState = this._state.current;\r\n            if (this._drawCalls.length) {\r\n                let currentRendererName = this._drawCalls[0].renderer;\r\n                let currentRenderer = this._renderers.get(currentRendererName);\r\n                for (let i = 0; i < this._drawCalls.length; i++) {\r\n                    // hydrate the state for renderers\r\n                    this._transform.current = this._drawCalls[i].transform;\r\n                    this._state.current = this._drawCalls[i].state;\r\n                    if (this._drawCalls[i].renderer !== currentRendererName) {\r\n                        // switching graphics renderer means we must flush the previous\r\n                        currentRenderer.flush();\r\n                        currentRendererName = this._drawCalls[i].renderer;\r\n                        currentRenderer = this._renderers.get(currentRendererName);\r\n                    }\r\n                    // If we are still using the same renderer we can add to the current batch\r\n                    currentRenderer.draw(...this._drawCalls[i].args);\r\n                }\r\n                if (currentRenderer.hasPendingDraws()) {\r\n                    currentRenderer.flush();\r\n                }\r\n            }\r\n            // reset state\r\n            this._transform.current = oldTransform;\r\n            this._state.current = oldState;\r\n            // reclaim draw calls\r\n            this._drawCallPool.done();\r\n            this._drawCalls.length = 0;\r\n        }\r\n        else {\r\n            // This is the final flush at the moment to draw any leftover pending draw\r\n            for (const renderer of this._renderers.values()) {\r\n                if (renderer.hasPendingDraws()) {\r\n                    renderer.flush();\r\n                }\r\n            }\r\n        }\r\n        this._renderTarget.disable();\r\n        // post process step\r\n        const source = this._renderTarget.toRenderSource();\r\n        source.use();\r\n        // flip flop render targets\r\n        for (let i = 0; i < this._postprocessors.length; i++) {\r\n            this._postProcessTargets[i % 2].use();\r\n            this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);\r\n            this._postProcessTargets[i % 2].toRenderSource().use();\r\n        }\r\n        // passing null switches rendering back to the canvas\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        this._screenRenderer.renderToScreen();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts\n\r\n\r\n\r\n\r\nconst ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon = 0.0001;\r\nclass ExcaliburGraphicsContext2DCanvasDebug {\r\n    constructor(_ex) {\r\n        this._ex = _ex;\r\n        this._debugText = new DebugText();\r\n    }\r\n    /**\r\n     * Draw a debug rectangle to the context\r\n     * @param x\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     */\r\n    drawRect(x, y, width, height) {\r\n        this._ex.__ctx.save();\r\n        this._ex.__ctx.strokeStyle = 'red';\r\n        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this._ex.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y, this._ex.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this._ex.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);\r\n        this._ex.__ctx.restore();\r\n    }\r\n    drawLine(start, end, lineOptions = { color: Color.Black }) {\r\n        this._ex.__ctx.save();\r\n        this._ex.__ctx.beginPath();\r\n        this._ex.__ctx.strokeStyle = lineOptions.color.toString();\r\n        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this._ex.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);\r\n        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this._ex.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);\r\n        this._ex.__ctx.lineWidth = 2;\r\n        this._ex.__ctx.stroke();\r\n        this._ex.__ctx.closePath();\r\n        this._ex.__ctx.restore();\r\n    }\r\n    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {\r\n        this._ex.__ctx.save();\r\n        this._ex.__ctx.beginPath();\r\n        this._ex.__ctx.fillStyle = pointOptions.color.toString();\r\n        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~(point.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.x, this._ex.snapToPixel ? ~~(point.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.y, pointOptions.size, 0, Math.PI * 2);\r\n        this._ex.__ctx.fill();\r\n        this._ex.__ctx.closePath();\r\n        this._ex.__ctx.restore();\r\n    }\r\n    drawText(text, pos) {\r\n        this._debugText.write(this._ex, text, pos);\r\n    }\r\n}\r\nclass ExcaliburGraphicsContext2DCanvas {\r\n    constructor(options) {\r\n        /**\r\n         * Unused in Canvas implementation\r\n         */\r\n        this.useDrawSorting = false;\r\n        /**\r\n         * Unused in Canvas implementation\r\n         */\r\n        this.z = 0;\r\n        this.backgroundColor = Color.ExcaliburBlue;\r\n        this._state = new StateStack();\r\n        this.snapToPixel = false;\r\n        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);\r\n        const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;\r\n        this.__ctx = canvasElement.getContext('2d', {\r\n            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true\r\n        });\r\n        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;\r\n        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;\r\n        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;\r\n    }\r\n    get width() {\r\n        return this.__ctx.canvas.width;\r\n    }\r\n    get height() {\r\n        return this.__ctx.canvas.height;\r\n    }\r\n    get opacity() {\r\n        return this._state.current.opacity;\r\n    }\r\n    set opacity(value) {\r\n        this._state.current.opacity = value;\r\n    }\r\n    get tint() {\r\n        return this._state.current.tint;\r\n    }\r\n    set tint(color) {\r\n        this._state.current.tint = color;\r\n    }\r\n    get smoothing() {\r\n        return this.__ctx.imageSmoothingEnabled;\r\n    }\r\n    set smoothing(value) {\r\n        this.__ctx.imageSmoothingEnabled = value;\r\n    }\r\n    resetTransform() {\r\n        this.__ctx.resetTransform();\r\n    }\r\n    updateViewport(_resolution) {\r\n        // pass\r\n    }\r\n    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\r\n        if (swidth === 0 || sheight === 0) {\r\n            return; // zero dimension dest exit early\r\n        }\r\n        else if (dwidth === 0 || dheight === 0) {\r\n            return; // zero dimension dest exit early\r\n        }\r\n        else if (image.width === 0 || image.height === 0) {\r\n            return; // zero dimension source exit early\r\n        }\r\n        this.__ctx.globalAlpha = this.opacity;\r\n        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]\r\n            .filter((a) => a !== undefined)\r\n            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));\r\n        this.__ctx.drawImage.apply(this.__ctx, args);\r\n        GraphicsDiagnostics.DrawCallCount++;\r\n        GraphicsDiagnostics.DrawnImagesCount = 1;\r\n    }\r\n    drawLine(start, end, color, thickness = 1) {\r\n        this.__ctx.save();\r\n        this.__ctx.beginPath();\r\n        this.__ctx.strokeStyle = color.toString();\r\n        this.__ctx.moveTo(this.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);\r\n        this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);\r\n        this.__ctx.lineWidth = thickness;\r\n        this.__ctx.stroke();\r\n        this.__ctx.closePath();\r\n        this.__ctx.restore();\r\n    }\r\n    drawRectangle(pos, width, height, color) {\r\n        this.__ctx.save();\r\n        this.__ctx.fillStyle = color.toString();\r\n        this.__ctx.fillRect(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, this.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);\r\n        this.__ctx.restore();\r\n    }\r\n    drawCircle(pos, radius, color, stroke, thickness) {\r\n        this.__ctx.save();\r\n        this.__ctx.beginPath();\r\n        if (stroke) {\r\n            this.__ctx.strokeStyle = stroke.toString();\r\n        }\r\n        if (thickness) {\r\n            this.__ctx.lineWidth = thickness;\r\n        }\r\n        this.__ctx.fillStyle = color.toString();\r\n        this.__ctx.arc(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2);\r\n        this.__ctx.fill();\r\n        if (stroke) {\r\n            this.__ctx.stroke();\r\n        }\r\n        this.__ctx.closePath();\r\n        this.__ctx.restore();\r\n    }\r\n    /**\r\n     * Save the current state of the canvas to the stack (transforms and opacity)\r\n     */\r\n    save() {\r\n        this.__ctx.save();\r\n    }\r\n    /**\r\n     * Restore the state of the canvas from the stack\r\n     */\r\n    restore() {\r\n        this.__ctx.restore();\r\n    }\r\n    /**\r\n     * Translate the origin of the context by an x and y\r\n     * @param x\r\n     * @param y\r\n     */\r\n    translate(x, y) {\r\n        this.__ctx.translate(this.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y);\r\n    }\r\n    /**\r\n     * Rotate the context about the current origin\r\n     */\r\n    rotate(angle) {\r\n        this.__ctx.rotate(angle);\r\n    }\r\n    /**\r\n     * Scale the context by an x and y factor\r\n     * @param x\r\n     * @param y\r\n     */\r\n    scale(x, y) {\r\n        this.__ctx.scale(x, y);\r\n    }\r\n    getTransform() {\r\n        throw new Error('Not implemented');\r\n    }\r\n    multiply(_m) {\r\n        this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));\r\n    }\r\n    addPostProcessor(_postprocessor) {\r\n        // pass\r\n    }\r\n    removePostProcessor(_postprocessor) {\r\n        // pass\r\n    }\r\n    clearPostProcessors() {\r\n        // pass\r\n    }\r\n    beginDrawLifecycle() {\r\n        // pass\r\n    }\r\n    endDrawLifecycle() {\r\n        // pass\r\n    }\r\n    clear() {\r\n        // Clear frame\r\n        this.__ctx.clearRect(0, 0, this.width, this.height);\r\n        this.__ctx.fillStyle = this.backgroundColor.toString();\r\n        this.__ctx.fillRect(0, 0, this.width, this.height);\r\n        GraphicsDiagnostics.clear();\r\n    }\r\n    /**\r\n     * Flushes the batched draw calls to the screen\r\n     */\r\n    flush() {\r\n        // pass\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Screen.ts\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Enum representing the different display modes available to Excalibur.\r\n */\r\nvar DisplayMode;\r\n(function (DisplayMode) {\r\n    /**\r\n     * Default, use a specified resolution for the game. Like 800x600 pixels for example.\r\n     */\r\n    DisplayMode[\"Fixed\"] = \"Fixed\";\r\n    /**\r\n     * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.\r\n     * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n     * is guaranteed to be on screen.\r\n     */\r\n    DisplayMode[\"FitContainerAndFill\"] = \"FitContainerAndFill\";\r\n    /**\r\n     * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.\r\n     * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n     * is guaranteed to be on screen.\r\n     */\r\n    DisplayMode[\"FitScreenAndFill\"] = \"FitScreenAndFill\";\r\n    /**\r\n     * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n     * (letterbox) that would otherwise be present in [[FitContainer]].\r\n     *\r\n     * **warning** This will clip some drawable area from the user because of the zoom,\r\n     * use [[Screen.contentArea]] to know the safe to draw area.\r\n     */\r\n    DisplayMode[\"FitContainerAndZoom\"] = \"FitContainerAndZoom\";\r\n    /**\r\n     * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n     * (letterbox) that would otherwise be present in [[FitScreen]].\r\n     *\r\n     * **warning** This will clip some drawable area from the user because of the zoom,\r\n     * use [[Screen.contentArea]] to know the safe to draw area.\r\n     */\r\n    DisplayMode[\"FitScreenAndZoom\"] = \"FitScreenAndZoom\";\r\n    /**\r\n     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.\r\n     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.\r\n     *\r\n     * You may want to center your game here is an example\r\n     * ```html\r\n     * <!-- html -->\r\n     * <body>\r\n     * <main>\r\n     *   <canvas id=\"game\"></canvas>\r\n     * </main>\r\n     * </body>\r\n     * ```\r\n     *\r\n     * ```css\r\n     * // css\r\n     * main {\r\n     *   display: flex;\r\n     *   align-items: center;\r\n     *   justify-content: center;\r\n     *   height: 100%;\r\n     *   width: 100%;\r\n     * }\r\n     * ```\r\n     */\r\n    DisplayMode[\"FitScreen\"] = \"FitScreen\";\r\n    /**\r\n     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will\r\n     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]\r\n     */\r\n    DisplayMode[\"FillScreen\"] = \"FillScreen\";\r\n    /**\r\n     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.\r\n     */\r\n    DisplayMode[\"FitContainer\"] = \"FitContainer\";\r\n    /**\r\n     * Use the parent DOM container's css width/height for the game resolution dynamically\r\n     */\r\n    DisplayMode[\"FillContainer\"] = \"FillContainer\";\r\n})(DisplayMode || (DisplayMode = {}));\r\n/**\r\n * Convenience class for quick resolutions\r\n * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution\r\n */\r\nclass Resolution {\r\n    /* istanbul ignore next */\r\n    static get SVGA() {\r\n        return { width: 800, height: 600 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get Standard() {\r\n        return { width: 1920, height: 1080 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get Atari2600() {\r\n        return { width: 160, height: 192 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get GameBoy() {\r\n        return { width: 160, height: 144 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get GameBoyAdvance() {\r\n        return { width: 240, height: 160 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get NintendoDS() {\r\n        return { width: 256, height: 192 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get NES() {\r\n        return { width: 256, height: 224 };\r\n    }\r\n    /* istanbul ignore next */\r\n    static get SNES() {\r\n        return { width: 256, height: 244 };\r\n    }\r\n}\r\n/**\r\n * The Screen handles all aspects of interacting with the screen for Excalibur.\r\n */\r\nclass Screen {\r\n    constructor(options) {\r\n        var _a, _b, _c;\r\n        this._antialiasing = true;\r\n        this._resolutionStack = [];\r\n        this._viewportStack = [];\r\n        this._pixelRatioOverride = null;\r\n        this._isFullScreen = false;\r\n        this._isDisposed = false;\r\n        this._logger = Logger.getInstance();\r\n        this._fullscreenChangeHandler = () => {\r\n            this._isFullScreen = !this._isFullScreen;\r\n            this._logger.debug('Fullscreen Change', this._isFullScreen);\r\n        };\r\n        this._pixelRatioChangeHandler = () => {\r\n            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);\r\n            this._listenForPixelRatio();\r\n            this._devicePixelRatio = this._calculateDevicePixelRatio();\r\n            this.applyResolutionAndViewport();\r\n        };\r\n        this._resizeHandler = () => {\r\n            const parent = this.parent;\r\n            this._logger.debug('View port resized');\r\n            this._setResolutionAndViewportByDisplayMode(parent);\r\n            this.applyResolutionAndViewport();\r\n        };\r\n        // Asking the window.devicePixelRatio is expensive we do it once\r\n        this._devicePixelRatio = this._calculateDevicePixelRatio();\r\n        this._alreadyWarned = false;\r\n        this._contentArea = new BoundingBox();\r\n        this.viewport = options.viewport;\r\n        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : { ...this.viewport };\r\n        this._contentResolution = this.resolution;\r\n        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;\r\n        this._canvas = options.canvas;\r\n        this.graphicsContext = options.context;\r\n        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;\r\n        this._browser = options.browser;\r\n        this._pixelRatioOverride = options.pixelRatio;\r\n        this._applyDisplayMode();\r\n        this._listenForPixelRatio();\r\n        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n        this.applyResolutionAndViewport();\r\n    }\r\n    _listenForPixelRatio() {\r\n        if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {\r\n            // Safari <=13.1 workaround, remove any existing handlers\r\n            this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n        }\r\n        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\r\n        // Safari <=13.1 workaround\r\n        if (this._mediaQueryList.addEventListener) {\r\n            this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });\r\n        }\r\n        else {\r\n            this._mediaQueryList.addListener(this._pixelRatioChangeHandler);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (!this._isDisposed) {\r\n            // Clean up handlers\r\n            this._isDisposed = true;\r\n            this._browser.window.off('resize', this._resizeHandler);\r\n            if (this._resizeObserver) {\r\n                this._resizeObserver.disconnect();\r\n            }\r\n            this.parent.removeEventListener('resize', this._resizeHandler);\r\n            // Safari <=13.1 workaround\r\n            if (this._mediaQueryList.removeEventListener) {\r\n                this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);\r\n            }\r\n            else {\r\n                this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n            }\r\n            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n        }\r\n    }\r\n    _calculateDevicePixelRatio() {\r\n        if (window.devicePixelRatio < 1) {\r\n            return 1;\r\n        }\r\n        const devicePixelRatio = window.devicePixelRatio || 1;\r\n        return devicePixelRatio;\r\n    }\r\n    get pixelRatio() {\r\n        if (this._pixelRatioOverride) {\r\n            return this._pixelRatioOverride;\r\n        }\r\n        return this._devicePixelRatio;\r\n    }\r\n    get isHiDpi() {\r\n        return this.pixelRatio !== 1;\r\n    }\r\n    get displayMode() {\r\n        return this._displayMode;\r\n    }\r\n    get canvas() {\r\n        return this._canvas;\r\n    }\r\n    get parent() {\r\n        switch (this.displayMode) {\r\n            case DisplayMode.FillContainer:\r\n            case DisplayMode.FitContainer:\r\n            case DisplayMode.FitContainerAndFill:\r\n            case DisplayMode.FitContainerAndZoom:\r\n                return this.canvas.parentElement || document.body;\r\n            default:\r\n                return window;\r\n        }\r\n    }\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n    set resolution(resolution) {\r\n        this._resolution = resolution;\r\n    }\r\n    get viewport() {\r\n        if (this._viewport) {\r\n            return this._viewport;\r\n        }\r\n        return this._resolution;\r\n    }\r\n    set viewport(viewport) {\r\n        this._viewport = viewport;\r\n    }\r\n    get aspectRatio() {\r\n        return this._resolution.width / this._resolution.height;\r\n    }\r\n    get scaledWidth() {\r\n        return this._resolution.width * this.pixelRatio;\r\n    }\r\n    get scaledHeight() {\r\n        return this._resolution.height * this.pixelRatio;\r\n    }\r\n    setCurrentCamera(camera) {\r\n        this._camera = camera;\r\n    }\r\n    pushResolutionAndViewport() {\r\n        this._resolutionStack.push(this.resolution);\r\n        this._viewportStack.push(this.viewport);\r\n        this.resolution = { ...this.resolution };\r\n        this.viewport = { ...this.viewport };\r\n    }\r\n    peekViewport() {\r\n        return this._viewportStack[this._viewportStack.length - 1];\r\n    }\r\n    peekResolution() {\r\n        return this._resolutionStack[this._resolutionStack.length - 1];\r\n    }\r\n    popResolutionAndViewport() {\r\n        this.resolution = this._resolutionStack.pop();\r\n        this.viewport = this._viewportStack.pop();\r\n    }\r\n    applyResolutionAndViewport() {\r\n        this._canvas.width = this.scaledWidth;\r\n        this._canvas.height = this.scaledHeight;\r\n        if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n            const supported = this.graphicsContext.checkIfResolutionSupported({\r\n                width: this.scaledWidth,\r\n                height: this.scaledHeight\r\n            });\r\n            if (!supported && !this._alreadyWarned) {\r\n                this._alreadyWarned = true; // warn once\r\n                this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +\r\n                    ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +\r\n                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +\r\n                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');\r\n            }\r\n        }\r\n        if (this._antialiasing) {\r\n            this._canvas.style.imageRendering = 'auto';\r\n        }\r\n        else {\r\n            this._canvas.style.imageRendering = 'pixelated';\r\n            // Fall back to 'crisp-edges' if 'pixelated' is not supported\r\n            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\r\n            if (this._canvas.style.imageRendering === '') {\r\n                this._canvas.style.imageRendering = 'crisp-edges';\r\n            }\r\n        }\r\n        this._canvas.style.width = this.viewport.width + 'px';\r\n        this._canvas.style.height = this.viewport.height + 'px';\r\n        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset\r\n        this.graphicsContext.updateViewport(this.resolution);\r\n        this.graphicsContext.resetTransform();\r\n        this.graphicsContext.smoothing = this._antialiasing;\r\n        if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {\r\n            this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);\r\n        }\r\n    }\r\n    get antialiasing() {\r\n        return this._antialiasing;\r\n    }\r\n    set antialiasing(isSmooth) {\r\n        this._antialiasing = isSmooth;\r\n        this.graphicsContext.smoothing = this._antialiasing;\r\n    }\r\n    /**\r\n     * Returns true if excalibur is fullscreen using the browser fullscreen api\r\n     */\r\n    get isFullScreen() {\r\n        return this._isFullScreen;\r\n    }\r\n    /**\r\n     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.\r\n     * For example, wire this to a user click handler.\r\n     *\r\n     * Optionally specify a target element id to go fullscreen, by default the game canvas is used\r\n     * @param elementId\r\n     */\r\n    goFullScreen(elementId) {\r\n        if (elementId) {\r\n            const maybeElement = document.getElementById(elementId);\r\n            if (maybeElement) {\r\n                return maybeElement.requestFullscreen();\r\n            }\r\n        }\r\n        return this._canvas.requestFullscreen();\r\n    }\r\n    /**\r\n     * Requests to exit fullscreen using the browser fullscreen api\r\n     */\r\n    exitFullScreen() {\r\n        return document.exitFullscreen();\r\n    }\r\n    /**\r\n     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to\r\n     * Excalibur screen space.\r\n     *\r\n     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n     * bottom right corner (resolutionX, resolutionY)\r\n     * @param point\r\n     */\r\n    pageToScreenCoordinates(point) {\r\n        let newX = point.x;\r\n        let newY = point.y;\r\n        if (!this._isFullScreen) {\r\n            newX -= getPosition(this._canvas).x;\r\n            newY -= getPosition(this._canvas).y;\r\n        }\r\n        // if fullscreen api on it centers with black bars\r\n        // we need to adjust the screen to world coordinates in this case\r\n        if (this._isFullScreen) {\r\n            if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n                const screenHeight = window.innerWidth / this.aspectRatio;\r\n                const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n                newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;\r\n                newX = (newX / window.innerWidth) * this.viewport.width;\r\n            }\r\n            else {\r\n                const screenWidth = window.innerHeight * this.aspectRatio;\r\n                const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n                newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;\r\n                newY = (newY / window.innerHeight) * this.viewport.height;\r\n            }\r\n        }\r\n        newX = (newX / this.viewport.width) * this.resolution.width;\r\n        newY = (newY / this.viewport.height) * this.resolution.height;\r\n        return new Vector(newX, newY);\r\n    }\r\n    /**\r\n     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,\r\n     * this is where html elements might live if you want to position them relative to Excalibur.\r\n     *\r\n     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n     * bottom right corner (resolutionX, resolutionY)\r\n     * @param point\r\n     */\r\n    screenToPageCoordinates(point) {\r\n        let newX = point.x;\r\n        let newY = point.y;\r\n        newX = (newX / this.resolution.width) * this.viewport.width;\r\n        newY = (newY / this.resolution.height) * this.viewport.height;\r\n        if (this._isFullScreen) {\r\n            if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n                const screenHeight = window.innerWidth / this.aspectRatio;\r\n                const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n                newY = (newY / this.viewport.height) * screenHeight + screenMarginY;\r\n                newX = (newX / this.viewport.width) * window.innerWidth;\r\n            }\r\n            else {\r\n                const screenWidth = window.innerHeight * this.aspectRatio;\r\n                const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n                newX = (newX / this.viewport.width) * screenWidth + screenMarginX;\r\n                newY = (newY / this.viewport.height) * window.innerHeight;\r\n            }\r\n        }\r\n        if (!this._isFullScreen) {\r\n            newX += getPosition(this._canvas).x;\r\n            newY += getPosition(this._canvas).y;\r\n        }\r\n        return new Vector(newX, newY);\r\n    }\r\n    /**\r\n     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.\r\n     *\r\n     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]\r\n     * and extends infinitely out relative from the [[Camera]].\r\n     * @param point  Screen coordinate to convert\r\n     */\r\n    screenToWorldCoordinates(point) {\r\n        // the only difference between screen & world is the camera transform\r\n        if (this._camera) {\r\n            return this._camera.inverse.multiply(point);\r\n        }\r\n        return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n    }\r\n    /**\r\n     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.\r\n     *\r\n     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.\r\n     * @param point  World coordinate to convert\r\n     */\r\n    worldToScreenCoordinates(point) {\r\n        if (this._camera) {\r\n            return this._camera.transform.multiply(point);\r\n        }\r\n        return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n    }\r\n    pageToWorldCoordinates(point) {\r\n        const screen = this.pageToScreenCoordinates(point);\r\n        return this.screenToWorldCoordinates(screen);\r\n    }\r\n    worldToPageCoordinates(point) {\r\n        const screen = this.worldToScreenCoordinates(point);\r\n        return this.screenToPageCoordinates(screen);\r\n    }\r\n    /**\r\n     * Returns a BoundingBox of the top left corner of the screen\r\n     * and the bottom right corner of the screen.\r\n     *\r\n     * World bounds are in world coordinates, useful for culling objects offscreen\r\n     */\r\n    getWorldBounds() {\r\n        const topLeft = this.screenToWorldCoordinates(Vector.Zero);\r\n        const right = topLeft.x + this.drawWidth;\r\n        const bottom = topLeft.y + this.drawHeight;\r\n        return new BoundingBox(topLeft.x, topLeft.y, right, bottom);\r\n    }\r\n    /**\r\n     * The width of the game canvas in pixels (physical width component of the\r\n     * resolution of the canvas element)\r\n     */\r\n    get canvasWidth() {\r\n        return this.canvas.width;\r\n    }\r\n    /**\r\n     * Returns half width of the game canvas in pixels (half physical width component)\r\n     */\r\n    get halfCanvasWidth() {\r\n        return this.canvas.width / 2;\r\n    }\r\n    /**\r\n     * The height of the game canvas in pixels, (physical height component of\r\n     * the resolution of the canvas element)\r\n     */\r\n    get canvasHeight() {\r\n        return this.canvas.height;\r\n    }\r\n    /**\r\n     * Returns half height of the game canvas in pixels (half physical height component)\r\n     */\r\n    get halfCanvasHeight() {\r\n        return this.canvas.height / 2;\r\n    }\r\n    /**\r\n     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get drawWidth() {\r\n        if (this._camera) {\r\n            return this.resolution.width / this._camera.zoom;\r\n        }\r\n        return this.resolution.width;\r\n    }\r\n    /**\r\n     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get halfDrawWidth() {\r\n        return this.drawWidth / 2;\r\n    }\r\n    /**\r\n     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get drawHeight() {\r\n        if (this._camera) {\r\n            return this.resolution.height / this._camera.zoom;\r\n        }\r\n        return this.resolution.height;\r\n    }\r\n    /**\r\n     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get halfDrawHeight() {\r\n        return this.drawHeight / 2;\r\n    }\r\n    /**\r\n     * Returns screen center coordinates including zoom and device pixel ratio.\r\n     */\r\n    get center() {\r\n        return vec(this.halfDrawWidth, this.halfDrawHeight);\r\n    }\r\n    /**\r\n     * Returns the content area in screen space where it is safe to place content\r\n     */\r\n    get contentArea() {\r\n        return this._contentArea;\r\n    }\r\n    _computeFit() {\r\n        document.body.style.margin = '0px';\r\n        document.body.style.overflow = 'hidden';\r\n        const aspect = this.aspectRatio;\r\n        let adjustedWidth = 0;\r\n        let adjustedHeight = 0;\r\n        if (window.innerWidth / aspect < window.innerHeight) {\r\n            adjustedWidth = window.innerWidth;\r\n            adjustedHeight = window.innerWidth / aspect;\r\n        }\r\n        else {\r\n            adjustedWidth = window.innerHeight * aspect;\r\n            adjustedHeight = window.innerHeight;\r\n        }\r\n        this.viewport = {\r\n            width: adjustedWidth,\r\n            height: adjustedHeight\r\n        };\r\n        this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n    }\r\n    _computeFitScreenAndFill() {\r\n        document.body.style.margin = '0px';\r\n        document.body.style.overflow = 'hidden';\r\n        const vw = window.innerWidth;\r\n        const vh = window.innerHeight;\r\n        this._computeFitAndFill(vw, vh);\r\n    }\r\n    _computeFitContainerAndFill() {\r\n        document.body.style.margin = '0px';\r\n        document.body.style.overflow = 'hidden';\r\n        const parent = this.canvas.parentElement;\r\n        const vw = parent.clientWidth;\r\n        const vh = parent.clientHeight;\r\n        this._computeFitAndFill(vw, vh);\r\n    }\r\n    _computeFitAndFill(vw, vh) {\r\n        this.viewport = {\r\n            width: vw,\r\n            height: vh\r\n        };\r\n        // if the current screen aspectRatio is less than the original aspectRatio\r\n        if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {\r\n            // compute new resolution to match the original aspect ratio\r\n            this.resolution = {\r\n                width: vw * this._contentResolution.width / vw,\r\n                height: vw * this._contentResolution.width / vw * vh / vw\r\n            };\r\n            const clip = (this.resolution.height - this._contentResolution.height) / 2;\r\n            this._contentArea = new BoundingBox({\r\n                top: clip,\r\n                left: 0,\r\n                right: this._contentResolution.width,\r\n                bottom: this.resolution.height - clip\r\n            });\r\n        }\r\n        else {\r\n            this.resolution = {\r\n                width: vh * this._contentResolution.height / vh * vw / vh,\r\n                height: vh * this._contentResolution.height / vh\r\n            };\r\n            const clip = (this.resolution.width - this._contentResolution.width) / 2;\r\n            this._contentArea = new BoundingBox({\r\n                top: 0,\r\n                left: clip,\r\n                right: this.resolution.width - clip,\r\n                bottom: this._contentResolution.height\r\n            });\r\n        }\r\n    }\r\n    _computeFitScreenAndZoom() {\r\n        document.body.style.margin = '0px';\r\n        document.body.style.overflow = 'hidden';\r\n        this.canvas.style.position = 'absolute';\r\n        const vw = window.innerWidth;\r\n        const vh = window.innerHeight;\r\n        this._computeFitAndZoom(vw, vh);\r\n    }\r\n    _computeFitContainerAndZoom() {\r\n        document.body.style.margin = '0px';\r\n        document.body.style.overflow = 'hidden';\r\n        this.canvas.style.position = 'absolute';\r\n        const parent = this.canvas.parentElement;\r\n        parent.style.position = 'relative';\r\n        parent.style.overflow = 'hidden';\r\n        const vw = parent.clientWidth;\r\n        const vh = parent.clientHeight;\r\n        this._computeFitAndZoom(vw, vh);\r\n    }\r\n    _computeFitAndZoom(vw, vh) {\r\n        const aspect = this.aspectRatio;\r\n        let adjustedWidth = 0;\r\n        let adjustedHeight = 0;\r\n        if (vw / aspect < vh) {\r\n            adjustedWidth = vw;\r\n            adjustedHeight = vw / aspect;\r\n        }\r\n        else {\r\n            adjustedWidth = vh * aspect;\r\n            adjustedHeight = vh;\r\n        }\r\n        const scaleX = vw / adjustedWidth;\r\n        const scaleY = vh / adjustedHeight;\r\n        const maxScaleFactor = Math.max(scaleX, scaleY);\r\n        const zoomedWidth = adjustedWidth * maxScaleFactor;\r\n        const zoomedHeight = adjustedHeight * maxScaleFactor;\r\n        // Center zoomed dimension if bigger than the screen\r\n        if (zoomedWidth > vw) {\r\n            this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';\r\n        }\r\n        else {\r\n            this.canvas.style.left = '';\r\n        }\r\n        if (zoomedHeight > vh) {\r\n            this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';\r\n        }\r\n        else {\r\n            this.canvas.style.top = '';\r\n        }\r\n        this.viewport = {\r\n            width: zoomedWidth,\r\n            height: zoomedHeight\r\n        };\r\n        const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);\r\n        // return safe area\r\n        if (this.viewport.width > vw) {\r\n            const clip = (this.viewport.width - vw) / this.viewport.width * this.resolution.width;\r\n            bounds.top = 0;\r\n            bounds.left = clip / 2;\r\n            bounds.right = this.resolution.width - clip / 2;\r\n            bounds.bottom = this.resolution.height;\r\n        }\r\n        if (this.viewport.height > vh) {\r\n            const clip = (this.viewport.height - vh) / this.viewport.height * this.resolution.height;\r\n            bounds.top = clip / 2;\r\n            bounds.left = 0;\r\n            bounds.bottom = this.resolution.height - clip / 2;\r\n            bounds.right = this.resolution.width;\r\n        }\r\n        this._contentArea = bounds;\r\n    }\r\n    _computeFitContainer() {\r\n        const aspect = this.aspectRatio;\r\n        let adjustedWidth = 0;\r\n        let adjustedHeight = 0;\r\n        const parent = this.canvas.parentElement;\r\n        if (parent.clientWidth / aspect < parent.clientHeight) {\r\n            adjustedWidth = parent.clientWidth;\r\n            adjustedHeight = parent.clientWidth / aspect;\r\n        }\r\n        else {\r\n            adjustedWidth = parent.clientHeight * aspect;\r\n            adjustedHeight = parent.clientHeight;\r\n        }\r\n        this.viewport = {\r\n            width: adjustedWidth,\r\n            height: adjustedHeight\r\n        };\r\n        this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n    }\r\n    _applyDisplayMode() {\r\n        this._setResolutionAndViewportByDisplayMode(this.parent);\r\n        // watch resizing\r\n        if (this.parent instanceof Window) {\r\n            this._browser.window.on('resize', this._resizeHandler);\r\n        }\r\n        else {\r\n            this._resizeObserver = new ResizeObserver(() => {\r\n                this._resizeHandler();\r\n            });\r\n            this._resizeObserver.observe(this.parent);\r\n        }\r\n        this.parent.addEventListener('resize', this._resizeHandler);\r\n    }\r\n    /**\r\n     * Sets the resolution and viewport based on the selected display mode.\r\n     */\r\n    _setResolutionAndViewportByDisplayMode(parent) {\r\n        if (this.displayMode === DisplayMode.FillContainer) {\r\n            this.resolution = {\r\n                width: parent.clientWidth,\r\n                height: parent.clientHeight\r\n            };\r\n            this.viewport = this.resolution;\r\n        }\r\n        if (this.displayMode === DisplayMode.FillScreen) {\r\n            document.body.style.margin = '0px';\r\n            document.body.style.overflow = 'hidden';\r\n            this.resolution = {\r\n                width: parent.innerWidth,\r\n                height: parent.innerHeight\r\n            };\r\n            this.viewport = this.resolution;\r\n        }\r\n        if (this.displayMode === DisplayMode.FitScreen) {\r\n            this._computeFit();\r\n        }\r\n        if (this.displayMode === DisplayMode.FitContainer) {\r\n            this._computeFitContainer();\r\n        }\r\n        if (this.displayMode === DisplayMode.FitScreenAndFill) {\r\n            this._computeFitScreenAndFill();\r\n        }\r\n        if (this.displayMode === DisplayMode.FitContainerAndFill) {\r\n            this._computeFitContainerAndFill();\r\n        }\r\n        if (this.displayMode === DisplayMode.FitScreenAndZoom) {\r\n            this._computeFitScreenAndZoom();\r\n        }\r\n        if (this.displayMode === DisplayMode.FitContainerAndZoom) {\r\n            this._computeFitContainerAndZoom();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Resources/Sound/AudioContext.ts\n/**\r\n * Internal class used to build instances of AudioContext\r\n */\r\n/* istanbul ignore next */\r\nclass AudioContextFactory {\r\n    static create() {\r\n        if (!this._INSTANCE) {\r\n            if (window.AudioContext || window.webkitAudioContext) {\r\n                this._INSTANCE = new AudioContext();\r\n            }\r\n        }\r\n        return this._INSTANCE;\r\n    }\r\n}\r\nAudioContextFactory._INSTANCE = null;\r\n\n;// CONCATENATED MODULE: ./Util/WebAudio.ts\n\r\n\r\n/**\r\n * Patch for detecting legacy web audio in browsers\r\n * @internal\r\n * @param source\r\n */\r\nfunction isLegacyWebAudioSource(source) {\r\n    return !!source.playbackState;\r\n}\r\nclass WebAudio {\r\n    /**\r\n     * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n     * right after a user interaction event.\r\n     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n     */\r\n    static unlock() {\r\n        const promise = new Promise((resolve, reject) => {\r\n            if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {\r\n                return resolve(true);\r\n            }\r\n            const unlockTimeoutTimer = setTimeout(() => {\r\n                Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');\r\n                resolve(false);\r\n            }, 200);\r\n            const audioContext = AudioContextFactory.create();\r\n            audioContext.resume().then(() => {\r\n                // create empty buffer and play it\r\n                const buffer = audioContext.createBuffer(1, 1, 22050);\r\n                const source = audioContext.createBufferSource();\r\n                let ended = false;\r\n                source.buffer = buffer;\r\n                source.connect(audioContext.destination);\r\n                source.onended = () => (ended = true);\r\n                source.start(0);\r\n                // by checking the play state after some time, we know if we're really unlocked\r\n                setTimeout(() => {\r\n                    if (isLegacyWebAudioSource(source)) {\r\n                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {\r\n                            WebAudio._UNLOCKED = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (audioContext.currentTime > 0 || ended) {\r\n                            WebAudio._UNLOCKED = true;\r\n                        }\r\n                    }\r\n                }, 0);\r\n                clearTimeout(unlockTimeoutTimer);\r\n                resolve(true);\r\n            }, () => {\r\n                reject();\r\n            });\r\n        });\r\n        return promise;\r\n    }\r\n    static isUnlocked() {\r\n        return this._UNLOCKED;\r\n    }\r\n}\r\nWebAudio._UNLOCKED = false;\r\n\n;// CONCATENATED MODULE: ./Class.ts\n\r\n/**\r\n * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n * and extending abilities for vanilla Javascript projects\r\n */\r\nclass Class {\r\n    constructor() {\r\n        this.eventDispatcher = new EventDispatcher();\r\n    }\r\n    /**\r\n     * Alias for `addEventListener`. You can listen for a variety of\r\n     * events off of the engine; see the events section below for a complete list.\r\n     * @param eventName  Name of the event to listen for\r\n     * @param handler    Event handler for the thrown event\r\n     */\r\n    on(eventName, handler) {\r\n        this.eventDispatcher.on(eventName, handler);\r\n    }\r\n    /**\r\n     * Alias for `removeEventListener`. If only the eventName is specified\r\n     * it will remove all handlers registered for that specific event. If the eventName\r\n     * and the handler instance are specified only that handler will be removed.\r\n     *\r\n     * @param eventName  Name of the event to listen for\r\n     * @param handler    Event handler for the thrown event\r\n     */\r\n    off(eventName, handler) {\r\n        this.eventDispatcher.off(eventName, handler);\r\n    }\r\n    /**\r\n     * Emits a new event\r\n     * @param eventName   Name of the event to emit\r\n     * @param eventObject Data associated with this event\r\n     */\r\n    emit(eventName, eventObject) {\r\n        this.eventDispatcher.emit(eventName, eventObject);\r\n    }\r\n    /**\r\n     * Once listens to an event one time, then unsubscribes from that event\r\n     *\r\n     * @param eventName The name of the event to subscribe to once\r\n     * @param handler   The handler of the event that will be auto unsubscribed\r\n     */\r\n    once(eventName, handler) {\r\n        this.eventDispatcher.once(eventName, handler);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/DrawUtil.ts\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw a line on canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param color The color of the line\r\n * @param x1 The start x coordinate\r\n * @param y1 The start y coordinate\r\n * @param x2 The ending x coordinate\r\n * @param y2 The ending y coordinate\r\n * @param thickness The line thickness\r\n * @param cap The [[LineCapStyle]] (butt, round, or square)\r\n */\r\nfunction line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.lineWidth = thickness;\r\n    ctx.lineCap = cap;\r\n    ctx.strokeStyle = color.toString();\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineTo(x2, y2);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n    ctx.restore();\r\n}\r\n/* istanbul ignore next */\r\n/**\r\n * Draw the vector as a point onto the canvas.\r\n */\r\nfunction point(ctx, color = Color.Red, point) {\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = color.toString();\r\n    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n}\r\n/**\r\n * Draw the vector as a line onto the canvas starting a origin point.\r\n */\r\n/* istanbul ignore next */\r\n/**\r\n *\r\n */\r\nfunction vector(ctx, color, origin, vector, scale = 1.0) {\r\n    const c = color ? color.toString() : 'blue';\r\n    const v = vector.scale(scale);\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = c;\r\n    ctx.moveTo(origin.x, origin.y);\r\n    ctx.lineTo(origin.x + v.x, origin.y + v.y);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n}\r\n/**\r\n * Draw a round rectangle on a canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param x The top-left x coordinate\r\n * @param y The top-left y coordinate\r\n * @param width The width of the rectangle\r\n * @param height The height of the rectangle\r\n * @param radius The border radius of the rectangle\r\n * @param stroke The [[Color]] to stroke rectangle with\r\n * @param fill The [[Color]] to fill rectangle with\r\n */\r\nfunction roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {\r\n    let br;\r\n    if (typeof radius === 'number') {\r\n        br = { tl: radius, tr: radius, br: radius, bl: radius };\r\n    }\r\n    else {\r\n        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n        for (const prop in defaultRadius) {\r\n            if (defaultRadius.hasOwnProperty(prop)) {\r\n                const side = prop;\r\n                br[side] = radius[side] || defaultRadius[side];\r\n            }\r\n        }\r\n    }\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + br.tl, y);\r\n    ctx.lineTo(x + width - br.tr, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\r\n    ctx.lineTo(x + width, y + height - br.br);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\r\n    ctx.lineTo(x + br.bl, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\r\n    ctx.lineTo(x, y + br.tl);\r\n    ctx.quadraticCurveTo(x, y, x + br.tl, y);\r\n    ctx.closePath();\r\n    if (fill) {\r\n        ctx.fillStyle = fill.toString();\r\n        ctx.fill();\r\n    }\r\n    if (stroke) {\r\n        ctx.strokeStyle = stroke.toString();\r\n        ctx.stroke();\r\n    }\r\n}\r\n/**\r\n *\r\n */\r\nfunction circle(ctx, x, y, radius, stroke = Color.White, fill = null) {\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n    ctx.closePath();\r\n    if (fill) {\r\n        ctx.fillStyle = fill.toString();\r\n        ctx.fill();\r\n    }\r\n    if (stroke) {\r\n        ctx.strokeStyle = stroke.toString();\r\n        ctx.stroke();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Loader.logo.png\n/* harmony default export */ const Loader_logo = (\"data:image/png;base64,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\");\n// EXTERNAL MODULE: ./Loader.css\nvar Loader_0 = __webpack_require__(1388);\n;// CONCATENATED MODULE: ./Graphics/Raster.ts\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the\r\n * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.\r\n *\r\n * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.\r\n */\r\nclass Raster extends Graphic {\r\n    constructor(options) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n        super(options);\r\n        this.filtering = null;\r\n        this.lineCap = 'butt';\r\n        this.quality = 1;\r\n        this._dirty = true;\r\n        this._smoothing = false;\r\n        this._color = watch(Color.Black, () => this.flagDirty());\r\n        this._lineWidth = 1;\r\n        this._lineDash = [];\r\n        this._padding = 0;\r\n        if (options) {\r\n            this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;\r\n            this.color = (_b = options.color) !== null && _b !== void 0 ? _b : Color.Black;\r\n            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;\r\n            this.smoothing = (_c = options.smoothing) !== null && _c !== void 0 ? _c : this.smoothing;\r\n            this.lineWidth = (_d = options.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;\r\n            this.lineDash = (_e = options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;\r\n            this.lineCap = (_f = options.lineCap) !== null && _f !== void 0 ? _f : this.lineCap;\r\n            this.padding = (_g = options.padding) !== null && _g !== void 0 ? _g : this.padding;\r\n            this.filtering = (_h = options.filtering) !== null && _h !== void 0 ? _h : this.filtering;\r\n        }\r\n        this._bitmap = document.createElement('canvas');\r\n        // get the default canvas width/height as a fallback\r\n        const bitmapWidth = (_j = options === null || options === void 0 ? void 0 : options.width) !== null && _j !== void 0 ? _j : this._bitmap.width;\r\n        const bitmapHeight = (_k = options === null || options === void 0 ? void 0 : options.height) !== null && _k !== void 0 ? _k : this._bitmap.height;\r\n        this.width = bitmapWidth;\r\n        this.height = bitmapHeight;\r\n        const maybeCtx = this._bitmap.getContext('2d');\r\n        if (!maybeCtx) {\r\n            /* istanbul ignore next */\r\n            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');\r\n        }\r\n        else {\r\n            this._ctx = maybeCtx;\r\n        }\r\n    }\r\n    cloneRasterOptions() {\r\n        return {\r\n            color: this.color ? this.color.clone() : null,\r\n            strokeColor: this.strokeColor ? this.strokeColor.clone() : null,\r\n            smoothing: this.smoothing,\r\n            lineWidth: this.lineWidth,\r\n            lineDash: this.lineDash,\r\n            lineCap: this.lineCap,\r\n            quality: this.quality,\r\n            padding: this.padding\r\n        };\r\n    }\r\n    /**\r\n     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized\r\n     */\r\n    get dirty() {\r\n        return this._dirty;\r\n    }\r\n    /**\r\n     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.\r\n     * This should be called any time the graphics state changes such that it affects the outputted drawing\r\n     */\r\n    flagDirty() {\r\n        this._dirty = true;\r\n    }\r\n    /**\r\n     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster\r\n     * to be flagged dirty causing a re-raster on the next draw.\r\n     *\r\n     * Any `padding`s or `quality` set will be factored into the width\r\n     */\r\n    get width() {\r\n        return Math.abs(this._getTotalWidth() * this.scale.x);\r\n    }\r\n    set width(value) {\r\n        value /= Math.abs(this.scale.x);\r\n        this._bitmap.width = value;\r\n        this._originalWidth = value;\r\n        this.flagDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster\r\n     * to be flagged dirty causing a re-raster on the next draw.\r\n     *\r\n     * Any `padding` or `quality` set will be factored into the height\r\n     */\r\n    get height() {\r\n        return Math.abs(this._getTotalHeight() * this.scale.y);\r\n    }\r\n    set height(value) {\r\n        value /= Math.abs(this.scale.y);\r\n        this._bitmap.height = value;\r\n        this._originalHeight = value;\r\n        this.flagDirty();\r\n    }\r\n    _getTotalWidth() {\r\n        var _a;\r\n        return (((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2) * 1;\r\n    }\r\n    _getTotalHeight() {\r\n        var _a;\r\n        return (((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2) * 1;\r\n    }\r\n    /**\r\n     * Returns the local bounds of the Raster including the padding\r\n     */\r\n    get localBounds() {\r\n        return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);\r\n    }\r\n    /**\r\n     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster\r\n     * to be flagged dirty causing a re-raster on the next draw.\r\n     */\r\n    get smoothing() {\r\n        return this._smoothing;\r\n    }\r\n    set smoothing(value) {\r\n        this._smoothing = value;\r\n        this.flagDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be\r\n     * flagged dirty causing a re-raster on the next draw.\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n    set color(value) {\r\n        this.flagDirty();\r\n        this._color = watch(value, () => this.flagDirty());\r\n    }\r\n    /**\r\n     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be\r\n     * flagged dirty causing a re-raster on the next draw.\r\n     */\r\n    get strokeColor() {\r\n        return this._strokeColor;\r\n    }\r\n    set strokeColor(value) {\r\n        this.flagDirty();\r\n        this._strokeColor = watch(value, () => this.flagDirty());\r\n    }\r\n    /**\r\n     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be\r\n     * flagged dirty causing a re-raster on the next draw.\r\n     */\r\n    get lineWidth() {\r\n        return this._lineWidth;\r\n    }\r\n    set lineWidth(value) {\r\n        this._lineWidth = value;\r\n        this.flagDirty();\r\n    }\r\n    get lineDash() {\r\n        return this._lineDash;\r\n    }\r\n    set lineDash(value) {\r\n        this._lineDash = value;\r\n        this.flagDirty();\r\n    }\r\n    get padding() {\r\n        return this._padding;\r\n    }\r\n    set padding(value) {\r\n        this._padding = value;\r\n        this.flagDirty();\r\n    }\r\n    /**\r\n     * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if\r\n     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call\r\n     */\r\n    rasterize() {\r\n        this._dirty = false;\r\n        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());\r\n        this._ctx.save();\r\n        this._applyRasterProperties(this._ctx);\r\n        this.execute(this._ctx);\r\n        this._ctx.restore();\r\n        // The webgl texture needs to be updated if it exists after a raster cycle\r\n        TextureLoader.load(this._bitmap, this.filtering, true);\r\n    }\r\n    _applyRasterProperties(ctx) {\r\n        var _a, _b, _c;\r\n        this._bitmap.width = this._getTotalWidth() * this.quality;\r\n        this._bitmap.height = this._getTotalHeight() * this.quality;\r\n        ctx.scale(this.quality, this.quality);\r\n        ctx.translate(this.padding, this.padding);\r\n        ctx.imageSmoothingEnabled = this.smoothing;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());\r\n        ctx.lineCap = this.lineCap;\r\n        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();\r\n        ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();\r\n    }\r\n    _drawImage(ex, x, y) {\r\n        if (this._dirty) {\r\n            this.rasterize();\r\n        }\r\n        ex.scale(1 / this.quality, 1 / this.quality);\r\n        ex.drawImage(this._bitmap, x, y);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Canvas.ts\n\r\n/**\r\n * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].\r\n *\r\n * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed\r\n * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.\r\n *\r\n * **Low performance API**\r\n */\r\nclass Canvas extends Raster {\r\n    constructor(_options) {\r\n        super(_options);\r\n        this._options = _options;\r\n    }\r\n    /**\r\n     * Return the 2D graphics context of this canvas\r\n     */\r\n    get ctx() {\r\n        return this._ctx;\r\n    }\r\n    clone() {\r\n        return new Canvas({\r\n            ...this._options,\r\n            ...this.cloneGraphicOptions(),\r\n            ...this.cloneRasterOptions()\r\n        });\r\n    }\r\n    execute(ctx) {\r\n        var _a, _b;\r\n        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {\r\n            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);\r\n        }\r\n        if (!this._options.cache) {\r\n            this.flagDirty();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Interfaces/AudioImplementation.ts\nclass ExResponse {\r\n}\r\nExResponse.type = {\r\n    any: '',\r\n    blob: 'blob',\r\n    json: 'json',\r\n    text: 'text',\r\n    document: 'document',\r\n    arraybuffer: 'arraybuffer'\r\n};\r\n\n;// CONCATENATED MODULE: ./Util/StateMachine.ts\nclass StateMachine {\r\n    constructor() {\r\n        this.states = new Map();\r\n    }\r\n    get currentState() {\r\n        return this._currentState;\r\n    }\r\n    set currentState(state) {\r\n        this._currentState = state;\r\n    }\r\n    static create(machineDescription, data) {\r\n        const machine = new StateMachine();\r\n        machine.data = data;\r\n        for (const stateName in machineDescription.states) {\r\n            machine.states.set(stateName, {\r\n                name: stateName,\r\n                ...machineDescription.states[stateName]\r\n            });\r\n        }\r\n        // validate transitions are states\r\n        for (const state of machine.states.values()) {\r\n            for (const transitionState of state.transitions) {\r\n                if (transitionState === '*') {\r\n                    continue;\r\n                }\r\n                if (!machine.states.has(transitionState)) {\r\n                    throw Error(`Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`);\r\n                }\r\n            }\r\n        }\r\n        machine.currentState = machine.startState = machine.states.get(machineDescription.start);\r\n        return machine;\r\n    }\r\n    in(state) {\r\n        return this.currentState.name === state;\r\n    }\r\n    go(stateName, eventData) {\r\n        var _a, _b;\r\n        if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes('*')) {\r\n            const potentialNewState = this.states.get(stateName);\r\n            if (this.currentState.onExit) {\r\n                const canExit = (_a = this.currentState) === null || _a === void 0 ? void 0 : _a.onExit({ to: potentialNewState.name, data: this.data });\r\n                if (canExit === false) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter) {\r\n                const canEnter = potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter({ from: this.currentState.name, eventData, data: this.data });\r\n                if (canEnter === false) {\r\n                    return false;\r\n                }\r\n            }\r\n            // console.log(`${this.currentState.name} => ${potentialNewState.name} (${eventData})`);\r\n            this.currentState = potentialNewState;\r\n            if ((_b = this.currentState) === null || _b === void 0 ? void 0 : _b.onState) {\r\n                this.currentState.onState();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    update(elapsedMs) {\r\n        if (this.currentState.onUpdate) {\r\n            this.currentState.onUpdate(this.data, elapsedMs);\r\n        }\r\n    }\r\n    save(saveKey) {\r\n        localStorage.setItem(saveKey, JSON.stringify({\r\n            currentState: this.currentState.name,\r\n            data: this.data\r\n        }));\r\n    }\r\n    restore(saveKey) {\r\n        const state = JSON.parse(localStorage.getItem(saveKey));\r\n        this.currentState = this.states.get(state.currentState);\r\n        this.data = state.data;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Resources/Sound/WebAudioInstance.ts\n\r\n\r\n\r\n/**\r\n * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n */\r\nclass WebAudioInstance {\r\n    constructor(_src) {\r\n        this._src = _src;\r\n        this._audioContext = AudioContextFactory.create();\r\n        this._volumeNode = this._audioContext.createGain();\r\n        this._playingPromise = new Promise((resolve) => {\r\n            this._playingResolve = resolve;\r\n        });\r\n        this._stateMachine = StateMachine.create({\r\n            start: 'STOPPED',\r\n            states: {\r\n                PLAYING: {\r\n                    onEnter: ({ data }) => {\r\n                        // Buffer nodes are single use\r\n                        this._createNewBufferSource();\r\n                        this._handleEnd();\r\n                        this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);\r\n                        data.startedAt = (this._audioContext.currentTime - data.pausedAt);\r\n                        data.pausedAt = 0;\r\n                    },\r\n                    onState: () => this._playStarted(),\r\n                    onExit: ({ to }) => {\r\n                        // If you've exited early only resolve if explicitly STOPPED\r\n                        if (to === 'STOPPED') {\r\n                            this._playingResolve(true);\r\n                        }\r\n                        // Whenever you're not playing... you stop!\r\n                        this._instance.onended = null; // disconnect the wired on-end handler\r\n                        this._instance.disconnect();\r\n                        this._instance.stop(0);\r\n                        this._instance = null;\r\n                    },\r\n                    transitions: ['STOPPED', 'PAUSED', 'SEEK']\r\n                },\r\n                SEEK: {\r\n                    onEnter: ({ eventData: position, data }) => {\r\n                        data.pausedAt = (position !== null && position !== void 0 ? position : 0) / this._playbackRate;\r\n                        data.startedAt = 0;\r\n                    },\r\n                    transitions: ['*']\r\n                },\r\n                STOPPED: {\r\n                    onEnter: ({ data }) => {\r\n                        data.pausedAt = 0;\r\n                        data.startedAt = 0;\r\n                        this._playingResolve(true);\r\n                    },\r\n                    transitions: ['PLAYING', 'PAUSED', 'SEEK']\r\n                },\r\n                PAUSED: {\r\n                    onEnter: ({ data }) => {\r\n                        // Playback rate will be a scale factor of how fast/slow the audio is being played\r\n                        // default is 1.0\r\n                        // we need to invert it to get the time scale\r\n                        data.pausedAt = (this._audioContext.currentTime - data.startedAt);\r\n                    },\r\n                    transitions: ['PLAYING', 'STOPPED', 'SEEK']\r\n                }\r\n            }\r\n        }, {\r\n            startedAt: 0,\r\n            pausedAt: 0\r\n        });\r\n        this._volume = 1;\r\n        this._loop = false;\r\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n        this._playStarted = () => { };\r\n        this._playbackRate = 1.0;\r\n        this._createNewBufferSource();\r\n    }\r\n    _createNewBufferSource() {\r\n        this._instance = this._audioContext.createBufferSource();\r\n        this._instance.buffer = this._src;\r\n        this._instance.loop = this.loop;\r\n        this._instance.playbackRate.value = this._playbackRate;\r\n        this._instance.connect(this._volumeNode);\r\n        this._volumeNode.connect(this._audioContext.destination);\r\n    }\r\n    _handleEnd() {\r\n        if (!this.loop) {\r\n            this._instance.onended = () => {\r\n                this._playingResolve(true);\r\n            };\r\n        }\r\n    }\r\n    set loop(value) {\r\n        this._loop = value;\r\n        if (this._instance) {\r\n            this._instance.loop = value;\r\n            if (!this.loop) {\r\n                this._instance.onended = () => {\r\n                    this._playingResolve(true);\r\n                };\r\n            }\r\n        }\r\n    }\r\n    get loop() {\r\n        return this._loop;\r\n    }\r\n    set volume(value) {\r\n        value = clamp(value, 0, 1.0);\r\n        this._volume = value;\r\n        if (this._stateMachine.in('PLAYING') && this._volumeNode.gain.setTargetAtTime) {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime\r\n            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.\r\n            // This exponential ramp provides a more pleasant transition in gain\r\n            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);\r\n        }\r\n        else {\r\n            this._volumeNode.gain.value = value;\r\n        }\r\n    }\r\n    get volume() {\r\n        return this._volume;\r\n    }\r\n    /**\r\n     * Returns the set duration to play, otherwise returns the total duration if unset\r\n     */\r\n    get duration() {\r\n        var _a;\r\n        return (_a = this._duration) !== null && _a !== void 0 ? _a : this.getTotalPlaybackDuration();\r\n    }\r\n    /**\r\n     * Set the duration that this audio should play.\r\n     *\r\n     * Note: if you seek to a specific point the duration will start from that point, for example\r\n     *\r\n     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n     */\r\n    set duration(duration) {\r\n        this._duration = duration;\r\n    }\r\n    isPlaying() {\r\n        return this._stateMachine.in('PLAYING');\r\n    }\r\n    isPaused() {\r\n        return this._stateMachine.in('PAUSED') || this._stateMachine.in('SEEK');\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    play(playStarted = () => { }) {\r\n        this._playStarted = playStarted;\r\n        this._stateMachine.go('PLAYING');\r\n        return this._playingPromise;\r\n    }\r\n    pause() {\r\n        this._stateMachine.go('PAUSED');\r\n    }\r\n    stop() {\r\n        this._stateMachine.go('STOPPED');\r\n    }\r\n    seek(position) {\r\n        this._stateMachine.go('PAUSED');\r\n        this._stateMachine.go('SEEK', position);\r\n    }\r\n    getTotalPlaybackDuration() {\r\n        return this._src.duration;\r\n    }\r\n    getPlaybackPosition() {\r\n        const { pausedAt, startedAt } = this._stateMachine.data;\r\n        if (pausedAt) {\r\n            return pausedAt * this._playbackRate;\r\n        }\r\n        if (startedAt) {\r\n            return (this._audioContext.currentTime - startedAt) * this._playbackRate;\r\n        }\r\n        return 0;\r\n    }\r\n    set playbackRate(playbackRate) {\r\n        this._instance.playbackRate.value = this._playbackRate = playbackRate;\r\n    }\r\n    get playbackRate() {\r\n        return this._instance.playbackRate.value;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Events/MediaEvents.ts\n\r\nclass MediaEvent extends GameEvent {\r\n    constructor(target, _name = 'MediaEvent') {\r\n        super();\r\n        this.target = target;\r\n        this._name = _name;\r\n    }\r\n    /**\r\n     * Media event cannot bubble\r\n     */\r\n    set bubbles(_value) {\r\n        // stubbed\r\n    }\r\n    /**\r\n     * Media event cannot bubble\r\n     */\r\n    get bubbles() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Media event cannot bubble, so they have no path\r\n     */\r\n    get _path() {\r\n        return null;\r\n    }\r\n    /**\r\n     * Media event cannot bubble, so they have no path\r\n     */\r\n    set _path(_val) {\r\n        // stubbed\r\n    }\r\n    /**\r\n     * Prevents event from bubbling\r\n     */\r\n    stopPropagation() {\r\n        /**\r\n         * Stub\r\n         */\r\n    }\r\n    /**\r\n     * Action, that calls when event happens\r\n     */\r\n    action() {\r\n        /**\r\n         * Stub\r\n         */\r\n    }\r\n    /**\r\n     * Propagate event further through event path\r\n     */\r\n    propagate() {\r\n        /**\r\n         * Stub\r\n         */\r\n    }\r\n    layPath(_actor) {\r\n        /**\r\n         * Stub\r\n         */\r\n    }\r\n}\r\nclass NativeSoundEvent extends MediaEvent {\r\n    constructor(target, track) {\r\n        super(target, 'NativeSoundEvent');\r\n        this.track = track;\r\n    }\r\n}\r\nclass NativeSoundProcessedEvent extends MediaEvent {\r\n    constructor(target, _processedData) {\r\n        super(target, 'NativeSoundProcessedEvent');\r\n        this._processedData = _processedData;\r\n        this.data = this._processedData;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Sound.ts\n\r\n/**\r\n * Whether or not the browser can play this file as HTML5 Audio\r\n */\r\nfunction canPlayFile(file) {\r\n    try {\r\n        const a = new Audio();\r\n        const filetype = /.*\\.([A-Za-z0-9]+)$/;\r\n        const type = file.match(filetype)[1];\r\n        if (a.canPlayType('audio/' + type)) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e) {\r\n        Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);\r\n        return false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Resources/Sound/Sound.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The [[Sound]] object allows games built in Excalibur to load audio\r\n * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]\r\n * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n */\r\nclass Sound extends Class {\r\n    /**\r\n     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n     */\r\n    constructor(...paths) {\r\n        super();\r\n        this.logger = Logger.getInstance();\r\n        this._loop = false;\r\n        this._volume = 1;\r\n        this._isStopped = false;\r\n        // private _isPaused = false;\r\n        this._tracks = [];\r\n        this._wasPlayingOnHidden = false;\r\n        this._playbackRate = 1.0;\r\n        this._audioContext = AudioContextFactory.create();\r\n        this._resource = new Resource('', ExResponse.type.arraybuffer);\r\n        /**\r\n         * Chrome : MP3, WAV, Ogg\r\n         * Firefox : WAV, Ogg,\r\n         * IE : MP3, WAV coming soon\r\n         * Safari MP3, WAV, Ogg\r\n         */\r\n        for (const path of paths) {\r\n            if (canPlayFile(path)) {\r\n                this.path = path;\r\n                break;\r\n            }\r\n        }\r\n        if (!this.path) {\r\n            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));\r\n            this.logger.warn('Attempting to use', paths[0]);\r\n            this.path = paths[0]; // select the first specified\r\n        }\r\n    }\r\n    /**\r\n     * Indicates whether the clip should loop when complete\r\n     * @param value  Set the looping flag\r\n     */\r\n    set loop(value) {\r\n        this._loop = value;\r\n        for (const track of this._tracks) {\r\n            track.loop = this._loop;\r\n        }\r\n        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);\r\n    }\r\n    get loop() {\r\n        return this._loop;\r\n    }\r\n    set volume(value) {\r\n        this._volume = value;\r\n        for (const track of this._tracks) {\r\n            track.volume = this._volume;\r\n        }\r\n        this.emit('volumechange', new NativeSoundEvent(this));\r\n        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);\r\n    }\r\n    get volume() {\r\n        return this._volume;\r\n    }\r\n    /**\r\n     * Get the duration that this audio should play. If unset the total natural playback duration will be used.\r\n     */\r\n    get duration() {\r\n        return this._duration;\r\n    }\r\n    /**\r\n     * Set the duration that this audio should play. If unset the total natural playback duration will be used.\r\n     *\r\n     * Note: if you seek to a specific point the duration will start from that point, for example\r\n     *\r\n     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n     */\r\n    set duration(duration) {\r\n        this._duration = duration;\r\n    }\r\n    /**\r\n     * Return array of Current AudioInstances playing or being paused\r\n     */\r\n    get instances() {\r\n        return this._tracks;\r\n    }\r\n    get path() {\r\n        return this._resource.path;\r\n    }\r\n    set path(val) {\r\n        this._resource.path = val;\r\n    }\r\n    isLoaded() {\r\n        return !!this.data;\r\n    }\r\n    async load() {\r\n        var _a, _b;\r\n        if (this.data) {\r\n            return this.data;\r\n        }\r\n        const arraybuffer = await this._resource.load();\r\n        const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));\r\n        this._duration = (_b = (_a = this._duration) !== null && _a !== void 0 ? _a : audiobuffer === null || audiobuffer === void 0 ? void 0 : audiobuffer.duration) !== null && _b !== void 0 ? _b : undefined;\r\n        this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));\r\n        return this.data = audiobuffer;\r\n    }\r\n    async decodeAudio(data) {\r\n        try {\r\n            return await this._audioContext.decodeAudioData(data.slice(0));\r\n        }\r\n        catch (e) {\r\n            this.logger.error('Unable to decode ' +\r\n                ' this browser may not fully support this format, or the file may be corrupt, ' +\r\n                'if this is an mp3 try removing id3 tags and album art from the file.');\r\n            return await Promise.reject();\r\n        }\r\n    }\r\n    wireEngine(engine) {\r\n        if (engine) {\r\n            this._engine = engine;\r\n            this._engine.on('hidden', () => {\r\n                if (engine.pauseAudioWhenHidden && this.isPlaying()) {\r\n                    this._wasPlayingOnHidden = true;\r\n                    this.pause();\r\n                }\r\n            });\r\n            this._engine.on('visible', () => {\r\n                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {\r\n                    this.play();\r\n                    this._wasPlayingOnHidden = false;\r\n                }\r\n            });\r\n            this._engine.on('start', () => {\r\n                this._isStopped = false;\r\n            });\r\n            this._engine.on('stop', () => {\r\n                this.stop();\r\n                this._isStopped = true;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Returns how many instances of the sound are currently playing\r\n     */\r\n    instanceCount() {\r\n        return this._tracks.length;\r\n    }\r\n    /**\r\n     * Whether or not the sound is playing right now\r\n     */\r\n    isPlaying() {\r\n        return this._tracks.some((t) => t.isPlaying());\r\n    }\r\n    isPaused() {\r\n        return this._tracks.some(t => t.isPaused());\r\n    }\r\n    /**\r\n     * Play the sound, returns a promise that resolves when the sound is done playing\r\n     * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n     */\r\n    play(volume) {\r\n        if (!this.isLoaded()) {\r\n            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');\r\n            return Promise.resolve(true);\r\n        }\r\n        if (this._isStopped) {\r\n            this.logger.warn('Cannot start playing. Engine is in a stopped state.');\r\n            return Promise.resolve(false);\r\n        }\r\n        this.volume = volume || this.volume;\r\n        if (this.isPaused()) {\r\n            return this._resumePlayback();\r\n        }\r\n        else {\r\n            return this._startPlayback();\r\n        }\r\n    }\r\n    /**\r\n     * Stop the sound, and do not rewind\r\n     */\r\n    pause() {\r\n        if (!this.isPlaying()) {\r\n            return;\r\n        }\r\n        for (const track of this._tracks) {\r\n            track.pause();\r\n        }\r\n        this.emit('pause', new NativeSoundEvent(this));\r\n        this.logger.debug('Paused all instances of sound', this.path);\r\n    }\r\n    /**\r\n     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.\r\n     */\r\n    stop() {\r\n        for (const track of this._tracks) {\r\n            track.stop();\r\n        }\r\n        this.emit('stop', new NativeSoundEvent(this));\r\n        this._tracks.length = 0;\r\n        this.logger.debug('Stopped all instances of sound', this.path);\r\n    }\r\n    get playbackRate() {\r\n        return this._playbackRate;\r\n    }\r\n    set playbackRate(playbackRate) {\r\n        this._playbackRate = playbackRate;\r\n        this._tracks.forEach(t => {\r\n            t.playbackRate = this._playbackRate;\r\n        });\r\n    }\r\n    seek(position, trackId = 0) {\r\n        if (this._tracks.length === 0) {\r\n            this._getTrackInstance(this.data);\r\n        }\r\n        this._tracks[trackId].seek(position);\r\n    }\r\n    getTotalPlaybackDuration() {\r\n        return this.data.duration;\r\n    }\r\n    /**\r\n     * Return the current playback time of the playing track in seconds from the start.\r\n     *\r\n     * Optionally specify the track to query if multiple are playing at once.\r\n     * @param trackId\r\n     */\r\n    getPlaybackPosition(trackId = 0) {\r\n        if (this._tracks.length) {\r\n            return this._tracks[trackId].getPlaybackPosition();\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Get Id of provided AudioInstance in current trackList\r\n     * @param track [[Audio]] which Id is to be given\r\n     */\r\n    getTrackId(track) {\r\n        return this._tracks.indexOf(track);\r\n    }\r\n    async _resumePlayback() {\r\n        if (this.isPaused) {\r\n            const resumed = [];\r\n            // ensure we resume *current* tracks (if paused)\r\n            for (const track of this._tracks) {\r\n                resumed.push(track.play().then(() => {\r\n                    this.emit('playbackend', new NativeSoundEvent(this, track));\r\n                    this._tracks.splice(this.getTrackId(track), 1);\r\n                    return true;\r\n                }));\r\n            }\r\n            this.emit('resume', new NativeSoundEvent(this));\r\n            this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);\r\n            // resolve when resumed tracks are done\r\n            await Promise.all(resumed);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Starts playback, returns a promise that resolves when playback is complete\r\n     */\r\n    async _startPlayback() {\r\n        const track = await this._getTrackInstance(this.data);\r\n        const complete = await track.play(() => {\r\n            this.emit('playbackstart', new NativeSoundEvent(this, track));\r\n            this.logger.debug('Playing new instance for sound', this.path);\r\n        });\r\n        // when done, remove track\r\n        this.emit('playbackend', new NativeSoundEvent(this, track));\r\n        this._tracks.splice(this.getTrackId(track), 1);\r\n        return complete;\r\n    }\r\n    _getTrackInstance(data) {\r\n        const newTrack = new WebAudioInstance(data);\r\n        newTrack.loop = this.loop;\r\n        newTrack.volume = this.volume;\r\n        newTrack.duration = this.duration;\r\n        newTrack.playbackRate = this._playbackRate;\r\n        this._tracks.push(newTrack);\r\n        return newTrack;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Loader.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Pre-loading assets\r\n *\r\n * The loader provides a mechanism to preload multiple resources at\r\n * one time. The loader must be passed to the engine in order to\r\n * trigger the loading progress bar.\r\n *\r\n * The [[Loader]] itself implements [[Loadable]] so you can load loaders.\r\n *\r\n * ## Example: Pre-loading resources for a game\r\n *\r\n * ```js\r\n * // create a loader\r\n * var loader = new ex.Loader();\r\n *\r\n * // create a resource dictionary (best practice is to keep a separate file)\r\n * var resources = {\r\n *   TextureGround: new ex.Texture(\"/images/textures/ground.png\"),\r\n *   SoundDeath: new ex.Sound(\"/sound/death.wav\", \"/sound/death.mp3\")\r\n * };\r\n *\r\n * // loop through dictionary and add to loader\r\n * for (var loadable in resources) {\r\n *   if (resources.hasOwnProperty(loadable)) {\r\n *     loader.addResource(resources[loadable]);\r\n *   }\r\n * }\r\n *\r\n * // start game\r\n * game.start(loader).then(function () {\r\n *   console.log(\"Game started!\");\r\n * });\r\n * ```\r\n *\r\n * ## Customize the Loader\r\n *\r\n * The loader can be customized to show different, text, logo, background color, and button.\r\n *\r\n * ```typescript\r\n * const loader = new ex.Loader([playerTexture]);\r\n *\r\n * // The loaders button text can simply modified using this\r\n * loader.playButtonText = 'Start the best game ever';\r\n *\r\n * // The logo can be changed by inserting a base64 image string here\r\n *\r\n * loader.logo = 'data:image/png;base64,iVBORw...';\r\n * loader.logoWidth = 15;\r\n * loader.logoHeight = 14;\r\n *\r\n * // The background color can be changed like so by supplying a valid CSS color string\r\n *\r\n * loader.backgroundColor = 'red'\r\n * loader.backgroundColor = '#176BAA'\r\n *\r\n * // To build a completely new button\r\n * loader.startButtonFactory = () => {\r\n *     let myButton = document.createElement('button');\r\n *     myButton.textContent = 'The best button';\r\n *     return myButton;\r\n * };\r\n *\r\n * engine.start(loader).then(() => {});\r\n * ```\r\n */\r\nclass Loader extends Class {\r\n    /**\r\n     * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n     */\r\n    constructor(loadables) {\r\n        super();\r\n        this.canvas = new Canvas({\r\n            filtering: ImageFiltering.Blended,\r\n            smoothing: true,\r\n            cache: true,\r\n            draw: this.draw.bind(this)\r\n        });\r\n        this._resourceList = [];\r\n        this._index = 0;\r\n        this._playButtonShown = false;\r\n        this._resourceCount = 0;\r\n        this._numLoaded = 0;\r\n        this._progressCounts = {};\r\n        this._totalCounts = {};\r\n        // logo drawing stuff\r\n        // base64 string encoding of the excalibur logo (logo-white.png)\r\n        this.logo = Loader_logo;\r\n        this.logoWidth = 468;\r\n        this.logoHeight = 118;\r\n        /**\r\n         * Gets or sets the color of the loading bar, default is [[Color.White]]\r\n         */\r\n        this.loadingBarColor = Color.White;\r\n        /**\r\n         * Gets or sets the background color of the loader as a hex string\r\n         */\r\n        this.backgroundColor = '#176BAA';\r\n        this.suppressPlayButton = false;\r\n        /** Loads the css from Loader.css */\r\n        this._playButtonStyles = Loader_0/* default.toString */.Z.toString();\r\n        /**\r\n         * Get/set play button text\r\n         */\r\n        this.playButtonText = 'Play game';\r\n        /**\r\n         * Return a html button element for excalibur to use as a play button\r\n         */\r\n        this.startButtonFactory = () => {\r\n            let buttonElement = document.getElementById('excalibur-play');\r\n            if (!buttonElement) {\r\n                buttonElement = document.createElement('button');\r\n            }\r\n            buttonElement.id = 'excalibur-play';\r\n            buttonElement.textContent = this.playButtonText;\r\n            buttonElement.style.display = 'none';\r\n            return buttonElement;\r\n        };\r\n        this._loadingFuture = new Future();\r\n        if (loadables) {\r\n            this.addResources(loadables);\r\n        }\r\n    }\r\n    get _image() {\r\n        if (!this._imageElement) {\r\n            this._imageElement = new Image();\r\n            this._imageElement.src = this.logo;\r\n        }\r\n        return this._imageElement;\r\n    }\r\n    get playButtonRootElement() {\r\n        return this._playButtonRootElement;\r\n    }\r\n    get playButtonElement() {\r\n        return this._playButtonElement;\r\n    }\r\n    get _playButton() {\r\n        const existingRoot = document.getElementById('excalibur-play-root');\r\n        if (existingRoot) {\r\n            this._playButtonRootElement = existingRoot;\r\n        }\r\n        if (!this._playButtonRootElement) {\r\n            this._playButtonRootElement = document.createElement('div');\r\n            this._playButtonRootElement.id = 'excalibur-play-root';\r\n            this._playButtonRootElement.style.position = 'absolute';\r\n            document.body.appendChild(this._playButtonRootElement);\r\n        }\r\n        if (!this._styleBlock) {\r\n            this._styleBlock = document.createElement('style');\r\n            this._styleBlock.textContent = this._playButtonStyles;\r\n            document.head.appendChild(this._styleBlock);\r\n        }\r\n        if (!this._playButtonElement) {\r\n            this._playButtonElement = this.startButtonFactory();\r\n            this._playButtonRootElement.appendChild(this._playButtonElement);\r\n        }\r\n        return this._playButtonElement;\r\n    }\r\n    wireEngine(engine) {\r\n        this._engine = engine;\r\n        this.canvas.width = this._engine.canvas.width;\r\n        this.canvas.height = this._engine.canvas.height;\r\n    }\r\n    /**\r\n     * Add a resource to the loader to load\r\n     * @param loadable  Resource to add\r\n     */\r\n    addResource(loadable) {\r\n        const key = this._index++;\r\n        this._resourceList.push(loadable);\r\n        this._progressCounts[key] = 0;\r\n        this._totalCounts[key] = 1;\r\n        this._resourceCount++;\r\n    }\r\n    /**\r\n     * Add a list of resources to the loader to load\r\n     * @param loadables  The list of resources to load\r\n     */\r\n    addResources(loadables) {\r\n        let i = 0;\r\n        const len = loadables.length;\r\n        for (i; i < len; i++) {\r\n            this.addResource(loadables[i]);\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the loader has completely loaded all resources\r\n     */\r\n    isLoaded() {\r\n        return this._numLoaded === this._resourceCount;\r\n    }\r\n    /**\r\n     * Shows the play button and returns a promise that resolves when clicked\r\n     */\r\n    async showPlayButton() {\r\n        var _a, _b;\r\n        if (this.suppressPlayButton) {\r\n            this.hidePlayButton();\r\n            // Delay is to give the logo a chance to show, otherwise don't delay\r\n            await delay(500, (_a = this._engine) === null || _a === void 0 ? void 0 : _a.clock);\r\n        }\r\n        else {\r\n            const resizeHandler = () => {\r\n                this._positionPlayButton();\r\n            };\r\n            if ((_b = this._engine) === null || _b === void 0 ? void 0 : _b.browser) {\r\n                this._engine.browser.window.on('resize', resizeHandler);\r\n            }\r\n            this._playButtonShown = true;\r\n            this._playButton.style.display = 'block';\r\n            document.body.addEventListener('keyup', (evt) => {\r\n                if (evt.key === 'Enter') {\r\n                    this._playButton.click();\r\n                }\r\n            });\r\n            this._positionPlayButton();\r\n            const playButtonClicked = new Promise((resolve) => {\r\n                const startButtonHandler = (e) => {\r\n                    var _a;\r\n                    // We want to stop propagation to keep bubbling to the engine pointer handlers\r\n                    e.stopPropagation();\r\n                    // Hide Button after click\r\n                    this.hidePlayButton();\r\n                    if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {\r\n                        this._engine.browser.window.off('resize', resizeHandler);\r\n                    }\r\n                    resolve();\r\n                };\r\n                this._playButton.addEventListener('click', startButtonHandler);\r\n                this._playButton.addEventListener('touchend', startButtonHandler);\r\n                this._playButton.addEventListener('pointerup', startButtonHandler);\r\n            });\r\n            return await playButtonClicked;\r\n        }\r\n    }\r\n    hidePlayButton() {\r\n        this._playButtonShown = false;\r\n        this._playButton.style.display = 'none';\r\n    }\r\n    /**\r\n     * Clean up generated elements for the loader\r\n     */\r\n    dispose() {\r\n        if (this._playButtonRootElement.parentElement) {\r\n            this._playButtonRootElement.removeChild(this._playButtonElement);\r\n            document.body.removeChild(this._playButtonRootElement);\r\n            document.head.removeChild(this._styleBlock);\r\n            this._playButtonRootElement = null;\r\n            this._playButtonElement = null;\r\n            this._styleBlock = null;\r\n        }\r\n    }\r\n    update(_engine, _delta) {\r\n        // override me\r\n    }\r\n    areResourcesLoaded() {\r\n        return this._loadingFuture.promise;\r\n    }\r\n    /**\r\n     * Begin loading all of the supplied resources, returning a promise\r\n     * that resolves when loading of all is complete AND the user has clicked the \"Play button\"\r\n     */\r\n    async load() {\r\n        var _a, _b;\r\n        await ((_a = this._image) === null || _a === void 0 ? void 0 : _a.decode()); // decode logo if it exists\r\n        this.canvas.flagDirty();\r\n        await Promise.all(this._resourceList.map(async (r) => {\r\n            await r.load().finally(() => {\r\n                // capture progress\r\n                this._numLoaded++;\r\n                this.canvas.flagDirty();\r\n            });\r\n        }));\r\n        // Wire all sound to the engine\r\n        for (const resource of this._resourceList) {\r\n            if (resource instanceof Sound) {\r\n                resource.wireEngine(this._engine);\r\n            }\r\n        }\r\n        this._loadingFuture.resolve();\r\n        // short delay in showing the button for aesthetics\r\n        await delay(200, (_b = this._engine) === null || _b === void 0 ? void 0 : _b.clock);\r\n        this.canvas.flagDirty();\r\n        await this.showPlayButton();\r\n        // Unlock browser AudioContext in after user gesture\r\n        // See: https://github.com/excaliburjs/Excalibur/issues/262\r\n        // See: https://github.com/excaliburjs/Excalibur/issues/1031\r\n        await WebAudio.unlock();\r\n        return (this.data = this._resourceList);\r\n    }\r\n    markResourceComplete() {\r\n        this._numLoaded++;\r\n    }\r\n    /**\r\n     * Returns the progress of the loader as a number between [0, 1] inclusive.\r\n     */\r\n    get progress() {\r\n        return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;\r\n    }\r\n    _positionPlayButton() {\r\n        if (this._engine) {\r\n            const screenHeight = this._engine.screen.viewport.height;\r\n            const screenWidth = this._engine.screen.viewport.width;\r\n            if (this._playButtonRootElement) {\r\n                const left = this._engine.canvas.offsetLeft;\r\n                const top = this._engine.canvas.offsetTop;\r\n                const buttonWidth = this._playButton.clientWidth;\r\n                const buttonHeight = this._playButton.clientHeight;\r\n                if (this.playButtonPosition) {\r\n                    this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;\r\n                    this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;\r\n                }\r\n                else {\r\n                    this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;\r\n                    this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Loader draw function. Draws the default Excalibur loading screen.\r\n     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n     * to customize the drawing, or just override entire method.\r\n     */\r\n    draw(ctx) {\r\n        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;\r\n        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;\r\n        this._positionPlayButton();\r\n        ctx.fillStyle = this.backgroundColor;\r\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n        let logoY = canvasHeight / 2;\r\n        const width = Math.min(this.logoWidth, canvasWidth * 0.75);\r\n        let logoX = canvasWidth / 2 - width / 2;\r\n        if (this.logoPosition) {\r\n            logoX = this.logoPosition.x;\r\n            logoY = this.logoPosition.y;\r\n        }\r\n        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\r\n        const oldAntialias = this._engine.getAntialiasing();\r\n        this._engine.setAntialiasing(true);\r\n        if (!this.logoPosition) {\r\n            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);\r\n        }\r\n        else {\r\n            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);\r\n        }\r\n        // loading box\r\n        if (!this.suppressPlayButton && this._playButtonShown) {\r\n            this._engine.setAntialiasing(oldAntialias);\r\n            return;\r\n        }\r\n        let loadingX = logoX;\r\n        let loadingY = logoY;\r\n        if (this.loadingBarPosition) {\r\n            loadingX = this.loadingBarPosition.x;\r\n            loadingY = this.loadingBarPosition.y;\r\n        }\r\n        ctx.lineWidth = 2;\r\n        roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);\r\n        const progress = width * this.progress;\r\n        const margin = 5;\r\n        const progressWidth = progress - margin * 2;\r\n        const height = 20 - margin * 2;\r\n        roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);\r\n        this._engine.setAntialiasing(oldAntialias);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Detector.ts\n\r\n/**\r\n * This is the list of features that will be used to log the supported\r\n * features to the console when Detector.logBrowserFeatures() is called.\r\n */\r\nconst REPORTED_FEATURES = {\r\n    webgl: 'WebGL',\r\n    webaudio: 'WebAudio',\r\n    gamepadapi: 'Gamepad API'\r\n};\r\n/**\r\n * Excalibur internal feature detection helper class\r\n */\r\nclass Detector {\r\n    constructor() {\r\n        this._features = null;\r\n        this.failedTests = [];\r\n        // critical browser features required for ex to run\r\n        this._criticalTests = {\r\n            // Test canvas/2d context support\r\n            canvasSupport: function () {\r\n                const elem = document.createElement('canvas');\r\n                return !!(elem.getContext && elem.getContext('2d'));\r\n            },\r\n            // Test array buffer support ex uses for downloading binary data\r\n            arrayBufferSupport: function () {\r\n                const xhr = new XMLHttpRequest();\r\n                xhr.open('GET', '/');\r\n                try {\r\n                    xhr.responseType = 'arraybuffer';\r\n                }\r\n                catch (e) {\r\n                    return false;\r\n                }\r\n                return xhr.responseType === 'arraybuffer';\r\n            },\r\n            // Test data urls ex uses for sprites\r\n            dataUrlSupport: function () {\r\n                const canvas = document.createElement('canvas');\r\n                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;\r\n            },\r\n            // Test object url support for loading\r\n            objectUrlSupport: function () {\r\n                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;\r\n            },\r\n            // RGBA support for colors\r\n            rgbaSupport: function () {\r\n                const style = document.createElement('a').style;\r\n                style.cssText = 'background-color:rgba(150,255,150,.5)';\r\n                return ('' + style.backgroundColor).indexOf('rgba') > -1;\r\n            }\r\n        };\r\n        // warnings excalibur performance will be degraded\r\n        this._warningTest = {\r\n            webAudioSupport: function () {\r\n                return !!(window.AudioContext ||\r\n                    window.webkitAudioContext ||\r\n                    window.mozAudioContext ||\r\n                    window.msAudioContext ||\r\n                    window.oAudioContext);\r\n            },\r\n            webglSupport: function () {\r\n                const elem = document.createElement('canvas');\r\n                return !!(elem.getContext && elem.getContext('webgl'));\r\n            }\r\n        };\r\n        this._features = this._loadBrowserFeatures();\r\n    }\r\n    /**\r\n     * Returns a map of currently supported browser features. This method\r\n     * treats the features as a singleton and will only calculate feature\r\n     * support if it has not previously been done.\r\n     */\r\n    getBrowserFeatures() {\r\n        if (this._features === null) {\r\n            this._features = this._loadBrowserFeatures();\r\n        }\r\n        return this._features;\r\n    }\r\n    /**\r\n     * Report on non-critical browser support for debugging purposes.\r\n     * Use native browser console colors for visibility.\r\n     */\r\n    logBrowserFeatures() {\r\n        let msg = '%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n';\r\n        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];\r\n        const supported = this.getBrowserFeatures();\r\n        for (const feature of Object.keys(REPORTED_FEATURES)) {\r\n            if (supported[feature]) {\r\n                msg += '(%c\\u2713%c)'; // (✓)\r\n                args.push('font-weight: bold; color: green');\r\n                args.push('font-weight: normal; color: inherit');\r\n            }\r\n            else {\r\n                msg += '(%c\\u2717%c)'; // (✗)\r\n                args.push('font-weight: bold; color: red');\r\n                args.push('font-weight: normal; color: inherit');\r\n            }\r\n            msg += ' ' + REPORTED_FEATURES[feature] + '\\n';\r\n        }\r\n        args.unshift(msg);\r\n        // eslint-disable-next-line no-console\r\n        console.log.apply(console, args);\r\n    }\r\n    /**\r\n     * Executes several IIFE's to get a constant reference to supported\r\n     * features within the current execution context.\r\n     */\r\n    _loadBrowserFeatures() {\r\n        return {\r\n            // IIFE to check canvas support\r\n            canvas: (() => {\r\n                return this._criticalTests.canvasSupport();\r\n            })(),\r\n            // IIFE to check arraybuffer support\r\n            arraybuffer: (() => {\r\n                return this._criticalTests.arrayBufferSupport();\r\n            })(),\r\n            // IIFE to check dataurl support\r\n            dataurl: (() => {\r\n                return this._criticalTests.dataUrlSupport();\r\n            })(),\r\n            // IIFE to check objecturl support\r\n            objecturl: (() => {\r\n                return this._criticalTests.objectUrlSupport();\r\n            })(),\r\n            // IIFE to check rgba support\r\n            rgba: (() => {\r\n                return this._criticalTests.rgbaSupport();\r\n            })(),\r\n            // IIFE to check webaudio support\r\n            webaudio: (() => {\r\n                return this._warningTest.webAudioSupport();\r\n            })(),\r\n            // IIFE to check webgl support\r\n            webgl: (() => {\r\n                return this._warningTest.webglSupport();\r\n            })(),\r\n            // IIFE to check gamepadapi support\r\n            gamepadapi: (() => {\r\n                return !!navigator.getGamepads;\r\n            })()\r\n        };\r\n    }\r\n    test() {\r\n        // Critical test will for ex not to run\r\n        let failedCritical = false;\r\n        for (const test in this._criticalTests) {\r\n            if (!this._criticalTests[test].call(this)) {\r\n                this.failedTests.push(test);\r\n                Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);\r\n                failedCritical = true;\r\n            }\r\n        }\r\n        if (failedCritical) {\r\n            return false;\r\n        }\r\n        // Warning tests do not for ex to return false to compatibility\r\n        for (const warning in this._warningTest) {\r\n            if (!this._warningTest[warning]()) {\r\n                Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/CollisionType.ts\n/**\r\n * An enum that describes the types of collisions bodies can participate in\r\n */\r\nvar CollisionType;\r\n(function (CollisionType) {\r\n    /**\r\n     * Bodies with the `PreventCollision` setting do not participate in any\r\n     * collisions and do not raise collision events.\r\n     */\r\n    CollisionType[\"PreventCollision\"] = \"PreventCollision\";\r\n    /**\r\n     * Bodies with the `Passive` setting only raise collision events, but are not\r\n     * influenced or moved by other bodies and do not influence or move other bodies.\r\n     * This is useful for use in trigger type behavior.\r\n     */\r\n    CollisionType[\"Passive\"] = \"Passive\";\r\n    /**\r\n     * Bodies with the `Active` setting raise collision events and participate\r\n     * in collisions with other bodies and will be push or moved by bodies sharing\r\n     * the `Active` or `Fixed` setting.\r\n     */\r\n    CollisionType[\"Active\"] = \"Active\";\r\n    /**\r\n     * Bodies with the `Fixed` setting raise collision events and participate in\r\n     * collisions with other bodies. Actors with the `Fixed` setting will not be\r\n     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed\r\n     * bodies as \"immovable/unstoppable\" objects. If two `Fixed` bodies meet they will\r\n     * not be pushed or moved by each other, they will not interact except to throw\r\n     * collision events.\r\n     */\r\n    CollisionType[\"Fixed\"] = \"Fixed\";\r\n})(CollisionType || (CollisionType = {}));\r\n\n;// CONCATENATED MODULE: ./Util/Decorators.ts\n\r\n\r\nconst maxMessages = 5;\r\nconst obsoleteMessage = {};\r\nconst resetObsoleteCounter = () => {\r\n    for (const message in obsoleteMessage) {\r\n        obsoleteMessage[message] = 0;\r\n    }\r\n};\r\nconst logMessage = (message, options) => {\r\n    const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');\r\n    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {\r\n        Logger.getInstance().warn(message);\r\n        // tslint:disable-next-line: no-console\r\n        if (console.trace && options.showStackTrace) {\r\n            // tslint:disable-next-line: no-console\r\n            console.trace();\r\n        }\r\n    }\r\n    obsoleteMessage[message]++;\r\n};\r\n/**\r\n * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n */\r\nfunction obsolete(options) {\r\n    options = {\r\n        message: 'This feature will be removed in future versions of Excalibur.',\r\n        alternateMethod: null,\r\n        showStackTrace: false,\r\n        ...options\r\n    };\r\n    return function (target, property, descriptor) {\r\n        if (descriptor &&\r\n            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {\r\n            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');\r\n        }\r\n        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;\r\n        const message = `${methodSignature} is marked obsolete: ${options.message}` +\r\n            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');\r\n        if (!obsoleteMessage[message]) {\r\n            obsoleteMessage[message] = 0;\r\n        }\r\n        // If descriptor is null it is a class\r\n        const method = descriptor ? { ...descriptor } : target;\r\n        if (!descriptor) {\r\n            // with es2015 classes we need to change our decoration tactic\r\n            class DecoratedClass extends method {\r\n                constructor(...args) {\r\n                    logMessage(message, options);\r\n                    super(...args);\r\n                }\r\n            }\r\n            return DecoratedClass;\r\n        }\r\n        if (descriptor && descriptor.value) {\r\n            method.value = function () {\r\n                logMessage(message, options);\r\n                return descriptor.value.apply(this, arguments);\r\n            };\r\n            return method;\r\n        }\r\n        if (descriptor && descriptor.get) {\r\n            method.get = function () {\r\n                logMessage(message, options);\r\n                return descriptor.get.apply(this, arguments);\r\n            };\r\n        }\r\n        if (descriptor && descriptor.set) {\r\n            method.set = function () {\r\n                logMessage(message, options);\r\n                return descriptor.set.apply(this, arguments);\r\n            };\r\n        }\r\n        return method;\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Physics.ts\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n/**\r\n * Possible collision resolution strategies\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things\r\n * like platformers or top down games.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */\r\nvar CollisionResolutionStrategy;\r\n(function (CollisionResolutionStrategy) {\r\n    CollisionResolutionStrategy[\"Arcade\"] = \"arcade\";\r\n    CollisionResolutionStrategy[\"Realistic\"] = \"realistic\";\r\n})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));\r\n/**\r\n * Possible broadphase collision pair identification strategies\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */\r\nvar BroadphaseStrategy;\r\n(function (BroadphaseStrategy) {\r\n    BroadphaseStrategy[BroadphaseStrategy[\"DynamicAABBTree\"] = 0] = \"DynamicAABBTree\";\r\n})(BroadphaseStrategy || (BroadphaseStrategy = {}));\r\n/**\r\n * Possible numerical integrators for position and velocity\r\n */\r\nvar Integrator;\r\n(function (Integrator) {\r\n    Integrator[Integrator[\"Euler\"] = 0] = \"Euler\";\r\n})(Integrator || (Integrator = {}));\r\n/**\r\n * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n */\r\n/* istanbul ignore next */\r\nclass Physics {\r\n    static get gravity() {\r\n        return Physics.acc;\r\n    }\r\n    static set gravity(v) {\r\n        Physics.acc = v;\r\n    }\r\n    /**\r\n     * Configures Excalibur to use \"arcade\" physics. Arcade physics which performs simple axis aligned arcade style physics.\r\n     */\r\n    static useArcadePhysics() {\r\n        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n    }\r\n    /**\r\n     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n     * simulated physical interactions.\r\n     */\r\n    static useRealisticPhysics() {\r\n        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;\r\n    }\r\n    static get dynamicTreeVelocityMultiplyer() {\r\n        return Physics.dynamicTreeVelocityMultiplier;\r\n    }\r\n    static set dynamicTreeVelocityMultiplyer(value) {\r\n        Physics.dynamicTreeVelocityMultiplier = value;\r\n    }\r\n}\r\n/**\r\n * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.\r\n * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.\r\n *\r\n * This is a great way to globally simulate effects like gravity.\r\n */\r\nPhysics.acc = new Vector(0, 0);\r\n/**\r\n * Globally switches all Excalibur physics behavior on or off.\r\n */\r\nPhysics.enabled = true;\r\n/**\r\n * Gets or sets the broadphase pair identification strategy.\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */\r\nPhysics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\r\n/**\r\n * Gets or sets the global collision resolution strategy (narrowphase).\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */\r\nPhysics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n/**\r\n * The default mass to use if none is specified\r\n */\r\nPhysics.defaultMass = 10;\r\n/**\r\n * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n */\r\nPhysics.integrator = Integrator.Euler;\r\n/**\r\n * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);\r\n */\r\nPhysics.dynamicTreeVelocityMultiplier = 2;\r\n/**\r\n * Pad RigidBody BoundingBox by a constant amount\r\n */\r\nPhysics.boundsPadding = 5;\r\n/**\r\n * Number of position iterations (overlap) to run in the solver\r\n */\r\nPhysics.positionIterations = 3;\r\n/**\r\n * Number of velocity iteration (response) to run in the solver\r\n */\r\nPhysics.velocityIterations = 8;\r\n/**\r\n * Amount of overlap to tolerate in pixels\r\n */\r\nPhysics.slop = 1;\r\n/**\r\n * Amount of positional overlap correction to apply each position iteration of the solver\r\n * O - meaning no correction, 1 - meaning correct all overlap\r\n */\r\nPhysics.steeringFactor = 0.2;\r\n/**\r\n * Warm start set to true re-uses impulses from previous frames back in the solver\r\n */\r\nPhysics.warmStart = true;\r\n/**\r\n * By default bodies do not sleep\r\n */\r\nPhysics.bodiesCanSleepByDefault = false;\r\n/**\r\n * Surface epsilon is used to help deal with surface penetration\r\n */\r\nPhysics.surfaceEpsilon = 0.1;\r\nPhysics.sleepEpsilon = 0.07;\r\nPhysics.wakeThreshold = Physics.sleepEpsilon * 3;\r\nPhysics.sleepBias = 0.9;\r\n/**\r\n * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n * bodies from tunneling through one another.\r\n */\r\nPhysics.checkForFastBodies = true;\r\n/**\r\n * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n * Excalibur will always perform the fast body raycast regardless of speed.\r\n */\r\nPhysics.disableMinimumSpeedForFastBody = false;\r\n__decorate([\r\n    obsolete({\r\n        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',\r\n        alternateMethod: 'dynamicTreeVelocityMultiplier'\r\n    })\r\n], Physics, \"dynamicTreeVelocityMultiplyer\", null);\r\n\n;// CONCATENATED MODULE: ./Math/coord-plane.ts\n/**\r\n * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]\r\n */\r\nvar CoordPlane;\r\n(function (CoordPlane) {\r\n    /**\r\n     * The world coordinate plane (default) represents world space, any entities drawn with world\r\n     * space move when the camera moves.\r\n     */\r\n    CoordPlane[\"World\"] = \"world\";\r\n    /**\r\n     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned\r\n     * to screen coordinates ignoring the camera.\r\n     */\r\n    CoordPlane[\"Screen\"] = \"screen\";\r\n})(CoordPlane || (CoordPlane = {}));\r\n\n;// CONCATENATED MODULE: ./Math/vector-view.ts\n\r\nclass VectorView extends Vector {\r\n    constructor(options) {\r\n        super(0, 0);\r\n        this._getX = options.getX;\r\n        this._getY = options.getY;\r\n        this._setX = options.setX;\r\n        this._setY = options.setY;\r\n    }\r\n    get x() {\r\n        return (this._x = this._getX());\r\n    }\r\n    set x(val) {\r\n        this._setX(val);\r\n        this._x = val;\r\n    }\r\n    get y() {\r\n        return (this._y = this._getY());\r\n    }\r\n    set y(val) {\r\n        this._setY(val);\r\n        this._y = val;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/watch-vector.ts\n\r\n/**\r\n * Wraps a vector and watches for changes in the x/y, modifies the original vector.\r\n */\r\nclass WatchVector extends Vector {\r\n    constructor(original, change) {\r\n        super(original.x, original.y);\r\n        this.original = original;\r\n        this.change = change;\r\n    }\r\n    get x() {\r\n        return this._x = this.original.x;\r\n    }\r\n    set x(newX) {\r\n        this.change(newX, this._y);\r\n        this._x = this.original.x = newX;\r\n    }\r\n    get y() {\r\n        return this._y = this.original.y;\r\n    }\r\n    set y(newY) {\r\n        this.change(this._x, newY);\r\n        this._y = this.original.y = newY;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/transform.ts\n\r\n\r\n\r\n\r\n\r\nclass Transform {\r\n    constructor() {\r\n        this._parent = null;\r\n        this._children = [];\r\n        this._pos = vec(0, 0);\r\n        this._rotation = 0;\r\n        this._scale = vec(1, 1);\r\n        this._isDirty = false;\r\n        this._isInverseDirty = false;\r\n        this._matrix = AffineMatrix.identity();\r\n        this._inverse = AffineMatrix.identity();\r\n    }\r\n    get parent() {\r\n        return this._parent;\r\n    }\r\n    set parent(transform) {\r\n        if (this._parent) {\r\n            const index = this._parent._children.indexOf(this);\r\n            if (index > -1) {\r\n                this._parent._children.splice(index, 1);\r\n            }\r\n        }\r\n        this._parent = transform;\r\n        if (this._parent) {\r\n            this._parent._children.push(this);\r\n        }\r\n        this.flagDirty();\r\n    }\r\n    get children() {\r\n        return this._children;\r\n    }\r\n    set pos(v) {\r\n        if (!v.equals(this._pos)) {\r\n            this._pos.x = v.x;\r\n            this._pos.y = v.y;\r\n            this.flagDirty();\r\n        }\r\n    }\r\n    get pos() {\r\n        return new WatchVector(this._pos, (x, y) => {\r\n            if (x !== this._pos.x || y !== this._pos.y) {\r\n                this.flagDirty();\r\n            }\r\n        });\r\n    }\r\n    set globalPos(v) {\r\n        let localPos = v.clone();\r\n        if (this.parent) {\r\n            localPos = this.parent.inverse.multiply(v);\r\n        }\r\n        if (!localPos.equals(this._pos)) {\r\n            this._pos = localPos;\r\n            this.flagDirty();\r\n        }\r\n    }\r\n    get globalPos() {\r\n        return new VectorView({\r\n            getX: () => this.matrix.data[4],\r\n            getY: () => this.matrix.data[5],\r\n            setX: (x) => {\r\n                if (this.parent) {\r\n                    const { x: newX } = this.parent.inverse.multiply(vec(x, this.pos.y));\r\n                    this.pos.x = newX;\r\n                }\r\n                else {\r\n                    this.pos.x = x;\r\n                }\r\n                if (x !== this.matrix.data[4]) {\r\n                    this.flagDirty();\r\n                }\r\n            },\r\n            setY: (y) => {\r\n                if (this.parent) {\r\n                    const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y));\r\n                    this.pos.y = newY;\r\n                }\r\n                else {\r\n                    this.pos.y = y;\r\n                }\r\n                if (y !== this.matrix.data[5]) {\r\n                    this.flagDirty();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    set rotation(rotation) {\r\n        const canonRotation = canonicalizeAngle(rotation);\r\n        if (canonRotation !== this._rotation) {\r\n            this.flagDirty();\r\n        }\r\n        this._rotation = canonRotation;\r\n    }\r\n    get rotation() {\r\n        return this._rotation;\r\n    }\r\n    set globalRotation(rotation) {\r\n        let inverseRotation = 0;\r\n        if (this.parent) {\r\n            inverseRotation = this.parent.globalRotation;\r\n        }\r\n        const canonRotation = canonicalizeAngle(rotation + inverseRotation);\r\n        if (canonRotation !== this._rotation) {\r\n            this.flagDirty();\r\n        }\r\n        this._rotation = canonRotation;\r\n    }\r\n    get globalRotation() {\r\n        if (this.parent) {\r\n            return this.matrix.getRotation();\r\n        }\r\n        return this.rotation;\r\n    }\r\n    set scale(v) {\r\n        if (!v.equals(this._scale)) {\r\n            this._scale.x = v.x;\r\n            this._scale.y = v.y;\r\n            this.flagDirty();\r\n        }\r\n    }\r\n    get scale() {\r\n        return new WatchVector(this._scale, (x, y) => {\r\n            if (x !== this._scale.x || y !== this._scale.y) {\r\n                this.flagDirty();\r\n            }\r\n        });\r\n    }\r\n    set globalScale(v) {\r\n        let inverseScale = vec(1, 1);\r\n        if (this.parent) {\r\n            inverseScale = this.parent.globalScale;\r\n        }\r\n        this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));\r\n    }\r\n    get globalScale() {\r\n        return new VectorView({\r\n            getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,\r\n            getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,\r\n            setX: (x) => {\r\n                if (this.parent) {\r\n                    const globalScaleX = this.parent.globalScale.x;\r\n                    this.scale.x = x / globalScaleX;\r\n                }\r\n                else {\r\n                    this.scale.x = x;\r\n                }\r\n            },\r\n            setY: (y) => {\r\n                if (this.parent) {\r\n                    const globalScaleY = this.parent.globalScale.y;\r\n                    this.scale.y = y / globalScaleY;\r\n                }\r\n                else {\r\n                    this.scale.y = y;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    get matrix() {\r\n        if (this._isDirty) {\r\n            if (this.parent === null) {\r\n                this._matrix = this._calculateMatrix();\r\n            }\r\n            else {\r\n                this._matrix = this.parent.matrix.multiply(this._calculateMatrix());\r\n            }\r\n            this._isDirty = false;\r\n        }\r\n        return this._matrix;\r\n    }\r\n    get inverse() {\r\n        if (this._isInverseDirty) {\r\n            this._inverse = this.matrix.inverse();\r\n            this._isInverseDirty = false;\r\n        }\r\n        return this._inverse;\r\n    }\r\n    _calculateMatrix() {\r\n        const matrix = AffineMatrix.identity()\r\n            .translate(this.pos.x, this.pos.y)\r\n            .rotate(this.rotation)\r\n            .scale(this.scale.x, this.scale.y);\r\n        return matrix;\r\n    }\r\n    flagDirty() {\r\n        this._isDirty = true;\r\n        this._isInverseDirty = true;\r\n        for (let i = 0; i < this._children.length; i++) {\r\n            this._children[i].flagDirty();\r\n        }\r\n    }\r\n    apply(point) {\r\n        return this.matrix.multiply(point);\r\n    }\r\n    applyInverse(point) {\r\n        return this.inverse.multiply(point);\r\n    }\r\n    setTransform(pos, rotation, scale) {\r\n        this._pos.x = pos.x;\r\n        this._pos.y = pos.y;\r\n        this._rotation = canonicalizeAngle(rotation);\r\n        this._scale.x = scale.x;\r\n        this._scale.y = scale.y;\r\n        this.flagDirty();\r\n    }\r\n    clone(dest) {\r\n        const target = dest !== null && dest !== void 0 ? dest : new Transform();\r\n        this._pos.clone(target._pos);\r\n        target._rotation = this._rotation;\r\n        this._scale.clone(target._scale);\r\n        target.flagDirty();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/Component.ts\n/**\r\n * Type guard to check if a component implements clone\r\n * @param x\r\n */\r\nfunction hasClone(x) {\r\n    return !!(x === null || x === void 0 ? void 0 : x.clone);\r\n}\r\n/**\r\n * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses\r\n *\r\n * Implementations of Component must have a zero-arg constructor to support dependencies\r\n *\r\n * ```typescript\r\n * class MyComponent extends ex.Component<'my'> {\r\n *   public readonly type = 'my';\r\n *   // zero arg support required if you want to use component dependencies\r\n *   constructor(public optionalPos?: ex.Vector) {}\r\n * }\r\n * ```\r\n */\r\nclass Component {\r\n    constructor() {\r\n        /**\r\n         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]\r\n         */\r\n        this.owner = null;\r\n    }\r\n    /**\r\n     * Clones any properties on this component, if that property value has a `clone()` method it will be called\r\n     */\r\n    clone() {\r\n        const newComponent = new this.constructor();\r\n        for (const prop in this) {\r\n            if (this.hasOwnProperty(prop)) {\r\n                const val = this[prop];\r\n                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {\r\n                    newComponent[prop] = val.clone();\r\n                }\r\n                else {\r\n                    newComponent[prop] = val;\r\n                }\r\n            }\r\n        }\r\n        return newComponent;\r\n    }\r\n}\r\n/**\r\n * Tag components are a way of tagging a component with label and a simple value\r\n *\r\n * For example:\r\n *\r\n * ```typescript\r\n * const isOffscreen = new TagComponent('offscreen');\r\n * entity.addComponent(isOffscreen);\r\n * entity.tags.includes\r\n * ```\r\n */\r\nclass TagComponent extends Component {\r\n    constructor(type, value) {\r\n        super();\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Observable.ts\n/**\r\n * Simple Observable implementation\r\n * @template T is the typescript Type that defines the data being observed\r\n */\r\nclass Observable {\r\n    constructor() {\r\n        this.observers = [];\r\n        this.subscriptions = [];\r\n    }\r\n    /**\r\n     * Register an observer to listen to this observable\r\n     * @param observer\r\n     */\r\n    register(observer) {\r\n        this.observers.push(observer);\r\n    }\r\n    /**\r\n     * Register a callback to listen to this observable\r\n     * @param func\r\n     */\r\n    subscribe(func) {\r\n        this.subscriptions.push(func);\r\n    }\r\n    /**\r\n     * Remove an observer from the observable\r\n     * @param observer\r\n     */\r\n    unregister(observer) {\r\n        const i = this.observers.indexOf(observer);\r\n        if (i !== -1) {\r\n            this.observers.splice(i, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Remove a callback that is listening to this observable\r\n     * @param func\r\n     */\r\n    unsubscribe(func) {\r\n        const i = this.subscriptions.indexOf(func);\r\n        if (i !== -1) {\r\n            this.subscriptions.splice(i, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Broadcasts a message to all observers and callbacks\r\n     * @param message\r\n     */\r\n    notifyAll(message) {\r\n        const observersLength = this.observers.length;\r\n        for (let i = 0; i < observersLength; i++) {\r\n            this.observers[i].notify(message);\r\n        }\r\n        const subscriptionsLength = this.subscriptions.length;\r\n        for (let i = 0; i < subscriptionsLength; i++) {\r\n            this.subscriptions[i](message);\r\n        }\r\n    }\r\n    /**\r\n     * Removes all observers and callbacks\r\n     */\r\n    clear() {\r\n        this.observers.length = 0;\r\n        this.subscriptions.length = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/Components/TransformComponent.ts\n\r\n\r\n\r\n\r\nclass TransformComponent extends Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'ex.transform';\r\n        this._transform = new Transform();\r\n        this._addChildTransform = (child) => {\r\n            const childTxComponent = child.get(TransformComponent);\r\n            if (childTxComponent) {\r\n                childTxComponent._transform.parent = this._transform;\r\n            }\r\n        };\r\n        /**\r\n         * Observable that emits when the z index changes on this component\r\n         */\r\n        this.zIndexChanged$ = new Observable();\r\n        this._z = 0;\r\n        /**\r\n         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.\r\n         */\r\n        this.coordPlane = CoordPlane.World;\r\n    }\r\n    get() {\r\n        return this._transform;\r\n    }\r\n    onAdd(owner) {\r\n        for (const child of owner.children) {\r\n            this._addChildTransform(child);\r\n        }\r\n        owner.childrenAdded$.subscribe(child => this._addChildTransform(child));\r\n        owner.childrenRemoved$.subscribe(child => {\r\n            const childTxComponent = child.get(TransformComponent);\r\n            if (childTxComponent) {\r\n                childTxComponent._transform.parent = null;\r\n            }\r\n        });\r\n    }\r\n    onRemove(_previousOwner) {\r\n        this._transform.parent = null;\r\n    }\r\n    /**\r\n     * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n     * For example z=99 would be drawn on top of z=0.\r\n     */\r\n    get z() {\r\n        return this._z;\r\n    }\r\n    set z(val) {\r\n        const oldz = this._z;\r\n        this._z = val;\r\n        if (oldz !== val) {\r\n            this.zIndexChanged$.notifyAll(val);\r\n        }\r\n    }\r\n    get pos() {\r\n        return this._transform.pos;\r\n    }\r\n    set pos(v) {\r\n        this._transform.pos = v;\r\n    }\r\n    get globalPos() {\r\n        return this._transform.globalPos;\r\n    }\r\n    set globalPos(v) {\r\n        this._transform.globalPos = v;\r\n    }\r\n    get rotation() {\r\n        return this._transform.rotation;\r\n    }\r\n    set rotation(rotation) {\r\n        this._transform.rotation = rotation;\r\n    }\r\n    get globalRotation() {\r\n        return this._transform.globalRotation;\r\n    }\r\n    set globalRotation(rotation) {\r\n        this._transform.globalRotation = rotation;\r\n    }\r\n    get scale() {\r\n        return this._transform.scale;\r\n    }\r\n    set scale(v) {\r\n        this._transform.scale = v;\r\n    }\r\n    get globalScale() {\r\n        return this._transform.globalScale;\r\n    }\r\n    set globalScale(v) {\r\n        this._transform.globalScale = v;\r\n    }\r\n    applyInverse(v) {\r\n        return this._transform.applyInverse(v);\r\n    }\r\n    apply(v) {\r\n        return this._transform.apply(v);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/Components/MotionComponent.ts\n\r\n\r\nclass MotionComponent extends Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'ex.motion';\r\n        /**\r\n         * The velocity of an entity in pixels per second\r\n         */\r\n        this.vel = Vector.Zero;\r\n        /**\r\n         * The acceleration of entity in pixels per second^2\r\n         */\r\n        this.acc = Vector.Zero;\r\n        /**\r\n         * The scale rate of change in scale units per second\r\n         */\r\n        this.scaleFactor = Vector.Zero;\r\n        /**\r\n         * The angular velocity which is how quickly the entity is rotating in radians per second\r\n         */\r\n        this.angularVelocity = 0;\r\n        /**\r\n         * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n         */\r\n        this.torque = 0;\r\n        /**\r\n         * Inertia can be thought of as the resistance to motion\r\n         */\r\n        this.inertia = 1;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Group/CollisionGroup.ts\n/**\r\n * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s\r\n *\r\n * For example:\r\n *\r\n * Players have collision group \"player\"\r\n *\r\n * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)\r\n *\r\n * Enemies have collision group \"enemy\"\r\n *\r\n * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)\r\n *\r\n * Blocks have collision group \"ground\"\r\n *\r\n * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)\r\n *\r\n * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide\r\n * with players and blocks.\r\n *\r\n * This is done with bitmasking, see the following pseudo-code\r\n *\r\n * PlayerGroup = `0b001`\r\n * PlayerGroupMask = `0b110`\r\n *\r\n * EnemyGroup = `0b010`\r\n * EnemyGroupMask = `0b101`\r\n *\r\n * BlockGroup = `0b100`\r\n * BlockGroupMask = `0b011`\r\n *\r\n * Should Players collide? No because the bitwise mask evaluates to 0\r\n * `(player1.group & player2.mask) === 0`\r\n * `(0b001 & 0b110) === 0`\r\n *\r\n * Should Players and Enemies collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & enemy1.mask) === 1`\r\n * `(0b001 & 0b101) === 1`\r\n *\r\n * Should Players and Blocks collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & blocks1.mask) === 1`\r\n * `(0b001 & 0b011) === 1`\r\n */\r\nclass CollisionGroup {\r\n    /**\r\n     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups\r\n     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.\r\n     * @param name Name of the collision group\r\n     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`\r\n     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`\r\n     */\r\n    constructor(name, category, mask) {\r\n        this._name = name;\r\n        this._category = category;\r\n        this._mask = mask;\r\n    }\r\n    /**\r\n     * Get the name of the collision group\r\n     */\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    /**\r\n     * Get the category of the collision group, a 32 bit number which should be a unique power of 2\r\n     */\r\n    get category() {\r\n        return this._category;\r\n    }\r\n    /**\r\n     * Get the mask for this collision group\r\n     */\r\n    get mask() {\r\n        return this._mask;\r\n    }\r\n    /**\r\n     * Evaluates whether 2 collision groups can collide\r\n     * @param other  CollisionGroup\r\n     */\r\n    canCollide(other) {\r\n        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;\r\n    }\r\n    /**\r\n     * Inverts the collision group. For example, if before the group specified \"players\",\r\n     * inverting would specify all groups except players\r\n     * @returns CollisionGroup\r\n     */\r\n    invert() {\r\n        return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);\r\n    }\r\n    /**\r\n     * Combine collision groups with each other. The new group includes all of the previous groups.\r\n     *\r\n     * @param collisionGroups\r\n     */\r\n    static combine(collisionGroups) {\r\n        const combinedName = collisionGroups.map((c) => c.name).join('+');\r\n        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);\r\n        const combinedMask = ~combinedCategory;\r\n        return new CollisionGroup(combinedName, combinedCategory, combinedMask);\r\n    }\r\n    /**\r\n     * Creates a collision group that collides with the listed groups\r\n     * @param collisionGroups\r\n     */\r\n    static collidesWith(collisionGroups) {\r\n        return CollisionGroup.combine(collisionGroups).invert();\r\n    }\r\n}\r\n/**\r\n * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,\r\n * it is the default collision group on colliders.\r\n */\r\nCollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);\r\n\n;// CONCATENATED MODULE: ./Collision/Detection/Pair.ts\n\r\n\r\n/**\r\n * Models a potential collision between 2 colliders\r\n */\r\nclass Pair {\r\n    constructor(colliderA, colliderB) {\r\n        this.colliderA = colliderA;\r\n        this.colliderB = colliderB;\r\n        this.id = null;\r\n        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    }\r\n    /**\r\n     * Returns whether a it is allowed for 2 colliders in a Pair to collide\r\n     * @param colliderA\r\n     * @param colliderB\r\n     */\r\n    static canCollide(colliderA, colliderB) {\r\n        var _a, _b;\r\n        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n        // Prevent self collision\r\n        if (colliderA.id === colliderB.id) {\r\n            return false;\r\n        }\r\n        // Colliders with the same owner do not collide (composite colliders)\r\n        if (colliderA.owner &&\r\n            colliderB.owner &&\r\n            colliderA.owner.id === colliderB.owner.id) {\r\n            return false;\r\n        }\r\n        // if the pair has a member with zero dimension don't collide\r\n        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {\r\n            return false;\r\n        }\r\n        // Body's needed for collision in the current state\r\n        // TODO can we collide without a body?\r\n        if (!bodyA || !bodyB) {\r\n            return false;\r\n        }\r\n        // If both are in the same collision group short circuit\r\n        if (!bodyA.group.canCollide(bodyB.group)) {\r\n            return false;\r\n        }\r\n        // if both are fixed short circuit\r\n        if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {\r\n            return false;\r\n        }\r\n        // if the either is prevent collision short circuit\r\n        if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {\r\n            return false;\r\n        }\r\n        // if either is dead short circuit\r\n        if (!bodyA.active || !bodyB.active) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns whether or not it is possible for the pairs to collide\r\n     */\r\n    get canCollide() {\r\n        const colliderA = this.colliderA;\r\n        const colliderB = this.colliderB;\r\n        return Pair.canCollide(colliderA, colliderB);\r\n    }\r\n    /**\r\n     * Runs the collision intersection logic on the members of this pair\r\n     */\r\n    collide() {\r\n        return this.colliderA.collide(this.colliderB);\r\n    }\r\n    /**\r\n     * Check if the collider is part of the pair\r\n     * @param collider\r\n     */\r\n    hasCollider(collider) {\r\n        return collider === this.colliderA || collider === this.colliderB;\r\n    }\r\n    /**\r\n     * Calculates the unique pair hash id for this collision pair (owning id)\r\n     */\r\n    static calculatePairHash(idA, idB) {\r\n        if (idA.value < idB.value) {\r\n            return `#${idA.value}+${idB.value}`;\r\n        }\r\n        else {\r\n            return `#${idB.value}+${idA.value}`;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/projection.ts\n/**\r\n * A 1 dimensional projection on an axis, used to test overlaps\r\n */\r\nclass Projection {\r\n    constructor(min, max) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    overlaps(projection) {\r\n        return this.max > projection.min && projection.max > this.min;\r\n    }\r\n    getOverlap(projection) {\r\n        if (this.overlaps(projection)) {\r\n            if (this.max > projection.max) {\r\n                return projection.max - this.min;\r\n            }\r\n            else {\r\n                return this.max - projection.min;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Detection/DynamicTree.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Dynamic Tree Node used for tracking bounds within the tree\r\n */\r\nclass TreeNode {\r\n    constructor(parent) {\r\n        this.parent = parent;\r\n        this.parent = parent || null;\r\n        this.data = null;\r\n        this.bounds = new BoundingBox();\r\n        this.left = null;\r\n        this.right = null;\r\n        this.height = 0;\r\n    }\r\n    isLeaf() {\r\n        return !this.left && !this.right;\r\n    }\r\n}\r\n/**\r\n * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for\r\n * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n *\r\n * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n */\r\nclass DynamicTree {\r\n    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {\r\n        this.worldBounds = worldBounds;\r\n        this.root = null;\r\n        this.nodes = {};\r\n    }\r\n    /**\r\n     * Inserts a node into the dynamic tree\r\n     */\r\n    _insert(leaf) {\r\n        // If there are no nodes in the tree, make this the root leaf\r\n        if (this.root === null) {\r\n            this.root = leaf;\r\n            this.root.parent = null;\r\n            return;\r\n        }\r\n        // Search the tree for a node that is not a leaf and find the best place to insert\r\n        const leafAABB = leaf.bounds;\r\n        let currentRoot = this.root;\r\n        while (!currentRoot.isLeaf()) {\r\n            const left = currentRoot.left;\r\n            const right = currentRoot.right;\r\n            const area = currentRoot.bounds.getPerimeter();\r\n            const combinedAABB = currentRoot.bounds.combine(leafAABB);\r\n            const combinedArea = combinedAABB.getPerimeter();\r\n            // Calculate cost heuristic for creating a new parent and leaf\r\n            const cost = 2 * combinedArea;\r\n            // Minimum cost of pushing the leaf down the tree\r\n            const inheritanceCost = 2 * (combinedArea - area);\r\n            // Cost of descending\r\n            let leftCost = 0;\r\n            const leftCombined = leafAABB.combine(left.bounds);\r\n            let newArea;\r\n            let oldArea;\r\n            if (left.isLeaf()) {\r\n                leftCost = leftCombined.getPerimeter() + inheritanceCost;\r\n            }\r\n            else {\r\n                oldArea = left.bounds.getPerimeter();\r\n                newArea = leftCombined.getPerimeter();\r\n                leftCost = newArea - oldArea + inheritanceCost;\r\n            }\r\n            let rightCost = 0;\r\n            const rightCombined = leafAABB.combine(right.bounds);\r\n            if (right.isLeaf()) {\r\n                rightCost = rightCombined.getPerimeter() + inheritanceCost;\r\n            }\r\n            else {\r\n                oldArea = right.bounds.getPerimeter();\r\n                newArea = rightCombined.getPerimeter();\r\n                rightCost = newArea - oldArea + inheritanceCost;\r\n            }\r\n            // cost is acceptable\r\n            if (cost < leftCost && cost < rightCost) {\r\n                break;\r\n            }\r\n            // Descend to the depths\r\n            if (leftCost < rightCost) {\r\n                currentRoot = left;\r\n            }\r\n            else {\r\n                currentRoot = right;\r\n            }\r\n        }\r\n        // Create the new parent node and insert into the tree\r\n        const oldParent = currentRoot.parent;\r\n        const newParent = new TreeNode(oldParent);\r\n        newParent.bounds = leafAABB.combine(currentRoot.bounds);\r\n        newParent.height = currentRoot.height + 1;\r\n        if (oldParent !== null) {\r\n            // The sibling node was not the root\r\n            if (oldParent.left === currentRoot) {\r\n                oldParent.left = newParent;\r\n            }\r\n            else {\r\n                oldParent.right = newParent;\r\n            }\r\n            newParent.left = currentRoot;\r\n            newParent.right = leaf;\r\n            currentRoot.parent = newParent;\r\n            leaf.parent = newParent;\r\n        }\r\n        else {\r\n            // The sibling node was the root\r\n            newParent.left = currentRoot;\r\n            newParent.right = leaf;\r\n            currentRoot.parent = newParent;\r\n            leaf.parent = newParent;\r\n            this.root = newParent;\r\n        }\r\n        // Walk up the tree fixing heights and AABBs\r\n        let currentNode = leaf.parent;\r\n        while (currentNode) {\r\n            currentNode = this._balance(currentNode);\r\n            if (!currentNode.left) {\r\n                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);\r\n            }\r\n            if (!currentNode.right) {\r\n                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);\r\n            }\r\n            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n            currentNode = currentNode.parent;\r\n        }\r\n    }\r\n    /**\r\n     * Removes a node from the dynamic tree\r\n     */\r\n    _remove(leaf) {\r\n        if (leaf === this.root) {\r\n            this.root = null;\r\n            return;\r\n        }\r\n        const parent = leaf.parent;\r\n        const grandParent = parent.parent;\r\n        let sibling;\r\n        if (parent.left === leaf) {\r\n            sibling = parent.right;\r\n        }\r\n        else {\r\n            sibling = parent.left;\r\n        }\r\n        if (grandParent) {\r\n            if (grandParent.left === parent) {\r\n                grandParent.left = sibling;\r\n            }\r\n            else {\r\n                grandParent.right = sibling;\r\n            }\r\n            sibling.parent = grandParent;\r\n            let currentNode = grandParent;\r\n            while (currentNode) {\r\n                currentNode = this._balance(currentNode);\r\n                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n                currentNode = currentNode.parent;\r\n            }\r\n        }\r\n        else {\r\n            this.root = sibling;\r\n            sibling.parent = null;\r\n        }\r\n    }\r\n    /**\r\n     * Tracks a body in the dynamic tree\r\n     */\r\n    trackCollider(collider) {\r\n        const node = new TreeNode();\r\n        node.data = collider;\r\n        node.bounds = collider.bounds;\r\n        node.bounds.left -= 2;\r\n        node.bounds.top -= 2;\r\n        node.bounds.right += 2;\r\n        node.bounds.bottom += 2;\r\n        this.nodes[collider.id.value] = node;\r\n        this._insert(node);\r\n    }\r\n    /**\r\n     * Updates the dynamic tree given the current bounds of each body being tracked\r\n     */\r\n    updateCollider(collider) {\r\n        var _a;\r\n        const node = this.nodes[collider.id.value];\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        const b = collider.bounds;\r\n        // if the body is outside the world no longer update it\r\n        if (!this.worldBounds.contains(b)) {\r\n            Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');\r\n            this.untrackCollider(collider);\r\n            return false;\r\n        }\r\n        if (node.bounds.contains(b)) {\r\n            return false;\r\n        }\r\n        this._remove(node);\r\n        b.left -= Physics.boundsPadding;\r\n        b.top -= Physics.boundsPadding;\r\n        b.right += Physics.boundsPadding;\r\n        b.bottom += Physics.boundsPadding;\r\n        // THIS IS CAUSING UNECESSARY CHECKS\r\n        if (collider.owner) {\r\n            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n            if (body) {\r\n                const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n                const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n                if (multdx < 0) {\r\n                    b.left += multdx;\r\n                }\r\n                else {\r\n                    b.right += multdx;\r\n                }\r\n                if (multdy < 0) {\r\n                    b.top += multdy;\r\n                }\r\n                else {\r\n                    b.bottom += multdy;\r\n                }\r\n            }\r\n        }\r\n        node.bounds = b;\r\n        this._insert(node);\r\n        return true;\r\n    }\r\n    /**\r\n     * Untracks a body from the dynamic tree\r\n     */\r\n    untrackCollider(collider) {\r\n        const node = this.nodes[collider.id.value];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        this._remove(node);\r\n        this.nodes[collider.id.value] = null;\r\n        delete this.nodes[collider.id.value];\r\n    }\r\n    /**\r\n     * Balances the tree about a node\r\n     */\r\n    _balance(node) {\r\n        if (node === null) {\r\n            throw new Error('Cannot balance at null node');\r\n        }\r\n        if (node.isLeaf() || node.height < 2) {\r\n            return node;\r\n        }\r\n        const left = node.left;\r\n        const right = node.right;\r\n        const a = node;\r\n        const b = left;\r\n        const c = right;\r\n        const d = left.left;\r\n        const e = left.right;\r\n        const f = right.left;\r\n        const g = right.right;\r\n        const balance = c.height - b.height;\r\n        // Rotate c node up\r\n        if (balance > 1) {\r\n            // Swap the right node with it's parent\r\n            c.left = a;\r\n            c.parent = a.parent;\r\n            a.parent = c;\r\n            // The original node's old parent should point to the right node\r\n            // this is mega confusing\r\n            if (c.parent) {\r\n                if (c.parent.left === a) {\r\n                    c.parent.left = c;\r\n                }\r\n                else {\r\n                    c.parent.right = c;\r\n                }\r\n            }\r\n            else {\r\n                this.root = c;\r\n            }\r\n            // Rotate\r\n            if (f.height > g.height) {\r\n                c.right = f;\r\n                a.right = g;\r\n                g.parent = a;\r\n                a.bounds = b.bounds.combine(g.bounds);\r\n                c.bounds = a.bounds.combine(f.bounds);\r\n                a.height = 1 + Math.max(b.height, g.height);\r\n                c.height = 1 + Math.max(a.height, f.height);\r\n            }\r\n            else {\r\n                c.right = g;\r\n                a.right = f;\r\n                f.parent = a;\r\n                a.bounds = b.bounds.combine(f.bounds);\r\n                c.bounds = a.bounds.combine(g.bounds);\r\n                a.height = 1 + Math.max(b.height, f.height);\r\n                c.height = 1 + Math.max(a.height, g.height);\r\n            }\r\n            return c;\r\n        }\r\n        // Rotate left node up\r\n        if (balance < -1) {\r\n            // swap\r\n            b.left = a;\r\n            b.parent = a.parent;\r\n            a.parent = b;\r\n            // node's old parent should point to b\r\n            if (b.parent) {\r\n                if (b.parent.left === a) {\r\n                    b.parent.left = b;\r\n                }\r\n                else {\r\n                    if (b.parent.right !== a) {\r\n                        throw 'Error rotating Dynamic Tree';\r\n                    }\r\n                    b.parent.right = b;\r\n                }\r\n            }\r\n            else {\r\n                this.root = b;\r\n            }\r\n            // rotate\r\n            if (d.height > e.height) {\r\n                b.right = d;\r\n                a.left = e;\r\n                e.parent = a;\r\n                a.bounds = c.bounds.combine(e.bounds);\r\n                b.bounds = a.bounds.combine(d.bounds);\r\n                a.height = 1 + Math.max(c.height, e.height);\r\n                b.height = 1 + Math.max(a.height, d.height);\r\n            }\r\n            else {\r\n                b.right = e;\r\n                a.left = d;\r\n                d.parent = a;\r\n                a.bounds = c.bounds.combine(d.bounds);\r\n                b.bounds = a.bounds.combine(e.bounds);\r\n                a.height = 1 + Math.max(c.height, d.height);\r\n                b.height = 1 + Math.max(a.height, e.height);\r\n            }\r\n            return b;\r\n        }\r\n        return node;\r\n    }\r\n    /**\r\n     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n     */\r\n    getHeight() {\r\n        if (this.root === null) {\r\n            return 0;\r\n        }\r\n        return this.root.height;\r\n    }\r\n    /**\r\n     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n     *\r\n     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n     * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n     * the tree until all possible colliders have been returned.\r\n     */\r\n    query(collider, callback) {\r\n        const bounds = collider.bounds;\r\n        const helper = (currentNode) => {\r\n            if (currentNode && currentNode.bounds.overlaps(bounds)) {\r\n                if (currentNode.isLeaf() && currentNode.data !== collider) {\r\n                    if (callback.call(collider, currentNode.data)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return helper(currentNode.left) || helper(currentNode.right);\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        helper(this.root);\r\n    }\r\n    /**\r\n     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n     * long ray to test the tree specified by `max`.\r\n     *\r\n     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this\r\n     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n     * the tree until all possible bodies that would intersect with the ray have been returned.\r\n     */\r\n    rayCastQuery(ray, max = Infinity, callback) {\r\n        const helper = (currentNode) => {\r\n            if (currentNode && currentNode.bounds.rayCast(ray, max)) {\r\n                if (currentNode.isLeaf()) {\r\n                    if (callback.call(ray, currentNode.data)) {\r\n                        // ray hit a leaf! return the body\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    // ray hit but not at a leaf, recurse deeper\r\n                    return helper(currentNode.left) || helper(currentNode.right);\r\n                }\r\n            }\r\n            return false; // ray missed\r\n        };\r\n        helper(this.root);\r\n    }\r\n    getNodes() {\r\n        const helper = (currentNode) => {\r\n            if (currentNode) {\r\n                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));\r\n            }\r\n            else {\r\n                return [];\r\n            }\r\n        };\r\n        return helper(this.root);\r\n    }\r\n    debug(ex) {\r\n        // draw all the nodes in the Dynamic Tree\r\n        const helper = (currentNode) => {\r\n            if (currentNode) {\r\n                if (currentNode.isLeaf()) {\r\n                    currentNode.bounds.draw(ex, Color.Green);\r\n                }\r\n                else {\r\n                    currentNode.bounds.draw(ex, Color.White);\r\n                }\r\n                if (currentNode.left) {\r\n                    helper(currentNode.left);\r\n                }\r\n                if (currentNode.right) {\r\n                    helper(currentNode.right);\r\n                }\r\n            }\r\n        };\r\n        helper(this.root);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/ray.ts\n/**\r\n * A 2D ray that can be cast into the scene to do collision detection\r\n */\r\nclass Ray {\r\n    /**\r\n     * @param pos The starting position for the ray\r\n     * @param dir The vector indicating the direction of the ray\r\n     */\r\n    constructor(pos, dir) {\r\n        this.pos = pos;\r\n        this.dir = dir.normalize();\r\n    }\r\n    /**\r\n     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\r\n     * This number indicates the mathematical intersection time.\r\n     * @param line  The line to test\r\n     */\r\n    intersect(line) {\r\n        const numerator = line.begin.sub(this.pos);\r\n        // Test is line and ray are parallel and non intersecting\r\n        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {\r\n            return -1;\r\n        }\r\n        // Lines are parallel\r\n        const divisor = this.dir.cross(line.getSlope());\r\n        if (divisor === 0) {\r\n            return -1;\r\n        }\r\n        const t = numerator.cross(line.getSlope()) / divisor;\r\n        if (t >= 0) {\r\n            const u = numerator.cross(this.dir) / divisor / line.getLength();\r\n            if (u >= 0 && u <= 1) {\r\n                return t;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    intersectPoint(line) {\r\n        const time = this.intersect(line);\r\n        if (time < 0) {\r\n            return null;\r\n        }\r\n        return this.getPoint(time);\r\n    }\r\n    /**\r\n     * Returns the point of intersection given the intersection time\r\n     */\r\n    getPoint(time) {\r\n        return this.pos.add(this.dir.scale(time));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Detection/DynamicTreeCollisionProcessor.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Responsible for performing the collision broadphase (locating potential collisions) and\r\n * the narrowphase (actual collision contacts)\r\n */\r\nclass DynamicTreeCollisionProcessor {\r\n    constructor() {\r\n        this._dynamicCollisionTree = new DynamicTree();\r\n        this._pairs = new Set();\r\n        this._collisionPairCache = [];\r\n        this._colliders = [];\r\n    }\r\n    getColliders() {\r\n        return this._colliders;\r\n    }\r\n    /**\r\n     * Tracks a physics body for collisions\r\n     */\r\n    track(target) {\r\n        if (!target) {\r\n            Logger.getInstance().warn('Cannot track null collider');\r\n            return;\r\n        }\r\n        if (target instanceof CompositeCollider) {\r\n            const colliders = target.getColliders();\r\n            for (const c of colliders) {\r\n                c.owner = target.owner;\r\n                this._colliders.push(c);\r\n                this._dynamicCollisionTree.trackCollider(c);\r\n            }\r\n        }\r\n        else {\r\n            this._colliders.push(target);\r\n            this._dynamicCollisionTree.trackCollider(target);\r\n        }\r\n    }\r\n    /**\r\n     * Untracks a physics body\r\n     */\r\n    untrack(target) {\r\n        if (!target) {\r\n            Logger.getInstance().warn('Cannot untrack a null collider');\r\n            return;\r\n        }\r\n        if (target instanceof CompositeCollider) {\r\n            const colliders = target.getColliders();\r\n            for (const c of colliders) {\r\n                const index = this._colliders.indexOf(c);\r\n                if (index !== -1) {\r\n                    this._colliders.splice(index, 1);\r\n                }\r\n                this._dynamicCollisionTree.untrackCollider(c);\r\n            }\r\n        }\r\n        else {\r\n            const index = this._colliders.indexOf(target);\r\n            if (index !== -1) {\r\n                this._colliders.splice(index, 1);\r\n            }\r\n            this._dynamicCollisionTree.untrackCollider(target);\r\n        }\r\n    }\r\n    _pairExists(colliderA, colliderB) {\r\n        // if the collision pair has been calculated already short circuit\r\n        const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n        return this._pairs.has(hash);\r\n    }\r\n    /**\r\n     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy\r\n     */\r\n    broadphase(targets, delta, stats) {\r\n        const seconds = delta / 1000;\r\n        // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n        const potentialColliders = targets.filter((other) => {\r\n            var _a, _b;\r\n            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;\r\n        });\r\n        // clear old list of collision pairs\r\n        this._collisionPairCache = [];\r\n        this._pairs.clear();\r\n        // check for normal collision pairs\r\n        let collider;\r\n        for (let j = 0, l = potentialColliders.length; j < l; j++) {\r\n            collider = potentialColliders[j];\r\n            // Query the collision tree for potential colliders\r\n            this._dynamicCollisionTree.query(collider, (other) => {\r\n                if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n                    const pair = new Pair(collider, other);\r\n                    this._pairs.add(pair.id);\r\n                    this._collisionPairCache.push(pair);\r\n                }\r\n                // Always return false, to query whole tree. Returning true in the query method stops searching\r\n                return false;\r\n            });\r\n        }\r\n        if (stats) {\r\n            stats.physics.pairs = this._collisionPairCache.length;\r\n        }\r\n        // Check dynamic tree for fast moving objects\r\n        // Fast moving objects are those moving at least there smallest bound per frame\r\n        if (Physics.checkForFastBodies) {\r\n            for (const collider of potentialColliders) {\r\n                const body = collider.owner.get(BodyComponent);\r\n                // Skip non-active objects. Does not make sense on other collision types\r\n                if (body.collisionType !== CollisionType.Active) {\r\n                    continue;\r\n                }\r\n                // Maximum travel distance next frame\r\n                const updateDistance = body.vel.size * seconds + // velocity term\r\n                    body.acc.size * 0.5 * seconds * seconds; // acc term\r\n                // Find the minimum dimension\r\n                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);\r\n                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {\r\n                    if (stats) {\r\n                        stats.physics.fastBodies++;\r\n                    }\r\n                    // start with the oldPos because the integration for actors has already happened\r\n                    // objects resting on a surface may be slightly penetrating in the current position\r\n                    const updateVec = body.globalPos.sub(body.oldPos);\r\n                    const centerPoint = collider.center;\r\n                    const furthestPoint = collider.getFurthestPoint(body.vel);\r\n                    const origin = furthestPoint.sub(updateVec);\r\n                    const ray = new Ray(origin, body.vel);\r\n                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface\r\n                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));\r\n                    let minCollider;\r\n                    let minTranslate = new Vector(Infinity, Infinity);\r\n                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {\r\n                        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);\r\n                            if (hitPoint) {\r\n                                const translate = hitPoint.sub(origin);\r\n                                if (translate.size < minTranslate.size) {\r\n                                    minTranslate = translate;\r\n                                    minCollider = other;\r\n                                }\r\n                            }\r\n                        }\r\n                        return false;\r\n                    });\r\n                    if (minCollider && Vector.isValid(minTranslate)) {\r\n                        const pair = new Pair(collider, minCollider);\r\n                        if (!this._pairs.has(pair.id)) {\r\n                            this._pairs.add(pair.id);\r\n                            this._collisionPairCache.push(pair);\r\n                        }\r\n                        // move the fast moving object to the other body\r\n                        // need to push into the surface by ex.Physics.surfaceEpsilon\r\n                        const shift = centerPoint.sub(furthestPoint);\r\n                        body.globalPos = origin\r\n                            .add(shift)\r\n                            .add(minTranslate)\r\n                            .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact\r\n                        collider.update(body.transform.get());\r\n                        if (stats) {\r\n                            stats.physics.fastBodyCollisions++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // return cache\r\n        return this._collisionPairCache;\r\n    }\r\n    /**\r\n     * Applies narrow phase on collision pairs to find actual area intersections\r\n     * Adds actual colliding pairs to stats' Frame data\r\n     */\r\n    narrowphase(pairs, stats) {\r\n        let contacts = [];\r\n        for (let i = 0; i < pairs.length; i++) {\r\n            const newContacts = pairs[i].collide();\r\n            contacts = contacts.concat(newContacts);\r\n            if (stats && newContacts.length > 0) {\r\n                for (const c of newContacts) {\r\n                    stats.physics.contacts.set(c.id, c);\r\n                }\r\n            }\r\n        }\r\n        if (stats) {\r\n            stats.physics.collisions += contacts.length;\r\n        }\r\n        return contacts;\r\n    }\r\n    /**\r\n     * Update the dynamic tree positions\r\n     */\r\n    update(targets) {\r\n        let updated = 0;\r\n        const len = targets.length;\r\n        for (let i = 0; i < len; i++) {\r\n            if (this._dynamicCollisionTree.updateCollider(targets[i])) {\r\n                updated++;\r\n            }\r\n        }\r\n        return updated;\r\n    }\r\n    debug(ex) {\r\n        this._dynamicCollisionTree.debug(ex);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/Collider.ts\n\r\n\r\n/**\r\n * A collision collider specifies the geometry that can detect when other collision colliders intersect\r\n * for the purposes of colliding 2 objects in excalibur.\r\n */\r\nclass Collider {\r\n    constructor() {\r\n        this.id = createId('collider', Collider._ID++);\r\n        /**\r\n         * Excalibur uses this to signal to the [[CollisionSystem]] this is part of a composite collider\r\n         * @internal\r\n         * @hidden\r\n         */\r\n        this.__compositeColliderId = null;\r\n        this.events = new EventDispatcher();\r\n    }\r\n    /**\r\n     * Returns a boolean indicating whether this body collided with\r\n     * or was in stationary contact with\r\n     * the body of the other [[Collider]]\r\n     */\r\n    touching(other) {\r\n        const contact = this.collide(other);\r\n        if (contact) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nCollider._ID = 0;\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/CompositeCollider.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass CompositeCollider extends Collider {\r\n    constructor(colliders) {\r\n        super();\r\n        this._collisionProcessor = new DynamicTreeCollisionProcessor();\r\n        this._dynamicAABBTree = new DynamicTree();\r\n        this._colliders = [];\r\n        for (const c of colliders) {\r\n            this.addCollider(c);\r\n        }\r\n    }\r\n    clearColliders() {\r\n        this._colliders = [];\r\n    }\r\n    addCollider(collider) {\r\n        this.events.wire(collider.events);\r\n        collider.__compositeColliderId = this.id;\r\n        this._colliders.push(collider);\r\n        this._collisionProcessor.track(collider);\r\n        this._dynamicAABBTree.trackCollider(collider);\r\n    }\r\n    removeCollider(collider) {\r\n        this.events.unwire(collider.events);\r\n        collider.__compositeColliderId = null;\r\n        removeItemFromArray(collider, this._colliders);\r\n        this._collisionProcessor.untrack(collider);\r\n        this._dynamicAABBTree.untrackCollider(collider);\r\n    }\r\n    getColliders() {\r\n        return this._colliders;\r\n    }\r\n    get worldPos() {\r\n        var _a, _b;\r\n        // TODO transform component world pos\r\n        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;\r\n    }\r\n    get center() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;\r\n    }\r\n    get bounds() {\r\n        var _a, _b;\r\n        // TODO cache this\r\n        const colliders = this.getColliders();\r\n        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));\r\n        return results;\r\n    }\r\n    get localBounds() {\r\n        var _a, _b;\r\n        // TODO cache this\r\n        const colliders = this.getColliders();\r\n        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());\r\n        return results;\r\n    }\r\n    get axes() {\r\n        // TODO cache this\r\n        const colliders = this.getColliders();\r\n        let axes = [];\r\n        for (const collider of colliders) {\r\n            axes = axes.concat(collider.axes);\r\n        }\r\n        return axes;\r\n    }\r\n    getFurthestPoint(direction) {\r\n        const colliders = this.getColliders();\r\n        const furthestPoints = [];\r\n        for (const collider of colliders) {\r\n            furthestPoints.push(collider.getFurthestPoint(direction));\r\n        }\r\n        // Pick best point from all colliders\r\n        let bestPoint = furthestPoints[0];\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (const point of furthestPoints) {\r\n            const distance = point.dot(direction);\r\n            if (distance > maxDistance) {\r\n                bestPoint = point;\r\n                maxDistance = distance;\r\n            }\r\n        }\r\n        return bestPoint;\r\n    }\r\n    getInertia(mass) {\r\n        const colliders = this.getColliders();\r\n        let totalInertia = 0;\r\n        for (const collider of colliders) {\r\n            totalInertia += collider.getInertia(mass);\r\n        }\r\n        return totalInertia;\r\n    }\r\n    collide(other) {\r\n        let otherColliders = [other];\r\n        if (other instanceof CompositeCollider) {\r\n            otherColliders = other.getColliders();\r\n        }\r\n        const pairs = [];\r\n        for (const c of otherColliders) {\r\n            this._dynamicAABBTree.query(c, (potentialCollider) => {\r\n                pairs.push(new Pair(c, potentialCollider));\r\n                return false;\r\n            });\r\n        }\r\n        let contacts = [];\r\n        for (const p of pairs) {\r\n            contacts = contacts.concat(p.collide());\r\n        }\r\n        return contacts;\r\n    }\r\n    getClosestLineBetween(other) {\r\n        const colliders = this.getColliders();\r\n        const lines = [];\r\n        if (other instanceof CompositeCollider) {\r\n            const otherColliders = other.getColliders();\r\n            for (const colliderA of colliders) {\r\n                for (const colliderB of otherColliders) {\r\n                    const maybeLine = colliderA.getClosestLineBetween(colliderB);\r\n                    if (maybeLine) {\r\n                        lines.push(maybeLine);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (const collider of colliders) {\r\n                const maybeLine = other.getClosestLineBetween(collider);\r\n                if (maybeLine) {\r\n                    lines.push(maybeLine);\r\n                }\r\n            }\r\n        }\r\n        if (lines.length) {\r\n            let minLength = lines[0].getLength();\r\n            let minLine = lines[0];\r\n            for (const line of lines) {\r\n                const length = line.getLength();\r\n                if (length < minLength) {\r\n                    minLength = length;\r\n                    minLine = line;\r\n                }\r\n            }\r\n            return minLine;\r\n        }\r\n        return null;\r\n    }\r\n    contains(point) {\r\n        const colliders = this.getColliders();\r\n        for (const collider of colliders) {\r\n            if (collider.contains(point)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    rayCast(ray, max) {\r\n        const colliders = this.getColliders();\r\n        const points = [];\r\n        for (const collider of colliders) {\r\n            const vec = collider.rayCast(ray, max);\r\n            if (vec) {\r\n                points.push(vec);\r\n            }\r\n        }\r\n        if (points.length) {\r\n            let minPoint = points[0];\r\n            let minDistance = minPoint.dot(ray.dir);\r\n            for (const point of points) {\r\n                const distance = ray.dir.dot(point);\r\n                if (distance < minDistance) {\r\n                    minPoint = point;\r\n                    minDistance = distance;\r\n                }\r\n            }\r\n            return minPoint;\r\n        }\r\n        return null;\r\n    }\r\n    project(axis) {\r\n        const colliders = this.getColliders();\r\n        const projs = [];\r\n        for (const collider of colliders) {\r\n            const proj = collider.project(axis);\r\n            if (proj) {\r\n                projs.push(proj);\r\n            }\r\n        }\r\n        // Merge all proj's on the same axis\r\n        if (projs.length) {\r\n            const newProjection = new Projection(projs[0].min, projs[0].max);\r\n            for (const proj of projs) {\r\n                newProjection.min = Math.min(proj.min, newProjection.min);\r\n                newProjection.max = Math.max(proj.max, newProjection.max);\r\n            }\r\n            return newProjection;\r\n        }\r\n        return null;\r\n    }\r\n    update(transform) {\r\n        if (transform) {\r\n            const colliders = this.getColliders();\r\n            for (const collider of colliders) {\r\n                collider.owner = this.owner;\r\n                collider.update(transform);\r\n            }\r\n        }\r\n    }\r\n    debug(ex, color) {\r\n        const colliders = this.getColliders();\r\n        for (const collider of colliders) {\r\n            collider.debug(ex, color);\r\n        }\r\n    }\r\n    clone() {\r\n        return new CompositeCollider(this._colliders.map((c) => c.clone()));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/line-segment.ts\n\r\n/**\r\n * A 2D line segment\r\n */\r\nclass LineSegment {\r\n    /**\r\n     * @param begin  The starting point of the line segment\r\n     * @param end  The ending point of the line segment\r\n     */\r\n    constructor(begin, end) {\r\n        this.begin = begin;\r\n        this.end = end;\r\n    }\r\n    /**\r\n     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\r\n     */\r\n    get slope() {\r\n        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\r\n    }\r\n    /**\r\n     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\r\n     */\r\n    get intercept() {\r\n        return this.begin.y - this.slope * this.begin.x;\r\n    }\r\n    /**\r\n     * Gets the normal of the line\r\n     */\r\n    normal() {\r\n        if (this._normal) {\r\n            return this._normal;\r\n        }\r\n        return this._normal = this.end.sub(this.begin).normal();\r\n    }\r\n    dir() {\r\n        if (this._dir) {\r\n            return this._dir;\r\n        }\r\n        return this._dir = this.end.sub(this.begin);\r\n    }\r\n    getPoints() {\r\n        return [this.begin, this.end];\r\n    }\r\n    /**\r\n     * Returns the slope of the line in the form of a vector of length 1\r\n     */\r\n    getSlope() {\r\n        if (this._slope) {\r\n            return this._slope;\r\n        }\r\n        const begin = this.begin;\r\n        const end = this.end;\r\n        const distance = begin.distance(end);\r\n        return this._slope = end.sub(begin).scale(1 / distance);\r\n    }\r\n    /**\r\n     * Returns the edge of the line as vector, the length of the vector is the length of the edge\r\n     */\r\n    getEdge() {\r\n        const begin = this.begin;\r\n        const end = this.end;\r\n        return end.sub(begin);\r\n    }\r\n    /**\r\n     * Returns the length of the line segment in pixels\r\n     */\r\n    getLength() {\r\n        if (this._length) {\r\n            return this._length;\r\n        }\r\n        const begin = this.begin;\r\n        const end = this.end;\r\n        const distance = begin.distance(end);\r\n        return this._length = distance;\r\n    }\r\n    /**\r\n     * Returns the midpoint of the edge\r\n     */\r\n    get midpoint() {\r\n        return this.begin.add(this.end).scale(0.5);\r\n    }\r\n    /**\r\n     * Flips the direction of the line segment\r\n     */\r\n    flip() {\r\n        return new LineSegment(this.end, this.begin);\r\n    }\r\n    /**\r\n     * Tests if a given point is below the line, points in the normal direction above the line are considered above.\r\n     * @param point\r\n     */\r\n    below(point) {\r\n        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);\r\n        return above2 >= 0;\r\n    }\r\n    /**\r\n     * Returns the clip point\r\n     * @param sideVector Vector that traces the line\r\n     * @param length Length to clip along side\r\n     */\r\n    clip(sideVector, length) {\r\n        let dir = sideVector;\r\n        dir = dir.normalize();\r\n        const near = dir.dot(this.begin) - length;\r\n        const far = dir.dot(this.end) - length;\r\n        const results = [];\r\n        if (near <= 0) {\r\n            results.push(this.begin);\r\n        }\r\n        if (far <= 0) {\r\n            results.push(this.end);\r\n        }\r\n        if (near * far < 0) {\r\n            const clipTime = near / (near - far);\r\n            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));\r\n        }\r\n        if (results.length !== 2) {\r\n            return null;\r\n        }\r\n        return new LineSegment(results[0], results[1]);\r\n    }\r\n    /**\r\n     * Find the perpendicular distance from the line to a point\r\n     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n     * @param point\r\n     */\r\n    distanceToPoint(point, signed = false) {\r\n        const x0 = point.x;\r\n        const y0 = point.y;\r\n        const l = this.getLength();\r\n        const dy = this.end.y - this.begin.y;\r\n        const dx = this.end.x - this.begin.x;\r\n        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\r\n        return signed ? distance : Math.abs(distance);\r\n    }\r\n    /**\r\n     * Find the perpendicular line from the line to a point\r\n     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n     * (a - p) - ((a - p) * n)n\r\n     * a is a point on the line\r\n     * p is the arbitrary point above the line\r\n     * n is a unit vector in direction of the line\r\n     * @param point\r\n     */\r\n    findVectorToPoint(point) {\r\n        const aMinusP = this.begin.sub(point);\r\n        const n = this.getSlope();\r\n        return aMinusP.sub(n.scale(aMinusP.dot(n)));\r\n    }\r\n    /**\r\n     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\r\n     * a new point with the calculated Y value and vice-versa.\r\n     *\r\n     * @param x The known X value of the target point\r\n     * @param y The known Y value of the target point\r\n     * @returns A new point with the other calculated axis value\r\n     */\r\n    findPoint(x = null, y = null) {\r\n        const m = this.slope;\r\n        const b = this.intercept;\r\n        if (x !== null) {\r\n            return new Vector(x, m * x + b);\r\n        }\r\n        else if (y !== null) {\r\n            return new Vector((y - b) / m, y);\r\n        }\r\n        else {\r\n            throw new Error('You must provide an X or a Y value');\r\n        }\r\n    }\r\n    /**\r\n     * @see http://stackoverflow.com/a/11908158/109458\r\n     */\r\n    hasPoint() {\r\n        let currPoint;\r\n        let threshold = 0;\r\n        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\r\n            currPoint = new Vector(arguments[0], arguments[1]);\r\n            threshold = arguments[2] || 0;\r\n        }\r\n        else if (arguments[0] instanceof Vector) {\r\n            currPoint = arguments[0];\r\n            threshold = arguments[1] || 0;\r\n        }\r\n        else {\r\n            throw 'Could not determine the arguments for Vector.hasPoint';\r\n        }\r\n        const dxc = currPoint.x - this.begin.x;\r\n        const dyc = currPoint.y - this.begin.y;\r\n        const dx1 = this.end.x - this.begin.x;\r\n        const dy1 = this.end.y - this.begin.y;\r\n        const cross = dxc * dy1 - dyc * dx1;\r\n        // check whether point lines on the line\r\n        if (Math.abs(cross) > threshold) {\r\n            return false;\r\n        }\r\n        // check whether point lies in-between start and end\r\n        if (Math.abs(dx1) >= Math.abs(dy1)) {\r\n            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\r\n        }\r\n        else {\r\n            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/ClosestLineJumpTable.ts\n\r\n\r\n\r\n/**\r\n * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment\r\n * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n * @param p0 Point where L1 begins\r\n * @param u Direction and length of L1\r\n * @param q0 Point were L2 begins\r\n * @param v Direction and length of L2\r\n */\r\nfunction ClosestLine(p0, u, q0, v) {\r\n    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html\r\n    // w(s, t) = P(s) - Q(t)\r\n    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest\r\n    //\r\n    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.\r\n    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0\r\n    //\r\n    // The closest point between 2 lines then satisfies this pair of equations\r\n    // 1: u * wClosest = 0\r\n    // 2: v * wClosest = 0\r\n    //\r\n    // Substituting wClosest into the equations we get\r\n    //\r\n    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0\r\n    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0\r\n    // simplify w0\r\n    const w0 = p0.sub(q0);\r\n    // simplify (u * u);\r\n    const a = u.dot(u);\r\n    // simplify (u * v);\r\n    const b = u.dot(v);\r\n    // simplify (v * v)\r\n    const c = v.dot(v);\r\n    // simplify (u * w0)\r\n    const d = u.dot(w0);\r\n    // simplify (v * w0)\r\n    const e = v.dot(w0);\r\n    // denominator ac - b^2\r\n    const denom = a * c - b * b;\r\n    let sDenom = denom;\r\n    let tDenom = denom;\r\n    // if denom is 0 they are parallel, use any point from either as the start in this case p0\r\n    if (denom === 0 || denom <= 0.01) {\r\n        const tClosestParallel = d / b;\r\n        return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));\r\n    }\r\n    // Solve for sClosest for infinite line\r\n    let sClosest = b * e - c * d; // / denom;\r\n    // Solve for tClosest for infinite line\r\n    let tClosest = a * e - b * d; // / denom;\r\n    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments\r\n    if (sClosest < 0) {\r\n        sClosest = 0;\r\n        tClosest = e;\r\n        tDenom = c;\r\n    }\r\n    else if (sClosest > sDenom) {\r\n        sClosest = sDenom;\r\n        tClosest = e + b;\r\n        tDenom = c;\r\n    }\r\n    if (tClosest < 0) {\r\n        tClosest = 0;\r\n        if (-d < 0) {\r\n            sClosest = 0;\r\n        }\r\n        else if (-d > a) {\r\n            sClosest = sDenom;\r\n        }\r\n        else {\r\n            sClosest = -d;\r\n            sDenom = a;\r\n        }\r\n    }\r\n    else if (tClosest > tDenom) {\r\n        tClosest = tDenom;\r\n        if (-d + b < 0) {\r\n            sClosest = 0;\r\n        }\r\n        else if (-d + b > a) {\r\n            sClosest = sDenom;\r\n        }\r\n        else {\r\n            sClosest = -d + b;\r\n            sDenom = a;\r\n        }\r\n    }\r\n    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;\r\n    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;\r\n    return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));\r\n}\r\nconst ClosestLineJumpTable = {\r\n    PolygonPolygonClosestLine(polygonA, polygonB) {\r\n        // Find the 2 closest faces on each polygon\r\n        const otherWorldPos = polygonB.worldPos;\r\n        const otherDirection = otherWorldPos.sub(polygonA.worldPos);\r\n        const thisDirection = otherDirection.negate();\r\n        const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);\r\n        const rayTowardsThis = new Ray(otherWorldPos, thisDirection);\r\n        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));\r\n        const thisFace = polygonA.getClosestFace(thisPoint);\r\n        const otherFace = polygonB.getClosestFace(otherPoint);\r\n        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n        const p0 = thisFace.face.begin;\r\n        const u = thisFace.face.getEdge();\r\n        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n        const q0 = otherFace.face.begin;\r\n        const v = otherFace.face.getEdge();\r\n        return ClosestLine(p0, u, q0, v);\r\n    },\r\n    PolygonEdgeClosestLine(polygon, edge) {\r\n        // Find the 2 closest faces on each polygon\r\n        const otherWorldPos = edge.worldPos;\r\n        const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);\r\n        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n        const thisFace = polygon.getClosestFace(thisPoint);\r\n        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n        const p0 = thisFace.face.begin;\r\n        const u = thisFace.face.getEdge();\r\n        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n        const edgeLine = edge.asLine();\r\n        const edgeStart = edgeLine.begin;\r\n        const edgeVector = edgeLine.getEdge();\r\n        const q0 = edgeStart;\r\n        const v = edgeVector;\r\n        return ClosestLine(p0, u, q0, v);\r\n    },\r\n    PolygonCircleClosestLine(polygon, circle) {\r\n        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n        // Find the 2 closest faces on each polygon\r\n        const otherWorldPos = circle.worldPos;\r\n        const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());\r\n        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n        const thisFace = polygon.getClosestFace(thisPoint);\r\n        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n        const p0 = thisFace.face.begin;\r\n        const u = thisFace.face.getEdge();\r\n        // Time of minimum distance\r\n        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n        // If time of minimum is past the edge clamp\r\n        if (t > 1) {\r\n            t = 1;\r\n        }\r\n        else if (t < 0) {\r\n            t = 0;\r\n        }\r\n        // Minimum distance\r\n        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;\r\n        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);\r\n        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);\r\n        return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));\r\n    },\r\n    CircleCircleClosestLine(circleA, circleB) {\r\n        // Find the 2 closest faces on each polygon\r\n        const otherWorldPos = circleB.worldPos;\r\n        const otherDirection = otherWorldPos.sub(circleA.worldPos);\r\n        const thisWorldPos = circleA.worldPos;\r\n        const thisDirection = thisWorldPos.sub(circleB.worldPos);\r\n        const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);\r\n        const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);\r\n        const thisPoint = circleA.rayCast(rayTowardsOther);\r\n        const otherPoint = circleB.rayCast(rayTowardsThis);\r\n        return new LineSegment(thisPoint, otherPoint);\r\n    },\r\n    CircleEdgeClosestLine(circle, edge) {\r\n        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n        const circleWorlPos = circle.worldPos;\r\n        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n        const edgeLine = edge.asLine();\r\n        const edgeStart = edgeLine.begin;\r\n        const edgeVector = edgeLine.getEdge();\r\n        const p0 = edgeStart;\r\n        const u = edgeVector;\r\n        // Time of minimum distance\r\n        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n        // If time of minimum is past the edge clamp to edge\r\n        if (t > 1) {\r\n            t = 1;\r\n        }\r\n        else if (t < 0) {\r\n            t = 0;\r\n        }\r\n        // Minimum distance\r\n        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;\r\n        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);\r\n        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);\r\n        return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));\r\n    },\r\n    EdgeEdgeClosestLine(edgeA, edgeB) {\r\n        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n        const edgeLineA = edgeA.asLine();\r\n        const edgeStartA = edgeLineA.begin;\r\n        const edgeVectorA = edgeLineA.getEdge();\r\n        const p0 = edgeStartA;\r\n        const u = edgeVectorA;\r\n        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n        const edgeLineB = edgeB.asLine();\r\n        const edgeStartB = edgeLineB.begin;\r\n        const edgeVectorB = edgeLineB.getEdge();\r\n        const q0 = edgeStartB;\r\n        const v = edgeVectorB;\r\n        return ClosestLine(p0, u, q0, v);\r\n    }\r\n};\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/CircleCollider.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This is a circle collider for the excalibur rigid body physics simulation\r\n */\r\nclass CircleCollider extends Collider {\r\n    constructor(options) {\r\n        super();\r\n        /**\r\n         * Position of the circle relative to the collider, by default (0, 0).\r\n         */\r\n        this.offset = Vector.Zero;\r\n        this._globalMatrix = AffineMatrix.identity();\r\n        this.offset = options.offset || Vector.Zero;\r\n        this.radius = options.radius || 0;\r\n        this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    }\r\n    get worldPos() {\r\n        return this._globalMatrix.getPosition();\r\n    }\r\n    /**\r\n     * Get the radius of the circle\r\n     */\r\n    get radius() {\r\n        var _a;\r\n        const tx = this._transform;\r\n        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\r\n        // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n        return this._naturalRadius * Math.min(scale.x, scale.y);\r\n    }\r\n    /**\r\n     * Set the radius of the circle\r\n     */\r\n    set radius(val) {\r\n        var _a;\r\n        const tx = this._transform;\r\n        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\r\n        // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n        this._naturalRadius = val / Math.min(scale.x, scale.y);\r\n    }\r\n    /**\r\n     * Returns a clone of this shape, not associated with any collider\r\n     */\r\n    clone() {\r\n        return new CircleCollider({\r\n            offset: this.offset.clone(),\r\n            radius: this.radius\r\n        });\r\n    }\r\n    /**\r\n     * Get the center of the collider in world coordinates\r\n     */\r\n    get center() {\r\n        return this._globalMatrix.getPosition();\r\n    }\r\n    /**\r\n     * Tests if a point is contained in this collider\r\n     */\r\n    contains(point) {\r\n        var _a, _b;\r\n        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;\r\n        const distance = pos.distance(point);\r\n        if (distance <= this.radius) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Casts a ray at the Circle collider and returns the nearest point of collision\r\n     * @param ray\r\n     */\r\n    rayCast(ray, max = Infinity) {\r\n        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n        const c = this.center;\r\n        const dir = ray.dir;\r\n        const orig = ray.pos;\r\n        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));\r\n        if (discriminant < 0) {\r\n            // no intersection\r\n            return null;\r\n        }\r\n        else {\r\n            let toi = 0;\r\n            if (discriminant === 0) {\r\n                toi = -dir.dot(orig.sub(c));\r\n                if (toi > 0 && toi < max) {\r\n                    return ray.getPoint(toi);\r\n                }\r\n                return null;\r\n            }\r\n            else {\r\n                const toi1 = -dir.dot(orig.sub(c)) + discriminant;\r\n                const toi2 = -dir.dot(orig.sub(c)) - discriminant;\r\n                const positiveToi = [];\r\n                if (toi1 >= 0) {\r\n                    positiveToi.push(toi1);\r\n                }\r\n                if (toi2 >= 0) {\r\n                    positiveToi.push(toi2);\r\n                }\r\n                const mintoi = Math.min(...positiveToi);\r\n                if (mintoi <= max) {\r\n                    return ray.getPoint(mintoi);\r\n                }\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    getClosestLineBetween(shape) {\r\n        if (shape instanceof CircleCollider) {\r\n            return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);\r\n        }\r\n        else if (shape instanceof PolygonCollider) {\r\n            return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();\r\n        }\r\n        else if (shape instanceof EdgeCollider) {\r\n            return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();\r\n        }\r\n        else {\r\n            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n        }\r\n    }\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    collide(collider) {\r\n        if (collider instanceof CircleCollider) {\r\n            return CollisionJumpTable.CollideCircleCircle(this, collider);\r\n        }\r\n        else if (collider instanceof PolygonCollider) {\r\n            return CollisionJumpTable.CollideCirclePolygon(this, collider);\r\n        }\r\n        else if (collider instanceof EdgeCollider) {\r\n            return CollisionJumpTable.CollideCircleEdge(this, collider);\r\n        }\r\n        else {\r\n            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);\r\n        }\r\n    }\r\n    /**\r\n     * Find the point on the collider furthest in the direction specified\r\n     */\r\n    getFurthestPoint(direction) {\r\n        return this.center.add(direction.normalize().scale(this.radius));\r\n    }\r\n    /**\r\n     * Find the local point on the shape in the direction specified\r\n     * @param direction\r\n     */\r\n    getFurthestLocalPoint(direction) {\r\n        const dir = direction.normalize();\r\n        return dir.scale(this.radius);\r\n    }\r\n    /**\r\n     * Get the axis aligned bounding box for the circle collider in world coordinates\r\n     */\r\n    get bounds() {\r\n        var _a, _b, _c;\r\n        const tx = this._transform;\r\n        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\r\n        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;\r\n        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero);\r\n        return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius).rotate(rotation).scale(scale).translate(pos);\r\n    }\r\n    /**\r\n     * Get the axis aligned bounding box for the circle collider in local coordinates\r\n     */\r\n    get localBounds() {\r\n        return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius);\r\n    }\r\n    /**\r\n     * Get axis not implemented on circles, since there are infinite axis in a circle\r\n     */\r\n    get axes() {\r\n        return [];\r\n    }\r\n    /**\r\n     * Returns the moment of inertia of a circle given it's mass\r\n     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n     */\r\n    getInertia(mass) {\r\n        return (mass * this.radius * this.radius) / 2;\r\n    }\r\n    /* istanbul ignore next */\r\n    update(transform) {\r\n        var _a;\r\n        this._transform = transform;\r\n        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;\r\n        globalMat.clone(this._globalMatrix);\r\n        this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    }\r\n    /**\r\n     * Project the circle along a specified axis\r\n     */\r\n    project(axis) {\r\n        const scalars = [];\r\n        const point = this.center;\r\n        const dotProduct = point.dot(axis);\r\n        scalars.push(dotProduct);\r\n        scalars.push(dotProduct + this.radius);\r\n        scalars.push(dotProduct - this.radius);\r\n        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n    }\r\n    debug(ex, color) {\r\n        var _a, _b, _c, _d;\r\n        const tx = this._transform;\r\n        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;\r\n        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;\r\n        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero);\r\n        ex.save();\r\n        ex.translate(pos.x, pos.y);\r\n        ex.rotate(rotation);\r\n        ex.scale(scale.x, scale.y);\r\n        ex.drawCircle(((_d = this.offset) !== null && _d !== void 0 ? _d : Vector.Zero), this._naturalRadius, Color.Transparent, color, 2);\r\n        ex.restore();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Detection/CollisionContact.ts\n\r\n\r\n\r\n\r\n/**\r\n * Collision contacts are used internally by Excalibur to resolve collision between colliders. This\r\n * Pair prevents collisions from being evaluated more than one time\r\n */\r\nclass CollisionContact {\r\n    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {\r\n        var _a, _b;\r\n        this._canceled = false;\r\n        this.colliderA = colliderA;\r\n        this.colliderB = colliderB;\r\n        this.mtv = mtv;\r\n        this.normal = normal;\r\n        this.tangent = tangent;\r\n        this.points = points;\r\n        this.localPoints = localPoints;\r\n        this.info = info;\r\n        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n        if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {\r\n            // Add on the parent composite pair for start/end contact\r\n            this.id += '|' + Pair.calculatePairHash((_a = colliderA.__compositeColliderId) !== null && _a !== void 0 ? _a : colliderA.id, (_b = colliderB.__compositeColliderId) !== null && _b !== void 0 ? _b : colliderB.id);\r\n        }\r\n    }\r\n    /**\r\n     * Match contact awake state, except if body's are Fixed\r\n     */\r\n    matchAwake() {\r\n        const bodyA = this.colliderA.owner.get(BodyComponent);\r\n        const bodyB = this.colliderB.owner.get(BodyComponent);\r\n        if (bodyA && bodyB) {\r\n            if (bodyA.sleeping !== bodyB.sleeping) {\r\n                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {\r\n                    bodyA.setSleeping(false);\r\n                }\r\n                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {\r\n                    bodyB.setSleeping(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    isCanceled() {\r\n        return this._canceled;\r\n    }\r\n    cancel() {\r\n        this._canceled = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/SeparatingAxis.ts\nclass SeparatingAxis {\r\n    static findPolygonPolygonSeparation(polyA, polyB) {\r\n        let bestSeparation = -Number.MAX_VALUE;\r\n        let bestSide = null;\r\n        let bestAxis = null;\r\n        let bestSideIndex = -1;\r\n        let bestOtherPoint = null;\r\n        const sides = polyA.getSides();\r\n        const localSides = polyA.getLocalSides();\r\n        for (let i = 0; i < sides.length; i++) {\r\n            const side = sides[i];\r\n            const axis = side.normal();\r\n            const vertB = polyB.getFurthestPoint(axis.negate());\r\n            // Separation on side i's axis\r\n            // We are looking for the largest separation between poly A's sides\r\n            const vertSeparation = side.distanceToPoint(vertB, true);\r\n            if (vertSeparation > bestSeparation) {\r\n                bestSeparation = vertSeparation;\r\n                bestSide = side;\r\n                bestAxis = axis;\r\n                bestSideIndex = i;\r\n                bestOtherPoint = vertB;\r\n            }\r\n        }\r\n        return {\r\n            collider: polyA,\r\n            separation: bestAxis ? bestSeparation : 99,\r\n            axis: bestAxis,\r\n            side: bestSide,\r\n            localSide: localSides[bestSideIndex],\r\n            sideId: bestSideIndex,\r\n            point: bestOtherPoint,\r\n            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null\r\n        };\r\n    }\r\n    static findCirclePolygonSeparation(circle, polygon) {\r\n        const axes = polygon.axes;\r\n        const pc = polygon.center;\r\n        // Special SAT with circles\r\n        const polyDir = pc.sub(circle.worldPos);\r\n        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());\r\n        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());\r\n        let minOverlap = Number.MAX_VALUE;\r\n        let minAxis = null;\r\n        let minIndex = -1;\r\n        for (let i = 0; i < axes.length; i++) {\r\n            const proj1 = polygon.project(axes[i]);\r\n            const proj2 = circle.project(axes[i]);\r\n            const overlap = proj1.getOverlap(proj2);\r\n            if (overlap <= 0) {\r\n                return null;\r\n            }\r\n            else {\r\n                if (overlap < minOverlap) {\r\n                    minOverlap = overlap;\r\n                    minAxis = axes[i];\r\n                    minIndex = i;\r\n                }\r\n            }\r\n        }\r\n        if (minIndex < 0) {\r\n            return null;\r\n        }\r\n        return minAxis.normalize().scale(minOverlap);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/CollisionJumpTable.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst CollisionJumpTable = {\r\n    CollideCircleCircle(circleA, circleB) {\r\n        const circleAPos = circleA.worldPos;\r\n        const circleBPos = circleB.worldPos;\r\n        const combinedRadius = circleA.radius + circleB.radius;\r\n        const distance = circleAPos.distance(circleBPos);\r\n        if (distance > combinedRadius) {\r\n            return [];\r\n        }\r\n        // negative means overlap\r\n        const separation = combinedRadius - distance;\r\n        // Normal points from A -> B\r\n        const normal = circleBPos.sub(circleAPos).normalize();\r\n        const tangent = normal.perpendicular();\r\n        const mvt = normal.scale(separation);\r\n        const point = circleA.getFurthestPoint(normal);\r\n        const local = circleA.getFurthestLocalPoint(normal);\r\n        const info = {\r\n            collider: circleA,\r\n            separation,\r\n            axis: normal,\r\n            point: point\r\n        };\r\n        return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];\r\n    },\r\n    CollideCirclePolygon(circle, polygon) {\r\n        var _a, _b;\r\n        let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);\r\n        if (!minAxis) {\r\n            return [];\r\n        }\r\n        // make sure that the minAxis is pointing away from circle\r\n        const samedir = minAxis.dot(polygon.center.sub(circle.center));\r\n        minAxis = samedir < 0 ? minAxis.negate() : minAxis;\r\n        const point = circle.getFurthestPoint(minAxis);\r\n        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();\r\n        const local = xf.applyInverse(point);\r\n        const normal = minAxis.normalize();\r\n        const info = {\r\n            collider: circle,\r\n            separation: -minAxis.size,\r\n            axis: normal,\r\n            point: point,\r\n            localPoint: local,\r\n            side: polygon.findSide(normal.negate()),\r\n            localSide: polygon.findLocalSide(normal.negate())\r\n        };\r\n        return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];\r\n    },\r\n    CollideCircleEdge(circle, edge) {\r\n        // TODO not sure this actually abides by local/world collisions\r\n        // Are edge.begin and edge.end local space or world space? I think they should be local\r\n        // center of the circle in world pos\r\n        const cc = circle.center;\r\n        // vector in the direction of the edge\r\n        const edgeWorld = edge.asLine();\r\n        const e = edgeWorld.end.sub(edgeWorld.begin);\r\n        // amount of overlap with the circle's center along the edge direction\r\n        const u = e.dot(edgeWorld.end.sub(cc));\r\n        const v = e.dot(cc.sub(edgeWorld.begin));\r\n        const side = edge.asLine();\r\n        const localSide = edge.asLocalLine();\r\n        // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n        if (v <= 0) {\r\n            const da = edgeWorld.begin.sub(cc);\r\n            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n            // save some sqrts\r\n            if (dda > circle.radius * circle.radius) {\r\n                return []; // no collision\r\n            }\r\n            const normal = da.normalize();\r\n            const separation = circle.radius - Math.sqrt(dda);\r\n            const info = {\r\n                collider: circle,\r\n                separation: separation,\r\n                axis: normal,\r\n                point: side.begin,\r\n                side: side,\r\n                localSide: localSide\r\n            };\r\n            return [\r\n                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)\r\n            ];\r\n        }\r\n        // Potential region B collision (circle is on the right side of the edge, after the end)\r\n        if (u <= 0) {\r\n            const db = edgeWorld.end.sub(cc);\r\n            const ddb = db.dot(db);\r\n            if (ddb > circle.radius * circle.radius) {\r\n                return [];\r\n            }\r\n            const normal = db.normalize();\r\n            const separation = circle.radius - Math.sqrt(ddb);\r\n            const info = {\r\n                collider: circle,\r\n                separation: separation,\r\n                axis: normal,\r\n                point: side.end,\r\n                side: side,\r\n                localSide: localSide\r\n            };\r\n            return [\r\n                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)\r\n            ];\r\n        }\r\n        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n        const den = e.dot(e);\r\n        const pointOnEdge = edgeWorld.begin\r\n            .scale(u)\r\n            .add(edgeWorld.end.scale(v))\r\n            .scale(1 / den);\r\n        const d = cc.sub(pointOnEdge);\r\n        const dd = d.dot(d);\r\n        if (dd > circle.radius * circle.radius) {\r\n            return []; // no collision\r\n        }\r\n        let normal = e.perpendicular();\r\n        // flip correct direction\r\n        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {\r\n            normal.x = -normal.x;\r\n            normal.y = -normal.y;\r\n        }\r\n        normal = normal.normalize();\r\n        const separation = circle.radius - Math.sqrt(dd);\r\n        const mvt = normal.scale(separation);\r\n        const info = {\r\n            collider: circle,\r\n            separation: separation,\r\n            axis: normal,\r\n            point: pointOnEdge,\r\n            side: side,\r\n            localSide: localSide\r\n        };\r\n        return [\r\n            new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)\r\n        ];\r\n    },\r\n    CollideEdgeEdge() {\r\n        // Edge-edge collision doesn't make sense\r\n        return [];\r\n    },\r\n    CollidePolygonEdge(polygon, edge) {\r\n        var _a;\r\n        const pc = polygon.center;\r\n        const ec = edge.center;\r\n        const dir = ec.sub(pc).normalize();\r\n        // build a temporary polygon from the edge to use SAT\r\n        const linePoly = new PolygonCollider({\r\n            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],\r\n            offset: edge.offset\r\n        });\r\n        linePoly.owner = edge.owner;\r\n        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);\r\n        if (tx) {\r\n            linePoly.update(edge.owner.get(TransformComponent).get());\r\n        }\r\n        // Gross hack but poly-poly works well\r\n        const contact = this.CollidePolygonPolygon(polygon, linePoly);\r\n        if (contact.length) {\r\n            // Fudge the contact back to edge\r\n            contact[0].colliderB = edge;\r\n            contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);\r\n        }\r\n        return contact;\r\n    },\r\n    CollidePolygonPolygon(polyA, polyB) {\r\n        var _a, _b, _c, _d;\r\n        // Multi contact from SAT\r\n        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection\r\n        // do a SAT test to find a min axis if it exists\r\n        const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);\r\n        // If there is no overlap from boxA's perspective we can end early\r\n        if (separationA.separation > 0) {\r\n            return [];\r\n        }\r\n        const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);\r\n        // If there is no overlap from boxB's perspective exit now\r\n        if (separationB.separation > 0) {\r\n            return [];\r\n        }\r\n        // Separations are both negative, we want to pick the least negative (minimal movement)\r\n        const separation = separationA.separation > separationB.separation ? separationA : separationB;\r\n        // The incident side is the most opposite from the axes of collision on the other collider\r\n        const other = separation.collider === polyA ? polyB : polyA;\r\n        const incident = other.findSide(separation.axis.negate());\r\n        // Clip incident side by the perpendicular lines at each end of the reference side\r\n        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\r\n        const reference = separation.side;\r\n        const refDir = reference.dir().normalize();\r\n        // Find our contact points by clipping the incident by the collision side\r\n        const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));\r\n        let clipLeft = null;\r\n        if (clipRight) {\r\n            clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));\r\n        }\r\n        // If there is no left there is no collision\r\n        if (clipLeft) {\r\n            // We only want clip points below the reference edge, discard the others\r\n            const points = clipLeft.getPoints().filter((p) => {\r\n                return reference.below(p);\r\n            });\r\n            let normal = separation.axis;\r\n            let tangent = normal.perpendicular();\r\n            // Point Contact A -> B\r\n            if (polyB.center.sub(polyA.center).dot(normal) < 0) {\r\n                normal = normal.negate();\r\n                tangent = normal.perpendicular();\r\n            }\r\n            // Points are clipped from incident which is the other collider\r\n            // Store those as locals\r\n            let localPoints = [];\r\n            if (separation.collider === polyA) {\r\n                const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();\r\n                localPoints = points.map((p) => xf.applyInverse(p));\r\n            }\r\n            else {\r\n                const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();\r\n                localPoints = points.map((p) => xf.applyInverse(p));\r\n            }\r\n            return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];\r\n        }\r\n        return [];\r\n    },\r\n    FindContactSeparation(contact, localPoint) {\r\n        var _a, _b, _c, _d;\r\n        const shapeA = contact.colliderA;\r\n        const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();\r\n        const shapeB = contact.colliderB;\r\n        const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();\r\n        // both are circles\r\n        if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {\r\n            const combinedRadius = shapeA.radius + shapeB.radius;\r\n            const distance = txA.pos.distance(txB.pos);\r\n            const separation = combinedRadius - distance;\r\n            return -separation;\r\n        }\r\n        // both are polygons\r\n        if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {\r\n            if (contact.info.localSide) {\r\n                let side;\r\n                let worldPoint;\r\n                if (contact.info.collider === shapeA) {\r\n                    side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));\r\n                    worldPoint = txB.apply(localPoint);\r\n                }\r\n                else {\r\n                    side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));\r\n                    worldPoint = txA.apply(localPoint);\r\n                }\r\n                return side.distanceToPoint(worldPoint, true);\r\n            }\r\n        }\r\n        // polygon v circle\r\n        if ((shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||\r\n            (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)) {\r\n            const worldPoint = txA.apply(localPoint);\r\n            if (contact.info.side) {\r\n                return contact.info.side.distanceToPoint(worldPoint, true);\r\n            }\r\n        }\r\n        // polygon v edge\r\n        if ((shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||\r\n            (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)) {\r\n            let worldPoint;\r\n            if (contact.info.collider === shapeA) {\r\n                worldPoint = txB.apply(localPoint);\r\n            }\r\n            else {\r\n                worldPoint = txA.apply(localPoint);\r\n            }\r\n            if (contact.info.side) {\r\n                return contact.info.side.distanceToPoint(worldPoint, true);\r\n            }\r\n        }\r\n        // circle v edge\r\n        if ((shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||\r\n            (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)) {\r\n            // Local point is always on the edge which is always shapeB\r\n            const worldPoint = txB.apply(localPoint);\r\n            let circlePoint;\r\n            if (shapeA instanceof CircleCollider) {\r\n                circlePoint = shapeA.getFurthestPoint(contact.normal);\r\n            }\r\n            const dist = worldPoint.distance(circlePoint);\r\n            if (contact.info.side) {\r\n                return dist > 0 ? -dist : 0;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/EdgeCollider.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Edge is a single line collider to create collisions with a single line.\r\n */\r\nclass EdgeCollider extends Collider {\r\n    constructor(options) {\r\n        var _a;\r\n        super();\r\n        this._globalMatrix = AffineMatrix.identity();\r\n        this.begin = options.begin || Vector.Zero;\r\n        this.end = options.end || Vector.Zero;\r\n        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;\r\n    }\r\n    /**\r\n     * Returns a clone of this Edge, not associated with any collider\r\n     */\r\n    clone() {\r\n        return new EdgeCollider({\r\n            begin: this.begin.clone(),\r\n            end: this.end.clone()\r\n        });\r\n    }\r\n    get worldPos() {\r\n        var _a;\r\n        const tx = this._transform;\r\n        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;\r\n    }\r\n    /**\r\n     * Get the center of the collision area in world coordinates\r\n     */\r\n    get center() {\r\n        const begin = this._getTransformedBegin();\r\n        const end = this._getTransformedEnd();\r\n        const pos = begin.average(end);\r\n        return pos;\r\n    }\r\n    _getTransformedBegin() {\r\n        return this._globalMatrix.multiply(this.begin);\r\n    }\r\n    _getTransformedEnd() {\r\n        return this._globalMatrix.multiply(this.end);\r\n    }\r\n    /**\r\n     * Returns the slope of the line in the form of a vector\r\n     */\r\n    getSlope() {\r\n        const begin = this._getTransformedBegin();\r\n        const end = this._getTransformedEnd();\r\n        const distance = begin.distance(end);\r\n        return end.sub(begin).scale(1 / distance);\r\n    }\r\n    /**\r\n     * Returns the length of the line segment in pixels\r\n     */\r\n    getLength() {\r\n        const begin = this._getTransformedBegin();\r\n        const end = this._getTransformedEnd();\r\n        const distance = begin.distance(end);\r\n        return distance;\r\n    }\r\n    /**\r\n     * Tests if a point is contained in this collision area\r\n     */\r\n    contains() {\r\n        return false;\r\n    }\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    rayCast(ray, max = Infinity) {\r\n        const numerator = this._getTransformedBegin().sub(ray.pos);\r\n        // Test is line and ray are parallel and non intersecting\r\n        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {\r\n            return null;\r\n        }\r\n        // Lines are parallel\r\n        const divisor = ray.dir.cross(this.getSlope());\r\n        if (divisor === 0) {\r\n            return null;\r\n        }\r\n        const t = numerator.cross(this.getSlope()) / divisor;\r\n        if (t >= 0 && t <= max) {\r\n            const u = numerator.cross(ray.dir) / divisor / this.getLength();\r\n            if (u >= 0 && u <= 1) {\r\n                return ray.getPoint(t);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns the closes line between this and another collider, from this -> collider\r\n     * @param shape\r\n     */\r\n    getClosestLineBetween(shape) {\r\n        if (shape instanceof CircleCollider) {\r\n            return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);\r\n        }\r\n        else if (shape instanceof PolygonCollider) {\r\n            return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();\r\n        }\r\n        else if (shape instanceof EdgeCollider) {\r\n            return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);\r\n        }\r\n        else {\r\n            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n        }\r\n    }\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    collide(shape) {\r\n        if (shape instanceof CircleCollider) {\r\n            return CollisionJumpTable.CollideCircleEdge(shape, this);\r\n        }\r\n        else if (shape instanceof PolygonCollider) {\r\n            return CollisionJumpTable.CollidePolygonEdge(shape, this);\r\n        }\r\n        else if (shape instanceof EdgeCollider) {\r\n            return CollisionJumpTable.CollideEdgeEdge();\r\n        }\r\n        else {\r\n            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);\r\n        }\r\n    }\r\n    /**\r\n     * Find the point on the collider furthest in the direction specified\r\n     */\r\n    getFurthestPoint(direction) {\r\n        const transformedBegin = this._getTransformedBegin();\r\n        const transformedEnd = this._getTransformedEnd();\r\n        if (direction.dot(transformedBegin) > 0) {\r\n            return transformedBegin;\r\n        }\r\n        else {\r\n            return transformedEnd;\r\n        }\r\n    }\r\n    _boundsFromBeginEnd(begin, end, padding = 10) {\r\n        // A perfectly vertical or horizontal edge would have a bounds 0 width or height\r\n        // this causes problems for the collision system so we give them some padding\r\n        return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);\r\n    }\r\n    /**\r\n     * Get the axis aligned bounding box for the edge collider in world space\r\n     */\r\n    get bounds() {\r\n        const transformedBegin = this._getTransformedBegin();\r\n        const transformedEnd = this._getTransformedEnd();\r\n        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);\r\n    }\r\n    /**\r\n     * Get the axis aligned bounding box for the edge collider in local space\r\n     */\r\n    get localBounds() {\r\n        return this._boundsFromBeginEnd(this.begin, this.end);\r\n    }\r\n    /**\r\n     * Returns this edge represented as a line in world coordinates\r\n     */\r\n    asLine() {\r\n        return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());\r\n    }\r\n    /**\r\n     * Return this edge as a line in local line coordinates (relative to the position)\r\n     */\r\n    asLocalLine() {\r\n        return new LineSegment(this.begin, this.end);\r\n    }\r\n    /**\r\n     * Get the axis associated with the edge\r\n     */\r\n    get axes() {\r\n        const e = this._getTransformedEnd().sub(this._getTransformedBegin());\r\n        const edgeNormal = e.normal();\r\n        const axes = [];\r\n        axes.push(edgeNormal);\r\n        axes.push(edgeNormal.negate());\r\n        axes.push(edgeNormal.normal());\r\n        axes.push(edgeNormal.normal().negate());\r\n        return axes;\r\n    }\r\n    /**\r\n     * Get the moment of inertia for an edge\r\n     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n     */\r\n    getInertia(mass) {\r\n        const length = this.end.sub(this.begin).distance() / 2;\r\n        return mass * length * length;\r\n    }\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    update(transform) {\r\n        var _a;\r\n        this._transform = transform;\r\n        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;\r\n        globalMat.clone(this._globalMatrix);\r\n        this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    }\r\n    /**\r\n     * Project the edge along a specified axis\r\n     */\r\n    project(axis) {\r\n        const scalars = [];\r\n        const points = [this._getTransformedBegin(), this._getTransformedEnd()];\r\n        const len = points.length;\r\n        for (let i = 0; i < len; i++) {\r\n            scalars.push(points[i].dot(axis));\r\n        }\r\n        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n    }\r\n    debug(ex, color) {\r\n        const begin = this._getTransformedBegin();\r\n        const end = this._getTransformedEnd();\r\n        ex.drawLine(begin, end, color, 2);\r\n        ex.drawCircle(begin, 2, color);\r\n        ex.drawCircle(end, 2, color);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/PolygonCollider.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Polygon collider for detecting collisions\r\n */\r\nclass PolygonCollider extends Collider {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super();\r\n        this._logger = Logger.getInstance();\r\n        this._transformedPoints = [];\r\n        this._sides = [];\r\n        this._localSides = [];\r\n        this._globalMatrix = AffineMatrix.identity();\r\n        this._transformedPointsDirty = true;\r\n        this._sidesDirty = true;\r\n        this._localSidesDirty = true;\r\n        this._localBoundsDirty = true;\r\n        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;\r\n        this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n        this.points = (_b = options.points) !== null && _b !== void 0 ? _b : [];\r\n        const counterClockwise = this._isCounterClockwiseWinding(this.points);\r\n        if (!counterClockwise) {\r\n            this.points.reverse();\r\n        }\r\n        if (!this.isConvex()) {\r\n            this._logger.warn('Excalibur only supports convex polygon colliders and will not behave properly.' +\r\n                'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');\r\n        }\r\n        // calculate initial transformation\r\n        this._calculateTransformation();\r\n    }\r\n    /**\r\n     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n     * Excalibur stores these in counter-clockwise order\r\n     */\r\n    set points(points) {\r\n        this._localBoundsDirty = true;\r\n        this._localSidesDirty = true;\r\n        this._sidesDirty = true;\r\n        this._points = points;\r\n    }\r\n    /**\r\n     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n     * Excalibur stores these in counter-clockwise order\r\n     */\r\n    get points() {\r\n        return this._points;\r\n    }\r\n    _isCounterClockwiseWinding(points) {\r\n        // https://stackoverflow.com/a/1165943\r\n        let sum = 0;\r\n        for (let i = 0; i < points.length; i++) {\r\n            sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);\r\n        }\r\n        return sum < 0;\r\n    }\r\n    /**\r\n     * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.\r\n     * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape\r\n     */\r\n    isConvex() {\r\n        // From SO: https://stackoverflow.com/a/45372025\r\n        if (this.points.length < 3) {\r\n            return false;\r\n        }\r\n        let oldPoint = this.points[this.points.length - 2];\r\n        let newPoint = this.points[this.points.length - 1];\r\n        let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n        let oldDirection = 0;\r\n        let orientation = 0;\r\n        let angleSum = 0;\r\n        for (const [i, point] of this.points.entries()) {\r\n            oldPoint = newPoint;\r\n            oldDirection = direction;\r\n            newPoint = point;\r\n            direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n            if (oldPoint.equals(newPoint)) {\r\n                return false; // repeat point\r\n            }\r\n            let angle = direction - oldDirection;\r\n            if (angle <= -Math.PI) {\r\n                angle += Math.PI * 2;\r\n            }\r\n            else if (angle > Math.PI) {\r\n                angle -= Math.PI * 2;\r\n            }\r\n            if (i === 0) {\r\n                if (angle === 0.0) {\r\n                    return false;\r\n                }\r\n                orientation = angle > 0 ? 1 : -1;\r\n            }\r\n            else {\r\n                if (orientation * angle <= 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            angleSum += angle;\r\n        }\r\n        return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;\r\n    }\r\n    /**\r\n     * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons\r\n     */\r\n    tessellate() {\r\n        const polygons = [];\r\n        for (let i = 1; i < this.points.length - 2; i++) {\r\n            polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);\r\n        }\r\n        polygons.push([this.points[0], this.points[1], this.points[2]]);\r\n        return new CompositeCollider(polygons.map(points => Shape.Polygon(points)));\r\n    }\r\n    /**\r\n     * Triangulate the polygon collider using the \"Ear Clipping\" algorithm.\r\n     * Returns a new [[CompositeCollider]] made up of smaller triangles.\r\n     */\r\n    triangulate() {\r\n        // https://www.youtube.com/watch?v=hTJFcHutls8\r\n        if (this.points.length < 3) {\r\n            throw Error('Invalid polygon');\r\n        }\r\n        /**\r\n         * Helper to get a vertex in the list\r\n         */\r\n        function getItem(index, list) {\r\n            if (index >= list.length) {\r\n                return list[index % list.length];\r\n            }\r\n            else if (index < 0) {\r\n                return list[index % list.length + list.length];\r\n            }\r\n            else {\r\n                return list[index];\r\n            }\r\n        }\r\n        /**\r\n         * Quick test for point in triangle\r\n         */\r\n        function isPointInTriangle(point, a, b, c) {\r\n            const ab = b.sub(a);\r\n            const bc = c.sub(b);\r\n            const ca = a.sub(c);\r\n            const ap = point.sub(a);\r\n            const bp = point.sub(b);\r\n            const cp = point.sub(c);\r\n            const cross1 = ab.cross(ap);\r\n            const cross2 = bc.cross(bp);\r\n            const cross3 = ca.cross(cp);\r\n            if (cross1 > 0 || cross2 > 0 || cross3 > 0) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        const triangles = [];\r\n        const vertices = [...this.points];\r\n        const indices = range(0, this.points.length - 1);\r\n        // 1. Loop through vertices clockwise\r\n        //    if the vertex is convex (interior angle is < 180) (cross product positive)\r\n        //    if the polygon formed by it's edges doesn't contain the points\r\n        //         it's an ear add it to our list of triangles, and restart\r\n        while (indices.length > 3) {\r\n            for (let i = 0; i < indices.length; i++) {\r\n                const a = indices[i];\r\n                const b = getItem(i - 1, indices);\r\n                const c = getItem(i + 1, indices);\r\n                const va = vertices[a];\r\n                const vb = vertices[b];\r\n                const vc = vertices[c];\r\n                // Check convexity\r\n                const leftArm = vb.sub(va);\r\n                const rightArm = vc.sub(va);\r\n                const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex\r\n                if (!isConvex) {\r\n                    continue;\r\n                }\r\n                let isEar = true;\r\n                // Check that if any vertices are in the triangle a, b, c\r\n                for (let j = 0; j < indices.length; j++) {\r\n                    const vertIndex = indices[j];\r\n                    // We can skip these\r\n                    if (vertIndex === a || vertIndex === b || vertIndex === c) {\r\n                        continue;\r\n                    }\r\n                    const point = vertices[vertIndex];\r\n                    if (isPointInTriangle(point, vb, va, vc)) {\r\n                        isEar = false;\r\n                        break;\r\n                    }\r\n                }\r\n                // Add ear to polygon list and remove from list\r\n                if (isEar) {\r\n                    triangles.push([vb, va, vc]);\r\n                    indices.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);\r\n        return new CompositeCollider(triangles.map(points => Shape.Polygon(points)));\r\n    }\r\n    /**\r\n     * Returns a clone of this ConvexPolygon, not associated with any collider\r\n     */\r\n    clone() {\r\n        return new PolygonCollider({\r\n            offset: this.offset.clone(),\r\n            points: this.points.map((p) => p.clone())\r\n        });\r\n    }\r\n    /**\r\n     * Returns the world position of the collider, which is the current body transform plus any defined offset\r\n     */\r\n    get worldPos() {\r\n        if (this._transform) {\r\n            return this._transform.pos.add(this.offset);\r\n        }\r\n        return this.offset;\r\n    }\r\n    /**\r\n     * Get the center of the collider in world coordinates\r\n     */\r\n    get center() {\r\n        return this.bounds.center;\r\n    }\r\n    /**\r\n     * Calculates the underlying transformation from the body relative space to world space\r\n     */\r\n    _calculateTransformation() {\r\n        const points = this.points;\r\n        const len = points.length;\r\n        this._transformedPoints.length = 0; // clear out old transform\r\n        for (let i = 0; i < len; i++) {\r\n            this._transformedPoints[i] = this._globalMatrix.multiply(points[i].clone());\r\n        }\r\n    }\r\n    /**\r\n     * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n     */\r\n    getTransformedPoints() {\r\n        if (this._transformedPointsDirty) {\r\n            this._calculateTransformation();\r\n            this._transformedPointsDirty = false;\r\n        }\r\n        return this._transformedPoints;\r\n    }\r\n    /**\r\n     * Gets the sides of the polygon in world space\r\n     */\r\n    getSides() {\r\n        if (this._sidesDirty) {\r\n            const lines = [];\r\n            const points = this.getTransformedPoints();\r\n            const len = points.length;\r\n            for (let i = 0; i < len; i++) {\r\n                // This winding is important\r\n                lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n            }\r\n            this._sides = lines;\r\n            this._sidesDirty = false;\r\n        }\r\n        return this._sides;\r\n    }\r\n    /**\r\n     * Returns the local coordinate space sides\r\n     */\r\n    getLocalSides() {\r\n        if (this._localSidesDirty) {\r\n            const lines = [];\r\n            const points = this.points;\r\n            const len = points.length;\r\n            for (let i = 0; i < len; i++) {\r\n                // This winding is important\r\n                lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n            }\r\n            this._localSides = lines;\r\n            this._localSidesDirty = false;\r\n        }\r\n        return this._localSides;\r\n    }\r\n    /**\r\n     * Given a direction vector find the world space side that is most in that direction\r\n     * @param direction\r\n     */\r\n    findSide(direction) {\r\n        const sides = this.getSides();\r\n        let bestSide = sides[0];\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let side = 0; side < sides.length; side++) {\r\n            const currentSide = sides[side];\r\n            const sideNormal = currentSide.normal();\r\n            const mostDirection = sideNormal.dot(direction);\r\n            if (mostDirection > maxDistance) {\r\n                bestSide = currentSide;\r\n                maxDistance = mostDirection;\r\n            }\r\n        }\r\n        return bestSide;\r\n    }\r\n    /**\r\n     * Given a direction vector find the local space side that is most in that direction\r\n     * @param direction\r\n     */\r\n    findLocalSide(direction) {\r\n        const sides = this.getLocalSides();\r\n        let bestSide = sides[0];\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let side = 0; side < sides.length; side++) {\r\n            const currentSide = sides[side];\r\n            const sideNormal = currentSide.normal();\r\n            const mostDirection = sideNormal.dot(direction);\r\n            if (mostDirection > maxDistance) {\r\n                bestSide = currentSide;\r\n                maxDistance = mostDirection;\r\n            }\r\n        }\r\n        return bestSide;\r\n    }\r\n    /**\r\n     * Get the axis associated with the convex polygon\r\n     */\r\n    get axes() {\r\n        const axes = [];\r\n        const sides = this.getSides();\r\n        for (let i = 0; i < sides.length; i++) {\r\n            axes.push(sides[i].normal());\r\n        }\r\n        return axes;\r\n    }\r\n    /**\r\n     * Updates the transform for the collision geometry\r\n     *\r\n     * Collision geometry (points/bounds) will not change until this is called.\r\n     * @param transform\r\n     */\r\n    update(transform) {\r\n        var _a;\r\n        this._transform = transform;\r\n        this._transformedPointsDirty = true;\r\n        this._sidesDirty = true;\r\n        // This change means an update must be performed in order for geometry to update\r\n        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;\r\n        globalMat.clone(this._globalMatrix);\r\n        this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    }\r\n    /**\r\n     * Tests if a point is contained in this collider in world space\r\n     */\r\n    contains(point) {\r\n        // Always cast to the right, as long as we cast in a consistent fixed direction we\r\n        // will be fine\r\n        const testRay = new Ray(point, new Vector(1, 0));\r\n        const intersectCount = this.getSides().reduce(function (accum, side) {\r\n            if (testRay.intersect(side) >= 0) {\r\n                return accum + 1;\r\n            }\r\n            return accum;\r\n        }, 0);\r\n        if (intersectCount % 2 === 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    getClosestLineBetween(collider) {\r\n        if (collider instanceof CircleCollider) {\r\n            return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);\r\n        }\r\n        else if (collider instanceof PolygonCollider) {\r\n            return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);\r\n        }\r\n        else if (collider instanceof EdgeCollider) {\r\n            return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);\r\n        }\r\n        else {\r\n            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a collision contact if the 2 colliders collide, otherwise collide will\r\n     * return null.\r\n     * @param collider\r\n     */\r\n    collide(collider) {\r\n        if (collider instanceof CircleCollider) {\r\n            return CollisionJumpTable.CollideCirclePolygon(collider, this);\r\n        }\r\n        else if (collider instanceof PolygonCollider) {\r\n            return CollisionJumpTable.CollidePolygonPolygon(this, collider);\r\n        }\r\n        else if (collider instanceof EdgeCollider) {\r\n            return CollisionJumpTable.CollidePolygonEdge(this, collider);\r\n        }\r\n        else {\r\n            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n        }\r\n    }\r\n    /**\r\n     * Find the point on the collider furthest in the direction specified\r\n     */\r\n    getFurthestPoint(direction) {\r\n        const pts = this.getTransformedPoints();\r\n        let furthestPoint = null;\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let i = 0; i < pts.length; i++) {\r\n            const distance = direction.dot(pts[i]);\r\n            if (distance > maxDistance) {\r\n                maxDistance = distance;\r\n                furthestPoint = pts[i];\r\n            }\r\n        }\r\n        return furthestPoint;\r\n    }\r\n    /**\r\n     * Find the local point on the collider furthest in the direction specified\r\n     * @param direction\r\n     */\r\n    getFurthestLocalPoint(direction) {\r\n        const pts = this.points;\r\n        let furthestPoint = pts[0];\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let i = 0; i < pts.length; i++) {\r\n            const distance = direction.dot(pts[i]);\r\n            if (distance > maxDistance) {\r\n                maxDistance = distance;\r\n                furthestPoint = pts[i];\r\n            }\r\n        }\r\n        return furthestPoint;\r\n    }\r\n    /**\r\n     * Finds the closes face to the point using perpendicular distance\r\n     * @param point point to test against polygon\r\n     */\r\n    getClosestFace(point) {\r\n        const sides = this.getSides();\r\n        let min = Number.POSITIVE_INFINITY;\r\n        let faceIndex = -1;\r\n        let distance = -1;\r\n        for (let i = 0; i < sides.length; i++) {\r\n            const dist = sides[i].distanceToPoint(point);\r\n            if (dist < min) {\r\n                min = dist;\r\n                faceIndex = i;\r\n                distance = dist;\r\n            }\r\n        }\r\n        if (faceIndex !== -1) {\r\n            return {\r\n                distance: sides[faceIndex].normal().scale(distance),\r\n                face: sides[faceIndex]\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get the axis aligned bounding box for the polygon collider in world coordinates\r\n     */\r\n    get bounds() {\r\n        return this.localBounds.transform(this._globalMatrix);\r\n    }\r\n    /**\r\n     * Get the axis aligned bounding box for the polygon collider in local coordinates\r\n     */\r\n    get localBounds() {\r\n        if (this._localBoundsDirty) {\r\n            this._localBounds = BoundingBox.fromPoints(this.points);\r\n            this._localBoundsDirty = false;\r\n        }\r\n        return this._localBounds;\r\n    }\r\n    /**\r\n     * Get the moment of inertia for an arbitrary polygon\r\n     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n     */\r\n    getInertia(mass) {\r\n        if (this._cachedMass === mass && this._cachedInertia) {\r\n            return this._cachedInertia;\r\n        }\r\n        let numerator = 0;\r\n        let denominator = 0;\r\n        const points = this.points;\r\n        for (let i = 0; i < points.length; i++) {\r\n            const iplusone = (i + 1) % points.length;\r\n            const crossTerm = points[iplusone].cross(points[i]);\r\n            numerator +=\r\n                crossTerm *\r\n                    (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));\r\n            denominator += crossTerm;\r\n        }\r\n        this._cachedMass = mass;\r\n        return this._cachedInertia = (mass / 6) * (numerator / denominator);\r\n    }\r\n    /**\r\n     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n     */\r\n    rayCast(ray, max = Infinity) {\r\n        // find the minimum contact time greater than 0\r\n        // contact times less than 0 are behind the ray and we don't want those\r\n        const sides = this.getSides();\r\n        const len = sides.length;\r\n        let minContactTime = Number.MAX_VALUE;\r\n        let contactIndex = -1;\r\n        for (let i = 0; i < len; i++) {\r\n            const contactTime = ray.intersect(sides[i]);\r\n            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\r\n                minContactTime = contactTime;\r\n                contactIndex = i;\r\n            }\r\n        }\r\n        // contact was found\r\n        if (contactIndex >= 0) {\r\n            return ray.getPoint(minContactTime);\r\n        }\r\n        // no contact found\r\n        return null;\r\n    }\r\n    /**\r\n     * Project the edges of the polygon along a specified axis\r\n     */\r\n    project(axis) {\r\n        const points = this.getTransformedPoints();\r\n        const len = points.length;\r\n        let min = Number.MAX_VALUE;\r\n        let max = -Number.MAX_VALUE;\r\n        for (let i = 0; i < len; i++) {\r\n            const scalar = points[i].dot(axis);\r\n            min = Math.min(min, scalar);\r\n            max = Math.max(max, scalar);\r\n        }\r\n        return new Projection(min, max);\r\n    }\r\n    debug(ex, color) {\r\n        const firstPoint = this.getTransformedPoints()[0];\r\n        const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            ex.drawLine(points[i], points[i + 1], color, 2);\r\n            ex.drawCircle(points[i], 2, color);\r\n            ex.drawCircle(points[i + 1], 2, color);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Colliders/Shape.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Excalibur helper for defining colliders quickly\r\n */\r\nclass Shape {\r\n    /**\r\n     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider\r\n     * @param width Width of the box\r\n     * @param height Height of the box\r\n     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position\r\n     * @param offset Optional offset relative to the collider in local coordinates\r\n     */\r\n    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {\r\n        return new PolygonCollider({\r\n            points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),\r\n            offset: offset\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new [[PolygonCollider|arbitrary polygon]] collider\r\n     *\r\n     * PolygonColliders are useful for creating convex polygon shapes\r\n     * @param points Points specified in counter clockwise\r\n     * @param offset Optional offset relative to the collider in local coordinates\r\n     */\r\n    static Polygon(points, offset = Vector.Zero) {\r\n        return new PolygonCollider({\r\n            points: points,\r\n            offset: offset\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new [[CircleCollider|circle]] collider\r\n     *\r\n     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges\r\n     * @param radius Radius of the circle collider\r\n     * @param offset Optional offset relative to the collider in local coordinates\r\n     */\r\n    static Circle(radius, offset = Vector.Zero) {\r\n        return new CircleCollider({\r\n            radius: radius,\r\n            offset: offset\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new [[EdgeCollider|edge]] collider\r\n     *\r\n     * Edge colliders are useful for  floors, walls, and other barriers\r\n     * @param begin Beginning of the edge in local coordinates to the collider\r\n     * @param end Ending of the edge in local coordinates to the collider\r\n     */\r\n    static Edge(begin, end) {\r\n        return new EdgeCollider({\r\n            begin: begin,\r\n            end: end\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box\r\n     *\r\n     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth\r\n     * player experience.\r\n     *\r\n     * @param width\r\n     * @param height\r\n     * @param offset Optional offset\r\n     */\r\n    static Capsule(width, height, offset = Vector.Zero) {\r\n        const logger = Logger.getInstance();\r\n        if (width === height) {\r\n            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');\r\n        }\r\n        const vertical = height >= width;\r\n        if (vertical) {\r\n            // height > width, if equal maybe use a circle\r\n            const capsule = new CompositeCollider([\r\n                Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),\r\n                Shape.Box(width, height - width, Vector.Half, offset),\r\n                Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))\r\n            ]);\r\n            return capsule;\r\n        }\r\n        else {\r\n            // width > height, if equal maybe use a circle\r\n            const capsule = new CompositeCollider([\r\n                Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),\r\n                Shape.Box(width - height, height, Vector.Half, offset),\r\n                Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))\r\n            ]);\r\n            return capsule;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/ColliderComponent.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ColliderComponent extends Component {\r\n    constructor(collider) {\r\n        super();\r\n        this.type = 'ex.collider';\r\n        this.events = new EventDispatcher();\r\n        /**\r\n         * Observable that notifies when a collider is added to the body\r\n         */\r\n        this.$colliderAdded = new Observable();\r\n        /**\r\n         * Observable that notifies when a collider is removed from the body\r\n         */\r\n        this.$colliderRemoved = new Observable();\r\n        this.set(collider);\r\n    }\r\n    /**\r\n     * Get the current collider geometry\r\n     */\r\n    get() {\r\n        return this._collider;\r\n    }\r\n    /**\r\n     * Set the collider geometry\r\n     * @param collider\r\n     * @returns the collider you set\r\n     */\r\n    set(collider) {\r\n        this.clear();\r\n        if (collider) {\r\n            this._collider = collider;\r\n            this._collider.owner = this.owner;\r\n            this.events.wire(collider.events);\r\n            this.$colliderAdded.notifyAll(collider);\r\n            this.update();\r\n        }\r\n        return collider;\r\n    }\r\n    /**\r\n     * Remove collider geometry from collider component\r\n     */\r\n    clear() {\r\n        if (this._collider) {\r\n            this.events.unwire(this._collider.events);\r\n            this.$colliderRemoved.notifyAll(this._collider);\r\n            this._collider.owner = null;\r\n            this._collider = null;\r\n        }\r\n    }\r\n    /**\r\n     * Return world space bounds\r\n     */\r\n    get bounds() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();\r\n    }\r\n    /**\r\n     * Return local space bounds\r\n     */\r\n    get localBounds() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();\r\n    }\r\n    /**\r\n     * Update the collider's transformed geometry\r\n     */\r\n    update() {\r\n        var _a;\r\n        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);\r\n        if (this._collider) {\r\n            this._collider.owner = this.owner;\r\n            if (tx) {\r\n                this._collider.update(tx.get());\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Collide component with another\r\n     * @param other\r\n     */\r\n    collide(other) {\r\n        let colliderA = this._collider;\r\n        let colliderB = other._collider;\r\n        if (!colliderA || !colliderB) {\r\n            return [];\r\n        }\r\n        // If we have a composite lefthand side :(\r\n        // Might bite us, but to avoid updating all the handlers make composite always left side\r\n        let flipped = false;\r\n        if (colliderB instanceof CompositeCollider) {\r\n            colliderA = colliderB;\r\n            colliderB = this._collider;\r\n            flipped = true;\r\n        }\r\n        if (this._collider) {\r\n            const contacts = colliderA.collide(colliderB);\r\n            if (contacts) {\r\n                if (flipped) {\r\n                    contacts.forEach((contact) => {\r\n                        contact.mtv = contact.mtv.negate();\r\n                        contact.normal = contact.normal.negate();\r\n                        contact.tangent = contact.normal.perpendicular();\r\n                        contact.colliderA = this._collider;\r\n                        contact.colliderB = other._collider;\r\n                    });\r\n                }\r\n                return contacts;\r\n            }\r\n            return [];\r\n        }\r\n        return [];\r\n    }\r\n    onAdd(entity) {\r\n        if (this._collider) {\r\n            this.update();\r\n        }\r\n        // Wire up the collider events to the owning entity\r\n        this.events.on('precollision', (evt) => {\r\n            const precollision = evt;\r\n            entity.events.emit('precollision', new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));\r\n        });\r\n        this.events.on('postcollision', (evt) => {\r\n            const postcollision = evt;\r\n            entity.events.emit('postcollision', new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));\r\n        });\r\n        this.events.on('collisionstart', (evt) => {\r\n            const start = evt;\r\n            entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));\r\n        });\r\n        this.events.on('collisionend', (evt) => {\r\n            const end = evt;\r\n            entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));\r\n        });\r\n    }\r\n    onRemove() {\r\n        this.events.clear();\r\n        this.$colliderRemoved.notifyAll(this._collider);\r\n    }\r\n    /**\r\n     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.\r\n     *\r\n     * If no width/height are specified the body will attempt to use the associated actor's width/height.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */\r\n    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {\r\n        const collider = Shape.Box(width, height, anchor, center);\r\n        return (this.set(collider));\r\n    }\r\n    /**\r\n     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative\r\n     *  to the anchor of the associated actor\r\n     * of this physics body.\r\n     *\r\n     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */\r\n    usePolygonCollider(points, center = Vector.Zero) {\r\n        const poly = Shape.Polygon(points, center);\r\n        return (this.set(poly));\r\n    }\r\n    /**\r\n     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */\r\n    useCircleCollider(radius, center = Vector.Zero) {\r\n        const collider = Shape.Circle(radius, center);\r\n        return (this.set(collider));\r\n    }\r\n    /**\r\n     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor\r\n     * of this physics body.\r\n     *\r\n     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n     */\r\n    useEdgeCollider(begin, end) {\r\n        const collider = Shape.Edge(begin, end);\r\n        return (this.set(collider));\r\n    }\r\n    /**\r\n     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders\r\n     * @param colliders\r\n     */\r\n    useCompositeCollider(colliders) {\r\n        return (this.set(new CompositeCollider(colliders)));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/BodyComponent.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar DegreeOfFreedom;\r\n(function (DegreeOfFreedom) {\r\n    DegreeOfFreedom[\"Rotation\"] = \"rotation\";\r\n    DegreeOfFreedom[\"X\"] = \"x\";\r\n    DegreeOfFreedom[\"Y\"] = \"y\";\r\n})(DegreeOfFreedom || (DegreeOfFreedom = {}));\r\n/**\r\n * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of\r\n * of physics simulation.\r\n */\r\nclass BodyComponent extends Component {\r\n    constructor(options) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.type = 'ex.body';\r\n        this.dependencies = [TransformComponent, MotionComponent];\r\n        this.id = createId('body', BodyComponent._ID++);\r\n        this.events = new EventDispatcher();\r\n        this._oldTransform = new Transform();\r\n        /**\r\n         * Indicates whether the old transform has been captured at least once for interpolation\r\n         * @internal\r\n         */\r\n        this.__oldTransformCaptured = false;\r\n        /**\r\n         * Enable or disabled the fixed update interpolation, by default interpolation is on.\r\n         */\r\n        this.enableFixedUpdateInterpolate = true;\r\n        /**\r\n         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]\r\n         */\r\n        this.collisionType = CollisionType.PreventCollision;\r\n        /**\r\n         * The collision group for the body's colliders, by default body colliders collide with everything\r\n         */\r\n        this.group = CollisionGroup.All;\r\n        /**\r\n         * The amount of mass the body has\r\n         */\r\n        this._mass = Physics.defaultMass;\r\n        /**\r\n         * Amount of \"motion\" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to \"sleep\"\r\n         */\r\n        this.sleepMotion = Physics.sleepEpsilon * 5;\r\n        /**\r\n         * Can this body sleep, by default bodies do not sleep\r\n         */\r\n        this.canSleep = Physics.bodiesCanSleepByDefault;\r\n        this._sleeping = false;\r\n        /**\r\n         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the\r\n         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.\r\n         */\r\n        this.bounciness = 0.2;\r\n        /**\r\n         * The coefficient of friction on this actor\r\n         */\r\n        this.friction = 0.99;\r\n        /**\r\n         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true\r\n         */\r\n        this.useGravity = true;\r\n        /**\r\n         * Degrees of freedom to limit\r\n         *\r\n         * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond\r\n         */\r\n        this.limitDegreeOfFreedom = [];\r\n        /**\r\n         * The velocity of the actor last frame (vx, vy) in pixels/second\r\n         */\r\n        this.oldVel = new Vector(0, 0);\r\n        /**\r\n         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n         */\r\n        this.oldAcc = Vector.Zero;\r\n        if (options) {\r\n            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;\r\n            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;\r\n            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;\r\n        }\r\n    }\r\n    get matrix() {\r\n        return this.transform.get().matrix;\r\n    }\r\n    get mass() {\r\n        return this._mass;\r\n    }\r\n    set mass(newMass) {\r\n        this._mass = newMass;\r\n        this._cachedInertia = undefined;\r\n        this._cachedInverseInertia = undefined;\r\n    }\r\n    /**\r\n     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n     */\r\n    get inverseMass() {\r\n        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;\r\n    }\r\n    /**\r\n     * Whether this body is sleeping or not\r\n     */\r\n    get sleeping() {\r\n        return this._sleeping;\r\n    }\r\n    /**\r\n     * Set the sleep state of the body\r\n     * @param sleeping\r\n     */\r\n    setSleeping(sleeping) {\r\n        this._sleeping = sleeping;\r\n        if (!sleeping) {\r\n            // Give it a kick to keep it from falling asleep immediately\r\n            this.sleepMotion = Physics.sleepEpsilon * 5;\r\n        }\r\n        else {\r\n            this.vel = Vector.Zero;\r\n            this.acc = Vector.Zero;\r\n            this.angularVelocity = 0;\r\n            this.sleepMotion = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping\r\n     */\r\n    updateMotion() {\r\n        if (this._sleeping) {\r\n            this.setSleeping(true);\r\n        }\r\n        const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);\r\n        const bias = Physics.sleepBias;\r\n        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;\r\n        this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);\r\n        if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {\r\n            this.setSleeping(true);\r\n        }\r\n    }\r\n    /**\r\n     * Get the moment of inertia from the [[ColliderComponent]]\r\n     */\r\n    get inertia() {\r\n        if (this._cachedInertia) {\r\n            return this._cachedInertia;\r\n        }\r\n        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?\r\n        const collider = this.owner.get(ColliderComponent);\r\n        if (collider) {\r\n            collider.$colliderAdded.subscribe(() => {\r\n                this._cachedInertia = null;\r\n            });\r\n            collider.$colliderRemoved.subscribe(() => {\r\n                this._cachedInertia = null;\r\n            });\r\n            const maybeCollider = collider.get();\r\n            if (maybeCollider) {\r\n                return this._cachedInertia = maybeCollider.getInertia(this.mass);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n     */\r\n    get inverseInertia() {\r\n        if (this._cachedInverseInertia) {\r\n            return this._cachedInverseInertia;\r\n        }\r\n        return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;\r\n    }\r\n    /**\r\n     * Returns if the owner is active\r\n     */\r\n    get active() {\r\n        var _a;\r\n        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);\r\n    }\r\n    /**\r\n     * @deprecated Use globalP0s\r\n     */\r\n    get center() {\r\n        return this.globalPos;\r\n    }\r\n    get transform() {\r\n        var _a;\r\n        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);\r\n    }\r\n    get motion() {\r\n        var _a;\r\n        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);\r\n    }\r\n    get pos() {\r\n        return this.transform.pos;\r\n    }\r\n    set pos(val) {\r\n        this.transform.pos = val;\r\n    }\r\n    /**\r\n     * The (x, y) position of the actor this will be in the middle of the actor if the\r\n     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n     */\r\n    get globalPos() {\r\n        return this.transform.globalPos;\r\n    }\r\n    set globalPos(val) {\r\n        this.transform.globalPos = val;\r\n    }\r\n    /**\r\n     * The position of the actor last frame (x, y) in pixels\r\n     */\r\n    get oldPos() {\r\n        return this._oldTransform.pos;\r\n    }\r\n    /**\r\n     * The current velocity vector (vx, vy) of the actor in pixels/second\r\n     */\r\n    get vel() {\r\n        return this.motion.vel;\r\n    }\r\n    set vel(val) {\r\n        this.motion.vel = val;\r\n    }\r\n    /**\r\n     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n     * be useful to simulate a gravitational effect.\r\n     */\r\n    get acc() {\r\n        return this.motion.acc;\r\n    }\r\n    set acc(val) {\r\n        this.motion.acc = val;\r\n    }\r\n    /**\r\n     * The current torque applied to the actor\r\n     */\r\n    get torque() {\r\n        return this.motion.torque;\r\n    }\r\n    set torque(val) {\r\n        this.motion.torque = val;\r\n    }\r\n    /**\r\n     * Gets/sets the rotation of the body from the last frame.\r\n     */\r\n    get oldRotation() {\r\n        return this._oldTransform.rotation;\r\n    }\r\n    /**\r\n     * The rotation of the body in radians\r\n     */\r\n    get rotation() {\r\n        return this.transform.globalRotation;\r\n    }\r\n    set rotation(val) {\r\n        this.transform.globalRotation = val;\r\n    }\r\n    /**\r\n     * The scale vector of the actor\r\n     */\r\n    get scale() {\r\n        return this.transform.globalScale;\r\n    }\r\n    set scale(val) {\r\n        this.transform.globalScale = val;\r\n    }\r\n    /**\r\n     * The scale of the actor last frame\r\n     */\r\n    get oldScale() {\r\n        return this._oldTransform.scale;\r\n    }\r\n    /**\r\n     * The scale rate of change of the actor in scale/second\r\n     */\r\n    get scaleFactor() {\r\n        return this.motion.scaleFactor;\r\n    }\r\n    set scaleFactor(scaleFactor) {\r\n        this.motion.scaleFactor = scaleFactor;\r\n    }\r\n    /**\r\n     * Get the angular velocity in radians/second\r\n     */\r\n    get angularVelocity() {\r\n        return this.motion.angularVelocity;\r\n    }\r\n    /**\r\n     * Set the angular velocity in radians/second\r\n     */\r\n    set angularVelocity(value) {\r\n        this.motion.angularVelocity = value;\r\n    }\r\n    /**\r\n     * Apply a specific impulse to the body\r\n     * @param point\r\n     * @param impulse\r\n     */\r\n    applyImpulse(point, impulse) {\r\n        if (this.collisionType !== CollisionType.Active) {\r\n            return; // only active objects participate in the simulation\r\n        }\r\n        const finalImpulse = impulse.scale(this.inverseMass);\r\n        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n            finalImpulse.x = 0;\r\n        }\r\n        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n            finalImpulse.y = 0;\r\n        }\r\n        this.vel.addEqual(finalImpulse);\r\n        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n            const distanceFromCenter = point.sub(this.globalPos);\r\n            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n        }\r\n    }\r\n    /**\r\n     * Apply only linear impulse to the body\r\n     * @param impulse\r\n     */\r\n    applyLinearImpulse(impulse) {\r\n        if (this.collisionType !== CollisionType.Active) {\r\n            return; // only active objects participate in the simulation\r\n        }\r\n        const finalImpulse = impulse.scale(this.inverseMass);\r\n        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n            finalImpulse.x = 0;\r\n        }\r\n        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n            finalImpulse.y = 0;\r\n        }\r\n        this.vel = this.vel.add(finalImpulse);\r\n    }\r\n    /**\r\n     * Apply only angular impulse to the body\r\n     * @param point\r\n     * @param impulse\r\n     */\r\n    applyAngularImpulse(point, impulse) {\r\n        if (this.collisionType !== CollisionType.Active) {\r\n            return; // only active objects participate in the simulation\r\n        }\r\n        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n            const distanceFromCenter = point.sub(this.globalPos);\r\n            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n        }\r\n    }\r\n    /**\r\n     * Sets the old versions of pos, vel, acc, and scale.\r\n     */\r\n    captureOldTransform() {\r\n        // Capture old values before integration step updates them\r\n        this.__oldTransformCaptured = true;\r\n        this.transform.get().clone(this._oldTransform);\r\n        this.oldVel.setTo(this.vel.x, this.vel.y);\r\n        this.oldAcc.setTo(this.acc.x, this.acc.y);\r\n    }\r\n}\r\nBodyComponent._ID = 0;\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/Entity.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * AddedComponent message\r\n */\r\nclass AddedComponent {\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.type = 'Component Added';\r\n    }\r\n}\r\n/**\r\n * Type guard to know if message is f an Added Component\r\n */\r\nfunction isAddedComponent(x) {\r\n    return !!x && x.type === 'Component Added';\r\n}\r\n/**\r\n * RemovedComponent message\r\n */\r\nclass RemovedComponent {\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.type = 'Component Removed';\r\n    }\r\n}\r\n/**\r\n * Type guard to know if message is for a Removed Component\r\n */\r\nfunction isRemovedComponent(x) {\r\n    return !!x && x.type === 'Component Removed';\r\n}\r\n/**\r\n * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system\r\n *\r\n * Entities can be strongly typed with the components they contain\r\n *\r\n * ```typescript\r\n * const entity = new Entity<ComponentA | ComponentB>();\r\n * entity.components.a; // Type ComponentA\r\n * entity.components.b; // Type ComponentB\r\n * ```\r\n */\r\nclass Entity extends Class {\r\n    constructor(components, name) {\r\n        super();\r\n        /**\r\n         * The unique identifier for the entity\r\n         */\r\n        this.id = Entity._ID++;\r\n        this._name = 'anonymous';\r\n        /**\r\n         * Whether this entity is active, if set to false it will be reclaimed\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * Bucket to hold on to deferred removals\r\n         */\r\n        this._componentsToRemove = [];\r\n        this._componentTypeToInstance = new Map();\r\n        this._componentStringToInstance = new Map();\r\n        this._tagsMemo = [];\r\n        this._typesMemo = [];\r\n        /**\r\n         * Observable that keeps track of component add or remove changes on the entity\r\n         */\r\n        this.componentAdded$ = new Observable();\r\n        this.componentRemoved$ = new Observable();\r\n        this._parent = null;\r\n        this.childrenAdded$ = new Observable();\r\n        this.childrenRemoved$ = new Observable();\r\n        this._children = [];\r\n        this._isInitialized = false;\r\n        this._setName(name);\r\n        if (components) {\r\n            for (const component of components) {\r\n                this.addComponent(component);\r\n            }\r\n        }\r\n    }\r\n    _setName(name) {\r\n        if (name) {\r\n            this._name = name;\r\n        }\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get events() {\r\n        return this.eventDispatcher;\r\n    }\r\n    /**\r\n     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.\r\n     */\r\n    kill() {\r\n        this.active = false;\r\n    }\r\n    isKilled() {\r\n        return !this.active;\r\n    }\r\n    /**\r\n     * Specifically get the tags on the entity from [[TagComponent]]\r\n     */\r\n    get tags() {\r\n        return this._tagsMemo;\r\n    }\r\n    /**\r\n     * Check if a tag exists on the entity\r\n     * @param tag name to check for\r\n     */\r\n    hasTag(tag) {\r\n        return this.tags.includes(tag);\r\n    }\r\n    /**\r\n     * Adds a tag to an entity\r\n     * @param tag\r\n     * @returns Entity\r\n     */\r\n    addTag(tag) {\r\n        return this.addComponent(new TagComponent(tag));\r\n    }\r\n    /**\r\n     * Removes a tag on the entity\r\n     *\r\n     * Removals are deferred until the end of update\r\n     * @param tag\r\n     * @param force Remove component immediately, no deferred\r\n     */\r\n    removeTag(tag, force = false) {\r\n        return this.removeComponent(tag, force);\r\n    }\r\n    /**\r\n     * The types of the components on the Entity\r\n     */\r\n    get types() {\r\n        return this._typesMemo;\r\n    }\r\n    _rebuildMemos() {\r\n        this._tagsMemo = Array.from(this._componentStringToInstance.values())\r\n            .filter((c) => c instanceof TagComponent)\r\n            .map((c) => c.type);\r\n        this._typesMemo = Array.from(this._componentStringToInstance.keys());\r\n    }\r\n    getComponents() {\r\n        return Array.from(this._componentStringToInstance.values());\r\n    }\r\n    _notifyAddComponent(component) {\r\n        this._rebuildMemos();\r\n        const added = new AddedComponent({\r\n            component,\r\n            entity: this\r\n        });\r\n        this.componentAdded$.notifyAll(added);\r\n    }\r\n    _notifyRemoveComponent(component) {\r\n        const removed = new RemovedComponent({\r\n            component,\r\n            entity: this\r\n        });\r\n        this.componentRemoved$.notifyAll(removed);\r\n        this._rebuildMemos();\r\n    }\r\n    get parent() {\r\n        return this._parent;\r\n    }\r\n    /**\r\n     * Get the direct children of this entity\r\n     */\r\n    get children() {\r\n        return this._children;\r\n    }\r\n    /**\r\n     * Unparents this entity, if there is a parent. Otherwise it does nothing.\r\n     */\r\n    unparent() {\r\n        if (this._parent) {\r\n            this._parent.removeChild(this);\r\n            this._parent = null;\r\n        }\r\n    }\r\n    /**\r\n     * Adds an entity to be a child of this entity\r\n     * @param entity\r\n     */\r\n    addChild(entity) {\r\n        if (entity.parent === null) {\r\n            if (this.getAncestors().includes(entity)) {\r\n                throw new Error('Cycle detected, cannot add entity');\r\n            }\r\n            this._children.push(entity);\r\n            entity._parent = this;\r\n            this.childrenAdded$.notifyAll(entity);\r\n        }\r\n        else {\r\n            throw new Error('Entity already has a parent, cannot add without unparenting');\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove an entity from children if it exists\r\n     * @param entity\r\n     */\r\n    removeChild(entity) {\r\n        if (entity.parent === this) {\r\n            removeItemFromArray(entity, this._children);\r\n            entity._parent = null;\r\n            this.childrenRemoved$.notifyAll(entity);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes all children from this entity\r\n     */\r\n    removeAllChildren() {\r\n        this.children.forEach((c) => {\r\n            this.removeChild(c);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.\r\n     */\r\n    getAncestors() {\r\n        const result = [this];\r\n        let current = this.parent;\r\n        while (current) {\r\n            result.push(current);\r\n            current = current.parent;\r\n        }\r\n        return result.reverse();\r\n    }\r\n    /**\r\n     * Returns a list of all the entities that descend from this entity. Includes the current entity.\r\n     */\r\n    getDescendants() {\r\n        let result = [this];\r\n        let queue = [this];\r\n        while (queue.length > 0) {\r\n            const curr = queue.pop();\r\n            queue = queue.concat(curr.children);\r\n            result = result.concat(curr.children);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a deep copy of the entity and a copy of all its components\r\n     */\r\n    clone() {\r\n        const newEntity = new Entity();\r\n        for (const c of this.types) {\r\n            newEntity.addComponent(this.get(c).clone());\r\n        }\r\n        for (const child of this.children) {\r\n            newEntity.addChild(child.clone());\r\n        }\r\n        return newEntity;\r\n    }\r\n    /**\r\n     * Adds a copy of all the components from another template entity as a \"prefab\"\r\n     * @param templateEntity Entity to use as a template\r\n     * @param force Force component replacement if it already exists on the target entity\r\n     */\r\n    addTemplate(templateEntity, force = false) {\r\n        for (const c of templateEntity.getComponents()) {\r\n            this.addComponent(c.clone(), force);\r\n        }\r\n        for (const child of templateEntity.children) {\r\n            this.addChild(child.clone().addTemplate(child));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds a component to the entity\r\n     * @param component Component or Entity to add copy of components from\r\n     * @param force Optionally overwrite any existing components of the same type\r\n     */\r\n    addComponent(component, force = false) {\r\n        // if component already exists, skip if not forced\r\n        if (this.has(component.type)) {\r\n            if (force) {\r\n                // Remove existing component type if exists when forced\r\n                this.removeComponent(component);\r\n            }\r\n            else {\r\n                // early exit component exits\r\n                return this;\r\n            }\r\n        }\r\n        // TODO circular dependencies will be a problem\r\n        if (component.dependencies && component.dependencies.length) {\r\n            for (const ctor of component.dependencies) {\r\n                this.addComponent(new ctor());\r\n            }\r\n        }\r\n        component.owner = this;\r\n        const constuctorType = component.constructor;\r\n        this._componentTypeToInstance.set(constuctorType, component);\r\n        this._componentStringToInstance.set(component.type, component);\r\n        if (component.onAdd) {\r\n            component.onAdd(this);\r\n        }\r\n        this._notifyAddComponent(component);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues\r\n     *\r\n     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately\r\n     * @param componentOrType\r\n     * @param force\r\n     */\r\n    removeComponent(componentOrType, force = false) {\r\n        if (force) {\r\n            if (typeof componentOrType === 'string') {\r\n                this._removeComponentByType(componentOrType);\r\n            }\r\n            else if (componentOrType instanceof Component) {\r\n                this._removeComponentByType(componentOrType.type);\r\n            }\r\n        }\r\n        else {\r\n            this._componentsToRemove.push(componentOrType);\r\n        }\r\n        return this;\r\n    }\r\n    _removeComponentByType(type) {\r\n        if (this.has(type)) {\r\n            const component = this.get(type);\r\n            component.owner = null;\r\n            if (component.onRemove) {\r\n                component.onRemove(this);\r\n            }\r\n            const ctor = component.constructor;\r\n            this._componentTypeToInstance.delete(ctor);\r\n            this._componentStringToInstance.delete(component.type);\r\n            this._notifyRemoveComponent(component);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     * @internal\r\n     */\r\n    processComponentRemoval() {\r\n        for (const componentOrType of this._componentsToRemove) {\r\n            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;\r\n            this._removeComponentByType(type);\r\n        }\r\n        this._componentsToRemove.length = 0;\r\n    }\r\n    has(type) {\r\n        if (typeof type === 'string') {\r\n            return this._componentStringToInstance.has(type);\r\n        }\r\n        else {\r\n            return this._componentTypeToInstance.has(type);\r\n        }\r\n    }\r\n    get(type) {\r\n        if (typeof type === 'string') {\r\n            return this._componentStringToInstance.get(type);\r\n        }\r\n        else {\r\n            return this._componentTypeToInstance.get(type);\r\n        }\r\n    }\r\n    /**\r\n     * Gets whether the actor is Initialized\r\n     */\r\n    get isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n    /**\r\n     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.\r\n     *\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * @internal\r\n     */\r\n    _initialize(engine) {\r\n        if (!this.isInitialized) {\r\n            this.onInitialize(engine);\r\n            super.emit('initialize', new InitializeEvent(engine, this));\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _preupdate(engine, delta) {\r\n        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n        this.onPreUpdate(engine, delta);\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _postupdate(engine, delta) {\r\n        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n        this.onPostUpdate(engine, delta);\r\n    }\r\n    /**\r\n     * `onInitialize` is called before the first update of the entity. This method is meant to be\r\n     * overridden.\r\n     *\r\n     * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n     */\r\n    onInitialize(_engine) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before an entity is updated.\r\n     */\r\n    onPreUpdate(_engine, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after an entity is updated.\r\n     */\r\n    onPostUpdate(_engine, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     *\r\n     * Entity update lifecycle, called internally\r\n     *\r\n     * @internal\r\n     * @param engine\r\n     * @param delta\r\n     */\r\n    update(engine, delta) {\r\n        this._initialize(engine);\r\n        this._preupdate(engine, delta);\r\n        for (const child of this.children) {\r\n            child.update(engine, delta);\r\n        }\r\n        this._postupdate(engine, delta);\r\n    }\r\n}\r\nEntity._ID = 0;\r\n\n;// CONCATENATED MODULE: ./Graphics/GraphicsComponent.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)\r\n * @param graphic\r\n */\r\nfunction hasGraphicsTick(graphic) {\r\n    return !!graphic.tick;\r\n}\r\nclass GraphicsLayer {\r\n    constructor(_options, _graphics) {\r\n        this._options = _options;\r\n        this._graphics = _graphics;\r\n        this.graphics = [];\r\n    }\r\n    get name() {\r\n        return this._options.name;\r\n    }\r\n    hide(nameOrGraphic) {\r\n        if (!nameOrGraphic) {\r\n            this.graphics.length = 0;\r\n        }\r\n        else {\r\n            let gfx = null;\r\n            if (nameOrGraphic instanceof Graphic) {\r\n                gfx = nameOrGraphic;\r\n            }\r\n            else {\r\n                gfx = this._graphics.getGraphic(nameOrGraphic);\r\n            }\r\n            this.graphics = this.graphics.filter((g) => g.graphic !== gfx);\r\n            this._graphics.recalculateBounds();\r\n        }\r\n    }\r\n    /**\r\n     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.\r\n     *\r\n     * If `show()` is called multiple times for the same graphic it will be shown multiple times.\r\n     * @param nameOrGraphic\r\n     * @param options\r\n     */\r\n    show(nameOrGraphic, options) {\r\n        options = { ...options };\r\n        let gfx;\r\n        if (nameOrGraphic instanceof Graphic) {\r\n            gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;\r\n        }\r\n        else {\r\n            gfx = this._graphics.getGraphic(nameOrGraphic);\r\n            if (!gfx) {\r\n                Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());\r\n            }\r\n        }\r\n        if (gfx) {\r\n            this.graphics.push({ graphic: gfx, options });\r\n            this._graphics.recalculateBounds();\r\n            return gfx;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Use a specific graphic, swap out any current graphics being shown\r\n     * @param nameOrGraphic\r\n     * @param options\r\n     */\r\n    use(nameOrGraphic, options) {\r\n        options = { ...options };\r\n        this.hide();\r\n        return this.show(nameOrGraphic, options);\r\n    }\r\n    /**\r\n     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n     *\r\n     * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n     */\r\n    get order() {\r\n        return this._options.order;\r\n    }\r\n    /**\r\n     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n     *\r\n     * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n     */\r\n    set order(order) {\r\n        this._options.order = order;\r\n    }\r\n    /**\r\n     * Get or set the pixel offset from the layer anchor for all graphics in the layer\r\n     */\r\n    get offset() {\r\n        var _a;\r\n        return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;\r\n    }\r\n    set offset(value) {\r\n        this._options.offset = value;\r\n    }\r\n    get currentKeys() {\r\n        var _a;\r\n        return (_a = this.name) !== null && _a !== void 0 ? _a : 'anonymous';\r\n    }\r\n}\r\nclass GraphicsLayers {\r\n    constructor(_component) {\r\n        this._component = _component;\r\n        this._layers = [];\r\n        this._layerMap = {};\r\n        this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);\r\n        this._maybeAddLayer(this.default);\r\n    }\r\n    create(options) {\r\n        const layer = new GraphicsLayer(options, this._component);\r\n        return this._maybeAddLayer(layer);\r\n    }\r\n    get(name) {\r\n        if (name) {\r\n            return this._getLayer(name);\r\n        }\r\n        return this._layers;\r\n    }\r\n    currentKeys() {\r\n        const graphicsLayerKeys = [];\r\n        for (const layer of this._layers) {\r\n            graphicsLayerKeys.push(layer.currentKeys);\r\n        }\r\n        return graphicsLayerKeys;\r\n    }\r\n    has(name) {\r\n        return name in this._layerMap;\r\n    }\r\n    _maybeAddLayer(layer) {\r\n        if (this._layerMap[layer.name]) {\r\n            // todo log warning\r\n            return this._layerMap[layer.name];\r\n        }\r\n        this._layerMap[layer.name] = layer;\r\n        this._layers.push(layer);\r\n        this._layers.sort((a, b) => a.order - b.order);\r\n        return layer;\r\n    }\r\n    _getLayer(name) {\r\n        return this._layerMap[name];\r\n    }\r\n}\r\n/**\r\n * Component to manage drawings, using with the position component\r\n */\r\nclass GraphicsComponent extends Component {\r\n    constructor(options) {\r\n        super();\r\n        this.type = 'ex.graphics';\r\n        this._graphics = {};\r\n        /**\r\n         * Sets or gets wether any drawing should be visible in this component\r\n         */\r\n        this.visible = true;\r\n        /**\r\n         * Sets or gets wither all drawings should have an opacity applied\r\n         */\r\n        this.opacity = 1;\r\n        /**\r\n         * Offset to apply to graphics by default\r\n         */\r\n        this.offset = Vector.Zero;\r\n        /**\r\n         * Anchor to apply to graphics by default\r\n         */\r\n        this.anchor = Vector.Half;\r\n        /**\r\n         * If set to true graphics added to the component will be copied. This can affect performance\r\n         */\r\n        this.copyGraphics = false;\r\n        this._localBounds = null;\r\n        // Defaults\r\n        options = {\r\n            visible: this.visible,\r\n            ...options\r\n        };\r\n        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;\r\n        this._graphics = graphics || {};\r\n        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;\r\n        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;\r\n        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;\r\n        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;\r\n        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;\r\n        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;\r\n        this.visible = !!visible;\r\n        this.layers = new GraphicsLayers(this);\r\n        if (current && this._graphics[current]) {\r\n            this.show(this._graphics[current]);\r\n        }\r\n    }\r\n    getGraphic(name) {\r\n        return this._graphics[name];\r\n    }\r\n    /**\r\n     * Get registered graphics names\r\n     */\r\n    getNames() {\r\n        return Object.keys(this._graphics);\r\n    }\r\n    /**\r\n     * Returns the currently displayed graphics and their offsets, empty array if hidden\r\n     */\r\n    get current() {\r\n        return this.layers.default.graphics;\r\n    }\r\n    /**\r\n     * Returns all graphics associated with this component\r\n     */\r\n    get graphics() {\r\n        return this._graphics;\r\n    }\r\n    add(nameOrGraphic, graphic) {\r\n        let name = 'default';\r\n        let graphicToSet = null;\r\n        if (typeof nameOrGraphic === 'string') {\r\n            name = nameOrGraphic;\r\n            graphicToSet = graphic;\r\n        }\r\n        else {\r\n            graphicToSet = nameOrGraphic;\r\n        }\r\n        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;\r\n        if (name === 'default') {\r\n            this.show('default');\r\n        }\r\n        return graphicToSet;\r\n    }\r\n    /**\r\n     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]\r\n     */\r\n    show(nameOrGraphic, options) {\r\n        const result = this.layers.default.show(nameOrGraphic, options);\r\n        this.recalculateBounds();\r\n        return result;\r\n    }\r\n    /**\r\n     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]\r\n     * @param nameOrGraphic\r\n     * @param options\r\n     */\r\n    use(nameOrGraphic, options) {\r\n        const result = this.layers.default.use(nameOrGraphic, options);\r\n        this.recalculateBounds();\r\n        return result;\r\n    }\r\n    hide(nameOrGraphic) {\r\n        this.layers.default.hide(nameOrGraphic);\r\n    }\r\n    set localBounds(bounds) {\r\n        this._localBounds = bounds;\r\n    }\r\n    recalculateBounds() {\r\n        let bb = new BoundingBox();\r\n        for (const layer of this.layers.get()) {\r\n            for (const { graphic, options } of layer.graphics) {\r\n                let anchor = this.anchor;\r\n                let offset = this.offset;\r\n                if (options === null || options === void 0 ? void 0 : options.anchor) {\r\n                    anchor = options.anchor;\r\n                }\r\n                if (options === null || options === void 0 ? void 0 : options.offset) {\r\n                    offset = options.offset;\r\n                }\r\n                const bounds = graphic.localBounds;\r\n                const offsetX = -bounds.width * anchor.x + offset.x;\r\n                const offsetY = -bounds.height * anchor.y + offset.y;\r\n                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);\r\n            }\r\n        }\r\n        this._localBounds = bb;\r\n    }\r\n    get localBounds() {\r\n        if (!this._localBounds || this._localBounds.hasZeroDimensions()) {\r\n            this.recalculateBounds();\r\n        }\r\n        return this._localBounds;\r\n    }\r\n    /**\r\n     * Update underlying graphics if necesary, called internally\r\n     * @param elapsed\r\n     * @internal\r\n     */\r\n    update(elapsed, idempotencyToken = 0) {\r\n        for (const layer of this.layers.get()) {\r\n            for (const { graphic } of layer.graphics) {\r\n                if (hasGraphicsTick(graphic)) {\r\n                    graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Rectangle.ts\n\r\n/**\r\n * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]\r\n */\r\nclass Rectangle extends Raster {\r\n    constructor(options) {\r\n        super(options);\r\n        this.width = options.width;\r\n        this.height = options.height;\r\n        this.rasterize();\r\n    }\r\n    clone() {\r\n        return new Rectangle({\r\n            width: this.width,\r\n            height: this.height,\r\n            ...this.cloneGraphicOptions(),\r\n            ...this.cloneRasterOptions()\r\n        });\r\n    }\r\n    execute(ctx) {\r\n        if (this.color) {\r\n            ctx.fillRect(0, 0, this.width, this.height);\r\n        }\r\n        if (this.strokeColor) {\r\n            ctx.strokeRect(0, 0, this.width, this.height);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Circle.ts\n\r\n\r\n/**\r\n * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Circles default to [[ImageFiltering.Blended]]\r\n */\r\nclass Circle extends Raster {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super(options);\r\n        this._radius = 0;\r\n        this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice\r\n        this.radius = options.radius;\r\n        this.filtering = (_b = options.filtering) !== null && _b !== void 0 ? _b : ImageFiltering.Blended;\r\n        this.rasterize();\r\n    }\r\n    get radius() {\r\n        return this._radius;\r\n    }\r\n    set radius(value) {\r\n        this._radius = value;\r\n        this.width = this._radius * 2;\r\n        this.height = this._radius * 2;\r\n        this.flagDirty();\r\n    }\r\n    clone() {\r\n        return new Circle({\r\n            radius: this.radius,\r\n            ...this.cloneGraphicOptions(),\r\n            ...this.cloneRasterOptions()\r\n        });\r\n    }\r\n    execute(ctx) {\r\n        if (this.radius > 0) {\r\n            ctx.beginPath();\r\n            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);\r\n            if (this.color) {\r\n                ctx.fill();\r\n            }\r\n            if (this.strokeColor) {\r\n                ctx.stroke();\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/PointerComponent.ts\n\r\n/**\r\n * Add this component to optionally configure how the pointer\r\n * system detects pointer events.\r\n *\r\n * By default the collider shape is used and graphics bounds is not.\r\n *\r\n * If both collider shape and graphics bounds are enabled it will fire events if either or\r\n * are intersecting the pointer.\r\n */\r\nclass PointerComponent extends Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'ex.pointer';\r\n        /**\r\n         * Use any existing Collider component geometry for pointer events. This is useful if you want\r\n         * user pointer events only to trigger on the same collision geometry used in the collider component\r\n         * for collision resolution. Default is `true`.\r\n         */\r\n        this.useColliderShape = true;\r\n        /**\r\n         * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned\r\n         * bounds around the graphic to trigger pointer events. Default is `false`.\r\n         */\r\n        this.useGraphicsBounds = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/EasingFunctions.ts\n\r\n/**\r\n * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\r\n * Given a time, the function will return a value from positive startValue to positive endValue.\r\n *\r\n * ```js\r\n * function Linear (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInQuad (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutQuad (t) {\r\n *    return t * (2 - t);\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutQuad (t) {\r\n *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInCubic (t) {\r\n *    return t * t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutCubic (t) {\r\n *    return (--t) * t * t + 1;\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutCubic (t) {\r\n *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n * }\r\n * ```\r\n */\r\nclass EasingFunctions {\r\n    static CreateReversibleEasingFunction(easing) {\r\n        return (time, start, end, duration) => {\r\n            if (end < start) {\r\n                return start - (easing(time, end, start, duration) - end);\r\n            }\r\n            else {\r\n                return easing(time, start, end, duration);\r\n            }\r\n        };\r\n    }\r\n    static CreateVectorEasingFunction(easing) {\r\n        return (time, start, end, duration) => {\r\n            return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));\r\n        };\r\n    }\r\n}\r\nEasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    return (endValue * currentTime) / duration + startValue;\r\n});\r\nEasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    currentTime /= duration;\r\n    return endValue * currentTime * currentTime + startValue;\r\n});\r\nEasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    currentTime /= duration;\r\n    return -endValue * currentTime * (currentTime - 2) + startValue;\r\n});\r\nEasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    currentTime /= duration / 2;\r\n    if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime + startValue;\r\n    }\r\n    currentTime--;\r\n    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\r\n});\r\nEasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    currentTime /= duration;\r\n    return endValue * currentTime * currentTime * currentTime + startValue;\r\n});\r\nEasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    currentTime /= duration;\r\n    currentTime--;\r\n    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\r\n});\r\nEasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {\r\n    endValue = endValue - startValue;\r\n    currentTime /= duration / 2;\r\n    if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;\r\n    }\r\n    currentTime -= 2;\r\n    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;\r\n});\r\n\n;// CONCATENATED MODULE: ./Actions/ActionQueue.ts\n/**\r\n * Action Queues represent an ordered sequence of actions\r\n *\r\n * Action queues are part of the [[ActionContext|Action API]] and\r\n * store the list of actions to be executed for an [[Actor]].\r\n *\r\n * Actors implement [[Actor.actions]] which can be manipulated by\r\n * advanced users to adjust the actions currently being executed in the\r\n * queue.\r\n */\r\nclass ActionQueue {\r\n    constructor(entity) {\r\n        this._actions = [];\r\n        this._completedActions = [];\r\n        this._entity = entity;\r\n    }\r\n    /**\r\n     * Add an action to the sequence\r\n     * @param action\r\n     */\r\n    add(action) {\r\n        this._actions.push(action);\r\n    }\r\n    /**\r\n     * Remove an action by reference from the sequence\r\n     * @param action\r\n     */\r\n    remove(action) {\r\n        const index = this._actions.indexOf(action);\r\n        this._actions.splice(index, 1);\r\n    }\r\n    /**\r\n     * Removes all actions from this sequence\r\n     */\r\n    clearActions() {\r\n        this._actions.length = 0;\r\n        this._completedActions.length = 0;\r\n        if (this._currentAction) {\r\n            this._currentAction.stop();\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @returns The total list of actions in this sequence complete or not\r\n     */\r\n    getActions() {\r\n        return this._actions.concat(this._completedActions);\r\n    }\r\n    /**\r\n     *\r\n     * @returns `true` if there are more actions to process in the sequence\r\n     */\r\n    hasNext() {\r\n        return this._actions.length > 0;\r\n    }\r\n    /**\r\n     * @returns `true` if the current sequence of actions is done\r\n     */\r\n    isComplete() {\r\n        return this._actions.length === 0;\r\n    }\r\n    /**\r\n     * Resets the sequence of actions, this is used to restart a sequence from the beginning\r\n     */\r\n    reset() {\r\n        this._actions = this.getActions();\r\n        const len = this._actions.length;\r\n        for (let i = 0; i < len; i++) {\r\n            this._actions[i].reset();\r\n        }\r\n        this._completedActions = [];\r\n    }\r\n    /**\r\n     * Update the queue which updates actions and handles completing actions\r\n     * @param elapsedMs\r\n     */\r\n    update(elapsedMs) {\r\n        if (this._actions.length > 0) {\r\n            this._currentAction = this._actions[0];\r\n            this._currentAction.update(elapsedMs);\r\n            if (this._currentAction.isComplete(this._entity)) {\r\n                this._completedActions.push(this._actions.shift());\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Repeat.ts\n\r\nclass Repeat {\r\n    constructor(entity, repeatBuilder, repeat) {\r\n        this._stopped = false;\r\n        this._repeatBuilder = repeatBuilder;\r\n        this._repeatContext = new ActionContext(entity);\r\n        this._actionQueue = this._repeatContext.getQueue();\r\n        this._repeat = repeat;\r\n        this._originalRepeat = repeat;\r\n        this._repeatBuilder(this._repeatContext);\r\n        this._repeat--; // current execution is the first repeat\r\n    }\r\n    update(delta) {\r\n        if (this._actionQueue.isComplete()) {\r\n            this._actionQueue.clearActions();\r\n            this._repeatBuilder(this._repeatContext);\r\n            this._repeat--;\r\n        }\r\n        this._actionQueue.update(delta);\r\n    }\r\n    isComplete() {\r\n        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());\r\n    }\r\n    stop() {\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._repeat = this._originalRepeat;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/RepeatForever.ts\n\r\n/**\r\n * RepeatForever Action implementation, it is recommended you use the fluent action\r\n * context API.\r\n *\r\n *\r\n */\r\nclass RepeatForever {\r\n    constructor(entity, repeatBuilder) {\r\n        this._stopped = false;\r\n        this._repeatBuilder = repeatBuilder;\r\n        this._repeatContext = new ActionContext(entity);\r\n        this._actionQueue = this._repeatContext.getQueue();\r\n        this._repeatBuilder(this._repeatContext);\r\n    }\r\n    update(delta) {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n        if (this._actionQueue.isComplete()) {\r\n            this._actionQueue.clearActions();\r\n            this._repeatBuilder(this._repeatContext);\r\n        }\r\n        this._actionQueue.update(delta);\r\n    }\r\n    isComplete() {\r\n        return this._stopped;\r\n    }\r\n    stop() {\r\n        this._stopped = true;\r\n        this._actionQueue.clearActions();\r\n    }\r\n    reset() {\r\n        return;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/MoveBy.ts\n\r\n\r\n\r\n\r\nclass MoveBy {\r\n    constructor(entity, offsetX, offsetY, speed) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._entity = entity;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._speed = speed;\r\n        this._offset = new Vector(offsetX, offsetY);\r\n        if (speed <= 0) {\r\n            Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);\r\n            throw new Error('Speed must be greater than 0 pixels per second');\r\n        }\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n            this._end = this._start.add(this._offset);\r\n            this._distance = this._offset.size;\r\n            this._dir = this._end.sub(this._start).normalize();\r\n        }\r\n        if (this.isComplete(this._entity)) {\r\n            this._tx.pos = vec(this._end.x, this._end.y);\r\n            this._motion.vel = vec(0, 0);\r\n        }\r\n        else {\r\n            this._motion.vel = this._dir.scale(this._speed);\r\n        }\r\n    }\r\n    isComplete(entity) {\r\n        const tx = entity.get(TransformComponent);\r\n        return this._stopped || tx.pos.distance(this._start) >= this._distance;\r\n    }\r\n    stop() {\r\n        this._motion.vel = vec(0, 0);\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/MoveTo.ts\n\r\n\r\n\r\nclass MoveTo {\r\n    constructor(entity, destx, desty, speed) {\r\n        this.entity = entity;\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._end = new Vector(destx, desty);\r\n        this._speed = speed;\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n            this._distance = this._start.distance(this._end);\r\n            this._dir = this._end.sub(this._start).normalize();\r\n        }\r\n        const m = this._dir.scale(this._speed);\r\n        this._motion.vel = vec(m.x, m.y);\r\n        if (this.isComplete(this.entity)) {\r\n            this._tx.pos = vec(this._end.x, this._end.y);\r\n            this._motion.vel = vec(0, 0);\r\n        }\r\n    }\r\n    isComplete(entity) {\r\n        const tx = entity.get(TransformComponent);\r\n        return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;\r\n    }\r\n    stop() {\r\n        this._motion.vel = vec(0, 0);\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/RotationType.ts\n/**\r\n * An enum that describes the strategies that rotation actions can use\r\n */\r\nvar RotationType;\r\n(function (RotationType) {\r\n    /**\r\n     * Rotation via `ShortestPath` will use the smallest angle\r\n     * between the starting and ending points. This strategy is the default behavior.\r\n     */\r\n    RotationType[RotationType[\"ShortestPath\"] = 0] = \"ShortestPath\";\r\n    /**\r\n     * Rotation via `LongestPath` will use the largest angle\r\n     * between the starting and ending points.\r\n     */\r\n    RotationType[RotationType[\"LongestPath\"] = 1] = \"LongestPath\";\r\n    /**\r\n     * Rotation via `Clockwise` will travel in a clockwise direction,\r\n     * regardless of the starting and ending points.\r\n     */\r\n    RotationType[RotationType[\"Clockwise\"] = 2] = \"Clockwise\";\r\n    /**\r\n     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n     * regardless of the starting and ending points.\r\n     */\r\n    RotationType[RotationType[\"CounterClockwise\"] = 3] = \"CounterClockwise\";\r\n})(RotationType || (RotationType = {}));\r\n\n;// CONCATENATED MODULE: ./Actions/Action/RotateTo.ts\n\r\n\r\n\r\n\r\nclass RotateTo {\r\n    constructor(entity, angleRadians, speed, rotationType) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._end = angleRadians;\r\n        this._speed = speed;\r\n        this._rotationType = rotationType || RotationType.ShortestPath;\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._start = this._tx.rotation;\r\n            this._currentNonCannonAngle = this._tx.rotation;\r\n            const distance1 = Math.abs(this._end - this._start);\r\n            const distance2 = TwoPI - distance1;\r\n            if (distance1 > distance2) {\r\n                this._shortDistance = distance2;\r\n                this._longDistance = distance1;\r\n            }\r\n            else {\r\n                this._shortDistance = distance1;\r\n                this._longDistance = distance2;\r\n            }\r\n            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n            switch (this._rotationType) {\r\n                case RotationType.ShortestPath:\r\n                    this._distance = this._shortDistance;\r\n                    if (this._shortestPathIsPositive) {\r\n                        this._direction = 1;\r\n                    }\r\n                    else {\r\n                        this._direction = -1;\r\n                    }\r\n                    break;\r\n                case RotationType.LongestPath:\r\n                    this._distance = this._longDistance;\r\n                    if (this._shortestPathIsPositive) {\r\n                        this._direction = -1;\r\n                    }\r\n                    else {\r\n                        this._direction = 1;\r\n                    }\r\n                    break;\r\n                case RotationType.Clockwise:\r\n                    this._direction = 1;\r\n                    if (this._shortestPathIsPositive) {\r\n                        this._distance = this._shortDistance;\r\n                    }\r\n                    else {\r\n                        this._distance = this._longDistance;\r\n                    }\r\n                    break;\r\n                case RotationType.CounterClockwise:\r\n                    this._direction = -1;\r\n                    if (!this._shortestPathIsPositive) {\r\n                        this._distance = this._shortDistance;\r\n                    }\r\n                    else {\r\n                        this._distance = this._longDistance;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        this._motion.angularVelocity = this._direction * this._speed;\r\n        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n        if (this.isComplete()) {\r\n            this._tx.rotation = this._end;\r\n            this._motion.angularVelocity = 0;\r\n            this._stopped = true;\r\n        }\r\n    }\r\n    isComplete() {\r\n        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\r\n        return this._stopped || distanceTraveled >= Math.abs(this._distance);\r\n    }\r\n    stop() {\r\n        this._motion.angularVelocity = 0;\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/RotateBy.ts\n\r\n\r\n\r\n\r\nclass RotateBy {\r\n    constructor(entity, angleRadiansOffset, speed, rotationType) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._speed = speed;\r\n        this._offset = angleRadiansOffset;\r\n        this._rotationType = rotationType || RotationType.ShortestPath;\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._start = this._tx.rotation;\r\n            this._currentNonCannonAngle = this._tx.rotation;\r\n            this._end = this._start + this._offset;\r\n            const distance1 = Math.abs(this._end - this._start);\r\n            const distance2 = TwoPI - distance1;\r\n            if (distance1 > distance2) {\r\n                this._shortDistance = distance2;\r\n                this._longDistance = distance1;\r\n            }\r\n            else {\r\n                this._shortDistance = distance1;\r\n                this._longDistance = distance2;\r\n            }\r\n            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n            switch (this._rotationType) {\r\n                case RotationType.ShortestPath:\r\n                    this._distance = this._shortDistance;\r\n                    if (this._shortestPathIsPositive) {\r\n                        this._direction = 1;\r\n                    }\r\n                    else {\r\n                        this._direction = -1;\r\n                    }\r\n                    break;\r\n                case RotationType.LongestPath:\r\n                    this._distance = this._longDistance;\r\n                    if (this._shortestPathIsPositive) {\r\n                        this._direction = -1;\r\n                    }\r\n                    else {\r\n                        this._direction = 1;\r\n                    }\r\n                    break;\r\n                case RotationType.Clockwise:\r\n                    this._direction = 1;\r\n                    if (this._shortDistance >= 0) {\r\n                        this._distance = this._shortDistance;\r\n                    }\r\n                    else {\r\n                        this._distance = this._longDistance;\r\n                    }\r\n                    break;\r\n                case RotationType.CounterClockwise:\r\n                    this._direction = -1;\r\n                    if (this._shortDistance <= 0) {\r\n                        this._distance = this._shortDistance;\r\n                    }\r\n                    else {\r\n                        this._distance = this._longDistance;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        this._motion.angularVelocity = this._direction * this._speed;\r\n        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n        if (this.isComplete()) {\r\n            this._tx.rotation = this._end;\r\n            this._motion.angularVelocity = 0;\r\n            this._stopped = true;\r\n        }\r\n    }\r\n    isComplete() {\r\n        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\r\n        return this._stopped || distanceTraveled >= Math.abs(this._distance);\r\n    }\r\n    stop() {\r\n        this._motion.angularVelocity = 0;\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._start = undefined;\r\n        this._currentNonCannonAngle = undefined;\r\n        this._distance = undefined;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/ScaleTo.ts\n\r\n\r\n\r\nclass ScaleTo {\r\n    constructor(entity, scaleX, scaleY, speedX, speedY) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._endX = scaleX;\r\n        this._endY = scaleY;\r\n        this._speedX = speedX;\r\n        this._speedY = speedY;\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._startX = this._tx.scale.x;\r\n            this._startY = this._tx.scale.y;\r\n            this._distanceX = Math.abs(this._endX - this._startX);\r\n            this._distanceY = Math.abs(this._endY - this._startY);\r\n        }\r\n        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {\r\n            const directionX = this._endY < this._startY ? -1 : 1;\r\n            this._motion.scaleFactor.x = this._speedX * directionX;\r\n        }\r\n        else {\r\n            this._motion.scaleFactor.x = 0;\r\n        }\r\n        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {\r\n            const directionY = this._endY < this._startY ? -1 : 1;\r\n            this._motion.scaleFactor.y = this._speedY * directionY;\r\n        }\r\n        else {\r\n            this._motion.scaleFactor.y = 0;\r\n        }\r\n        if (this.isComplete()) {\r\n            this._tx.scale = vec(this._endX, this._endY);\r\n            this._motion.scaleFactor.x = 0;\r\n            this._motion.scaleFactor.y = 0;\r\n        }\r\n    }\r\n    isComplete() {\r\n        return (this._stopped ||\r\n            (Math.abs(this._tx.scale.y - this._startX) >= (this._distanceX - 0.01) &&\r\n                Math.abs(this._tx.scale.y - this._startY) >= (this._distanceY - 0.01)));\r\n    }\r\n    stop() {\r\n        this._motion.scaleFactor.x = 0;\r\n        this._motion.scaleFactor.y = 0;\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/ScaleBy.ts\n\r\n\r\n\r\nclass ScaleBy {\r\n    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._offset = new Vector(scaleOffsetX, scaleOffsetY);\r\n        this._speedX = this._speedY = speed;\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._startScale = this._tx.scale.clone();\r\n            this._endScale = this._startScale.add(this._offset);\r\n            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);\r\n            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);\r\n            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;\r\n            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;\r\n        }\r\n        this._motion.scaleFactor.x = this._speedX * this._directionX;\r\n        this._motion.scaleFactor.y = this._speedY * this._directionY;\r\n        if (this.isComplete()) {\r\n            this._tx.scale = this._endScale;\r\n            this._motion.scaleFactor.x = 0;\r\n            this._motion.scaleFactor.y = 0;\r\n        }\r\n    }\r\n    isComplete() {\r\n        return (this._stopped ||\r\n            (Math.abs(this._tx.scale.x - this._startScale.x) >= (this._distanceX - 0.01) &&\r\n                Math.abs(this._tx.scale.y - this._startScale.y) >= (this._distanceY - 0.01)));\r\n    }\r\n    stop() {\r\n        this._motion.scaleFactor.x = 0;\r\n        this._motion.scaleFactor.y = 0;\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/CallMethod.ts\nclass CallMethod {\r\n    constructor(method) {\r\n        this._method = null;\r\n        this._hasBeenCalled = false;\r\n        this._method = method;\r\n    }\r\n    update(_delta) {\r\n        this._method();\r\n        this._hasBeenCalled = true;\r\n    }\r\n    isComplete() {\r\n        return this._hasBeenCalled;\r\n    }\r\n    reset() {\r\n        this._hasBeenCalled = false;\r\n    }\r\n    stop() {\r\n        this._hasBeenCalled = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/EaseTo.ts\n\r\n\r\n\r\nclass EaseTo {\r\n    constructor(entity, x, y, duration, easingFcn) {\r\n        this.easingFcn = easingFcn;\r\n        this._currentLerpTime = 0;\r\n        this._lerpDuration = 1 * 1000; // 1 second\r\n        this._lerpStart = new Vector(0, 0);\r\n        this._lerpEnd = new Vector(0, 0);\r\n        this._initialized = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._lerpDuration = duration;\r\n        this._lerpEnd = new Vector(x, y);\r\n    }\r\n    _initialize() {\r\n        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n        this._currentLerpTime = 0;\r\n    }\r\n    update(delta) {\r\n        if (!this._initialized) {\r\n            this._initialize();\r\n            this._initialized = true;\r\n        }\r\n        // Need to update lerp time first, otherwise the first update will always be zero\r\n        this._currentLerpTime += delta;\r\n        let newX = this._tx.pos.x;\r\n        let newY = this._tx.pos.y;\r\n        if (this._currentLerpTime < this._lerpDuration) {\r\n            if (this._lerpEnd.x < this._lerpStart.x) {\r\n                newX =\r\n                    this._lerpStart.x -\r\n                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n            }\r\n            else {\r\n                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n            }\r\n            if (this._lerpEnd.y < this._lerpStart.y) {\r\n                newY =\r\n                    this._lerpStart.y -\r\n                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n            }\r\n            else {\r\n                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n            }\r\n            // Given the lerp position figure out the velocity in pixels per second\r\n            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n        }\r\n        else {\r\n            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n            this._motion.vel = Vector.Zero;\r\n        }\r\n    }\r\n    isComplete() {\r\n        return this._stopped || this._currentLerpTime >= this._lerpDuration;\r\n    }\r\n    reset() {\r\n        this._initialized = false;\r\n        this._stopped = false;\r\n        this._currentLerpTime = 0;\r\n    }\r\n    stop() {\r\n        this._motion.vel = vec(0, 0);\r\n        this._stopped = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/EaseBy.ts\n\r\n\r\n\r\nclass EaseBy {\r\n    constructor(entity, offsetX, offsetY, duration, easingFcn) {\r\n        this.easingFcn = easingFcn;\r\n        this._currentLerpTime = 0;\r\n        this._lerpDuration = 1 * 1000; // 1 second\r\n        this._lerpStart = new Vector(0, 0);\r\n        this._lerpEnd = new Vector(0, 0);\r\n        this._initialized = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._lerpDuration = duration;\r\n        this._offset = new Vector(offsetX, offsetY);\r\n    }\r\n    _initialize() {\r\n        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n        this._currentLerpTime = 0;\r\n        this._lerpEnd = this._lerpStart.add(this._offset);\r\n    }\r\n    update(delta) {\r\n        if (!this._initialized) {\r\n            this._initialize();\r\n            this._initialized = true;\r\n        }\r\n        // Need to update lerp time first, otherwise the first update will always be zero\r\n        this._currentLerpTime += delta;\r\n        let newX = this._tx.pos.x;\r\n        let newY = this._tx.pos.y;\r\n        if (this._currentLerpTime < this._lerpDuration) {\r\n            if (this._lerpEnd.x < this._lerpStart.x) {\r\n                newX =\r\n                    this._lerpStart.x -\r\n                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n            }\r\n            else {\r\n                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n            }\r\n            if (this._lerpEnd.y < this._lerpStart.y) {\r\n                newY =\r\n                    this._lerpStart.y -\r\n                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n            }\r\n            else {\r\n                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n            }\r\n            // Given the lerp position figure out the velocity in pixels per second\r\n            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n        }\r\n        else {\r\n            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n            this._motion.vel = Vector.Zero;\r\n        }\r\n    }\r\n    isComplete() {\r\n        return this._stopped || this._currentLerpTime >= this._lerpDuration;\r\n    }\r\n    reset() {\r\n        this._initialized = false;\r\n        this._stopped = false;\r\n        this._currentLerpTime = 0;\r\n    }\r\n    stop() {\r\n        this._motion.vel = vec(0, 0);\r\n        this._stopped = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Blink.ts\n\r\nclass Blink {\r\n    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {\r\n        this._timeVisible = 0;\r\n        this._timeNotVisible = 0;\r\n        this._elapsedTime = 0;\r\n        this._totalTime = 0;\r\n        this._stopped = false;\r\n        this._started = false;\r\n        this._graphics = entity.get(GraphicsComponent);\r\n        this._timeVisible = timeVisible;\r\n        this._timeNotVisible = timeNotVisible;\r\n        this._duration = (timeVisible + timeNotVisible) * numBlinks;\r\n    }\r\n    update(delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._elapsedTime = 0;\r\n            this._totalTime = 0;\r\n        }\r\n        if (!this._graphics) {\r\n            return;\r\n        }\r\n        this._elapsedTime += delta;\r\n        this._totalTime += delta;\r\n        if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {\r\n            this._graphics.visible = false;\r\n            this._elapsedTime = 0;\r\n        }\r\n        if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {\r\n            this._graphics.visible = true;\r\n            this._elapsedTime = 0;\r\n        }\r\n        if (this.isComplete()) {\r\n            this._graphics.visible = true;\r\n        }\r\n    }\r\n    isComplete() {\r\n        return this._stopped || this._totalTime >= this._duration;\r\n    }\r\n    stop() {\r\n        if (this._graphics) {\r\n            this._graphics.visible = true;\r\n        }\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._elapsedTime = 0;\r\n        this._totalTime = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Fade.ts\n\r\n\r\nclass Fade {\r\n    constructor(entity, endOpacity, speed) {\r\n        this._multiplier = 1;\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._graphics = entity.get(GraphicsComponent);\r\n        this._endOpacity = endOpacity;\r\n        this._speed = this._ogspeed = speed;\r\n    }\r\n    update(delta) {\r\n        if (!this._graphics) {\r\n            return;\r\n        }\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._speed = this._ogspeed;\r\n            // determine direction when we start\r\n            if (this._endOpacity < this._graphics.opacity) {\r\n                this._multiplier = -1;\r\n            }\r\n            else {\r\n                this._multiplier = 1;\r\n            }\r\n        }\r\n        if (this._speed > 0) {\r\n            this._graphics.opacity += (this._multiplier *\r\n                (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;\r\n        }\r\n        this._speed -= delta;\r\n        if (this.isComplete()) {\r\n            this._graphics.opacity = this._endOpacity;\r\n        }\r\n        Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);\r\n    }\r\n    isComplete() {\r\n        return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;\r\n    }\r\n    stop() {\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Delay.ts\nclass Delay {\r\n    constructor(delay) {\r\n        this._elapsedTime = 0;\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._delay = delay;\r\n    }\r\n    update(delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n        }\r\n        this._elapsedTime += delta;\r\n    }\r\n    isComplete() {\r\n        return this._stopped || this._elapsedTime >= this._delay;\r\n    }\r\n    stop() {\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._elapsedTime = 0;\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Die.ts\n\r\nclass Die {\r\n    constructor(entity) {\r\n        this._stopped = false;\r\n        this._entity = entity;\r\n    }\r\n    update(_delta) {\r\n        this._entity.get(ActionsComponent).clearActions();\r\n        this._entity.kill();\r\n        this._stopped = true;\r\n    }\r\n    isComplete() {\r\n        return this._stopped;\r\n    }\r\n    stop() {\r\n        return;\r\n    }\r\n    reset() {\r\n        return;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Follow.ts\n\r\n\r\n\r\nclass Follow {\r\n    constructor(entity, entityToFollow, followDistance) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._tx = entity.get(TransformComponent);\r\n        this._motion = entity.get(MotionComponent);\r\n        this._followTx = entityToFollow.get(TransformComponent);\r\n        this._followMotion = entityToFollow.get(MotionComponent);\r\n        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n        this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);\r\n        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);\r\n        this._speed = 0;\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._distanceBetween = this._current.distance(this._end);\r\n            this._dir = this._end.sub(this._current).normalize();\r\n        }\r\n        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));\r\n        if (actorToFollowSpeed !== 0) {\r\n            this._speed = actorToFollowSpeed;\r\n        }\r\n        this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n        this._end = vec(this._followTx.pos.x, this._followTx.pos.y);\r\n        this._distanceBetween = this._current.distance(this._end);\r\n        this._dir = this._end.sub(this._current).normalize();\r\n        if (this._distanceBetween >= this._maximumDistance) {\r\n            const m = this._dir.scale(this._speed);\r\n            this._motion.vel = vec(m.x, m.y);\r\n        }\r\n        else {\r\n            this._motion.vel = vec(0, 0);\r\n        }\r\n        if (this.isComplete()) {\r\n            this._tx.pos = vec(this._end.x, this._end.y);\r\n            this._motion.vel = vec(0, 0);\r\n        }\r\n    }\r\n    stop() {\r\n        this._motion.vel = vec(0, 0);\r\n        this._stopped = true;\r\n    }\r\n    isComplete() {\r\n        // the actor following should never stop unless specified to do so\r\n        return this._stopped;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/Meet.ts\n\r\n\r\n\r\nclass Meet {\r\n    constructor(actor, actorToMeet, speed) {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._speedWasSpecified = false;\r\n        this._tx = actor.get(TransformComponent);\r\n        this._motion = actor.get(MotionComponent);\r\n        this._meetTx = actorToMeet.get(TransformComponent);\r\n        this._meetMotion = actorToMeet.get(MotionComponent);\r\n        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n        this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);\r\n        this._speed = speed || 0;\r\n        if (speed !== undefined) {\r\n            this._speedWasSpecified = true;\r\n        }\r\n    }\r\n    update(_delta) {\r\n        if (!this._started) {\r\n            this._started = true;\r\n            this._distanceBetween = this._current.distance(this._end);\r\n            this._dir = this._end.sub(this._current).normalize();\r\n        }\r\n        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));\r\n        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {\r\n            this._speed = actorToMeetSpeed;\r\n        }\r\n        this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n        this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);\r\n        this._distanceBetween = this._current.distance(this._end);\r\n        this._dir = this._end.sub(this._current).normalize();\r\n        const m = this._dir.scale(this._speed);\r\n        this._motion.vel = vec(m.x, m.y);\r\n        if (this.isComplete()) {\r\n            this._tx.pos = vec(this._end.x, this._end.y);\r\n            this._motion.vel = vec(0, 0);\r\n        }\r\n    }\r\n    isComplete() {\r\n        return this._stopped || this._distanceBetween <= 1;\r\n    }\r\n    stop() {\r\n        this._motion.vel = vec(0, 0);\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._started = false;\r\n        this._stopped = false;\r\n        this._distanceBetween = undefined;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/ActionContext.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The fluent Action API allows you to perform \"actions\" on\r\n * [[Actor|Actors]] such as following, moving, rotating, and\r\n * more. You can implement your own actions by implementing\r\n * the [[Action]] interface.\r\n */\r\nclass ActionContext {\r\n    constructor(entity) {\r\n        this._entity = entity;\r\n        this._queue = new ActionQueue(entity);\r\n    }\r\n    getQueue() {\r\n        return this._queue;\r\n    }\r\n    update(elapsedMs) {\r\n        this._queue.update(elapsedMs);\r\n    }\r\n    /**\r\n     * Clears all queued actions from the Actor\r\n     */\r\n    clearActions() {\r\n        this._queue.clearActions();\r\n    }\r\n    runAction(action) {\r\n        action.reset();\r\n        this._queue.add(action);\r\n        return this;\r\n    }\r\n    easeTo(...args) {\r\n        var _a, _b;\r\n        let x = 0;\r\n        let y = 0;\r\n        let duration = 0;\r\n        let easingFcn = EasingFunctions.Linear;\r\n        if (args[0] instanceof Vector) {\r\n            x = args[0].x;\r\n            y = args[0].y;\r\n            duration = args[1];\r\n            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;\r\n        }\r\n        else {\r\n            x = args[0];\r\n            y = args[1];\r\n            duration = args[2];\r\n            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;\r\n        }\r\n        this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));\r\n        return this;\r\n    }\r\n    easeBy(...args) {\r\n        var _a, _b;\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n        let duration = 0;\r\n        let easingFcn = EasingFunctions.Linear;\r\n        if (args[0] instanceof Vector) {\r\n            offsetX = args[0].x;\r\n            offsetY = args[0].y;\r\n            duration = args[1];\r\n            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;\r\n        }\r\n        else {\r\n            offsetX = args[0];\r\n            offsetY = args[1];\r\n            duration = args[2];\r\n            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;\r\n        }\r\n        this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));\r\n        return this;\r\n    }\r\n    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {\r\n        let x = 0;\r\n        let y = 0;\r\n        let speed = 0;\r\n        if (xOrPos instanceof Vector) {\r\n            x = xOrPos.x;\r\n            y = xOrPos.y;\r\n            speed = yOrSpeed;\r\n        }\r\n        else {\r\n            x = xOrPos;\r\n            y = yOrSpeed;\r\n            speed = speedOrUndefined;\r\n        }\r\n        this._queue.add(new MoveTo(this._entity, x, y, speed));\r\n        return this;\r\n    }\r\n    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {\r\n        let xOffset = 0;\r\n        let yOffset = 0;\r\n        let speed = 0;\r\n        if (xOffsetOrVector instanceof Vector) {\r\n            xOffset = xOffsetOrVector.x;\r\n            yOffset = xOffsetOrVector.y;\r\n            speed = yOffsetOrSpeed;\r\n        }\r\n        else {\r\n            xOffset = xOffsetOrVector;\r\n            yOffset = yOffsetOrSpeed;\r\n            speed = speedOrUndefined;\r\n        }\r\n        this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will rotate an actor to the specified angle at the speed\r\n     * specified (in radians per second) and return back the actor. This\r\n     * method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadians  The angle to rotate to in radians\r\n     * @param speed         The angular velocity of the rotation specified in radians per second\r\n     * @param rotationType  The [[RotationType]] to use for this rotation\r\n     */\r\n    rotateTo(angleRadians, speed, rotationType) {\r\n        this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n     * in radians/sec and return back the actor. This method is part\r\n     * of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n     * @param speed          The speed in radians/sec the actor should rotate at\r\n     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n     */\r\n    rotateBy(angleRadiansOffset, speed, rotationType) {\r\n        this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));\r\n        return this;\r\n    }\r\n    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {\r\n        let sizeX = 1;\r\n        let sizeY = 1;\r\n        let speedX = 0;\r\n        let speedY = 0;\r\n        if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {\r\n            sizeX = sizeXOrVector.x;\r\n            sizeY = sizeXOrVector.y;\r\n            speedX = sizeYOrSpeed.x;\r\n            speedY = sizeYOrSpeed.y;\r\n        }\r\n        if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {\r\n            sizeX = sizeXOrVector;\r\n            sizeY = sizeYOrSpeed;\r\n            speedX = speedXOrUndefined;\r\n            speedY = speedYOrUndefined;\r\n        }\r\n        this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));\r\n        return this;\r\n    }\r\n    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {\r\n        let sizeOffsetX = 1;\r\n        let sizeOffsetY = 1;\r\n        if (sizeOffsetXOrVector instanceof Vector) {\r\n            sizeOffsetX = sizeOffsetXOrVector.x;\r\n            sizeOffsetY = sizeOffsetXOrVector.y;\r\n            speed = sizeOffsetYOrSpeed;\r\n        }\r\n        if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {\r\n            sizeOffsetX = sizeOffsetXOrVector;\r\n            sizeOffsetY = sizeOffsetYOrSpeed;\r\n        }\r\n        this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will cause an actor to blink (become visible and not\r\n     * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n     * the actor should be visible per blink, and the amount of time not visible.\r\n     * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n     * @param numBlinks       The number of times to blink\r\n     */\r\n    blink(timeVisible, timeNotVisible, numBlinks = 1) {\r\n        this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will cause an actor's opacity to change from its current value\r\n     * to the provided value by a specified time (in milliseconds). This method is\r\n     * part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param opacity  The ending opacity\r\n     * @param time     The time it should take to fade the actor (in milliseconds)\r\n     */\r\n    fade(opacity, time) {\r\n        this._queue.add(new Fade(this._entity, opacity, time));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will delay the next action from executing for a certain\r\n     * amount of time (in milliseconds). This method is part of the actor\r\n     * 'Action' fluent API allowing action chaining.\r\n     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n     */\r\n    delay(time) {\r\n        this._queue.add(new Delay(time));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will add an action to the queue that will remove the actor from the\r\n     * scene once it has completed its previous  Any actions on the\r\n     * action queue after this action will not be executed.\r\n     */\r\n    die() {\r\n        this._queue.add(new Die(this._entity));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method allows you to call an arbitrary method as the next action in the\r\n     * action queue. This is useful if you want to execute code in after a specific\r\n     * action, i.e An actor arrives at a destination after traversing a path\r\n     */\r\n    callMethod(method) {\r\n        this._queue.add(new CallMethod(method));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n     * will repeat forever\r\n     */\r\n    repeat(repeatBuilder, times) {\r\n        if (!times) {\r\n            this.repeatForever(repeatBuilder);\r\n            return this;\r\n        }\r\n        this._queue.add(new Repeat(this._entity, repeatBuilder, times));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     */\r\n    repeatForever(repeatBuilder) {\r\n        this._queue.add(new RepeatForever(this._entity, repeatBuilder));\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will cause the entity to follow another at a specified distance\r\n     * @param entity           The entity to follow\r\n     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n     */\r\n    follow(entity, followDistance) {\r\n        if (followDistance === undefined) {\r\n            this._queue.add(new Follow(this._entity, entity));\r\n        }\r\n        else {\r\n            this._queue.add(new Follow(this._entity, entity, followDistance));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * This method will cause the entity to move towards another until they\r\n     * collide \"meet\" at a specified speed.\r\n     * @param entity  The entity to meet\r\n     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n     */\r\n    meet(entity, speed) {\r\n        if (speed === undefined) {\r\n            this._queue.add(new Meet(this._entity, entity));\r\n        }\r\n        else {\r\n            this._queue.add(new Meet(this._entity, entity, speed));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a promise that resolves when the current action queue up to now\r\n     * is finished.\r\n     */\r\n    toPromise() {\r\n        const temp = new Promise((resolve) => {\r\n            this._queue.add(new CallMethod(() => {\r\n                resolve();\r\n            }));\r\n        });\r\n        return temp;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/ActionsComponent.ts\n\r\n\r\n\r\n\r\n;\r\nclass ActionsComponent extends Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'ex.actions';\r\n        this.dependencies = [TransformComponent, MotionComponent];\r\n    }\r\n    onAdd(entity) {\r\n        this._ctx = new ActionContext(entity);\r\n    }\r\n    onRemove() {\r\n        this._ctx = null;\r\n    }\r\n    /**\r\n     * Returns the internal action queue\r\n     * @returns action queue\r\n     */\r\n    getQueue() {\r\n        var _a;\r\n        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();\r\n    }\r\n    runAction(action) {\r\n        var _a;\r\n        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.runAction(action);\r\n    }\r\n    /**\r\n     * Updates the internal action context, performing action and moving through the internal queue\r\n     * @param elapsedMs\r\n     */\r\n    update(elapsedMs) {\r\n        var _a;\r\n        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);\r\n    }\r\n    /**\r\n     * Clears all queued actions from the Actor\r\n     */\r\n    clearActions() {\r\n        var _a;\r\n        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();\r\n    }\r\n    easeTo(...args) {\r\n        return this._ctx.easeTo.apply(this._ctx, args);\r\n    }\r\n    easeBy(...args) {\r\n        return this._ctx.easeBy.apply(this._ctx, args);\r\n    }\r\n    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {\r\n        return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);\r\n    }\r\n    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {\r\n        return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);\r\n    }\r\n    /**\r\n     * This method will rotate an actor to the specified angle at the speed\r\n     * specified (in radians per second) and return back the actor. This\r\n     * method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadians  The angle to rotate to in radians\r\n     * @param speed         The angular velocity of the rotation specified in radians per second\r\n     * @param rotationType  The [[RotationType]] to use for this rotation\r\n     */\r\n    rotateTo(angleRadians, speed, rotationType) {\r\n        return this._ctx.rotateTo(angleRadians, speed, rotationType);\r\n    }\r\n    /**\r\n     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n     * in radians/sec and return back the actor. This method is part\r\n     * of the actor 'Action' fluent API allowing action chaining.\r\n     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n     * @param speed          The speed in radians/sec the actor should rotate at\r\n     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n     */\r\n    rotateBy(angleRadiansOffset, speed, rotationType) {\r\n        return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);\r\n    }\r\n    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {\r\n        return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);\r\n    }\r\n    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {\r\n        return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);\r\n    }\r\n    /**\r\n     * This method will cause an actor to blink (become visible and not\r\n     * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n     * the actor should be visible per blink, and the amount of time not visible.\r\n     * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n     * @param numBlinks       The number of times to blink\r\n     */\r\n    blink(timeVisible, timeNotVisible, numBlinks) {\r\n        return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);\r\n    }\r\n    /**\r\n     * This method will cause an actor's opacity to change from its current value\r\n     * to the provided value by a specified time (in milliseconds). This method is\r\n     * part of the actor 'Action' fluent API allowing action chaining.\r\n     * @param opacity  The ending opacity\r\n     * @param time     The time it should take to fade the actor (in milliseconds)\r\n     */\r\n    fade(opacity, time) {\r\n        return this._ctx.fade(opacity, time);\r\n    }\r\n    /**\r\n     * This method will delay the next action from executing for a certain\r\n     * amount of time (in milliseconds). This method is part of the actor\r\n     * 'Action' fluent API allowing action chaining.\r\n     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n     */\r\n    delay(time) {\r\n        return this._ctx.delay(time);\r\n    }\r\n    /**\r\n     * This method will add an action to the queue that will remove the actor from the\r\n     * scene once it has completed its previous  Any actions on the\r\n     * action queue after this action will not be executed.\r\n     */\r\n    die() {\r\n        return this._ctx.die();\r\n    }\r\n    /**\r\n     * This method allows you to call an arbitrary method as the next action in the\r\n     * action queue. This is useful if you want to execute code in after a specific\r\n     * action, i.e An actor arrives at a destination after traversing a path\r\n     */\r\n    callMethod(method) {\r\n        return this._ctx.callMethod(method);\r\n    }\r\n    /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n     * will repeat forever\r\n     */\r\n    repeat(repeatBuilder, times) {\r\n        return this._ctx.repeat(repeatBuilder, times);\r\n    }\r\n    /**\r\n     * This method will cause the actor to repeat all of the actions built in\r\n     * the `repeatBuilder` callback. If the number of repeats\r\n     * is not specified it will repeat forever. This method is part of\r\n     * the actor 'Action' fluent API allowing action chaining\r\n     *\r\n     * ```typescript\r\n     * // Move up in a zig-zag by repeated moveBy's\r\n     * actor.actions.repeat(repeatCtx => {\r\n     *  repeatCtx.moveBy(10, 0, 10);\r\n     *  repeatCtx.moveBy(0, 10, 10);\r\n     * }, 5);\r\n     * ```\r\n     *\r\n     * @param repeatBuilder The builder to specify the repeatable list of actions\r\n     */\r\n    repeatForever(repeatBuilder) {\r\n        return this._ctx.repeatForever(repeatBuilder);\r\n    }\r\n    /**\r\n     * This method will cause the entity to follow another at a specified distance\r\n     * @param entity           The entity to follow\r\n     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n     */\r\n    follow(entity, followDistance) {\r\n        return this._ctx.follow(entity, followDistance);\r\n    }\r\n    /**\r\n     * This method will cause the entity to move towards another until they\r\n     * collide \"meet\" at a specified speed.\r\n     * @param entity  The entity to meet\r\n     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n     */\r\n    meet(entity, speed) {\r\n        return this._ctx.meet(entity, speed);\r\n    }\r\n    /**\r\n     * Returns a promise that resolves when the current action queue up to now\r\n     * is finished.\r\n     */\r\n    toPromise() {\r\n        return this._ctx.toPromise();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/FontCommon.ts\n/**\r\n * Enum representing the different font size units\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\r\n */\r\nvar FontUnit;\r\n(function (FontUnit) {\r\n    /**\r\n     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\r\n     */\r\n    FontUnit[\"Em\"] = \"em\";\r\n    /**\r\n     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element\r\n     */\r\n    FontUnit[\"Rem\"] = \"rem\";\r\n    /**\r\n     * Pixel is a unit of length in screen pixels\r\n     */\r\n    FontUnit[\"Px\"] = \"px\";\r\n    /**\r\n     * Point is a physical unit length (1/72 of an inch)\r\n     */\r\n    FontUnit[\"Pt\"] = \"pt\";\r\n    /**\r\n     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\r\n     */\r\n    FontUnit[\"Percent\"] = \"%\";\r\n})(FontUnit || (FontUnit = {}));\r\n/**\r\n * Enum representing the different horizontal text alignments\r\n */\r\nvar TextAlign;\r\n(function (TextAlign) {\r\n    /**\r\n     * The text is left-aligned.\r\n     */\r\n    TextAlign[\"Left\"] = \"left\";\r\n    /**\r\n     * The text is right-aligned.\r\n     */\r\n    TextAlign[\"Right\"] = \"right\";\r\n    /**\r\n     * The text is centered.\r\n     */\r\n    TextAlign[\"Center\"] = \"center\";\r\n    /**\r\n     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\r\n     * right-aligned for right-to-left locales).\r\n     */\r\n    TextAlign[\"Start\"] = \"start\";\r\n    /**\r\n     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\r\n     * left-aligned for right-to-left locales).\r\n     */\r\n    TextAlign[\"End\"] = \"end\";\r\n})(TextAlign || (TextAlign = {}));\r\n/**\r\n * Enum representing the different baseline text alignments\r\n */\r\nvar BaseAlign;\r\n(function (BaseAlign) {\r\n    /**\r\n     * The text baseline is the top of the em square.\r\n     */\r\n    BaseAlign[\"Top\"] = \"top\";\r\n    /**\r\n     * The text baseline is the hanging baseline.  Currently unsupported; this will act like\r\n     * alphabetic.\r\n     */\r\n    BaseAlign[\"Hanging\"] = \"hanging\";\r\n    /**\r\n     * The text baseline is the middle of the em square.\r\n     */\r\n    BaseAlign[\"Middle\"] = \"middle\";\r\n    /**\r\n     * The text baseline is the normal alphabetic baseline.\r\n     */\r\n    BaseAlign[\"Alphabetic\"] = \"alphabetic\";\r\n    /**\r\n     * The text baseline is the ideographic baseline; this is the bottom of\r\n     * the body of the characters, if the main body of characters protrudes\r\n     * beneath the alphabetic baseline.  Currently unsupported; this will\r\n     * act like alphabetic.\r\n     */\r\n    BaseAlign[\"Ideographic\"] = \"ideographic\";\r\n    /**\r\n     * The text baseline is the bottom of the bounding box.  This differs\r\n     * from the ideographic baseline in that the ideographic baseline\r\n     * doesn't consider descenders.\r\n     */\r\n    BaseAlign[\"Bottom\"] = \"bottom\";\r\n})(BaseAlign || (BaseAlign = {}));\r\n/**\r\n * Enum representing the different possible font styles\r\n */\r\nvar FontStyle;\r\n(function (FontStyle) {\r\n    FontStyle[\"Normal\"] = \"normal\";\r\n    FontStyle[\"Italic\"] = \"italic\";\r\n    FontStyle[\"Oblique\"] = \"oblique\";\r\n})(FontStyle || (FontStyle = {}));\r\n/**\r\n * Enum representing the text direction, useful for other languages, or writing text in reverse\r\n */\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[\"LeftToRight\"] = \"ltr\";\r\n    Direction[\"RightToLeft\"] = \"rtl\";\r\n})(Direction || (Direction = {}));\r\n\n;// CONCATENATED MODULE: ./Graphics/Font.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Represents a system or web font in Excalibur\r\n *\r\n * If no options specified, the system sans-serif 10 pixel is used\r\n *\r\n * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/\r\n */\r\nclass Font extends Graphic {\r\n    constructor(options = {}) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\r\n        super(options); // <- Graphics properties\r\n        /**\r\n         * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing\r\n         *\r\n         * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]\r\n         */\r\n        this.filtering = ImageFiltering.Blended;\r\n        /**\r\n         * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.\r\n         * If quality is set to 1, then just enough raster bitmap is generated to render the text.\r\n         *\r\n         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.\r\n         *\r\n         * (Default 2)\r\n         */\r\n        this.quality = 2;\r\n        // Raster properties for fonts\r\n        this.padding = 2;\r\n        this.smoothing = false;\r\n        this.lineWidth = 1;\r\n        this.lineDash = [];\r\n        this.color = Color.Black;\r\n        this.family = 'sans-serif';\r\n        this.style = FontStyle.Normal;\r\n        this.bold = false;\r\n        this.unit = FontUnit.Px;\r\n        this.textAlign = TextAlign.Left;\r\n        this.baseAlign = BaseAlign.Alphabetic;\r\n        this.direction = Direction.LeftToRight;\r\n        this.size = 10;\r\n        this.shadow = null;\r\n        this._textBounds = new BoundingBox();\r\n        this._cachedTextMeasurement = new Map();\r\n        this._bitmapToTextMeasurement = new Map();\r\n        this._textToBitmap = new Map();\r\n        this._bitmapUsage = new Map();\r\n        this._textFragments = [];\r\n        // Raster properties\r\n        this.smoothing = (_a = options === null || options === void 0 ? void 0 : options.smoothing) !== null && _a !== void 0 ? _a : this.smoothing;\r\n        this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : this.padding;\r\n        this.color = (_c = options === null || options === void 0 ? void 0 : options.color) !== null && _c !== void 0 ? _c : this.color;\r\n        this.strokeColor = (_d = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _d !== void 0 ? _d : this.strokeColor;\r\n        this.lineDash = (_e = options === null || options === void 0 ? void 0 : options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;\r\n        this.lineWidth = (_f = options === null || options === void 0 ? void 0 : options.lineWidth) !== null && _f !== void 0 ? _f : this.lineWidth;\r\n        this.filtering = (_g = options === null || options === void 0 ? void 0 : options.filtering) !== null && _g !== void 0 ? _g : this.filtering;\r\n        // Font specific properties\r\n        this.family = (_h = options === null || options === void 0 ? void 0 : options.family) !== null && _h !== void 0 ? _h : this.family;\r\n        this.style = (_j = options === null || options === void 0 ? void 0 : options.style) !== null && _j !== void 0 ? _j : this.style;\r\n        this.bold = (_k = options === null || options === void 0 ? void 0 : options.bold) !== null && _k !== void 0 ? _k : this.bold;\r\n        this.size = (_l = options === null || options === void 0 ? void 0 : options.size) !== null && _l !== void 0 ? _l : this.size;\r\n        this.unit = (_m = options === null || options === void 0 ? void 0 : options.unit) !== null && _m !== void 0 ? _m : this.unit;\r\n        this.textAlign = (_o = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _o !== void 0 ? _o : this.textAlign;\r\n        this.baseAlign = (_p = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _p !== void 0 ? _p : this.baseAlign;\r\n        this.direction = (_q = options === null || options === void 0 ? void 0 : options.direction) !== null && _q !== void 0 ? _q : this.direction;\r\n        this.quality = (_r = options === null || options === void 0 ? void 0 : options.quality) !== null && _r !== void 0 ? _r : this.quality;\r\n        if (options === null || options === void 0 ? void 0 : options.shadow) {\r\n            this.shadow = {};\r\n            this.shadow.blur = (_s = options.shadow.blur) !== null && _s !== void 0 ? _s : this.shadow.blur;\r\n            this.shadow.offset = (_t = options.shadow.offset) !== null && _t !== void 0 ? _t : this.shadow.offset;\r\n            this.shadow.color = (_u = options.shadow.color) !== null && _u !== void 0 ? _u : this.shadow.color;\r\n        }\r\n    }\r\n    clone() {\r\n        return new Font({\r\n            ...this.cloneGraphicOptions(),\r\n            size: this.size,\r\n            unit: this.unit,\r\n            family: this.family,\r\n            style: this.style,\r\n            bold: this.bold,\r\n            textAlign: this.textAlign,\r\n            baseAlign: this.baseAlign,\r\n            direction: this.direction,\r\n            shadow: this.shadow\r\n                ? {\r\n                    blur: this.shadow.blur,\r\n                    offset: this.shadow.offset,\r\n                    color: this.shadow.color\r\n                }\r\n                : null\r\n        });\r\n    }\r\n    get fontString() {\r\n        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;\r\n    }\r\n    get localBounds() {\r\n        return this._textBounds;\r\n    }\r\n    _drawImage(_ex, _x, _y) {\r\n        // TODO weird vestigial drawimage\r\n    }\r\n    _rotate(ex) {\r\n        var _a;\r\n        // TODO this needs to change depending on the bounding box...\r\n        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;\r\n        ex.translate(origin.x, origin.y);\r\n        ex.rotate(this.rotation);\r\n        ex.translate(-origin.x, -origin.y);\r\n    }\r\n    _flip(ex) {\r\n        if (this.flipHorizontal) {\r\n            ex.translate(this._textBounds.width / this.scale.x, 0);\r\n            ex.scale(-1, 1);\r\n        }\r\n        if (this.flipVertical) {\r\n            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);\r\n            ex.scale(1, -1);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a BoundingBox that is the total size of the text including multiple lines\r\n     *\r\n     * Does not include any padding or adjustment\r\n     * @param text\r\n     * @returns BoundingBox\r\n     */\r\n    measureText(text) {\r\n        let measurementDirty = false;\r\n        let cached = this._cachedTextMeasurement.get(text);\r\n        if (!cached) {\r\n            measurementDirty = true;\r\n        }\r\n        const rasterProps = this._getRasterPropertiesHash();\r\n        if (!cached || rasterProps !== cached.rasterProps) {\r\n            measurementDirty = true;\r\n        }\r\n        if (measurementDirty) {\r\n            const lines = text.split('\\n');\r\n            const maxWidthLine = lines.reduce((a, b) => {\r\n                return a.length > b.length ? a : b;\r\n            });\r\n            const ctx = this._getTextBitmap(text);\r\n            this._applyFont(ctx); // font must be applied to the context to measure it\r\n            const metrics = ctx.measureText(maxWidthLine);\r\n            let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);\r\n            // TODO lineheight makes the text bounds wonky\r\n            const lineAdjustedHeight = textHeight * lines.length;\r\n            textHeight = lineAdjustedHeight;\r\n            const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);\r\n            const x = 0;\r\n            const y = 0;\r\n            // this._cachedText = text;\r\n            // this._cachedRasterProps = rasterProps;\r\n            // this._measurementDirty = false;\r\n            const measurement = new BoundingBox({\r\n                left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,\r\n                top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,\r\n                bottom: y + bottomBounds + this.padding,\r\n                right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding\r\n            });\r\n            cached = {\r\n                text,\r\n                rasterProps,\r\n                measurement\r\n            };\r\n            this._cachedTextMeasurement.set(text, cached);\r\n            this._bitmapToTextMeasurement.set(ctx, cached);\r\n            return cached.measurement;\r\n        }\r\n        else {\r\n            return cached.measurement;\r\n        }\r\n    }\r\n    _setDimension(textBounds, bitmap) {\r\n        // Changing the width and height clears the context properties\r\n        // We double the bitmap width to account for all possible alignment\r\n        // We scale by \"quality\" so we render text without jaggies\r\n        bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;\r\n        bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;\r\n    }\r\n    _postDraw(ex) {\r\n        ex.restore();\r\n    }\r\n    /**\r\n     * We need to identify bitmaps with more than just the text content\r\n     *\r\n     * Any properties that can change the rendering of the text\r\n     */\r\n    _getRasterPropertiesHash(color) {\r\n        var _a, _b;\r\n        const hash = '__hashcode__' +\r\n            this.fontString +\r\n            this.showDebug +\r\n            this.textAlign +\r\n            this.baseAlign +\r\n            this.direction +\r\n            JSON.stringify(this.shadow) +\r\n            (this.padding.toString() +\r\n                this.smoothing.toString() +\r\n                this.lineWidth.toString() +\r\n                this.lineDash.toString() +\r\n                ((_a = this.strokeColor) === null || _a === void 0 ? void 0 : _a.toString()) +\r\n                (color ? color.toString() : (_b = this.color) === null || _b === void 0 ? void 0 : _b.toString()).toString());\r\n        return hash;\r\n    }\r\n    _applyRasterProperties(ctx, color) {\r\n        var _a, _b, _c;\r\n        ctx.translate(this.padding, this.padding);\r\n        ctx.imageSmoothingEnabled = this.smoothing;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());\r\n        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();\r\n        ctx.fillStyle = color ? color.toString() : (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();\r\n    }\r\n    _applyFont(ctx) {\r\n        ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);\r\n        ctx.scale(this.quality, this.quality);\r\n        ctx.textAlign = this.textAlign;\r\n        ctx.textBaseline = this.baseAlign;\r\n        ctx.font = this.fontString;\r\n        ctx.direction = this.direction;\r\n        if (this.shadow) {\r\n            ctx.shadowColor = this.shadow.color.toString();\r\n            ctx.shadowBlur = this.shadow.blur;\r\n            ctx.shadowOffsetX = this.shadow.offset.x;\r\n            ctx.shadowOffsetY = this.shadow.offset.y;\r\n        }\r\n    }\r\n    _drawText(ctx, text, colorOverride, lineHeight) {\r\n        const lines = text.split('\\n');\r\n        this._applyRasterProperties(ctx, colorOverride);\r\n        this._applyFont(ctx);\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            if (this.color) {\r\n                ctx.fillText(line, 0, i * lineHeight);\r\n            }\r\n            if (this.strokeColor) {\r\n                ctx.strokeText(line, 0, i * lineHeight);\r\n            }\r\n        }\r\n        if (this.showDebug) {\r\n            // Horizontal line\r\n            /* istanbul ignore next */\r\n            line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);\r\n            // Vertical line\r\n            /* istanbul ignore next */\r\n            line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);\r\n        }\r\n    }\r\n    _getTextBitmap(text, color) {\r\n        const textAndHash = text + this._getRasterPropertiesHash(color);\r\n        const bitmap = this._textToBitmap.get(textAndHash);\r\n        if (bitmap) {\r\n            return bitmap;\r\n        }\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        this._textToBitmap.set(textAndHash, ctx);\r\n        return ctx;\r\n    }\r\n    _splitTextBitmap(bitmap) {\r\n        const textImages = [];\r\n        let currentX = 0;\r\n        let currentY = 0;\r\n        // 4k is the max for mobile devices\r\n        const width = Math.min(4096, bitmap.canvas.width);\r\n        const height = Math.min(4096, bitmap.canvas.height);\r\n        // Splits the original bitmap into 4k max chunks\r\n        while (currentX < bitmap.canvas.width) {\r\n            while (currentY < bitmap.canvas.height) {\r\n                // create new bitmap\r\n                const canvas = document.createElement('canvas');\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n                const ctx = canvas.getContext('2d');\r\n                // draw current slice to new bitmap in < 4k chunks\r\n                ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);\r\n                textImages.push({ x: currentX, y: currentY, canvas });\r\n                currentY += height;\r\n            }\r\n            currentX += width;\r\n            currentY = 0;\r\n        }\r\n        return textImages;\r\n    }\r\n    render(ex, text, colorOverride, x, y) {\r\n        if (this.showDebug) {\r\n            this.clearCache();\r\n        }\r\n        this.checkAndClearCache();\r\n        // Get bitmap for rastering text, this is cached by raster properties\r\n        const bitmap = this._getTextBitmap(text, colorOverride);\r\n        const isNewBitmap = !this._bitmapUsage.get(bitmap);\r\n        // Bounds of the text\r\n        this._textBounds = this.measureText(text);\r\n        if (isNewBitmap) {\r\n            // Setting dimension is expensive because it invalidates the bitmap\r\n            this._setDimension(this._textBounds, bitmap);\r\n        }\r\n        // Apply affine transformations\r\n        this._preDraw(ex, x, y);\r\n        const lines = text.split('\\n');\r\n        const lineHeight = this._textBounds.height / lines.length;\r\n        if (isNewBitmap) {\r\n            // draws the text to the bitmap\r\n            this._drawText(bitmap, text, colorOverride, lineHeight);\r\n            // clean up any existing fragments\r\n            for (const frag of this._textFragments) {\r\n                TextureLoader[\"delete\"](frag.canvas);\r\n            }\r\n            this._textFragments = this._splitTextBitmap(bitmap);\r\n            for (const frag of this._textFragments) {\r\n                TextureLoader.load(frag.canvas, this.filtering, true);\r\n            }\r\n        }\r\n        // draws the bitmap fragments to excalibur graphics context\r\n        for (const frag of this._textFragments) {\r\n            ex.drawImage(frag.canvas, 0, 0, frag.canvas.width, frag.canvas.height, frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2, frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2, frag.canvas.width / this.quality, frag.canvas.height / this.quality);\r\n        }\r\n        this._postDraw(ex);\r\n        // Cache the bitmap for certain amount of time\r\n        this._bitmapUsage.set(bitmap, performance.now());\r\n    }\r\n    /**\r\n     * Get the internal cache size of the font\r\n     * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps\r\n     */\r\n    get cacheSize() {\r\n        return this._bitmapUsage.size;\r\n    }\r\n    /**\r\n     * Force clear all cached text bitmaps\r\n     */\r\n    clearCache() {\r\n        this._bitmapUsage.clear();\r\n    }\r\n    /**\r\n     * Remove any expired cached text bitmaps\r\n     */\r\n    checkAndClearCache() {\r\n        for (const [bitmap, time] of this._bitmapUsage.entries()) {\r\n            // if bitmap hasn't been used in 1 second clear it\r\n            if (time + 1000 < performance.now()) {\r\n                this._bitmapUsage.delete(bitmap);\r\n                // Cleanup measurements\r\n                const measurement = this._bitmapToTextMeasurement.get(bitmap);\r\n                if (measurement) {\r\n                    this._cachedTextMeasurement.delete(measurement.text);\r\n                    this._bitmapToTextMeasurement.delete(bitmap);\r\n                }\r\n                TextureLoader[\"delete\"](bitmap.canvas);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Text.ts\n\r\n\r\n\r\n/**\r\n * Represent Text graphics in excalibur\r\n *\r\n * Useful for in game labels, ui, or overlays\r\n */\r\nclass Text extends Graphic {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super(options);\r\n        this._text = '';\r\n        this._textWidth = 0;\r\n        this._textHeight = 0;\r\n        // This order is important font, color, then text\r\n        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();\r\n        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;\r\n        this.text = options.text;\r\n    }\r\n    clone() {\r\n        var _a, _b;\r\n        return new Text({\r\n            text: this.text.slice(),\r\n            color: (_b = (_a = this.color) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : Color.Black,\r\n            font: this.font.clone()\r\n        });\r\n    }\r\n    get text() {\r\n        return this._text;\r\n    }\r\n    set text(value) {\r\n        this._text = value;\r\n        const bounds = this.font.measureText(this._text);\r\n        this._textWidth = bounds.width;\r\n        this._textHeight = bounds.height;\r\n    }\r\n    get font() {\r\n        return this._font;\r\n    }\r\n    set font(font) {\r\n        this._font = font;\r\n    }\r\n    get width() {\r\n        if (this._textWidth === 0) {\r\n            this._calculateDimension();\r\n        }\r\n        return this._textWidth * this.scale.x;\r\n    }\r\n    get height() {\r\n        if (this._textHeight === 0) {\r\n            this._calculateDimension();\r\n        }\r\n        return this._textHeight * this.scale.y;\r\n    }\r\n    _calculateDimension() {\r\n        const { width, height } = this.font.measureText(this._text);\r\n        this._textWidth = width;\r\n        this._textHeight = height;\r\n    }\r\n    get localBounds() {\r\n        return this.font.measureText(this._text).scale(this.scale);\r\n    }\r\n    _rotate(_ex) {\r\n        // None this is delegated to font\r\n        // This override erases the default behavior\r\n    }\r\n    _flip(_ex) {\r\n        // None this is delegated to font\r\n        // This override erases the default behavior\r\n    }\r\n    _drawImage(ex, x, y) {\r\n        var _a;\r\n        let color = Color.Black;\r\n        if (this.font instanceof Font) {\r\n            color = (_a = this.color) !== null && _a !== void 0 ? _a : this.font.color;\r\n        }\r\n        if (this.isStale() || this.font.isStale()) {\r\n            this.font.flipHorizontal = this.flipHorizontal;\r\n            this.font.flipVertical = this.flipVertical;\r\n            this.font.rotation = this.rotation;\r\n            this.font.origin = this.origin;\r\n            this.font.opacity = this.opacity;\r\n        }\r\n        this.font.tint = this.tint;\r\n        const { width, height } = this.font.measureText(this._text);\r\n        this._textWidth = width;\r\n        this._textHeight = height;\r\n        this.font.render(ex, this._text, color, x, y);\r\n        if (this.font.showDebug) {\r\n            ex.debug.drawRect(x - width, y - height, width * 2, height * 2);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actor.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Type guard for checking if something is an Actor\r\n * @param x\r\n */\r\nfunction isActor(x) {\r\n    return x instanceof Actor;\r\n}\r\n/**\r\n * The most important primitive in Excalibur is an `Actor`. Anything that\r\n * can move on the screen, collide with another `Actor`, respond to events,\r\n * or interact with the current scene, must be an actor. An `Actor` **must**\r\n * be part of a [[Scene]] for it to be drawn to the screen.\r\n */\r\nclass Actor extends Entity {\r\n    // #endregion\r\n    /**\r\n     *\r\n     * @param config\r\n     */\r\n    constructor(config) {\r\n        super();\r\n        /**\r\n         * The anchor to apply all actor related transformations like rotation,\r\n         * translation, and scaling. By default the anchor is in the center of\r\n         * the actor. By default it is set to the center of the actor (.5, .5)\r\n         *\r\n         * An anchor of (.5, .5) will ensure that drawings are centered.\r\n         *\r\n         * Use `anchor.setTo` to set the anchor to a different point using\r\n         * values between 0 and 1. For example, anchoring to the top-left would be\r\n         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.\r\n         */\r\n        this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));\r\n        /**\r\n         * Convenience reference to the global logger\r\n         */\r\n        this.logger = Logger.getInstance();\r\n        /**\r\n         * The scene that the actor is in\r\n         */\r\n        this.scene = null;\r\n        /**\r\n         * Draggable helper\r\n         */\r\n        this._draggable = false;\r\n        this._dragging = false;\r\n        this._pointerDragStartHandler = () => {\r\n            this._dragging = true;\r\n        };\r\n        this._pointerDragEndHandler = () => {\r\n            this._dragging = false;\r\n        };\r\n        this._pointerDragMoveHandler = (pe) => {\r\n            if (this._dragging) {\r\n                this.pos = pe.worldPos;\r\n            }\r\n        };\r\n        this._pointerDragLeaveHandler = (pe) => {\r\n            if (this._dragging) {\r\n                this.pos = pe.worldPos;\r\n            }\r\n        };\r\n        const { name, x, y, pos, coordPlane, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, anchor, collisionType, collisionGroup } = {\r\n            ...config\r\n        };\r\n        this._setName(name);\r\n        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();\r\n        const tx = new TransformComponent();\r\n        this.addComponent(tx);\r\n        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);\r\n        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;\r\n        this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);\r\n        this.z = z !== null && z !== void 0 ? z : 0;\r\n        tx.coordPlane = coordPlane !== null && coordPlane !== void 0 ? coordPlane : CoordPlane.World;\r\n        this.addComponent(new PointerComponent);\r\n        this.addComponent(new GraphicsComponent({\r\n            anchor: this.anchor\r\n        }));\r\n        this.addComponent(new MotionComponent());\r\n        this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;\r\n        this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;\r\n        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;\r\n        this.addComponent(new ActionsComponent());\r\n        this.addComponent(new BodyComponent());\r\n        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;\r\n        if (collisionGroup) {\r\n            this.body.group = collisionGroup;\r\n        }\r\n        if (collider) {\r\n            this.addComponent(new ColliderComponent(collider));\r\n        }\r\n        else if (radius) {\r\n            this.addComponent(new ColliderComponent(Shape.Circle(radius)));\r\n        }\r\n        else {\r\n            if (width > 0 && height > 0) {\r\n                this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));\r\n            }\r\n            else {\r\n                this.addComponent(new ColliderComponent()); // no collider\r\n            }\r\n        }\r\n        this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;\r\n        if (color) {\r\n            this.color = color;\r\n            if (width && height) {\r\n                this.graphics.add(new Rectangle({\r\n                    color: color,\r\n                    width,\r\n                    height\r\n                }));\r\n            }\r\n            else if (radius) {\r\n                this.graphics.add(new Circle({\r\n                    color: color,\r\n                    radius\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n     * acceleration, mass, inertia, etc.\r\n     */\r\n    get body() {\r\n        return this.get(BodyComponent);\r\n    }\r\n    /**\r\n     * Access the Actor's built in [[TransformComponent]]\r\n     */\r\n    get transform() {\r\n        return this.get(TransformComponent);\r\n    }\r\n    /**\r\n     * Access the Actor's built in [[MotionComponent]]\r\n     */\r\n    get motion() {\r\n        return this.get(MotionComponent);\r\n    }\r\n    /**\r\n     * Access to the Actor's built in [[GraphicsComponent]]\r\n     */\r\n    get graphics() {\r\n        return this.get(GraphicsComponent);\r\n    }\r\n    /**\r\n     * Access to the Actor's built in [[ColliderComponent]]\r\n     */\r\n    get collider() {\r\n        return this.get(ColliderComponent);\r\n    }\r\n    /**\r\n     * Access to the Actor's built in [[PointerComponent]] config\r\n     */\r\n    get pointer() {\r\n        return this.get(PointerComponent);\r\n    }\r\n    /**\r\n     * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.\r\n     *\r\n     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the\r\n     * [[ActionContext|Action context]] of the actor.\r\n     */\r\n    get actions() {\r\n        return this.get(ActionsComponent);\r\n    }\r\n    /**\r\n     * Gets the position vector of the actor in pixels\r\n     */\r\n    get pos() {\r\n        return this.transform.pos;\r\n    }\r\n    /**\r\n     * Sets the position vector of the actor in pixels\r\n     */\r\n    set pos(thePos) {\r\n        this.transform.pos = thePos.clone();\r\n    }\r\n    /**\r\n     * Gets the position vector of the actor from the last frame\r\n     */\r\n    get oldPos() {\r\n        return this.body.oldPos;\r\n    }\r\n    /**\r\n     * Sets the position vector of the actor in the last frame\r\n     */\r\n    set oldPos(thePos) {\r\n        this.body.oldPos.setTo(thePos.x, thePos.y);\r\n    }\r\n    /**\r\n     * Gets the velocity vector of the actor in pixels/sec\r\n     */\r\n    get vel() {\r\n        return this.motion.vel;\r\n    }\r\n    /**\r\n     * Sets the velocity vector of the actor in pixels/sec\r\n     */\r\n    set vel(theVel) {\r\n        this.motion.vel = theVel.clone();\r\n    }\r\n    /**\r\n     * Gets the velocity vector of the actor from the last frame\r\n     */\r\n    get oldVel() {\r\n        return this.body.oldVel;\r\n    }\r\n    /**\r\n     * Sets the velocity vector of the actor from the last frame\r\n     */\r\n    set oldVel(theVel) {\r\n        this.body.oldVel.setTo(theVel.x, theVel.y);\r\n    }\r\n    /**\r\n     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n     * useful to simulate a gravitational effect.\r\n     */\r\n    get acc() {\r\n        return this.motion.acc;\r\n    }\r\n    /**\r\n     * Sets the acceleration vector of teh actor in pixels/second/second\r\n     */\r\n    set acc(theAcc) {\r\n        this.motion.acc = theAcc.clone();\r\n    }\r\n    /**\r\n     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n     */\r\n    set oldAcc(theAcc) {\r\n        this.body.oldAcc.setTo(theAcc.x, theAcc.y);\r\n    }\r\n    /**\r\n     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n     */\r\n    get oldAcc() {\r\n        return this.body.oldAcc;\r\n    }\r\n    /**\r\n     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n     */\r\n    get rotation() {\r\n        return this.transform.rotation;\r\n    }\r\n    /**\r\n     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n     */\r\n    set rotation(theAngle) {\r\n        this.transform.rotation = theAngle;\r\n    }\r\n    /**\r\n     * Gets the rotational velocity of the actor in radians/second\r\n     */\r\n    get angularVelocity() {\r\n        return this.motion.angularVelocity;\r\n    }\r\n    /**\r\n     * Sets the rotational velocity of the actor in radians/sec\r\n     */\r\n    set angularVelocity(angularVelocity) {\r\n        this.motion.angularVelocity = angularVelocity;\r\n    }\r\n    get scale() {\r\n        return this.get(TransformComponent).scale;\r\n    }\r\n    set scale(scale) {\r\n        this.get(TransformComponent).scale = scale;\r\n    }\r\n    get anchor() {\r\n        return this._anchor;\r\n    }\r\n    set anchor(vec) {\r\n        this._anchor = watch(vec, (v) => this._handleAnchorChange(v));\r\n        this._handleAnchorChange(vec);\r\n    }\r\n    _handleAnchorChange(v) {\r\n        if (this.graphics) {\r\n            this.graphics.anchor = v;\r\n        }\r\n    }\r\n    /**\r\n     * Indicates whether the actor is physically in the viewport\r\n     */\r\n    get isOffScreen() {\r\n        return this.hasTag('ex.offscreen');\r\n    }\r\n    get draggable() {\r\n        return this._draggable;\r\n    }\r\n    set draggable(isDraggable) {\r\n        if (isDraggable) {\r\n            if (isDraggable && !this._draggable) {\r\n                this.on('pointerdragstart', this._pointerDragStartHandler);\r\n                this.on('pointerdragend', this._pointerDragEndHandler);\r\n                this.on('pointerdragmove', this._pointerDragMoveHandler);\r\n                this.on('pointerdragleave', this._pointerDragLeaveHandler);\r\n            }\r\n            else if (!isDraggable && this._draggable) {\r\n                this.off('pointerdragstart', this._pointerDragStartHandler);\r\n                this.off('pointerdragend', this._pointerDragEndHandler);\r\n                this.off('pointerdragmove', this._pointerDragMoveHandler);\r\n                this.off('pointerdragleave', this._pointerDragLeaveHandler);\r\n            }\r\n            this._draggable = isDraggable;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the color of the actor's current graphic\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n    set color(v) {\r\n        var _a;\r\n        this._color = v.clone();\r\n        const defaultLayer = this.graphics.layers.default;\r\n        const currentGraphic = (_a = defaultLayer.graphics[0]) === null || _a === void 0 ? void 0 : _a.graphic;\r\n        if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {\r\n            currentGraphic.color = this._color;\r\n        }\r\n    }\r\n    /**\r\n     * `onInitialize` is called before the first update of the actor. This method is meant to be\r\n     * overridden. This is where initialization of child actors should take place.\r\n     *\r\n     * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n     */\r\n    onInitialize(_engine) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n     *\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * @internal\r\n     */\r\n    _initialize(engine) {\r\n        super._initialize(engine);\r\n        for (const child of this.children) {\r\n            child._initialize(engine);\r\n        }\r\n    }\r\n    on(eventName, handler) {\r\n        super.on(eventName, handler);\r\n    }\r\n    once(eventName, handler) {\r\n        super.once(eventName, handler);\r\n    }\r\n    off(eventName, handler) {\r\n        super.off(eventName, handler);\r\n    }\r\n    // #endregion\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _prekill handler for [[onPreKill]] lifecycle event\r\n     * @internal\r\n     */\r\n    _prekill(_scene) {\r\n        super.emit('prekill', new PreKillEvent(this));\r\n        this.onPreKill(_scene);\r\n    }\r\n    /**\r\n     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`\r\n     *\r\n     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].\r\n     */\r\n    onPreKill(_scene) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _prekill handler for [[onPostKill]] lifecycle event\r\n     * @internal\r\n     */\r\n    _postkill(_scene) {\r\n        super.emit('postkill', new PostKillEvent(this));\r\n        this.onPostKill(_scene);\r\n    }\r\n    /**\r\n     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`\r\n     *\r\n     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].\r\n     */\r\n    onPostKill(_scene) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * If the current actor is a member of the scene, this will remove\r\n     * it from the scene graph. It will no longer be drawn or updated.\r\n     */\r\n    kill() {\r\n        if (this.scene) {\r\n            this._prekill(this.scene);\r\n            this.emit('kill', new KillEvent(this));\r\n            super.kill();\r\n            this._postkill(this.scene);\r\n        }\r\n        else {\r\n            this.logger.warn('Cannot kill actor, it was never added to the Scene');\r\n        }\r\n    }\r\n    /**\r\n     * If the current actor is killed, it will now not be killed.\r\n     */\r\n    unkill() {\r\n        this.active = true;\r\n    }\r\n    /**\r\n     * Indicates wether the actor has been killed.\r\n     */\r\n    isKilled() {\r\n        return !this.active;\r\n    }\r\n    /**\r\n     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n     * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n     */\r\n    get z() {\r\n        return this.get(TransformComponent).z;\r\n    }\r\n    /**\r\n     * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n     * The z-index determines the relative order an actor is drawn in.\r\n     * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n     * @param newZ new z-index to assign\r\n     */\r\n    set z(newZ) {\r\n        this.get(TransformComponent).z = newZ;\r\n    }\r\n    /**\r\n     * Get the center point of an actor (global position)\r\n     */\r\n    get center() {\r\n        const globalPos = this.getGlobalPos();\r\n        return new Vector(globalPos.x + this.width / 2 - this.anchor.x * this.width, globalPos.y + this.height / 2 - this.anchor.y * this.height);\r\n    }\r\n    /**\r\n     * Get the local center point of an actor\r\n     */\r\n    get localCenter() {\r\n        return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);\r\n    }\r\n    get width() {\r\n        return this.collider.localBounds.width * this.getGlobalScale().x;\r\n    }\r\n    get height() {\r\n        return this.collider.localBounds.height * this.getGlobalScale().y;\r\n    }\r\n    /**\r\n     * Gets this actor's rotation taking into account any parent relationships\r\n     *\r\n     * @returns Rotation angle in radians\r\n     */\r\n    getGlobalRotation() {\r\n        return this.get(TransformComponent).globalRotation;\r\n    }\r\n    /**\r\n     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation\r\n     *\r\n     * @returns Position in world coordinates\r\n     */\r\n    getGlobalPos() {\r\n        return this.get(TransformComponent).globalPos;\r\n    }\r\n    /**\r\n     * Gets the global scale of the Actor\r\n     */\r\n    getGlobalScale() {\r\n        return this.get(TransformComponent).globalScale;\r\n    }\r\n    // #region Collision\r\n    /**\r\n     * Tests whether the x/y specified are contained in the actor\r\n     * @param x  X coordinate to test (in world coordinates)\r\n     * @param y  Y coordinate to test (in world coordinates)\r\n     * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n     */\r\n    contains(x, y, recurse = false) {\r\n        const point = vec(x, y);\r\n        const collider = this.get(ColliderComponent);\r\n        collider.update();\r\n        const geom = collider.get();\r\n        if (!geom) {\r\n            return false;\r\n        }\r\n        const containment = geom.contains(point);\r\n        if (recurse) {\r\n            return (containment ||\r\n                this.children.some((child) => {\r\n                    return child.contains(x, y, true);\r\n                }));\r\n        }\r\n        return containment;\r\n    }\r\n    /**\r\n     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other\r\n     * @param actor     Actor to test\r\n     * @param distance  Distance in pixels to test\r\n     */\r\n    within(actor, distance) {\r\n        const collider = this.get(ColliderComponent);\r\n        const otherCollider = actor.get(ColliderComponent);\r\n        const me = collider.get();\r\n        const other = otherCollider.get();\r\n        if (me && other) {\r\n            return me.getClosestLineBetween(other).getLength() <= distance;\r\n        }\r\n        return false;\r\n    }\r\n    // #endregion\r\n    // #region Update\r\n    /**\r\n     * Called by the Engine, updates the state of the actor\r\n     * @internal\r\n     * @param engine The reference to the current game engine\r\n     * @param delta  The time elapsed since the last update in milliseconds\r\n     */\r\n    update(engine, delta) {\r\n        this._initialize(engine);\r\n        this._preupdate(engine, delta);\r\n        this._postupdate(engine, delta);\r\n    }\r\n    /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before an actor is updated.\r\n     */\r\n    onPreUpdate(_engine, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after an actor is updated.\r\n     */\r\n    onPostUpdate(_engine, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _preupdate(engine, delta) {\r\n        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n        this.onPreUpdate(engine, delta);\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _postupdate(engine, delta) {\r\n        this.emit('postupdate', new PreUpdateEvent(engine, delta, this));\r\n        this.onPostUpdate(engine, delta);\r\n    }\r\n}\r\n// #region Properties\r\n/**\r\n * Set defaults for all Actors\r\n */\r\nActor.defaults = {\r\n    anchor: Vector.Half\r\n};\r\n\n;// CONCATENATED MODULE: ./ScreenElement.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Type guard to detect a screen element\r\n */\r\nfunction isScreenElement(actor) {\r\n    return actor instanceof ScreenElement;\r\n}\r\n/**\r\n * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does\r\n * not participate in collisions. Drawn on top of all other actors.\r\n */\r\nclass ScreenElement extends Actor {\r\n    constructor(config) {\r\n        super({ ...config });\r\n        this.get(TransformComponent).coordPlane = CoordPlane.Screen;\r\n        this.anchor = vec(0, 0);\r\n        this.body.collisionType = CollisionType.PreventCollision;\r\n        this.collider.useBoxCollider(this.width, this.height, this.anchor);\r\n    }\r\n    _initialize(engine) {\r\n        this._engine = engine;\r\n        super._initialize(engine);\r\n    }\r\n    contains(x, y, useWorld = true) {\r\n        if (useWorld) {\r\n            return super.contains(x, y);\r\n        }\r\n        const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));\r\n        return super.contains(coords.x, coords.y);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Timer.ts\n\r\n\r\n/**\r\n * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n * after a certain interval, optionally repeating.\r\n */\r\nclass Timer {\r\n    constructor(fcn, interval, repeats, numberOfRepeats, randomRange, random) {\r\n        this._logger = Logger.getInstance();\r\n        this.id = 0;\r\n        this._elapsedTime = 0;\r\n        this._totalTimeAlive = 0;\r\n        this._running = false;\r\n        this._numberOfTicks = 0;\r\n        this.interval = 10;\r\n        this.repeats = false;\r\n        this.maxNumberOfRepeats = -1;\r\n        this.randomRange = [0, 0];\r\n        this._baseInterval = 10;\r\n        this._generateRandomInterval = () => {\r\n            return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);\r\n        };\r\n        this._complete = false;\r\n        this.scene = null;\r\n        if (typeof fcn !== 'function') {\r\n            const options = fcn;\r\n            fcn = options.fcn;\r\n            interval = options.interval;\r\n            repeats = options.repeats;\r\n            numberOfRepeats = options.numberOfRepeats;\r\n            randomRange = options.randomRange;\r\n            random = options.random;\r\n        }\r\n        if (!!numberOfRepeats && numberOfRepeats >= 0) {\r\n            this.maxNumberOfRepeats = numberOfRepeats;\r\n            if (!repeats) {\r\n                throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n            }\r\n        }\r\n        this.id = Timer._MAX_ID++;\r\n        this._callbacks = [];\r\n        this._baseInterval = this.interval = interval;\r\n        if (!!randomRange) {\r\n            if (randomRange[0] > randomRange[1]) {\r\n                throw new Error('min value must be lower than max value for range');\r\n            }\r\n            //We use the instance of ex.Random to generate the range\r\n            this.random = random !== null && random !== void 0 ? random : new Random();\r\n            this.randomRange = randomRange;\r\n            this.interval = this._generateRandomInterval();\r\n            this.on(() => {\r\n                this.interval = this._generateRandomInterval();\r\n            });\r\n        }\r\n        ;\r\n        this.repeats = repeats || this.repeats;\r\n        if (fcn) {\r\n            this.on(fcn);\r\n        }\r\n    }\r\n    get complete() {\r\n        return this._complete;\r\n    }\r\n    /**\r\n     * Adds a new callback to be fired after the interval is complete\r\n     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.\r\n     */\r\n    on(fcn) {\r\n        this._callbacks.push(fcn);\r\n    }\r\n    /**\r\n     * Removes a callback from the callback list to be fired after the interval is complete.\r\n     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.\r\n     */\r\n    off(fcn) {\r\n        const index = this._callbacks.indexOf(fcn);\r\n        this._callbacks.splice(index, 1);\r\n    }\r\n    /**\r\n     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n     * @param delta  Number of elapsed milliseconds since the last update.\r\n     */\r\n    update(delta) {\r\n        if (this._running) {\r\n            this._totalTimeAlive += delta;\r\n            this._elapsedTime += delta;\r\n            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {\r\n                this._complete = true;\r\n                this._running = false;\r\n                this._elapsedTime = 0;\r\n            }\r\n            if (!this.complete && this._elapsedTime >= this.interval) {\r\n                this._callbacks.forEach((c) => {\r\n                    c.call(this);\r\n                });\r\n                this._numberOfTicks++;\r\n                if (this.repeats) {\r\n                    this._elapsedTime = 0;\r\n                }\r\n                else {\r\n                    this._complete = true;\r\n                    this._running = false;\r\n                    this._elapsedTime = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n     *\r\n     * Warning** you may need to call `timer.start()` again if the timer had completed\r\n     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes\r\n     */\r\n    reset(newInterval, newNumberOfRepeats) {\r\n        if (!!newInterval && newInterval >= 0) {\r\n            this._baseInterval = this.interval = newInterval;\r\n        }\r\n        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {\r\n            this.maxNumberOfRepeats = newNumberOfRepeats;\r\n            if (!this.repeats) {\r\n                throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n            }\r\n        }\r\n        this._complete = false;\r\n        this._elapsedTime = 0;\r\n        this._numberOfTicks = 0;\r\n    }\r\n    get timesRepeated() {\r\n        return this._numberOfTicks;\r\n    }\r\n    getTimeRunning() {\r\n        return this._totalTimeAlive;\r\n    }\r\n    /**\r\n     * @returns milliseconds until the next action callback, if complete will return 0\r\n     */\r\n    get timeToNextAction() {\r\n        if (this.complete) {\r\n            return 0;\r\n        }\r\n        return this.interval - this._elapsedTime;\r\n    }\r\n    /**\r\n     * @returns milliseconds elapsed toward the next action\r\n     */\r\n    get timeElapsedTowardNextAction() {\r\n        return this._elapsedTime;\r\n    }\r\n    get isRunning() {\r\n        return this._running;\r\n    }\r\n    /**\r\n     * Pauses the timer, time will no longer increment towards the next call\r\n     */\r\n    pause() {\r\n        this._running = false;\r\n        return this;\r\n    }\r\n    /**\r\n     * Resumes the timer, time will now increment towards the next call.\r\n     */\r\n    resume() {\r\n        this._running = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter\r\n     */\r\n    start() {\r\n        if (!this.scene) {\r\n            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');\r\n        }\r\n        this._running = true;\r\n        if (this.complete) {\r\n            this._complete = false;\r\n            this._elapsedTime = 0;\r\n            this._numberOfTicks = 0;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Stops the timer and resets the elapsed time counter towards the next action invocation\r\n     */\r\n    stop() {\r\n        this._running = false;\r\n        this._elapsedTime = 0;\r\n        this._numberOfTicks = 0;\r\n        return this;\r\n    }\r\n    /**\r\n     * Cancels the timer, preventing any further executions.\r\n     */\r\n    cancel() {\r\n        this.pause();\r\n        if (this.scene) {\r\n            this.scene.cancelTimer(this);\r\n        }\r\n    }\r\n}\r\nTimer._MAX_ID = 0;\r\n\n;// CONCATENATED MODULE: ./Graphics/ParallaxComponent.ts\n\r\n\r\nclass ParallaxComponent extends Component {\r\n    constructor(parallaxFactor) {\r\n        super();\r\n        this.type = 'ex.parallax';\r\n        this.parallaxFactor = vec(1.0, 1.0);\r\n        this.parallaxFactor = parallaxFactor !== null && parallaxFactor !== void 0 ? parallaxFactor : this.parallaxFactor;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/DebugGraphicsComponent.ts\n\r\n/**\r\n * Provide arbitrary drawing for the purposes of debugging your game\r\n *\r\n * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]\r\n *\r\n */\r\nclass DebugGraphicsComponent extends Component {\r\n    constructor(draw, useTransform = true) {\r\n        super();\r\n        this.draw = draw;\r\n        this.useTransform = useTransform;\r\n        this.type = 'ex.debuggraphics';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./TileMap/TileMap.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.\r\n *\r\n * TileMaps are useful for top down or side scrolling grid oriented games.\r\n */\r\nclass TileMap extends Entity {\r\n    /**\r\n     * @param options\r\n     */\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super(null, options.name);\r\n        this._token = 0;\r\n        this._onScreenXStart = 0;\r\n        this._onScreenXEnd = Number.MAX_VALUE;\r\n        this._onScreenYStart = 0;\r\n        this._onScreenYEnd = Number.MAX_VALUE;\r\n        this.logger = Logger.getInstance();\r\n        this.tiles = [];\r\n        this._rows = [];\r\n        this._cols = [];\r\n        this.renderFromTopOfGraphic = false;\r\n        this._collidersDirty = true;\r\n        this._originalOffsets = new WeakMap();\r\n        this.addComponent(new TransformComponent());\r\n        this.addComponent(new MotionComponent());\r\n        this.addComponent(new BodyComponent({\r\n            type: CollisionType.Fixed\r\n        }));\r\n        this.addComponent(new GraphicsComponent({\r\n            onPostDraw: (ctx, delta) => this.draw(ctx, delta)\r\n        }));\r\n        this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));\r\n        this.addComponent(new ColliderComponent());\r\n        this._graphics = this.get(GraphicsComponent);\r\n        this._transform = this.get(TransformComponent);\r\n        this._motion = this.get(MotionComponent);\r\n        this._collider = this.get(ColliderComponent);\r\n        this._composite = this._collider.useCompositeCollider([]);\r\n        this._transform.pos = (_a = options.pos) !== null && _a !== void 0 ? _a : Vector.Zero;\r\n        this._oldPos = this._transform.pos;\r\n        this.renderFromTopOfGraphic = (_b = options.renderFromTopOfGraphic) !== null && _b !== void 0 ? _b : this.renderFromTopOfGraphic;\r\n        this.tileWidth = options.tileWidth;\r\n        this.tileHeight = options.tileHeight;\r\n        this.rows = options.rows;\r\n        this.columns = options.columns;\r\n        this.tiles = new Array(this.rows * this.columns);\r\n        this._rows = new Array(this.rows);\r\n        this._cols = new Array(this.columns);\r\n        let currentCol = [];\r\n        for (let i = 0; i < this.columns; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const cd = new Tile({\r\n                    x: i,\r\n                    y: j,\r\n                    map: this\r\n                });\r\n                cd.map = this;\r\n                this.tiles[i + j * this.columns] = cd;\r\n                currentCol.push(cd);\r\n                if (!this._rows[j]) {\r\n                    this._rows[j] = [];\r\n                }\r\n                this._rows[j].push(cd);\r\n            }\r\n            this._cols[i] = currentCol;\r\n            currentCol = [];\r\n        }\r\n        this._graphics.localBounds = new BoundingBox({\r\n            left: 0,\r\n            top: 0,\r\n            right: this.columns * this.tileWidth,\r\n            bottom: this.rows * this.tileHeight\r\n        });\r\n    }\r\n    flagCollidersDirty() {\r\n        this._collidersDirty = true;\r\n    }\r\n    get x() {\r\n        var _a;\r\n        return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    set x(val) {\r\n        var _a;\r\n        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {\r\n            this.get(TransformComponent).pos = vec(val, this.y);\r\n        }\r\n    }\r\n    get y() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;\r\n    }\r\n    set y(val) {\r\n        var _a;\r\n        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {\r\n            this._transform.pos = vec(this.x, val);\r\n        }\r\n    }\r\n    get z() {\r\n        var _a;\r\n        return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    set z(val) {\r\n        if (this._transform) {\r\n            this._transform.z = val;\r\n        }\r\n    }\r\n    get rotation() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;\r\n    }\r\n    set rotation(val) {\r\n        var _a;\r\n        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {\r\n            this._transform.rotation = val;\r\n        }\r\n    }\r\n    get scale() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;\r\n    }\r\n    set scale(val) {\r\n        var _a;\r\n        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {\r\n            this._transform.scale = val;\r\n        }\r\n    }\r\n    get pos() {\r\n        return this._transform.pos;\r\n    }\r\n    set pos(val) {\r\n        this._transform.pos = val;\r\n    }\r\n    get vel() {\r\n        return this._motion.vel;\r\n    }\r\n    set vel(val) {\r\n        this._motion.vel = val;\r\n    }\r\n    on(eventName, handler) {\r\n        super.on(eventName, handler);\r\n    }\r\n    _initialize(engine) {\r\n        super._initialize(engine);\r\n    }\r\n    _getOrSetColliderOriginalOffset(collider) {\r\n        if (!this._originalOffsets.has(collider)) {\r\n            const originalOffset = collider.offset;\r\n            this._originalOffsets.set(collider, originalOffset);\r\n            return originalOffset;\r\n        }\r\n        else {\r\n            return this._originalOffsets.get(collider);\r\n        }\r\n    }\r\n    /**\r\n     * Tiles colliders based on the solid tiles in the tilemap.\r\n     */\r\n    _updateColliders() {\r\n        this._composite.clearColliders();\r\n        const colliders = [];\r\n        this._composite = this._collider.useCompositeCollider([]);\r\n        let current;\r\n        // Bad square tesselation algo\r\n        for (let i = 0; i < this.columns; i++) {\r\n            // Scan column for colliders\r\n            for (let j = 0; j < this.rows; j++) {\r\n                // Columns start with a new collider\r\n                if (j === 0) {\r\n                    current = null;\r\n                }\r\n                const tile = this.tiles[i + j * this.columns];\r\n                // Current tile in column is solid build up current collider\r\n                if (tile.solid) {\r\n                    // Use custom collider otherwise bounding box\r\n                    if (tile.getColliders().length > 0) {\r\n                        for (const collider of tile.getColliders()) {\r\n                            const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n                            collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);\r\n                            collider.owner = this;\r\n                            this._composite.addCollider(collider);\r\n                        }\r\n                        current = null;\r\n                    }\r\n                    else {\r\n                        if (!current) {\r\n                            current = tile.bounds;\r\n                        }\r\n                        else {\r\n                            current = current.combine(tile.bounds);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Not solid skip and cut off the current collider\r\n                    if (current) {\r\n                        colliders.push(current);\r\n                    }\r\n                    current = null;\r\n                }\r\n            }\r\n            // After a column is complete check to see if it can be merged into the last one\r\n            if (current) {\r\n                // if previous is the same combine it\r\n                const prev = colliders[colliders.length - 1];\r\n                if (prev && prev.top === current.top && prev.bottom === current.bottom) {\r\n                    colliders[colliders.length - 1] = prev.combine(current);\r\n                }\r\n                else {\r\n                    // else new collider\r\n                    colliders.push(current);\r\n                }\r\n            }\r\n        }\r\n        for (const c of colliders) {\r\n            const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));\r\n            collider.owner = this;\r\n            this._composite.addCollider(collider);\r\n        }\r\n        this._collider.update();\r\n    }\r\n    /**\r\n     * Returns the [[Tile]] by index (row major order)\r\n     */\r\n    getTileByIndex(index) {\r\n        return this.tiles[index];\r\n    }\r\n    /**\r\n     * Returns the [[Tile]] by its x and y integer coordinates\r\n     */\r\n    getTile(x, y) {\r\n        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n            return null;\r\n        }\r\n        return this.tiles[x + y * this.columns];\r\n    }\r\n    /**\r\n     * Returns the [[Tile]] by testing a point in world coordinates,\r\n     * returns `null` if no Tile was found.\r\n     */\r\n    getTileByPoint(point) {\r\n        const x = Math.floor((point.x - this.pos.x) / this.tileWidth);\r\n        const y = Math.floor((point.y - this.pos.y) / this.tileHeight);\r\n        const tile = this.getTile(x, y);\r\n        if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {\r\n            return tile;\r\n        }\r\n        return null;\r\n    }\r\n    getRows() {\r\n        return this._rows;\r\n    }\r\n    getColumns() {\r\n        return this._cols;\r\n    }\r\n    update(engine, delta) {\r\n        this.onPreUpdate(engine, delta);\r\n        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n        if (!this._oldPos.equals(this.pos)) {\r\n            this.flagCollidersDirty();\r\n            for (let i = 0; i < this.tiles.length; i++) {\r\n                if (this.tiles[i]) {\r\n                    this.tiles[i].flagDirty();\r\n                }\r\n            }\r\n        }\r\n        if (this._collidersDirty) {\r\n            this._collidersDirty = false;\r\n            this._updateColliders();\r\n        }\r\n        this._token++;\r\n        const worldBounds = engine.getWorldBounds();\r\n        const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);\r\n        const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);\r\n        let pos = this.pos;\r\n        const maybeParallax = this.get(ParallaxComponent);\r\n        let parallaxOffset = Vector.One;\r\n        if (maybeParallax) {\r\n            const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n            parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);\r\n            pos = pos.add(parallaxOffset);\r\n        }\r\n        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);\r\n        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);\r\n        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);\r\n        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);\r\n        // why are we resetting pos?\r\n        this._transform.pos = vec(this.x, this.y);\r\n        this.onPostUpdate(engine, delta);\r\n        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    }\r\n    /**\r\n     * Draws the tile map to the screen. Called by the [[Scene]].\r\n     * @param ctx ExcaliburGraphicsContext\r\n     * @param delta  The number of milliseconds since the last draw\r\n     */\r\n    draw(ctx, delta) {\r\n        this.emit('predraw', new PreDrawEvent(ctx, delta, this)); // TODO fix event\r\n        let x = this._onScreenXStart;\r\n        const xEnd = Math.min(this._onScreenXEnd, this.columns);\r\n        let y = this._onScreenYStart;\r\n        const yEnd = Math.min(this._onScreenYEnd, this.rows);\r\n        let graphics, graphicsIndex, graphicsLen;\r\n        for (x; x < xEnd; x++) {\r\n            for (y; y < yEnd; y++) {\r\n                // get non-negative tile sprites\r\n                graphics = this.getTile(x, y).getGraphics();\r\n                for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {\r\n                    // draw sprite, warning if sprite doesn't exist\r\n                    const graphic = graphics[graphicsIndex];\r\n                    if (graphic) {\r\n                        if (hasGraphicsTick(graphic)) {\r\n                            graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);\r\n                        }\r\n                        const offsetY = this.renderFromTopOfGraphic ? 0 : (graphic.height - this.tileHeight);\r\n                        graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight - offsetY);\r\n                    }\r\n                }\r\n            }\r\n            y = this._onScreenYStart;\r\n        }\r\n        this.emit('postdraw', new PostDrawEvent(ctx, delta, this));\r\n    }\r\n    debug(gfx) {\r\n        const width = this.tileWidth * this.columns;\r\n        const height = this.tileHeight * this.rows;\r\n        const pos = Vector.Zero;\r\n        for (let r = 0; r < this.rows + 1; r++) {\r\n            const yOffset = vec(0, r * this.tileHeight);\r\n            gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);\r\n        }\r\n        for (let c = 0; c < this.columns + 1; c++) {\r\n            const xOffset = vec(c * this.tileWidth, 0);\r\n            gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);\r\n        }\r\n        const colliders = this._composite.getColliders();\r\n        for (const collider of colliders) {\r\n            const grayish = Color.Gray;\r\n            grayish.a = 0.5;\r\n            const bounds = collider.localBounds;\r\n            const pos = collider.worldPos.sub(this.pos);\r\n            gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);\r\n        }\r\n    }\r\n}\r\n/**\r\n * TileMap Tile\r\n *\r\n * A light-weight object that occupies a space in a collision map. Generally\r\n * created by a [[TileMap]].\r\n *\r\n * Tiles can draw multiple sprites. Note that the order of drawing is the order\r\n * of the sprites in the array so the last one will be drawn on top. You can\r\n * use transparency to create layers this way.\r\n */\r\nclass Tile extends Entity {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super();\r\n        this._posDirty = false;\r\n        this._solid = false;\r\n        this._graphics = [];\r\n        /**\r\n         * Current list of colliders for this tile\r\n         */\r\n        this._colliders = [];\r\n        /**\r\n         * Arbitrary data storage per tile, useful for any game specific data\r\n         */\r\n        this.data = new Map();\r\n        this.x = options.x;\r\n        this.y = options.y;\r\n        this.map = options.map;\r\n        this.width = options.map.tileWidth;\r\n        this.height = options.map.tileHeight;\r\n        this.solid = (_a = options.solid) !== null && _a !== void 0 ? _a : this.solid;\r\n        this._graphics = (_b = options.graphics) !== null && _b !== void 0 ? _b : [];\r\n        this._recalculate();\r\n    }\r\n    // private _transform: TransformComponent;\r\n    /**\r\n     * Return the world position of the top left corner of the tile\r\n     */\r\n    get pos() {\r\n        if (this._posDirty) {\r\n            this._recalculate();\r\n            this._posDirty = false;\r\n        }\r\n        return this._pos;\r\n    }\r\n    /**\r\n     * Wether this tile should be treated as solid by the tilemap\r\n     */\r\n    get solid() {\r\n        return this._solid;\r\n    }\r\n    /**\r\n     * Wether this tile should be treated as solid by the tilemap\r\n     */\r\n    set solid(val) {\r\n        var _a;\r\n        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagCollidersDirty();\r\n        this._solid = val;\r\n    }\r\n    /**\r\n     * Current list of graphics for this tile\r\n     */\r\n    getGraphics() {\r\n        return this._graphics;\r\n    }\r\n    /**\r\n     * Add another [[Graphic]] to this TileMap tile\r\n     * @param graphic\r\n     */\r\n    addGraphic(graphic) {\r\n        this._graphics.push(graphic);\r\n    }\r\n    /**\r\n     * Remove an instance of a [[Graphic]] from this tile\r\n     */\r\n    removeGraphic(graphic) {\r\n        removeItemFromArray(graphic, this._graphics);\r\n    }\r\n    /**\r\n     * Clear all graphics from this tile\r\n     */\r\n    clearGraphics() {\r\n        this._graphics.length = 0;\r\n    }\r\n    /**\r\n     * Returns the list of colliders\r\n     */\r\n    getColliders() {\r\n        return this._colliders;\r\n    }\r\n    /**\r\n     * Adds a custom collider to the [[Tile]] to use instead of it's bounds\r\n     *\r\n     * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.\r\n     *\r\n     * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n     * @param collider\r\n     */\r\n    addCollider(collider) {\r\n        this._colliders.push(collider);\r\n        this.map.flagCollidersDirty();\r\n    }\r\n    /**\r\n     * Removes a collider from the [[Tile]]\r\n     * @param collider\r\n     */\r\n    removeCollider(collider) {\r\n        const index = this._colliders.indexOf(collider);\r\n        if (index > -1) {\r\n            this._colliders.splice(index, 1);\r\n        }\r\n        this.map.flagCollidersDirty();\r\n    }\r\n    /**\r\n     * Clears all colliders from the [[Tile]]\r\n     */\r\n    clearColliders() {\r\n        this._colliders.length = 0;\r\n        this.map.flagCollidersDirty();\r\n    }\r\n    flagDirty() {\r\n        return this._posDirty = true;\r\n    }\r\n    _recalculate() {\r\n        this._pos = this.map.pos.add(vec(this.x * this.map.tileWidth, this.y * this.map.tileHeight));\r\n        this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);\r\n        this._posDirty = false;\r\n    }\r\n    get bounds() {\r\n        if (this._posDirty) {\r\n            this._recalculate();\r\n        }\r\n        return this._bounds;\r\n    }\r\n    get center() {\r\n        if (this._posDirty) {\r\n            this._recalculate();\r\n        }\r\n        return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Camera.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Container to house convenience strategy methods\r\n * @internal\r\n */\r\nclass StrategyContainer {\r\n    constructor(camera) {\r\n        this.camera = camera;\r\n    }\r\n    /**\r\n     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n     * @param actor The actor to lock the camera to\r\n     */\r\n    lockToActor(actor) {\r\n        this.camera.addStrategy(new LockCameraToActorStrategy(actor));\r\n    }\r\n    /**\r\n     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n     * @param actor The actor to lock the camera to\r\n     * @param axis The axis to follow the actor on\r\n     */\r\n    lockToActorAxis(actor, axis) {\r\n        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\r\n    }\r\n    /**\r\n     * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n     * correct and bounce around the target\r\n     *\r\n     * @param actor Target actor to elastically follow\r\n     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n     */\r\n    elasticToActor(actor, cameraElasticity, cameraFriction) {\r\n        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\r\n    }\r\n    /**\r\n     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n     * @param actor Target actor to follow when it is \"radius\" pixels away\r\n     * @param radius Number of pixels away before the camera will follow\r\n     */\r\n    radiusAroundActor(actor, radius) {\r\n        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\r\n    }\r\n    /**\r\n     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera\r\n     * @param box The bounding box to limit the camera to.\r\n     */\r\n    limitCameraBounds(box) {\r\n        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));\r\n    }\r\n}\r\n/**\r\n * Camera axis enum\r\n */\r\nvar Axis;\r\n(function (Axis) {\r\n    Axis[Axis[\"X\"] = 0] = \"X\";\r\n    Axis[Axis[\"Y\"] = 1] = \"Y\";\r\n})(Axis || (Axis = {}));\r\n/**\r\n * Lock a camera to the exact x/y position of an actor.\r\n */\r\nclass LockCameraToActorStrategy {\r\n    constructor(target) {\r\n        this.target = target;\r\n        this.action = (target, _cam, _eng, _delta) => {\r\n            const center = target.center;\r\n            return center;\r\n        };\r\n    }\r\n}\r\n/**\r\n * Lock a camera to a specific axis around an actor.\r\n */\r\nclass LockCameraToActorAxisStrategy {\r\n    constructor(target, axis) {\r\n        this.target = target;\r\n        this.axis = axis;\r\n        this.action = (target, cam, _eng, _delta) => {\r\n            const center = target.center;\r\n            const currentFocus = cam.getFocus();\r\n            if (this.axis === Axis.X) {\r\n                return new Vector(center.x, currentFocus.y);\r\n            }\r\n            else {\r\n                return new Vector(currentFocus.x, center.y);\r\n            }\r\n        };\r\n    }\r\n}\r\n/**\r\n * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.\r\n */\r\nclass ElasticToActorStrategy {\r\n    /**\r\n     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n     * correct and bounce around the target\r\n     *\r\n     * @param target Target actor to elastically follow\r\n     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n     */\r\n    constructor(target, cameraElasticity, cameraFriction) {\r\n        this.target = target;\r\n        this.cameraElasticity = cameraElasticity;\r\n        this.cameraFriction = cameraFriction;\r\n        this.action = (target, cam, _eng, _delta) => {\r\n            const position = target.center;\r\n            let focus = cam.getFocus();\r\n            let cameraVel = cam.vel.clone();\r\n            // Calculate the stretch vector, using the spring equation\r\n            // F = kX\r\n            // https://en.wikipedia.org/wiki/Hooke's_law\r\n            // Apply to the current camera velocity\r\n            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X\r\n            cameraVel = cameraVel.add(stretch);\r\n            // Calculate the friction (-1 to apply a force in the opposition of motion)\r\n            // Apply to the current camera velocity\r\n            const friction = cameraVel.scale(-1).scale(this.cameraFriction);\r\n            cameraVel = cameraVel.add(friction);\r\n            // Update position by velocity deltas\r\n            focus = focus.add(cameraVel);\r\n            return focus;\r\n        };\r\n    }\r\n}\r\nclass RadiusAroundActorStrategy {\r\n    /**\r\n     *\r\n     * @param target Target actor to follow when it is \"radius\" pixels away\r\n     * @param radius Number of pixels away before the camera will follow\r\n     */\r\n    constructor(target, radius) {\r\n        this.target = target;\r\n        this.radius = radius;\r\n        this.action = (target, cam, _eng, _delta) => {\r\n            const position = target.center;\r\n            const focus = cam.getFocus();\r\n            const direction = position.sub(focus);\r\n            const distance = direction.size;\r\n            if (distance >= this.radius) {\r\n                const offset = distance - this.radius;\r\n                return focus.add(direction.normalize().scale(offset));\r\n            }\r\n            return focus;\r\n        };\r\n    }\r\n}\r\n/**\r\n * Prevent a camera from going beyond the given camera dimensions.\r\n */\r\nclass LimitCameraBoundsStrategy {\r\n    constructor(target) {\r\n        this.target = target;\r\n        /**\r\n         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.\r\n         *\r\n         * Note that this strategy does not perform any movement by itself.\r\n         * It only sets the camera position to within the given bounds when the camera has gone beyond them.\r\n         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.\r\n         *\r\n         * Make sure that the camera bounds are at least as large as the viewport size.\r\n         *\r\n         * @param target The bounding box to limit the camera to\r\n         */\r\n        this.boundSizeChecked = false; // Check and warn only once\r\n        this.action = (target, cam, _eng, _delta) => {\r\n            const focus = cam.getFocus();\r\n            if (!this.boundSizeChecked) {\r\n                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {\r\n                    Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');\r\n                }\r\n                this.boundSizeChecked = true;\r\n            }\r\n            let focusX = focus.x;\r\n            let focusY = focus.y;\r\n            if (focus.x < target.left + _eng.halfDrawWidth) {\r\n                focusX = target.left + _eng.halfDrawWidth;\r\n            }\r\n            else if (focus.x > target.right - _eng.halfDrawWidth) {\r\n                focusX = target.right - _eng.halfDrawWidth;\r\n            }\r\n            if (focus.y < target.top + _eng.halfDrawHeight) {\r\n                focusY = target.top + _eng.halfDrawHeight;\r\n            }\r\n            else if (focus.y > target.bottom - _eng.halfDrawHeight) {\r\n                focusY = target.bottom - _eng.halfDrawHeight;\r\n            }\r\n            return vec(focusX, focusY);\r\n        };\r\n    }\r\n}\r\n/**\r\n * Cameras\r\n *\r\n * [[Camera]] is the base class for all Excalibur cameras. Cameras are used\r\n * to move around your game and set focus. They are used to determine\r\n * what is \"off screen\" and can be used to scale the game.\r\n *\r\n */\r\nclass Camera extends Class {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.transform = AffineMatrix.identity();\r\n        this.inverse = AffineMatrix.identity();\r\n        this._cameraStrategies = [];\r\n        this.strategy = new StrategyContainer(this);\r\n        /**\r\n         * Get or set current zoom of the camera, defaults to 1\r\n         */\r\n        this._z = 1;\r\n        /**\r\n         * Get or set rate of change in zoom, defaults to 0\r\n         */\r\n        this.dz = 0;\r\n        /**\r\n         * Get or set zoom acceleration\r\n         */\r\n        this.az = 0;\r\n        /**\r\n         * Current rotation of the camera\r\n         */\r\n        this.rotation = 0;\r\n        this._angularVelocity = 0;\r\n        /**\r\n         * Get or set the camera's position\r\n         */\r\n        this._posChanged = false;\r\n        this._pos = watchAny(Vector.Zero, () => (this._posChanged = true));\r\n        /**\r\n         * Get or set the camera's velocity\r\n         */\r\n        this.vel = Vector.Zero;\r\n        /**\r\n         * Get or set the camera's acceleration\r\n         */\r\n        this.acc = Vector.Zero;\r\n        this._cameraMoving = false;\r\n        this._currentLerpTime = 0;\r\n        this._lerpDuration = 1000; // 1 second\r\n        this._lerpStart = null;\r\n        this._lerpEnd = null;\r\n        //camera effects\r\n        this._isShaking = false;\r\n        this._shakeMagnitudeX = 0;\r\n        this._shakeMagnitudeY = 0;\r\n        this._shakeDuration = 0;\r\n        this._elapsedShakeTime = 0;\r\n        this._xShake = 0;\r\n        this._yShake = 0;\r\n        this._isZooming = false;\r\n        this._zoomStart = 1;\r\n        this._zoomEnd = 1;\r\n        this._currentZoomTime = 0;\r\n        this._zoomDuration = 0;\r\n        this._zoomEasing = EasingFunctions.EaseInOutCubic;\r\n        this._easing = EasingFunctions.EaseInOutCubic;\r\n        this._halfWidth = 0;\r\n        this._halfHeight = 0;\r\n        this._viewport = null;\r\n        this._isInitialized = false;\r\n    }\r\n    get zoom() {\r\n        return this._z;\r\n    }\r\n    set zoom(val) {\r\n        this._z = val;\r\n        if (this._engine) {\r\n            this._halfWidth = this._engine.halfDrawWidth;\r\n            this._halfHeight = this._engine.halfDrawHeight;\r\n        }\r\n    }\r\n    /**\r\n     * Get or set the camera's angular velocity\r\n     */\r\n    get angularVelocity() {\r\n        return this._angularVelocity;\r\n    }\r\n    set angularVelocity(value) {\r\n        this._angularVelocity = value;\r\n    }\r\n    get pos() {\r\n        return this._pos;\r\n    }\r\n    set pos(vec) {\r\n        this._pos = watchAny(vec, () => (this._posChanged = true));\r\n        this._posChanged = true;\r\n    }\r\n    /**\r\n     * Get the camera's x position\r\n     */\r\n    get x() {\r\n        return this.pos.x;\r\n    }\r\n    /**\r\n     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)\r\n     */\r\n    set x(value) {\r\n        if (!this._follow && !this._cameraMoving) {\r\n            this.pos = vec(value, this.pos.y);\r\n        }\r\n    }\r\n    /**\r\n     * Get the camera's y position\r\n     */\r\n    get y() {\r\n        return this.pos.y;\r\n    }\r\n    /**\r\n     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)\r\n     */\r\n    set y(value) {\r\n        if (!this._follow && !this._cameraMoving) {\r\n            this.pos = vec(this.pos.x, value);\r\n        }\r\n    }\r\n    /**\r\n     * Get or set the camera's x velocity\r\n     */\r\n    get dx() {\r\n        return this.vel.x;\r\n    }\r\n    set dx(value) {\r\n        this.vel = vec(value, this.vel.y);\r\n    }\r\n    /**\r\n     * Get or set the camera's y velocity\r\n     */\r\n    get dy() {\r\n        return this.vel.y;\r\n    }\r\n    set dy(value) {\r\n        this.vel = vec(this.vel.x, value);\r\n    }\r\n    /**\r\n     * Get or set the camera's x acceleration\r\n     */\r\n    get ax() {\r\n        return this.acc.x;\r\n    }\r\n    set ax(value) {\r\n        this.acc = vec(value, this.acc.y);\r\n    }\r\n    /**\r\n     * Get or set the camera's y acceleration\r\n     */\r\n    get ay() {\r\n        return this.acc.y;\r\n    }\r\n    set ay(value) {\r\n        this.acc = vec(this.acc.x, value);\r\n    }\r\n    /**\r\n     * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n     */\r\n    getFocus() {\r\n        return this.pos;\r\n    }\r\n    /**\r\n     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n     *\r\n     * @param pos The target position to move to\r\n     * @param duration The duration in milliseconds the move should last\r\n     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.\r\n     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n     */\r\n    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {\r\n        if (typeof easingFn !== 'function') {\r\n            throw 'Please specify an EasingFunction';\r\n        }\r\n        // cannot move when following an actor\r\n        if (this._follow) {\r\n            return Promise.reject(pos);\r\n        }\r\n        // resolve existing promise, if any\r\n        if (this._lerpPromise && this._lerpResolve) {\r\n            this._lerpResolve(pos);\r\n        }\r\n        this._lerpPromise = new Promise((resolve) => {\r\n            this._lerpResolve = resolve;\r\n        });\r\n        this._lerpStart = this.getFocus().clone();\r\n        this._lerpDuration = duration;\r\n        this._lerpEnd = pos;\r\n        this._currentLerpTime = 0;\r\n        this._cameraMoving = true;\r\n        this._easing = easingFn;\r\n        return this._lerpPromise;\r\n    }\r\n    /**\r\n     * Sets the camera to shake at the specified magnitudes for the specified duration\r\n     * @param magnitudeX  The x magnitude of the shake\r\n     * @param magnitudeY  The y magnitude of the shake\r\n     * @param duration    The duration of the shake in milliseconds\r\n     */\r\n    shake(magnitudeX, magnitudeY, duration) {\r\n        this._isShaking = true;\r\n        this._shakeMagnitudeX = magnitudeX;\r\n        this._shakeMagnitudeY = magnitudeY;\r\n        this._shakeDuration = duration;\r\n    }\r\n    /**\r\n     * Zooms the camera in or out by the specified scale over the specified duration.\r\n     * If no duration is specified, it take effect immediately.\r\n     * @param scale    The scale of the zoom\r\n     * @param duration The duration of the zoom in milliseconds\r\n     */\r\n    zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {\r\n        this._zoomPromise = new Promise((resolve) => {\r\n            this._zoomResolve = resolve;\r\n        });\r\n        if (duration) {\r\n            this._isZooming = true;\r\n            this._zoomEasing = easingFn;\r\n            this._currentZoomTime = 0;\r\n            this._zoomDuration = duration;\r\n            this._zoomStart = this.zoom;\r\n            this._zoomEnd = scale;\r\n        }\r\n        else {\r\n            this._isZooming = false;\r\n            this.zoom = scale;\r\n            return Promise.resolve(true);\r\n        }\r\n        return this._zoomPromise;\r\n    }\r\n    /**\r\n     * Gets the bounding box of the viewport of this camera in world coordinates\r\n     */\r\n    get viewport() {\r\n        if (this._viewport) {\r\n            return this._viewport;\r\n        }\r\n        return new BoundingBox(0, 0, 0, 0);\r\n    }\r\n    /**\r\n     * Adds a new camera strategy to this camera\r\n     * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n     */\r\n    addStrategy(cameraStrategy) {\r\n        this._cameraStrategies.push(cameraStrategy);\r\n    }\r\n    /**\r\n     * Removes a camera strategy by reference\r\n     * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n     */\r\n    removeStrategy(cameraStrategy) {\r\n        removeItemFromArray(cameraStrategy, this._cameraStrategies);\r\n    }\r\n    /**\r\n     * Clears all camera strategies from the camera\r\n     */\r\n    clearAllStrategies() {\r\n        this._cameraStrategies.length = 0;\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _preupdate(engine, delta) {\r\n        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n        this.onPreUpdate(engine, delta);\r\n    }\r\n    /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before a scene is updated.\r\n     */\r\n    onPreUpdate(_engine, _delta) {\r\n        // Overridable\r\n    }\r\n    /**\r\n     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _postupdate(engine, delta) {\r\n        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n        this.onPostUpdate(engine, delta);\r\n    }\r\n    /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after a scene is updated.\r\n     */\r\n    onPostUpdate(_engine, _delta) {\r\n        // Overridable\r\n    }\r\n    get isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n    _initialize(_engine) {\r\n        if (!this.isInitialized) {\r\n            this._engine = _engine;\r\n            this._screen = _engine.screen;\r\n            const currentRes = this._screen.resolution;\r\n            let center = vec(currentRes.width / 2, currentRes.height / 2);\r\n            if (!this._engine.loadingComplete) {\r\n                // If there was a loading screen, we peek the configured resolution\r\n                const res = this._screen.peekResolution();\r\n                if (res) {\r\n                    center = vec(res.width / 2, res.height / 2);\r\n                }\r\n            }\r\n            this._halfWidth = center.x;\r\n            this._halfHeight = center.y;\r\n            // If the user has not set the camera pos, apply default center screen position\r\n            if (!this._posChanged) {\r\n                this.pos = center;\r\n            }\r\n            // First frame bootstrap\r\n            // Ensure camera tx is correct\r\n            // Run update twice to ensure properties are init'd\r\n            this.updateTransform();\r\n            // Run strategies for first frame\r\n            this.runStrategies(_engine, _engine.clock.elapsed());\r\n            // Setup the first frame viewport\r\n            this.updateViewport();\r\n            // It's important to update the camera after strategies\r\n            // This prevents jitter\r\n            this.updateTransform();\r\n            this.onInitialize(_engine);\r\n            super.emit('initialize', new InitializeEvent(_engine, this));\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n    /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after a scene is updated.\r\n     */\r\n    onInitialize(_engine) {\r\n        // Overridable\r\n    }\r\n    on(eventName, handler) {\r\n        super.on(eventName, handler);\r\n    }\r\n    off(eventName, handler) {\r\n        super.off(eventName, handler);\r\n    }\r\n    once(eventName, handler) {\r\n        super.once(eventName, handler);\r\n    }\r\n    runStrategies(engine, delta) {\r\n        for (const s of this._cameraStrategies) {\r\n            this.pos = s.action.call(s, s.target, this, engine, delta);\r\n        }\r\n    }\r\n    updateViewport() {\r\n        // recalc viewport\r\n        this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);\r\n    }\r\n    update(_engine, delta) {\r\n        this._initialize(_engine);\r\n        this._preupdate(_engine, delta);\r\n        // Update placements based on linear algebra\r\n        this.pos = this.pos.add(this.vel.scale(delta / 1000));\r\n        this.zoom += (this.dz * delta) / 1000;\r\n        this.vel = this.vel.add(this.acc.scale(delta / 1000));\r\n        this.dz += (this.az * delta) / 1000;\r\n        this.rotation += (this.angularVelocity * delta) / 1000;\r\n        if (this._isZooming) {\r\n            if (this._currentZoomTime < this._zoomDuration) {\r\n                const zoomEasing = this._zoomEasing;\r\n                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);\r\n                this.zoom = newZoom;\r\n                this._currentZoomTime += delta;\r\n            }\r\n            else {\r\n                this._isZooming = false;\r\n                this.zoom = this._zoomEnd;\r\n                this._currentZoomTime = 0;\r\n                this._zoomResolve(true);\r\n            }\r\n        }\r\n        if (this._cameraMoving) {\r\n            if (this._currentLerpTime < this._lerpDuration) {\r\n                const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);\r\n                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);\r\n                this.pos = lerpPoint;\r\n                this._currentLerpTime += delta;\r\n            }\r\n            else {\r\n                this.pos = this._lerpEnd;\r\n                const end = this._lerpEnd.clone();\r\n                this._lerpStart = null;\r\n                this._lerpEnd = null;\r\n                this._currentLerpTime = 0;\r\n                this._cameraMoving = false;\r\n                // Order matters here, resolve should be last so any chain promises have a clean slate\r\n                this._lerpResolve(end);\r\n            }\r\n        }\r\n        if (this._isDoneShaking()) {\r\n            this._isShaking = false;\r\n            this._elapsedShakeTime = 0;\r\n            this._shakeMagnitudeX = 0;\r\n            this._shakeMagnitudeY = 0;\r\n            this._shakeDuration = 0;\r\n            this._xShake = 0;\r\n            this._yShake = 0;\r\n        }\r\n        else {\r\n            this._elapsedShakeTime += delta;\r\n            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;\r\n            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;\r\n        }\r\n        this.runStrategies(_engine, delta);\r\n        this.updateViewport();\r\n        // It's important to update the camera after strategies\r\n        // This prevents jitter\r\n        this.updateTransform();\r\n        this._postupdate(_engine, delta);\r\n    }\r\n    /**\r\n     * Applies the relevant transformations to the game canvas to \"move\" or apply effects to the Camera\r\n     * @param ctx Canvas context to apply transformations\r\n     */\r\n    draw(ctx) {\r\n        ctx.multiply(this.transform);\r\n    }\r\n    updateTransform() {\r\n        // center the camera\r\n        const newCanvasWidth = this._screen.resolution.width / this.zoom;\r\n        const newCanvasHeight = this._screen.resolution.height / this.zoom;\r\n        const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);\r\n        // Calculate camera transform\r\n        this.transform.reset();\r\n        this.transform.scale(this.zoom, this.zoom);\r\n        this.transform.translate(cameraPos.x, cameraPos.y);\r\n        this.transform.inverse(this.inverse);\r\n    }\r\n    _isDoneShaking() {\r\n        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Trigger.ts\n\r\n\r\n\r\n\r\n\r\nconst triggerDefaults = {\r\n    pos: Vector.Zero,\r\n    width: 10,\r\n    height: 10,\r\n    visible: false,\r\n    action: () => {\r\n        return;\r\n    },\r\n    filter: () => true,\r\n    repeat: -1\r\n};\r\n/**\r\n * Triggers are a method of firing arbitrary code on collision. These are useful\r\n * as 'buttons', 'switches', or to trigger effects in a game. By default triggers\r\n * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\r\n */\r\nclass Trigger extends Actor {\r\n    /**\r\n     *\r\n     * @param opts Trigger options\r\n     */\r\n    constructor(opts) {\r\n        super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });\r\n        /**\r\n         * Action to fire when triggered by collision\r\n         */\r\n        this.action = () => {\r\n            return;\r\n        };\r\n        /**\r\n         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\r\n         * filter return true for the collided actor.\r\n         */\r\n        this.filter = () => true;\r\n        /**\r\n         * Number of times to repeat before killing the trigger,\r\n         */\r\n        this.repeat = -1;\r\n        opts = {\r\n            ...triggerDefaults,\r\n            ...opts\r\n        };\r\n        this.filter = opts.filter || this.filter;\r\n        this.repeat = opts.repeat || this.repeat;\r\n        this.action = opts.action || this.action;\r\n        if (opts.target) {\r\n            this.target = opts.target;\r\n        }\r\n        this.graphics.visible = opts.visible;\r\n        this.body.collisionType = CollisionType.Passive;\r\n        this.eventDispatcher = new EventDispatcher();\r\n        this.events.on('collisionstart', (evt) => {\r\n            if (this.filter(evt.other)) {\r\n                this.emit('enter', new EnterTriggerEvent(this, evt.other));\r\n                this._dispatchAction();\r\n                // remove trigger if its done, -1 repeat forever\r\n                if (this.repeat === 0) {\r\n                    this.kill();\r\n                }\r\n            }\r\n        });\r\n        this.events.on('collisionend', (evt) => {\r\n            if (this.filter(evt.other)) {\r\n                this.emit('exit', new ExitTriggerEvent(this, evt.other));\r\n            }\r\n        });\r\n    }\r\n    set target(target) {\r\n        this._target = target;\r\n        this.filter = (actor) => actor === target;\r\n    }\r\n    get target() {\r\n        return this._target;\r\n    }\r\n    _initialize(engine) {\r\n        super._initialize(engine);\r\n    }\r\n    _dispatchAction() {\r\n        if (this.repeat !== 0) {\r\n            this.action.call(this);\r\n            this.repeat--;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/System.ts\n/**\r\n * Enum that determines whether to run the system in the update or draw phase\r\n */\r\nvar SystemType;\r\n(function (SystemType) {\r\n    SystemType[\"Update\"] = \"update\";\r\n    SystemType[\"Draw\"] = \"draw\";\r\n})(SystemType || (SystemType = {}));\r\n/**\r\n * An Excalibur [[System]] that updates entities of certain types.\r\n * Systems are scene specific\r\n *\r\n * Excalibur Systems currently require at least 1 Component type to operated\r\n *\r\n * Multiple types are declared as a type union\r\n * For example:\r\n *\r\n * ```typescript\r\n * class MySystem extends System<ComponentA | ComponentB> {\r\n *   public readonly types = ['a', 'b'] as const;\r\n *   public readonly systemType = SystemType.Update;\r\n *   public update(entities: Entity<ComponentA | ComponentB>) {\r\n *      ...\r\n *   }\r\n * }\r\n * ```\r\n */\r\nclass System {\r\n    constructor() {\r\n        /**\r\n         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.\r\n         * For a system to execute before all other a lower priority value (-1 for example) must be set.\r\n         * For a system to execute after all other a higher priority value (10 for example) must be set.\r\n         */\r\n        this.priority = 0;\r\n    }\r\n    /**\r\n     * Systems observe when entities match their types or no longer match their types, override\r\n     * @param _entityAddedOrRemoved\r\n     */\r\n    notify(_entityAddedOrRemoved) {\r\n        // Override me\r\n    }\r\n}\r\n/**\r\n * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.\r\n */\r\nclass AddedEntity {\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.type = 'Entity Added';\r\n    }\r\n}\r\n/**\r\n * Type guard to check for AddedEntity messages\r\n * @param x\r\n */\r\nfunction isAddedSystemEntity(x) {\r\n    return !!x && x.type === 'Entity Added';\r\n}\r\n/**\r\n * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.\r\n */\r\nclass RemovedEntity {\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.type = 'Entity Removed';\r\n    }\r\n}\r\n/**\r\n * type guard to check for the RemovedEntity message\r\n */\r\nfunction isRemoveSystemEntity(x) {\r\n    return !!x && x.type === 'Entity Removed';\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/EntityManager.ts\n\r\n\r\n// Add/Remove entities and components\r\nclass EntityManager {\r\n    constructor(_world) {\r\n        this._world = _world;\r\n        this.entities = [];\r\n        this._entityIndex = {};\r\n        this._entitiesToRemove = [];\r\n    }\r\n    /**\r\n     * Runs the entity lifecycle\r\n     * @param _context\r\n     */\r\n    updateEntities(_context, elapsed) {\r\n        for (const entity of this.entities) {\r\n            // TODO is this right?\r\n            entity.update(_context.engine, elapsed);\r\n            if (!entity.active) {\r\n                this.removeEntity(entity);\r\n            }\r\n        }\r\n    }\r\n    findEntitiesForRemoval() {\r\n        for (const entity of this.entities) {\r\n            if (!entity.active) {\r\n                this.removeEntity(entity);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * EntityManager observes changes on entities\r\n     * @param message\r\n     */\r\n    notify(message) {\r\n        if (isAddedComponent(message)) {\r\n            // we don't need the component, it's already on the entity\r\n            this._world.queryManager.addEntity(message.data.entity);\r\n        }\r\n        if (isRemovedComponent(message)) {\r\n            this._world.queryManager.removeComponent(message.data.entity, message.data.component);\r\n        }\r\n    }\r\n    /**\r\n     * Adds an entity to be tracked by the EntityManager\r\n     * @param entity\r\n     */\r\n    addEntity(entity) {\r\n        entity.active = true;\r\n        if (entity && !this._entityIndex[entity.id]) {\r\n            this._entityIndex[entity.id] = entity;\r\n            this.entities.push(entity);\r\n            this._world.queryManager.addEntity(entity);\r\n            entity.componentAdded$.register(this);\r\n            entity.componentRemoved$.register(this);\r\n            // if entity has children\r\n            entity.children.forEach((c) => this.addEntity(c));\r\n            entity.childrenAdded$.register({\r\n                notify: (e) => {\r\n                    this.addEntity(e);\r\n                }\r\n            });\r\n            entity.childrenRemoved$.register({\r\n                notify: (e) => {\r\n                    this.removeEntity(e, false);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    removeEntity(idOrEntity, deferred = true) {\r\n        var _a;\r\n        let id = 0;\r\n        if (idOrEntity instanceof Entity) {\r\n            id = idOrEntity.id;\r\n        }\r\n        else {\r\n            id = idOrEntity;\r\n        }\r\n        const entity = this._entityIndex[id];\r\n        if (entity && entity.active) {\r\n            entity.kill();\r\n        }\r\n        if (entity && deferred) {\r\n            this._entitiesToRemove.push(entity);\r\n            return;\r\n        }\r\n        delete this._entityIndex[id];\r\n        if (entity) {\r\n            removeItemFromArray(entity, this.entities);\r\n            this._world.queryManager.removeEntity(entity);\r\n            entity.componentAdded$.unregister(this);\r\n            entity.componentRemoved$.unregister(this);\r\n            // if entity has children\r\n            entity.children.forEach((c) => this.removeEntity(c, deferred));\r\n            entity.childrenAdded$.clear();\r\n            entity.childrenRemoved$.clear();\r\n            // stats\r\n            if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {\r\n                this._world.context.engine.stats.currFrame.actors.killed++;\r\n            }\r\n        }\r\n    }\r\n    processEntityRemovals() {\r\n        for (const entity of this._entitiesToRemove) {\r\n            if (entity.active) {\r\n                continue;\r\n            }\r\n            this.removeEntity(entity, false);\r\n        }\r\n    }\r\n    processComponentRemovals() {\r\n        for (const entity of this.entities) {\r\n            entity.processComponentRemoval();\r\n        }\r\n    }\r\n    getById(id) {\r\n        return this._entityIndex[id];\r\n    }\r\n    getByName(name) {\r\n        return this.entities.filter(e => e.name === name);\r\n    }\r\n    clear() {\r\n        for (const entity of this.entities) {\r\n            this.removeEntity(entity);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/Util.ts\nconst buildTypeKey = (types) => {\r\n    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');\r\n    return key;\r\n};\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/Query.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Represents query for entities that match a list of types that is cached and observable\r\n *\r\n * Queries can be strongly typed by supplying a type union in the optional type parameter\r\n * ```typescript\r\n * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);\r\n * ```\r\n */\r\nclass Query extends Observable {\r\n    constructor(types) {\r\n        super();\r\n        this._entities = [];\r\n        if (types[0] instanceof Function) {\r\n            this.types = types.map(T => (new T).type);\r\n        }\r\n        else {\r\n            this.types = types;\r\n        }\r\n    }\r\n    get key() {\r\n        if (this._key) {\r\n            return this._key;\r\n        }\r\n        return (this._key = buildTypeKey(this.types));\r\n    }\r\n    /**\r\n     * Returns a list of entities that match the query\r\n     *\r\n     * @param sort Optional sorting function to sort entities returned from the query\r\n     */\r\n    getEntities(sort) {\r\n        if (sort) {\r\n            this._entities.sort(sort);\r\n        }\r\n        return this._entities;\r\n    }\r\n    /**\r\n     * Add an entity to the query, will only be added if the entity matches the query types\r\n     * @param entity\r\n     */\r\n    addEntity(entity) {\r\n        if (!contains(this._entities, entity) && this.matches(entity)) {\r\n            this._entities.push(entity);\r\n            this.notifyAll(new AddedEntity(entity));\r\n        }\r\n    }\r\n    /**\r\n     * If the entity is part of the query it will be removed regardless of types\r\n     * @param entity\r\n     */\r\n    removeEntity(entity) {\r\n        if (removeItemFromArray(entity, this._entities)) {\r\n            this.notifyAll(new RemovedEntity(entity));\r\n        }\r\n    }\r\n    /**\r\n     * Removes all entities and observers from the query\r\n     */\r\n    clear() {\r\n        this._entities.length = 0;\r\n        for (const observer of this.observers) {\r\n            this.unregister(observer);\r\n        }\r\n    }\r\n    matches(typesOrEntity) {\r\n        let types = [];\r\n        if (typesOrEntity instanceof Entity) {\r\n            types = typesOrEntity.types;\r\n        }\r\n        else {\r\n            types = typesOrEntity;\r\n        }\r\n        let matches = true;\r\n        for (const type of this.types) {\r\n            matches = matches && types.indexOf(type) > -1;\r\n            if (!matches) {\r\n                return false;\r\n            }\r\n        }\r\n        return matches;\r\n    }\r\n    contain(type) {\r\n        return this.types.indexOf(type) > -1;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/QueryManager.ts\n\r\n\r\n/**\r\n * The query manager is responsible for updating all queries when entities/components change\r\n */\r\nclass QueryManager {\r\n    constructor(_world) {\r\n        this._world = _world;\r\n        this._queries = {};\r\n    }\r\n    /**\r\n     * Adds a query to the manager and populates with any entities that match\r\n     * @param query\r\n     */\r\n    _addQuery(query) {\r\n        this._queries[buildTypeKey(query.types)] = query;\r\n        for (const entity of this._world.entityManager.entities) {\r\n            query.addEntity(entity);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the query if there are no observers left\r\n     * @param query\r\n     */\r\n    maybeRemoveQuery(query) {\r\n        if (query.observers.length === 0) {\r\n            query.clear();\r\n            delete this._queries[buildTypeKey(query.types)];\r\n        }\r\n    }\r\n    /**\r\n     * Adds the entity to any matching query in the query manage\r\n     * @param entity\r\n     */\r\n    addEntity(entity) {\r\n        for (const queryType in this._queries) {\r\n            if (this._queries[queryType]) {\r\n                this._queries[queryType].addEntity(entity);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Removes an entity from queries if the removed component disqualifies it\r\n     * @param entity\r\n     * @param component\r\n     */\r\n    removeComponent(entity, component) {\r\n        for (const queryType in this._queries) {\r\n            // If the component being removed from an entity is a part of a query,\r\n            // it is now disqualified from that query, remove it\r\n            if (this._queries[queryType].contain(component.type)) {\r\n                this._queries[queryType].removeEntity(entity);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Removes an entity from all queries it is currently a part of\r\n     * @param entity\r\n     */\r\n    removeEntity(entity) {\r\n        for (const queryType in this._queries) {\r\n            this._queries[queryType].removeEntity(entity);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance\r\n     * @param types\r\n     */\r\n    createQuery(types) {\r\n        const maybeExistingQuery = this.getQuery(types);\r\n        if (maybeExistingQuery) {\r\n            return maybeExistingQuery;\r\n        }\r\n        const query = new Query(types);\r\n        this._addQuery(query);\r\n        return query;\r\n    }\r\n    /**\r\n     * Retrieves an existing query by types if it exists otherwise returns null\r\n     * @param types\r\n     */\r\n    getQuery(types) {\r\n        const key = buildTypeKey(types);\r\n        if (this._queries[key]) {\r\n            return this._queries[key];\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/SystemManager.ts\n\r\n/**\r\n * The SystemManager is responsible for keeping track of all systems in a scene.\r\n * Systems are scene specific\r\n */\r\nclass SystemManager {\r\n    constructor(_world) {\r\n        this._world = _world;\r\n        /**\r\n         * List of systems, to add a new system call [[SystemManager.addSystem]]\r\n         */\r\n        this.systems = [];\r\n        this.initialized = false;\r\n    }\r\n    /**\r\n     * Get a system registered in the manager by type\r\n     * @param systemType\r\n     */\r\n    get(systemType) {\r\n        return this.systems.find((s) => s instanceof systemType);\r\n    }\r\n    /**\r\n     * Adds a system to the manager, it will now be updated every frame\r\n     * @param system\r\n     */\r\n    addSystem(system) {\r\n        // validate system has types\r\n        if (!system.types || system.types.length === 0) {\r\n            throw new Error(`Attempted to add a System without any types`);\r\n        }\r\n        const query = this._world.queryManager.createQuery(system.types);\r\n        this.systems.push(system);\r\n        this.systems.sort((a, b) => a.priority - b.priority);\r\n        query.register(system);\r\n        if (this.initialized && system.initialize) {\r\n            system.initialize(this._world.context);\r\n        }\r\n    }\r\n    /**\r\n     * Removes a system from the manager, it will no longer be updated\r\n     * @param system\r\n     */\r\n    removeSystem(system) {\r\n        removeItemFromArray(system, this.systems);\r\n        const query = this._world.queryManager.getQuery(system.types);\r\n        if (query) {\r\n            query.unregister(system);\r\n            this._world.queryManager.maybeRemoveQuery(query);\r\n        }\r\n    }\r\n    /**\r\n     * Initialize all systems in the manager\r\n     *\r\n     * Systems added after initialize() will be initialized on add\r\n     */\r\n    initialize() {\r\n        if (!this.initialized) {\r\n            this.initialized = true;\r\n            for (const s of this.systems) {\r\n                if (s.initialize) {\r\n                    s.initialize(this._world.context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Updates all systems\r\n     * @param type whether this is an update or draw system\r\n     * @param context context reference\r\n     * @param delta time in milliseconds\r\n     */\r\n    updateSystems(type, context, delta) {\r\n        const systems = this.systems.filter((s) => s.systemType === type);\r\n        for (const s of systems) {\r\n            if (s.preupdate) {\r\n                s.preupdate(context, delta);\r\n            }\r\n        }\r\n        for (const s of systems) {\r\n            // Get entities that match the system types, pre-sort\r\n            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);\r\n            // Initialize entities if needed\r\n            if (context instanceof Scene) {\r\n                for (const entity of entities) {\r\n                    entity._initialize(context === null || context === void 0 ? void 0 : context.engine);\r\n                }\r\n            }\r\n            s.update(entities, delta);\r\n        }\r\n        for (const s of systems) {\r\n            if (s.postupdate) {\r\n                s.postupdate(context, delta);\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        for (const system of this.systems) {\r\n            this.removeSystem(system);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/World.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The World is a self-contained entity component system for a particular context.\r\n */\r\nclass World {\r\n    /**\r\n     * The context type is passed to the system updates\r\n     * @param context\r\n     */\r\n    constructor(context) {\r\n        this.context = context;\r\n        this.queryManager = new QueryManager(this);\r\n        this.entityManager = new EntityManager(this);\r\n        this.systemManager = new SystemManager(this);\r\n    }\r\n    /**\r\n     * Update systems by type and time elapsed in milliseconds\r\n     */\r\n    update(type, delta) {\r\n        if (type === SystemType.Update) {\r\n            this.entityManager.updateEntities(this.context, delta);\r\n        }\r\n        this.systemManager.updateSystems(type, this.context, delta);\r\n        this.entityManager.findEntitiesForRemoval();\r\n        this.entityManager.processComponentRemovals();\r\n        this.entityManager.processEntityRemovals();\r\n    }\r\n    add(entityOrSystem) {\r\n        if (entityOrSystem instanceof Entity) {\r\n            this.entityManager.addEntity(entityOrSystem);\r\n        }\r\n        if (entityOrSystem instanceof System) {\r\n            this.systemManager.addSystem(entityOrSystem);\r\n        }\r\n    }\r\n    remove(entityOrSystem, deferred = true) {\r\n        if (entityOrSystem instanceof Entity) {\r\n            this.entityManager.removeEntity(entityOrSystem, deferred);\r\n        }\r\n        if (entityOrSystem instanceof System) {\r\n            this.systemManager.removeSystem(entityOrSystem);\r\n        }\r\n    }\r\n    clearEntities() {\r\n        this.entityManager.clear();\r\n    }\r\n    clearSystems() {\r\n        this.systemManager.clear();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Integrator.ts\n\r\nclass EulerIntegrator {\r\n    static integrate(transform, motion, totalAcc, elapsedMs) {\r\n        const seconds = elapsedMs / 1000;\r\n        // This code looks a little wild, but it's to avoid creating any new Vector instances\r\n        // integration is done in a tight loop so this is key to avoid GC'ing\r\n        motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));\r\n        transform.pos\r\n            .add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS)\r\n            .addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));\r\n        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;\r\n        const rotation = transform.rotation + motion.angularVelocity * seconds;\r\n        transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);\r\n        const tx = transform.get();\r\n        tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);\r\n    }\r\n}\r\n// Scratch vectors to avoid allocation\r\nEulerIntegrator._POS = new Vector(0, 0);\r\nEulerIntegrator._SCALE = new Vector(1, 1);\r\nEulerIntegrator._ACC = new Vector(0, 0);\r\nEulerIntegrator._VEL = new Vector(0, 0);\r\nEulerIntegrator._VEL_ACC = new Vector(0, 0);\r\nEulerIntegrator._SCALE_FACTOR = new Vector(0, 0);\r\n\n;// CONCATENATED MODULE: ./Collision/MotionSystem.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MotionSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform', 'ex.motion'];\r\n        this.systemType = SystemType.Update;\r\n        this.priority = -1;\r\n    }\r\n    update(entities, elapsedMs) {\r\n        let transform;\r\n        let motion;\r\n        for (let i = 0; i < entities.length; i++) {\r\n            transform = entities[i].get(TransformComponent);\r\n            motion = entities[i].get(MotionComponent);\r\n            const optionalBody = entities[i].get(BodyComponent);\r\n            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {\r\n                continue;\r\n            }\r\n            const totalAcc = motion.acc.clone();\r\n            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {\r\n                totalAcc.addEqual(Physics.gravity);\r\n            }\r\n            optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();\r\n            // Update transform and motion based on Euler linear algebra\r\n            EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Solver/ArcadeSolver.ts\n\r\n\r\n\r\n\r\n/**\r\n * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,\r\n * and negates velocity along the collision normal.\r\n *\r\n * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.\r\n *\r\n */\r\nclass ArcadeSolver {\r\n    constructor() {\r\n        this.directionMap = new Map();\r\n        this.distanceMap = new Map();\r\n    }\r\n    solve(contacts) {\r\n        // Events and init\r\n        this.preSolve(contacts);\r\n        // Remove any canceled contacts\r\n        contacts = contacts.filter(c => !c.isCanceled());\r\n        // Sort contacts by distance to avoid artifacts with seams\r\n        // It's important to solve in a specific order\r\n        contacts.sort((a, b) => {\r\n            const aDist = this.distanceMap.get(a.id);\r\n            const bDist = this.distanceMap.get(b.id);\r\n            return aDist - bDist;\r\n        });\r\n        for (const contact of contacts) {\r\n            // Solve position first in arcade\r\n            this.solvePosition(contact);\r\n            // Solve velocity second in arcade\r\n            this.solveVelocity(contact);\r\n        }\r\n        // Events and any contact house-keeping the solver needs\r\n        this.postSolve(contacts);\r\n        return contacts;\r\n    }\r\n    preSolve(contacts) {\r\n        for (const contact of contacts) {\r\n            const side = Side.fromDirection(contact.mtv);\r\n            const mtv = contact.mtv.negate();\r\n            const distance = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);\r\n            this.distanceMap.set(contact.id, distance);\r\n            // Publish collision events on both participants\r\n            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));\r\n        }\r\n    }\r\n    postSolve(contacts) {\r\n        var _a, _b;\r\n        for (const contact of contacts) {\r\n            if (contact.isCanceled()) {\r\n                continue;\r\n            }\r\n            const colliderA = contact.colliderA;\r\n            const colliderB = contact.colliderB;\r\n            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n            if (bodyA && bodyB) {\r\n                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n                    continue;\r\n                }\r\n            }\r\n            const side = Side.fromDirection(contact.mtv);\r\n            const mtv = contact.mtv.negate();\r\n            // Publish collision events on both participants\r\n            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));\r\n        }\r\n    }\r\n    solvePosition(contact) {\r\n        var _a, _b;\r\n        const epsilon = .0001;\r\n        // if bounds no longer intersect skip to the next\r\n        // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles\r\n        if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {\r\n            // Cancel the contact to prevent and solving\r\n            contact.cancel();\r\n            return;\r\n        }\r\n        if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {\r\n            // Cancel near 0 mtv collisions\r\n            contact.cancel();\r\n            return;\r\n        }\r\n        let mtv = contact.mtv;\r\n        const colliderA = contact.colliderA;\r\n        const colliderB = contact.colliderB;\r\n        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n        if (bodyA && bodyB) {\r\n            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n                return;\r\n            }\r\n            if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {\r\n                // split overlaps if both are Active\r\n                mtv = mtv.scale(0.5);\r\n            }\r\n            // Resolve overlaps\r\n            if (bodyA.collisionType === CollisionType.Active) {\r\n                bodyA.globalPos.x -= mtv.x;\r\n                bodyA.globalPos.y -= mtv.y;\r\n                colliderA.update(bodyA.transform.get());\r\n            }\r\n            if (bodyB.collisionType === CollisionType.Active) {\r\n                bodyB.globalPos.x += mtv.x;\r\n                bodyB.globalPos.y += mtv.y;\r\n                colliderB.update(bodyB.transform.get());\r\n            }\r\n        }\r\n    }\r\n    solveVelocity(contact) {\r\n        var _a, _b;\r\n        if (contact.isCanceled()) {\r\n            return;\r\n        }\r\n        const colliderA = contact.colliderA;\r\n        const colliderB = contact.colliderB;\r\n        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n        if (bodyA && bodyB) {\r\n            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n                return;\r\n            }\r\n            const normal = contact.normal;\r\n            const opposite = normal.negate();\r\n            if (bodyA.collisionType === CollisionType.Active) {\r\n                // only adjust velocity if the contact normal is opposite to the current velocity\r\n                // this avoids catching edges on a platform when sliding off\r\n                if (bodyA.vel.normalize().dot(opposite) < 0) {\r\n                    // Cancel out velocity opposite direction of collision normal\r\n                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));\r\n                    bodyA.vel = bodyA.vel.add(velAdj);\r\n                }\r\n            }\r\n            if (bodyB.collisionType === CollisionType.Active) {\r\n                // only adjust velocity if the contact normal is opposite to the current velocity\r\n                // this avoids catching edges on a platform\r\n                if (bodyB.vel.normalize().dot(normal) < 0) {\r\n                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));\r\n                    bodyB.vel = bodyB.vel.add(velAdj);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Solver/ContactConstraintPoint.ts\n\r\n\r\n/**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */\r\nclass ContactConstraintPoint {\r\n    constructor(point, local, contact) {\r\n        this.point = point;\r\n        this.local = local;\r\n        this.contact = contact;\r\n        /**\r\n         * Impulse accumulated over time in normal direction\r\n         */\r\n        this.normalImpulse = 0;\r\n        /**\r\n         * Impulse accumulated over time in the tangent direction\r\n         */\r\n        this.tangentImpulse = 0;\r\n        /**\r\n         * Effective mass seen in the normal direction\r\n         */\r\n        this.normalMass = 0;\r\n        /**\r\n         * Effective mass seen in the tangent direction\r\n         */\r\n        this.tangentMass = 0;\r\n        /**\r\n         * Direction from center of mass of bodyA to contact point\r\n         */\r\n        this.aToContact = new Vector(0, 0);\r\n        /**\r\n         * Direction from center of mass of bodyB to contact point\r\n         */\r\n        this.bToContact = new Vector(0, 0);\r\n        /**\r\n         * Original contact velocity combined with bounciness\r\n         */\r\n        this.originalVelocityAndRestitution = 0;\r\n        this.update();\r\n    }\r\n    /**\r\n     * Updates the contact information\r\n     */\r\n    update() {\r\n        var _a, _b;\r\n        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n        if (bodyA && bodyB) {\r\n            const normal = this.contact.normal;\r\n            const tangent = this.contact.tangent;\r\n            this.aToContact = this.point.sub(bodyA.globalPos);\r\n            this.bToContact = this.point.sub(bodyB.globalPos);\r\n            const aToContactNormal = this.aToContact.cross(normal);\r\n            const bToContactNormal = this.bToContact.cross(normal);\r\n            this.normalMass =\r\n                bodyA.inverseMass +\r\n                    bodyB.inverseMass +\r\n                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n            const aToContactTangent = this.aToContact.cross(tangent);\r\n            const bToContactTangent = this.bToContact.cross(tangent);\r\n            this.tangentMass =\r\n                bodyA.inverseMass +\r\n                    bodyB.inverseMass +\r\n                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the relative velocity between bodyA and bodyB\r\n     */\r\n    getRelativeVelocity() {\r\n        var _a, _b;\r\n        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n        if (bodyA && bodyB) {\r\n            // Relative velocity in linear terms\r\n            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\r\n            const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));\r\n            const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));\r\n            return velB.sub(velA);\r\n        }\r\n        return Vector.Zero;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/Solver/RealisticSolver.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass RealisticSolver {\r\n    constructor() {\r\n        this.lastFrameContacts = new Map();\r\n        // map contact id to contact points\r\n        this.idToContactConstraint = new Map();\r\n    }\r\n    getContactConstraints(id) {\r\n        var _a;\r\n        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n    solve(contacts) {\r\n        // Events and init\r\n        this.preSolve(contacts);\r\n        // Remove any canceled contacts\r\n        contacts = contacts.filter(c => !c.isCanceled());\r\n        // Solve velocity first\r\n        this.solveVelocity(contacts);\r\n        // Solve position last because non-overlap is the most important\r\n        this.solvePosition(contacts);\r\n        // Events and any contact house-keeping the solver needs\r\n        this.postSolve(contacts);\r\n        return contacts;\r\n    }\r\n    preSolve(contacts) {\r\n        var _a, _b, _c;\r\n        for (const contact of contacts) {\r\n            // Publish collision events on both participants\r\n            const side = Side.fromDirection(contact.mtv);\r\n            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n            contact.colliderA.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));\r\n            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));\r\n            contact.colliderB.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));\r\n            // Match awake state for sleeping\r\n            contact.matchAwake();\r\n        }\r\n        // Keep track of contacts that done\r\n        const finishedContactIds = Array.from(this.idToContactConstraint.keys());\r\n        for (const contact of contacts) {\r\n            // Remove all current contacts that are not done\r\n            const index = finishedContactIds.indexOf(contact.id);\r\n            if (index > -1) {\r\n                finishedContactIds.splice(index, 1);\r\n            }\r\n            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];\r\n            let pointIndex = 0;\r\n            const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n            const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n            if (bodyA && bodyB) {\r\n                for (const point of contact.points) {\r\n                    const normal = contact.normal;\r\n                    const tangent = contact.tangent;\r\n                    const aToContact = point.sub(bodyA.globalPos);\r\n                    const bToContact = point.sub(bodyB.globalPos);\r\n                    const aToContactNormal = aToContact.cross(normal);\r\n                    const bToContactNormal = bToContact.cross(normal);\r\n                    const normalMass = bodyA.inverseMass +\r\n                        bodyB.inverseMass +\r\n                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n                    const aToContactTangent = aToContact.cross(tangent);\r\n                    const bToContactTangent = bToContact.cross(tangent);\r\n                    const tangentMass = bodyA.inverseMass +\r\n                        bodyB.inverseMass +\r\n                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n                    // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {\r\n                        contactPoints[pointIndex].point = point;\r\n                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];\r\n                    }\r\n                    else {\r\n                        // new contact if it's not close or doesn't exist\r\n                        contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);\r\n                    }\r\n                    // Update contact point calculations\r\n                    contactPoints[pointIndex].aToContact = aToContact;\r\n                    contactPoints[pointIndex].bToContact = bToContact;\r\n                    contactPoints[pointIndex].normalMass = 1.0 / normalMass;\r\n                    contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;\r\n                    // Calculate relative velocity before solving to accurately do restitution\r\n                    const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;\r\n                    const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());\r\n                    contactPoints[pointIndex].originalVelocityAndRestitution = 0;\r\n                    if (relativeVelocity < -0.1) { // TODO what's a good threshold here?\r\n                        contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;\r\n                    }\r\n                    pointIndex++;\r\n                }\r\n            }\r\n            this.idToContactConstraint.set(contact.id, contactPoints);\r\n        }\r\n        // Clean up any contacts that did not occur last frame\r\n        for (const id of finishedContactIds) {\r\n            this.idToContactConstraint.delete(id);\r\n        }\r\n        // Warm contacts with accumulated impulse\r\n        // Useful for tall stacks\r\n        if (Physics.warmStart) {\r\n            this.warmStart(contacts);\r\n        }\r\n        else {\r\n            for (const contact of contacts) {\r\n                const contactPoints = this.getContactConstraints(contact.id);\r\n                for (const point of contactPoints) {\r\n                    point.normalImpulse = 0;\r\n                    point.tangentImpulse = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    postSolve(contacts) {\r\n        for (const contact of contacts) {\r\n            const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n            const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n            if (bodyA && bodyB) {\r\n                // Skip post solve for active+passive collisions\r\n                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n                    continue;\r\n                }\r\n                // Update motion values for sleeping\r\n                bodyA.updateMotion();\r\n                bodyB.updateMotion();\r\n            }\r\n            // Publish collision events on both participants\r\n            const side = Side.fromDirection(contact.mtv);\r\n            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n            contact.colliderA.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));\r\n            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));\r\n            contact.colliderB.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));\r\n        }\r\n        // Store contacts\r\n        this.lastFrameContacts.clear();\r\n        for (const c of contacts) {\r\n            this.lastFrameContacts.set(c.id, c);\r\n        }\r\n    }\r\n    /**\r\n     * Warm up body's based on previous frame contact points\r\n     * @param contacts\r\n     */\r\n    warmStart(contacts) {\r\n        var _a, _b, _c;\r\n        for (const contact of contacts) {\r\n            const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n            const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n            if (bodyA && bodyB) {\r\n                const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];\r\n                for (const point of contactPoints) {\r\n                    if (Physics.warmStart) {\r\n                        const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\r\n                        const impulse = normalImpulse.add(tangentImpulse);\r\n                        bodyA.applyImpulse(point.point, impulse.negate());\r\n                        bodyB.applyImpulse(point.point, impulse);\r\n                    }\r\n                    else {\r\n                        point.normalImpulse = 0;\r\n                        point.tangentImpulse = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Iteratively solve the position overlap constraint\r\n     * @param contacts\r\n     */\r\n    solvePosition(contacts) {\r\n        var _a, _b, _c;\r\n        for (let i = 0; i < Physics.positionIterations; i++) {\r\n            for (const contact of contacts) {\r\n                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n                if (bodyA && bodyB) {\r\n                    // Skip solving active+passive\r\n                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n                        continue;\r\n                    }\r\n                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];\r\n                    for (const point of constraints) {\r\n                        const normal = contact.normal;\r\n                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);\r\n                        const steeringConstant = Physics.steeringFactor; //0.2;\r\n                        const maxCorrection = -5;\r\n                        const slop = Physics.slop; //1;\r\n                        // Clamp to avoid over-correction\r\n                        // Remember that we are shooting for 0 overlap in the end\r\n                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n                        const impulse = normal.scale(-steeringForce * point.normalMass);\r\n                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n                        // We adjust position and rotation instead of doing the velocity\r\n                        if (bodyA.collisionType === CollisionType.Active) {\r\n                            // TODO make applyPseudoImpulse function?\r\n                            const impulseForce = impulse.negate().scale(bodyA.inverseMass);\r\n                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n                                impulseForce.x = 0;\r\n                            }\r\n                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n                                impulseForce.y = 0;\r\n                            }\r\n                            bodyA.globalPos = bodyA.globalPos.add(impulseForce);\r\n                            if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n                                bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n                            }\r\n                        }\r\n                        if (bodyB.collisionType === CollisionType.Active) {\r\n                            const impulseForce = impulse.scale(bodyB.inverseMass);\r\n                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n                                impulseForce.x = 0;\r\n                            }\r\n                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n                                impulseForce.y = 0;\r\n                            }\r\n                            bodyB.globalPos = bodyB.globalPos.add(impulseForce);\r\n                            if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n                                bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    solveVelocity(contacts) {\r\n        var _a, _b, _c;\r\n        for (let i = 0; i < Physics.velocityIterations; i++) {\r\n            for (const contact of contacts) {\r\n                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);\r\n                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);\r\n                if (bodyA && bodyB) {\r\n                    // Skip solving active+passive\r\n                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n                        continue;\r\n                    }\r\n                    const friction = Math.min(bodyA.friction, bodyB.friction);\r\n                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];\r\n                    // Friction constraint\r\n                    for (const point of constraints) {\r\n                        const relativeVelocity = point.getRelativeVelocity();\r\n                        // Negate velocity in tangent direction to simulate friction\r\n                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n                        let impulseDelta = tangentVelocity * point.tangentMass;\r\n                        // Clamping based in Erin Catto's GDC 2006 talk\r\n                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n                        // But deltas can vary\r\n                        const maxFriction = friction * point.normalImpulse;\r\n                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n                        impulseDelta = newImpulse - point.tangentImpulse;\r\n                        point.tangentImpulse = newImpulse;\r\n                        const impulse = contact.tangent.scale(impulseDelta);\r\n                        bodyA.applyImpulse(point.point, impulse.negate());\r\n                        bodyB.applyImpulse(point.point, impulse);\r\n                    }\r\n                    // Bounce constraint\r\n                    for (const point of constraints) {\r\n                        // Need to recalc relative velocity because the previous step could have changed vel\r\n                        const relativeVelocity = point.getRelativeVelocity();\r\n                        // Compute impulse in normal direction\r\n                        const normalVelocity = relativeVelocity.dot(contact.normal);\r\n                        // Per Erin it is a mistake to apply the restitution inside the iteration\r\n                        // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses\r\n                        let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);\r\n                        // Clamping based in Erin Catto's GDC 2014 talk\r\n                        // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n                        // But deltas can be negative\r\n                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n                        impulseDelta = newImpulse - point.normalImpulse;\r\n                        point.normalImpulse = newImpulse;\r\n                        const impulse = contact.normal.scale(impulseDelta);\r\n                        bodyA.applyImpulse(point.point, impulse.negate());\r\n                        bodyB.applyImpulse(point.point, impulse);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Collision/CollisionSystem.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass CollisionSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform', 'ex.motion', 'ex.collider'];\r\n        this.systemType = SystemType.Update;\r\n        this.priority = -1;\r\n        this._realisticSolver = new RealisticSolver();\r\n        this._arcadeSolver = new ArcadeSolver();\r\n        this._processor = new DynamicTreeCollisionProcessor();\r\n        this._lastFrameContacts = new Map();\r\n        this._currentFrameContacts = new Map();\r\n        this._trackCollider = (c) => this._processor.track(c);\r\n        this._untrackCollider = (c) => this._processor.untrack(c);\r\n    }\r\n    notify(message) {\r\n        if (isAddedSystemEntity(message)) {\r\n            const colliderComponent = message.data.get(ColliderComponent);\r\n            colliderComponent.$colliderAdded.subscribe(this._trackCollider);\r\n            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);\r\n            const collider = colliderComponent.get();\r\n            if (collider) {\r\n                this._processor.track(collider);\r\n            }\r\n        }\r\n        else {\r\n            const colliderComponent = message.data.get(ColliderComponent);\r\n            const collider = colliderComponent.get();\r\n            if (colliderComponent && collider) {\r\n                this._processor.untrack(collider);\r\n            }\r\n        }\r\n    }\r\n    initialize(scene) {\r\n        this._engine = scene.engine;\r\n    }\r\n    update(entities, elapsedMs) {\r\n        var _a, _b, _c, _d;\r\n        if (!Physics.enabled) {\r\n            return;\r\n        }\r\n        // Collect up all the colliders and update them\r\n        let colliders = [];\r\n        for (const entity of entities) {\r\n            const colliderComp = entity.get(ColliderComponent);\r\n            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();\r\n            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {\r\n                colliderComp.update();\r\n                if (collider instanceof CompositeCollider) {\r\n                    const compositeColliders = collider.getColliders();\r\n                    colliders = colliders.concat(compositeColliders);\r\n                }\r\n                else {\r\n                    colliders.push(collider);\r\n                }\r\n            }\r\n        }\r\n        // Update the spatial partitioning data structures\r\n        // TODO if collider invalid it will break the processor\r\n        // TODO rename \"update\" to something more specific\r\n        this._processor.update(colliders);\r\n        // Run broadphase on all colliders and locates potential collisions\r\n        const pairs = this._processor.broadphase(colliders, elapsedMs);\r\n        this._currentFrameContacts.clear();\r\n        // Given possible pairs find actual contacts\r\n        let contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.currFrame);\r\n        const solver = this.getSolver();\r\n        // Solve, this resolves the position/velocity so entities aren't overlapping\r\n        contacts = solver.solve(contacts);\r\n        // Record contacts for start/end\r\n        for (const contact of contacts) {\r\n            // Process composite ids, things with the same composite id are treated as the same collider for start/end\r\n            const index = contact.id.indexOf('|');\r\n            if (index > 0) {\r\n                const compositeId = contact.id.substring(index + 1);\r\n                this._currentFrameContacts.set(compositeId, contact);\r\n            }\r\n            else {\r\n                this._currentFrameContacts.set(contact.id, contact);\r\n            }\r\n        }\r\n        // Emit contact start/end events\r\n        this.runContactStartEnd();\r\n        // reset the last frame cache\r\n        this._lastFrameContacts.clear();\r\n        // Keep track of collisions contacts that have started or ended\r\n        this._lastFrameContacts = new Map(this._currentFrameContacts);\r\n    }\r\n    getSolver() {\r\n        return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;\r\n    }\r\n    debug(ex) {\r\n        this._processor.debug(ex);\r\n    }\r\n    runContactStartEnd() {\r\n        // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end\r\n        for (const [id, c] of this._currentFrameContacts) {\r\n            // find all new contacts\r\n            if (!this._lastFrameContacts.has(id)) {\r\n                const colliderA = c.colliderA;\r\n                const colliderB = c.colliderB;\r\n                colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));\r\n                colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c));\r\n                colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));\r\n                colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c));\r\n            }\r\n        }\r\n        // find all contacts that have ceased\r\n        for (const [id, c] of this._lastFrameContacts) {\r\n            if (!this._currentFrameContacts.has(id)) {\r\n                const colliderA = c.colliderA;\r\n                const colliderB = c.colliderB;\r\n                colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));\r\n                colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB));\r\n                colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));\r\n                colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA));\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Animation.ts\n\r\n\r\n\r\n\r\nvar AnimationDirection;\r\n(function (AnimationDirection) {\r\n    /**\r\n     * Animation is playing forwards\r\n     */\r\n    AnimationDirection[\"Forward\"] = \"forward\";\r\n    /**\r\n     * Animation is play backwards\r\n     */\r\n    AnimationDirection[\"Backward\"] = \"backward\";\r\n})(AnimationDirection || (AnimationDirection = {}));\r\nvar AnimationStrategy;\r\n(function (AnimationStrategy) {\r\n    /**\r\n     * Animation ends without displaying anything\r\n     */\r\n    AnimationStrategy[\"End\"] = \"end\";\r\n    /**\r\n     * Animation loops to the first frame after the last frame\r\n     */\r\n    AnimationStrategy[\"Loop\"] = \"loop\";\r\n    /**\r\n     * Animation plays to the last frame, then backwards to the first frame, then repeats\r\n     */\r\n    AnimationStrategy[\"PingPong\"] = \"pingpong\";\r\n    /**\r\n     * Animation ends stopping on the last frame\r\n     */\r\n    AnimationStrategy[\"Freeze\"] = \"freeze\";\r\n})(AnimationStrategy || (AnimationStrategy = {}));\r\n/**\r\n * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]\r\n *\r\n * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]\r\n */\r\nclass Animation extends Graphic {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        super(options);\r\n        this.events = new EventDispatcher(); // TODO replace with new Emitter\r\n        this.frames = [];\r\n        this.strategy = AnimationStrategy.Loop;\r\n        this.frameDuration = 100;\r\n        this.timeScale = 1;\r\n        this._idempotencyToken = -1;\r\n        this._firstTick = true;\r\n        this._currentFrame = 0;\r\n        this._timeLeftInFrame = 0;\r\n        this._direction = 1; // TODO only used in ping-pong\r\n        this._done = false;\r\n        this._playing = true;\r\n        this._reversed = false;\r\n        this.frames = options.frames;\r\n        this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;\r\n        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;\r\n        if (options.reverse) {\r\n            this.reverse();\r\n        }\r\n        this.goToFrame(0);\r\n    }\r\n    clone() {\r\n        return new Animation({\r\n            frames: this.frames.map((f) => ({ ...f })),\r\n            frameDuration: this.frameDuration,\r\n            reverse: this._reversed,\r\n            strategy: this.strategy,\r\n            ...this.cloneGraphicOptions()\r\n        });\r\n    }\r\n    get width() {\r\n        const maybeFrame = this.currentFrame;\r\n        if (maybeFrame) {\r\n            return Math.abs(maybeFrame.graphic.width * this.scale.x);\r\n        }\r\n        return 0;\r\n    }\r\n    get height() {\r\n        const maybeFrame = this.currentFrame;\r\n        if (maybeFrame) {\r\n            return Math.abs(maybeFrame.graphic.height * this.scale.y);\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame\r\n     * and optional [[AnimationStrategy]]\r\n     *\r\n     * Example:\r\n     * ```typescript\r\n     * const spriteSheet = SpriteSheet.fromImageSource({...});\r\n     *\r\n     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);\r\n     * ```\r\n     *\r\n     * @param spriteSheet\r\n     * @param frameIndices\r\n     * @param durationPerFrameMs\r\n     * @param strategy\r\n     */\r\n    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {\r\n        const maxIndex = spriteSheet.sprites.length - 1;\r\n        const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);\r\n        if (invalidIndices.length) {\r\n            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\\'t exist: ${invalidIndices.join(',')} no frame will be shown`);\r\n        }\r\n        return new Animation({\r\n            frames: spriteSheet.sprites\r\n                .filter((_, index) => frameIndices.indexOf(index) > -1)\r\n                .map((f) => ({\r\n                graphic: f,\r\n                duration: durationPerFrameMs\r\n            })),\r\n            strategy: strategy\r\n        });\r\n    }\r\n    /**\r\n     * Returns the current Frame of the animation\r\n     */\r\n    get currentFrame() {\r\n        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {\r\n            return this.frames[this._currentFrame];\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns the current frame index of the animation\r\n     */\r\n    get currentFrameIndex() {\r\n        return this._currentFrame;\r\n    }\r\n    /**\r\n     * Returns `true` if the animation is playing\r\n     */\r\n    get isPlaying() {\r\n        return this._playing;\r\n    }\r\n    /**\r\n     * Reverses the play direction of the Animation, this preserves the current frame\r\n     */\r\n    reverse() {\r\n        // Don't mutate with the original frame list, create a copy\r\n        this.frames = this.frames.slice().reverse();\r\n        this._reversed = !this._reversed;\r\n    }\r\n    /**\r\n     * Returns the current play direction of the animation\r\n     */\r\n    get direction() {\r\n        // Keep logically consistent with ping-pong direction\r\n        // If ping-pong is forward = 1 and reversed is true then we are logically reversed\r\n        const reversed = (this._reversed && this._direction === 1) ? true : false;\r\n        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;\r\n    }\r\n    /**\r\n     * Plays or resumes the animation from the current frame\r\n     */\r\n    play() {\r\n        this._playing = true;\r\n    }\r\n    /**\r\n     * Pauses the animation on the current frame\r\n     */\r\n    pause() {\r\n        this._playing = false;\r\n        this._firstTick = true; // firstTick must be set to emit the proper frame event\r\n    }\r\n    /**\r\n     * Reset the animation back to the beginning, including if the animation were done\r\n     */\r\n    reset() {\r\n        this._done = false;\r\n        this._firstTick = true;\r\n        this._currentFrame = 0;\r\n    }\r\n    /**\r\n     * Returns `true` if the animation can end\r\n     */\r\n    get canFinish() {\r\n        switch (this.strategy) {\r\n            case AnimationStrategy.End:\r\n            case AnimationStrategy.Freeze: {\r\n                return true;\r\n            }\r\n            default: {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns `true` if the animation is done, for looping type animations\r\n     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`\r\n     *\r\n     * See the `ex.Animation.canFinish()` method to know if an animation type can end\r\n     */\r\n    get done() {\r\n        return this._done;\r\n    }\r\n    /**\r\n     * Jump the animation immediately to a specific frame if it exists\r\n     * @param frameNumber\r\n     */\r\n    goToFrame(frameNumber) {\r\n        this._currentFrame = frameNumber;\r\n        this._timeLeftInFrame = this.frameDuration;\r\n        const maybeFrame = this.frames[this._currentFrame];\r\n        if (maybeFrame && !this._done) {\r\n            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;\r\n            this.events.emit('frame', maybeFrame);\r\n        }\r\n    }\r\n    _nextFrame() {\r\n        const currentFrame = this._currentFrame;\r\n        if (this._done) {\r\n            return currentFrame;\r\n        }\r\n        let next = -1;\r\n        switch (this.strategy) {\r\n            case AnimationStrategy.Loop: {\r\n                next = (currentFrame + 1) % this.frames.length;\r\n                if (next === 0) {\r\n                    this.events.emit('loop', this);\r\n                }\r\n                break;\r\n            }\r\n            case AnimationStrategy.End: {\r\n                next = currentFrame + 1;\r\n                if (next >= this.frames.length) {\r\n                    this._done = true;\r\n                    this._currentFrame = this.frames.length;\r\n                    this.events.emit('end', this);\r\n                }\r\n                break;\r\n            }\r\n            case AnimationStrategy.Freeze: {\r\n                next = clamp(currentFrame + 1, 0, this.frames.length - 1);\r\n                if (next >= this.frames.length - 1) {\r\n                    this._done = true;\r\n                    this.events.emit('end', this);\r\n                }\r\n                break;\r\n            }\r\n            case AnimationStrategy.PingPong: {\r\n                if (currentFrame + this._direction >= this.frames.length) {\r\n                    this._direction = -1;\r\n                    this.events.emit('loop', this);\r\n                }\r\n                if (currentFrame + this._direction < 0) {\r\n                    this._direction = 1;\r\n                    this.events.emit('loop', this);\r\n                }\r\n                next = currentFrame + (this._direction % this.frames.length);\r\n                break;\r\n            }\r\n        }\r\n        return next;\r\n    }\r\n    /**\r\n     * Called internally by Excalibur to update the state of the animation potential update the current frame\r\n     * @param elapsedMilliseconds Milliseconds elapsed\r\n     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame\r\n     */\r\n    tick(elapsedMilliseconds, idempotencyToken = 0) {\r\n        if (this._idempotencyToken === idempotencyToken) {\r\n            return;\r\n        }\r\n        this._idempotencyToken = idempotencyToken;\r\n        if (!this._playing) {\r\n            return;\r\n        }\r\n        // if it's the first frame emit frame event\r\n        if (this._firstTick) {\r\n            this._firstTick = false;\r\n            this.events.emit('frame', this.currentFrame);\r\n        }\r\n        this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;\r\n        if (this._timeLeftInFrame <= 0) {\r\n            this.goToFrame(this._nextFrame());\r\n        }\r\n    }\r\n    _drawImage(ctx, x, y) {\r\n        if (this.currentFrame) {\r\n            this.currentFrame.graphic.draw(ctx, x, y);\r\n        }\r\n    }\r\n}\r\nAnimation._LOGGER = Logger.getInstance();\r\n\n;// CONCATENATED MODULE: ./Graphics/GraphicsGroup.ts\n\r\n\r\n\r\nclass GraphicsGroup extends Graphic {\r\n    constructor(options) {\r\n        super(options);\r\n        this.members = [];\r\n        this.members = options.members;\r\n        this._updateDimensions();\r\n    }\r\n    clone() {\r\n        return new GraphicsGroup({\r\n            members: [...this.members],\r\n            ...this.cloneGraphicOptions()\r\n        });\r\n    }\r\n    _updateDimensions() {\r\n        let bb = new BoundingBox();\r\n        for (const { graphic, pos } of this.members) {\r\n            bb = graphic.localBounds.translate(pos).combine(bb);\r\n        }\r\n        this.width = bb.width;\r\n        this.height = bb.height;\r\n        return bb;\r\n    }\r\n    get localBounds() {\r\n        let bb = new BoundingBox();\r\n        for (const { graphic, pos } of this.members) {\r\n            bb = graphic.localBounds.translate(pos).combine(bb);\r\n        }\r\n        return bb;\r\n    }\r\n    _isAnimationOrGroup(graphic) {\r\n        return graphic instanceof Animation || graphic instanceof GraphicsGroup;\r\n    }\r\n    tick(elapsedMilliseconds, idempotencyToken) {\r\n        for (const member of this.members) {\r\n            const maybeAnimation = member.graphic;\r\n            if (this._isAnimationOrGroup(maybeAnimation)) {\r\n                maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);\r\n            }\r\n        }\r\n    }\r\n    reset() {\r\n        for (const member of this.members) {\r\n            const maybeAnimation = member.graphic;\r\n            if (this._isAnimationOrGroup(maybeAnimation)) {\r\n                maybeAnimation.reset();\r\n            }\r\n        }\r\n    }\r\n    _preDraw(ex, x, y) {\r\n        this._updateDimensions();\r\n        super._preDraw(ex, x, y);\r\n    }\r\n    _drawImage(ex, x, y) {\r\n        for (const member of this.members) {\r\n            ex.save();\r\n            ex.translate(x, y);\r\n            member.graphic.draw(ex, member.pos.x, member.pos.y);\r\n            if (this.showDebug) {\r\n                /* istanbul ignore next */\r\n                ex.debug.drawRect(0, 0, this.width, this.height);\r\n            }\r\n            ex.restore();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Configurable.ts\n/**\r\n * Configurable helper extends base type and makes all properties available as option bag arguments\r\n * @internal\r\n * @param base\r\n */\r\nfunction Configurable(base) {\r\n    return class extends base {\r\n        assign(props) {\r\n            //set the value of every property that was passed in,\r\n            //if the constructor previously set this value, it will be overridden here\r\n            for (const k in props) {\r\n                // eslint-disable-next-line\r\n                if (typeof this[k] !== 'function') {\r\n                    // eslint-disable-next-line\r\n                    this[k] = props[k];\r\n                }\r\n            }\r\n        }\r\n        constructor(...args) {\r\n            super(...args);\r\n            //get the number of arguments that aren't undefined. TS passes a value to all parameters\r\n            //of whatever ctor is the implementation, so args.length doesn't work here.\r\n            const size = args.filter(function (value) {\r\n                return value !== undefined;\r\n            }).length;\r\n            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {\r\n                this.assign(args[0]);\r\n            }\r\n        }\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./Particles.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * An enum that represents the types of emitter nozzles\r\n */\r\nvar EmitterType;\r\n(function (EmitterType) {\r\n    /**\r\n     * Constant for the circular emitter type\r\n     */\r\n    EmitterType[EmitterType[\"Circle\"] = 0] = \"Circle\";\r\n    /**\r\n     * Constant for the rectangular emitter type\r\n     */\r\n    EmitterType[EmitterType[\"Rectangle\"] = 1] = \"Rectangle\";\r\n})(EmitterType || (EmitterType = {}));\r\n/**\r\n * @hidden\r\n */\r\nclass ParticleImpl extends Entity {\r\n    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {\r\n        super();\r\n        this.position = new Vector(0, 0);\r\n        this.velocity = new Vector(0, 0);\r\n        this.acceleration = new Vector(0, 0);\r\n        this.particleRotationalVelocity = 0;\r\n        this.currentRotation = 0;\r\n        this.focus = null;\r\n        this.focusAccel = 0;\r\n        this.opacity = 1;\r\n        this.beginColor = Color.White;\r\n        this.endColor = Color.White;\r\n        // Life is counted in ms\r\n        this.life = 300;\r\n        this.fadeFlag = false;\r\n        // Color transitions\r\n        this._rRate = 1;\r\n        this._gRate = 1;\r\n        this._bRate = 1;\r\n        this._aRate = 0;\r\n        this._currentColor = Color.White;\r\n        this.emitter = null;\r\n        this.particleSize = 5;\r\n        this.particleSprite = null;\r\n        this.sizeRate = 0;\r\n        this.elapsedMultiplier = 0;\r\n        this.visible = true;\r\n        this.isOffscreen = false;\r\n        let emitter = emitterOrConfig;\r\n        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {\r\n            const config = emitterOrConfig;\r\n            emitter = config.emitter;\r\n            life = config.life;\r\n            opacity = config.opacity;\r\n            endColor = config.endColor;\r\n            beginColor = config.beginColor;\r\n            position = config.position;\r\n            velocity = config.velocity;\r\n            acceleration = config.acceleration;\r\n            startSize = config.startSize;\r\n            endSize = config.endSize;\r\n        }\r\n        this.emitter = emitter;\r\n        this.life = life || this.life;\r\n        this.opacity = opacity || this.opacity;\r\n        this.endColor = endColor || this.endColor.clone();\r\n        this.beginColor = beginColor || this.beginColor.clone();\r\n        this._currentColor = this.beginColor.clone();\r\n        this.position = (position || this.position).add(this.emitter.pos);\r\n        this.velocity = velocity || this.velocity;\r\n        this.acceleration = acceleration || this.acceleration;\r\n        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\r\n        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\r\n        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\r\n        this._aRate = this.opacity / this.life;\r\n        this.startSize = startSize || 0;\r\n        this.endSize = endSize || 0;\r\n        if (this.endSize > 0 && this.startSize > 0) {\r\n            this.sizeRate = (this.endSize - this.startSize) / this.life;\r\n            this.particleSize = this.startSize;\r\n        }\r\n        this.addComponent((this.transform = new TransformComponent()));\r\n        this.addComponent((this.graphics = new GraphicsComponent()));\r\n        this.transform.pos = this.position;\r\n        this.transform.rotation = this.currentRotation;\r\n        this.transform.scale = vec(1, 1); // TODO wut\r\n        if (this.particleSprite) {\r\n            this.graphics.opacity = this.opacity;\r\n            this.graphics.use(this.particleSprite);\r\n        }\r\n        else {\r\n            this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);\r\n            this.graphics.onPostDraw = (ctx) => {\r\n                ctx.save();\r\n                this.graphics.opacity = this.opacity;\r\n                const tmpColor = this._currentColor.clone();\r\n                tmpColor.a = 1;\r\n                ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });\r\n                ctx.restore();\r\n            };\r\n        }\r\n    }\r\n    kill() {\r\n        this.emitter.removeParticle(this);\r\n    }\r\n    update(_engine, delta) {\r\n        this.life = this.life - delta;\r\n        this.elapsedMultiplier = this.elapsedMultiplier + delta;\r\n        if (this.life < 0) {\r\n            this.kill();\r\n        }\r\n        if (this.fadeFlag) {\r\n            this.opacity = clamp(this._aRate * this.life, 0.0001, 1);\r\n        }\r\n        if (this.startSize > 0 && this.endSize > 0) {\r\n            this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));\r\n        }\r\n        this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);\r\n        this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);\r\n        this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);\r\n        this._currentColor.a = clamp(this.opacity, 0.0001, 1);\r\n        if (this.focus) {\r\n            const accel = this.focus\r\n                .sub(this.position)\r\n                .normalize()\r\n                .scale(this.focusAccel)\r\n                .scale(delta / 1000);\r\n            this.velocity = this.velocity.add(accel);\r\n        }\r\n        else {\r\n            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\r\n        }\r\n        this.position = this.position.add(this.velocity.scale(delta / 1000));\r\n        if (this.particleRotationalVelocity) {\r\n            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);\r\n        }\r\n        this.transform.pos = this.position;\r\n        this.transform.rotation = this.currentRotation;\r\n        this.transform.scale = vec(1, 1); // todo wut\r\n        this.graphics.opacity = this.opacity;\r\n    }\r\n}\r\n/**\r\n * Particle is used in a [[ParticleEmitter]]\r\n */\r\nclass Particle extends Configurable(ParticleImpl) {\r\n    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {\r\n        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);\r\n    }\r\n}\r\n/**\r\n * Using a particle emitter is a great way to create interesting effects\r\n * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n * extend [[Actor]] allowing you to use all of the features that come with.\r\n */\r\nclass ParticleEmitter extends Actor {\r\n    /**\r\n     * @param config particle emitter options bag\r\n     */\r\n    constructor(config) {\r\n        var _a, _b;\r\n        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });\r\n        this._particlesToEmit = 0;\r\n        this.numParticles = 0;\r\n        /**\r\n         * Gets or sets the isEmitting flag\r\n         */\r\n        this.isEmitting = true;\r\n        /**\r\n         * Gets or sets the backing particle collection\r\n         */\r\n        this.particles = [];\r\n        /**\r\n         * Gets or sets the backing deadParticle collection\r\n         */\r\n        this.deadParticles = [];\r\n        /**\r\n         * Gets or sets the minimum particle velocity\r\n         */\r\n        this.minVel = 0;\r\n        /**\r\n         * Gets or sets the maximum particle velocity\r\n         */\r\n        this.maxVel = 0;\r\n        /**\r\n         * Gets or sets the acceleration vector for all particles\r\n         */\r\n        this.acceleration = new Vector(0, 0);\r\n        /**\r\n         * Gets or sets the minimum angle in radians\r\n         */\r\n        this.minAngle = 0;\r\n        /**\r\n         * Gets or sets the maximum angle in radians\r\n         */\r\n        this.maxAngle = 0;\r\n        /**\r\n         * Gets or sets the emission rate for particles (particles/sec)\r\n         */\r\n        this.emitRate = 1; //particles/sec\r\n        /**\r\n         * Gets or sets the life of each particle in milliseconds\r\n         */\r\n        this.particleLife = 2000;\r\n        /**\r\n         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n         */\r\n        this.fadeFlag = false;\r\n        /**\r\n         * Gets or sets the optional focus where all particles should accelerate towards\r\n         */\r\n        this.focus = null;\r\n        /**\r\n         * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n         */\r\n        this.focusAccel = null;\r\n        /**\r\n         * Gets or sets the optional starting size for the particles\r\n         */\r\n        this.startSize = null;\r\n        /**\r\n         * Gets or sets the optional ending size for the particles\r\n         */\r\n        this.endSize = null;\r\n        /**\r\n         * Gets or sets the minimum size of all particles\r\n         */\r\n        this.minSize = 5;\r\n        /**\r\n         * Gets or sets the maximum size of all particles\r\n         */\r\n        this.maxSize = 5;\r\n        /**\r\n         * Gets or sets the beginning color of all particles\r\n         */\r\n        this.beginColor = Color.White;\r\n        /**\r\n         * Gets or sets the ending color of all particles\r\n         */\r\n        this.endColor = Color.White;\r\n        this._sprite = null;\r\n        /**\r\n         * Gets or sets the emitter type for the particle emitter\r\n         */\r\n        this.emitterType = EmitterType.Rectangle;\r\n        /**\r\n         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n         */\r\n        this.radius = 0;\r\n        /**\r\n         * Gets or sets the particle rotational speed velocity\r\n         */\r\n        this.particleRotationalVelocity = 0;\r\n        /**\r\n         * Indicates whether particles should start with a random rotation\r\n         */\r\n        this.randomRotation = false;\r\n        const { x, y, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, randomRotation, random } = { ...config };\r\n        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);\r\n        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;\r\n        this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;\r\n        this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;\r\n        this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;\r\n        this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;\r\n        this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;\r\n        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;\r\n        this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;\r\n        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;\r\n        this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;\r\n        this.focus = focus !== null && focus !== void 0 ? focus : this.focus;\r\n        this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;\r\n        this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;\r\n        this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;\r\n        this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;\r\n        this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;\r\n        this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;\r\n        this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;\r\n        this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;\r\n        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;\r\n        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;\r\n        this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;\r\n        this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;\r\n        this.body.collisionType = CollisionType.PreventCollision;\r\n        this.random = random !== null && random !== void 0 ? random : new Random();\r\n    }\r\n    /**\r\n     * Gets the opacity of each particle from 0 to 1.0\r\n     */\r\n    get opacity() {\r\n        return super.graphics.opacity;\r\n    }\r\n    /**\r\n     * Gets the opacity of each particle from 0 to 1.0\r\n     */\r\n    set opacity(opacity) {\r\n        super.graphics.opacity = opacity;\r\n    }\r\n    /**\r\n     * Gets or sets the sprite that a particle should use\r\n     */\r\n    get particleSprite() {\r\n        return this._sprite;\r\n    }\r\n    set particleSprite(val) {\r\n        if (val) {\r\n            this._sprite = val;\r\n        }\r\n    }\r\n    removeParticle(particle) {\r\n        this.deadParticles.push(particle);\r\n    }\r\n    /**\r\n     * Causes the emitter to emit particles\r\n     * @param particleCount  Number of particles to emit right now\r\n     */\r\n    emitParticles(particleCount) {\r\n        var _a;\r\n        for (let i = 0; i < particleCount; i++) {\r\n            const p = this._createParticle();\r\n            this.particles.push(p);\r\n            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {\r\n                this.scene.world.add(p);\r\n            }\r\n        }\r\n    }\r\n    clearParticles() {\r\n        this.particles.length = 0;\r\n    }\r\n    // Creates a new particle given the constraints of the emitter\r\n    _createParticle() {\r\n        // todo implement emitter constraints;\r\n        let ranX = 0;\r\n        let ranY = 0;\r\n        const angle = randomInRange(this.minAngle, this.maxAngle, this.random);\r\n        const vel = randomInRange(this.minVel, this.maxVel, this.random);\r\n        const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);\r\n        const dx = vel * Math.cos(angle);\r\n        const dy = vel * Math.sin(angle);\r\n        if (this.emitterType === EmitterType.Rectangle) {\r\n            ranX = randomInRange(0, this.width, this.random);\r\n            ranY = randomInRange(0, this.height, this.random);\r\n        }\r\n        else if (this.emitterType === EmitterType.Circle) {\r\n            const radius = randomInRange(0, this.radius, this.random);\r\n            ranX = radius * Math.cos(angle);\r\n            ranY = radius * Math.sin(angle);\r\n        }\r\n        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);\r\n        p.fadeFlag = this.fadeFlag;\r\n        p.particleSize = size;\r\n        if (this.particleSprite) {\r\n            p.particleSprite = this.particleSprite;\r\n            p.graphics.opacity = this.opacity;\r\n            p.graphics.use(this._sprite);\r\n        }\r\n        p.particleRotationalVelocity = this.particleRotationalVelocity;\r\n        if (this.randomRotation) {\r\n            p.currentRotation = randomInRange(0, Math.PI * 2, this.random);\r\n        }\r\n        if (this.focus) {\r\n            p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));\r\n            p.focusAccel = this.focusAccel;\r\n        }\r\n        return p;\r\n    }\r\n    update(engine, delta) {\r\n        var _a;\r\n        super.update(engine, delta);\r\n        if (this.isEmitting) {\r\n            this._particlesToEmit += this.emitRate * (delta / 1000);\r\n            if (this._particlesToEmit > 1.0) {\r\n                this.emitParticles(Math.floor(this._particlesToEmit));\r\n                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\r\n            }\r\n        }\r\n        // deferred removal\r\n        for (let i = 0; i < this.deadParticles.length; i++) {\r\n            removeItemFromArray(this.deadParticles[i], this.particles);\r\n            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {\r\n                this.scene.world.remove(this.deadParticles[i], false);\r\n            }\r\n        }\r\n        this.deadParticles.length = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/GraphicsSystem.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GraphicsSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform', 'ex.graphics'];\r\n        this.systemType = SystemType.Draw;\r\n        this.priority = 0;\r\n        this._token = 0;\r\n        this._sortedTransforms = [];\r\n        this._zHasChanged = false;\r\n        this._zIndexUpdate = () => {\r\n            this._zHasChanged = true;\r\n        };\r\n    }\r\n    get sortedTransforms() {\r\n        return this._sortedTransforms;\r\n    }\r\n    initialize(scene) {\r\n        this._camera = scene.camera;\r\n        this._engine = scene.engine;\r\n    }\r\n    preupdate() {\r\n        // Graphics context could be switched to fallback in a new frame\r\n        this._graphicsContext = this._engine.graphicsContext;\r\n        if (this._zHasChanged) {\r\n            this._sortedTransforms.sort((a, b) => {\r\n                return a.z - b.z;\r\n            });\r\n            this._zHasChanged = false;\r\n        }\r\n    }\r\n    notify(entityAddedOrRemoved) {\r\n        if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n            const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n            this._sortedTransforms.push(tx);\r\n            tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n            this._zHasChanged = true;\r\n        }\r\n        else {\r\n            const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n            const index = this._sortedTransforms.indexOf(tx);\r\n            if (index > -1) {\r\n                this._sortedTransforms.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n    update(_entities, delta) {\r\n        this._token++;\r\n        let graphics;\r\n        // This is a performance enhancement, most things are in world space\r\n        // so if we can only do this once saves a ton of transform updates\r\n        this._graphicsContext.save();\r\n        if (this._camera) {\r\n            this._camera.draw(this._graphicsContext);\r\n        }\r\n        for (const transform of this._sortedTransforms) {\r\n            const entity = transform.owner;\r\n            // If the entity is offscreen skip\r\n            if (entity.hasTag('ex.offscreen')) {\r\n                continue;\r\n            }\r\n            graphics = entity.get(GraphicsComponent);\r\n            // Exit if graphics set to not visible\r\n            if (!graphics.visible) {\r\n                continue;\r\n            }\r\n            // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n            if (transform.coordPlane === CoordPlane.Screen) {\r\n                this._graphicsContext.restore();\r\n            }\r\n            this._graphicsContext.save();\r\n            // Tick any graphics state (but only once) for animations and graphics groups\r\n            graphics.update(delta, this._token);\r\n            // Apply parallax\r\n            const parallax = entity.get(ParallaxComponent);\r\n            if (parallax) {\r\n                // We use the Tiled formula\r\n                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n                // cameraPos * (1 - parallaxFactor)\r\n                const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);\r\n                const parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n                this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);\r\n            }\r\n            // Position the entity + estimate lag\r\n            this._applyTransform(entity);\r\n            // Optionally run the onPreDraw graphics lifecycle draw\r\n            if (graphics.onPreDraw) {\r\n                graphics.onPreDraw(this._graphicsContext, delta);\r\n            }\r\n            // TODO remove this hack on the particle redo\r\n            const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;\r\n            this._graphicsContext.opacity = graphics.opacity * particleOpacity;\r\n            // Draw the graphics component\r\n            this._drawGraphicsComponent(graphics);\r\n            // Optionally run the onPostDraw graphics lifecycle draw\r\n            if (graphics.onPostDraw) {\r\n                graphics.onPostDraw(this._graphicsContext, delta);\r\n            }\r\n            this._graphicsContext.restore();\r\n            // Reset the transform back to the original world space\r\n            if (transform.coordPlane === CoordPlane.Screen) {\r\n                this._graphicsContext.save();\r\n                if (this._camera) {\r\n                    this._camera.draw(this._graphicsContext);\r\n                }\r\n            }\r\n        }\r\n        this._graphicsContext.restore();\r\n    }\r\n    _drawGraphicsComponent(graphicsComponent) {\r\n        var _a, _b;\r\n        if (graphicsComponent.visible) {\r\n            // this should be moved to the graphics system\r\n            for (const layer of graphicsComponent.layers.get()) {\r\n                for (const { graphic, options } of layer.graphics) {\r\n                    let anchor = graphicsComponent.anchor;\r\n                    let offset = graphicsComponent.offset;\r\n                    if (options === null || options === void 0 ? void 0 : options.anchor) {\r\n                        anchor = options.anchor;\r\n                    }\r\n                    if (options === null || options === void 0 ? void 0 : options.offset) {\r\n                        offset = options.offset;\r\n                    }\r\n                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\r\n                    const offsetX = -graphic.width * anchor.x + offset.x;\r\n                    const offsetY = -graphic.height * anchor.y + offset.y;\r\n                    graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {\r\n                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n                        if (graphic instanceof GraphicsGroup) {\r\n                            for (const g of graphic.members) {\r\n                                (_b = g.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n                            }\r\n                        }\r\n                        else {\r\n                            /* istanbul ignore next */\r\n                            graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * This applies the current entity transform to the graphics context\r\n     * @param entity\r\n     */\r\n    _applyTransform(entity) {\r\n        const ancestors = entity.getAncestors();\r\n        for (const ancestor of ancestors) {\r\n            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);\r\n            const optionalBody = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(BodyComponent);\r\n            let interpolatedPos = transform.pos;\r\n            let interpolatedScale = transform.scale;\r\n            let interpolatedRotation = transform.rotation;\r\n            if (optionalBody) {\r\n                if (this._engine.fixedUpdateFps &&\r\n                    optionalBody.__oldTransformCaptured &&\r\n                    optionalBody.enableFixedUpdateInterpolate) {\r\n                    // Interpolate graphics if needed\r\n                    const blend = this._engine.currentFrameLagMs / (1000 / this._engine.fixedUpdateFps);\r\n                    interpolatedPos = transform.pos.scale(blend).add(optionalBody.oldPos.scale(1.0 - blend));\r\n                    interpolatedScale = transform.scale.scale(blend).add(optionalBody.oldScale.scale(1.0 - blend));\r\n                    // Rotational lerp https://stackoverflow.com/a/30129248\r\n                    const cosine = (1.0 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);\r\n                    const sine = (1.0 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);\r\n                    interpolatedRotation = Math.atan2(sine, cosine);\r\n                }\r\n            }\r\n            if (transform) {\r\n                this._graphicsContext.z = transform.z;\r\n                this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);\r\n                this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);\r\n                this._graphicsContext.rotate(interpolatedRotation);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Debug/DebugSystem.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass DebugSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform'];\r\n        this.systemType = SystemType.Draw;\r\n        this.priority = 999; // lowest priority\r\n    }\r\n    initialize(scene) {\r\n        this._graphicsContext = scene.engine.graphicsContext;\r\n        this._camera = scene.camera;\r\n        this._engine = scene.engine;\r\n        this._collisionSystem = scene.world.systemManager.get(CollisionSystem);\r\n    }\r\n    update(entities, _delta) {\r\n        var _a;\r\n        if (!this._engine.isDebug) {\r\n            return;\r\n        }\r\n        const filterSettings = this._engine.debug.filter;\r\n        let id;\r\n        let name;\r\n        const entitySettings = this._engine.debug.entity;\r\n        let tx;\r\n        const txSettings = this._engine.debug.transform;\r\n        let motion;\r\n        const motionSettings = this._engine.debug.motion;\r\n        let colliderComp;\r\n        const colliderSettings = this._engine.debug.collider;\r\n        const physicsSettings = this._engine.debug.physics;\r\n        let graphics;\r\n        const graphicsSettings = this._engine.debug.graphics;\r\n        let debugDraw;\r\n        let body;\r\n        const bodySettings = this._engine.debug.body;\r\n        const cameraSettings = this._engine.debug.camera;\r\n        for (const entity of entities) {\r\n            if (entity.hasTag('offscreen')) {\r\n                // skip offscreen entities\r\n                continue;\r\n            }\r\n            if (entity instanceof Particle) {\r\n                // Particles crush the renderer :(\r\n                continue;\r\n            }\r\n            if (filterSettings.useFilter) {\r\n                const allIds = filterSettings.ids.length === 0;\r\n                const idMatch = allIds || filterSettings.ids.includes(entity.id);\r\n                if (!idMatch) {\r\n                    continue;\r\n                }\r\n                const allNames = filterSettings.nameQuery === '';\r\n                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);\r\n                if (!nameMatch) {\r\n                    continue;\r\n                }\r\n            }\r\n            let cursor = Vector.Zero;\r\n            const lineHeight = vec(0, 16);\r\n            id = entity.id;\r\n            name = entity.name;\r\n            tx = entity.get(TransformComponent);\r\n            // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n            this._pushCameraTransform(tx);\r\n            this._graphicsContext.save();\r\n            this._applyTransform(entity);\r\n            if (tx) {\r\n                if (txSettings.showAll || txSettings.showPosition) {\r\n                    this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });\r\n                }\r\n                if (txSettings.showAll || txSettings.showPositionLabel) {\r\n                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (txSettings.showAll || txSettings.showZIndex) {\r\n                    this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (entitySettings.showAll || entitySettings.showId) {\r\n                    this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? 'child of id(' + ((_a = entity.parent) === null || _a === void 0 ? void 0 : _a.id) + ')' : ''}`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (entitySettings.showAll || entitySettings.showName) {\r\n                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (txSettings.showAll || txSettings.showRotation) {\r\n                    this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);\r\n                    this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (txSettings.showAll || txSettings.showScale) {\r\n                    this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);\r\n                }\r\n            }\r\n            graphics = entity.get(GraphicsComponent);\r\n            if (graphics) {\r\n                if (graphicsSettings.showAll || graphicsSettings.showBounds) {\r\n                    const bounds = graphics.localBounds;\r\n                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);\r\n                }\r\n            }\r\n            debugDraw = entity.get(DebugGraphicsComponent);\r\n            if (debugDraw) {\r\n                if (!debugDraw.useTransform) {\r\n                    this._graphicsContext.restore();\r\n                }\r\n                debugDraw.draw(this._graphicsContext);\r\n                if (!debugDraw.useTransform) {\r\n                    this._graphicsContext.save();\r\n                    this._applyTransform(entity);\r\n                }\r\n            }\r\n            body = entity.get(BodyComponent);\r\n            if (body) {\r\n                if (bodySettings.showAll || bodySettings.showCollisionGroup) {\r\n                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (bodySettings.showAll || bodySettings.showCollisionType) {\r\n                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (bodySettings.showAll || bodySettings.showMass) {\r\n                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (bodySettings.showAll || bodySettings.showMotion) {\r\n                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (bodySettings.showAll || bodySettings.showSleeping) {\r\n                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : 'cant sleep'})`, cursor);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n            }\r\n            this._graphicsContext.restore();\r\n            motion = entity.get(MotionComponent);\r\n            if (motion) {\r\n                if (motionSettings.showAll || motionSettings.showVelocity) {\r\n                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));\r\n                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);\r\n                    cursor = cursor.add(lineHeight);\r\n                }\r\n                if (motionSettings.showAll || motionSettings.showAcceleration) {\r\n                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);\r\n                }\r\n            }\r\n            // Colliders live in world space already so after the restore()\r\n            colliderComp = entity.get(ColliderComponent);\r\n            if (colliderComp) {\r\n                const collider = colliderComp.get();\r\n                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {\r\n                    collider.debug(this._graphicsContext, colliderSettings.geometryColor);\r\n                }\r\n                if (colliderSettings.showAll || colliderSettings.showBounds) {\r\n                    if (collider instanceof CompositeCollider) {\r\n                        const colliders = collider.getColliders();\r\n                        for (const collider of colliders) {\r\n                            const bounds = collider.bounds;\r\n                            const pos = vec(bounds.left, bounds.top);\r\n                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n                            if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);\r\n                            }\r\n                        }\r\n                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);\r\n                    }\r\n                    else if (collider) {\r\n                        const bounds = colliderComp.bounds;\r\n                        const pos = vec(bounds.left, bounds.top);\r\n                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n                        if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this._popCameraTransform(tx);\r\n        }\r\n        this._graphicsContext.save();\r\n        this._camera.draw(this._graphicsContext);\r\n        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {\r\n            this._collisionSystem.debug(this._graphicsContext);\r\n        }\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {\r\n            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {\r\n                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {\r\n                    for (const point of contact.points) {\r\n                        this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });\r\n                    }\r\n                }\r\n                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {\r\n                    for (const point of contact.points) {\r\n                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {\r\n                            color: physicsSettings.collisionNormalColor\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._graphicsContext.restore();\r\n        if (cameraSettings) {\r\n            this._graphicsContext.save();\r\n            this._camera.draw(this._graphicsContext);\r\n            if (cameraSettings.showAll || cameraSettings.showFocus) {\r\n                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);\r\n            }\r\n            if (cameraSettings.showAll || cameraSettings.showZoom) {\r\n                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);\r\n            }\r\n            this._graphicsContext.restore();\r\n        }\r\n        this._graphicsContext.flush();\r\n    }\r\n    /**\r\n     * This applies the current entity transform to the graphics context\r\n     * @param entity\r\n     */\r\n    _applyTransform(entity) {\r\n        const ancestors = entity.getAncestors();\r\n        for (const ancestor of ancestors) {\r\n            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);\r\n            if (transform) {\r\n                this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n                this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n                this._graphicsContext.rotate(transform.rotation);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Applies the current camera transform if in world coordinates\r\n     * @param transform\r\n     */\r\n    _pushCameraTransform(transform) {\r\n        // Establish camera offset per entity\r\n        if (transform.coordPlane === CoordPlane.World) {\r\n            this._graphicsContext.save();\r\n            if (this._camera) {\r\n                this._camera.draw(this._graphicsContext);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Resets the current camera transform if in world coordinates\r\n     * @param transform\r\n     */\r\n    _popCameraTransform(transform) {\r\n        if (transform.coordPlane === CoordPlane.World) {\r\n            // Apply camera world offset\r\n            this._graphicsContext.restore();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/PointerSystem.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The PointerSystem is responsible for dispatching pointer events to entities\r\n * that need them.\r\n *\r\n * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use\r\n * the [[Collider]]'s shape for pointer events.\r\n */\r\nclass PointerSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform', 'ex.pointer'];\r\n        this.systemType = SystemType.Update;\r\n        this.priority = -1;\r\n        /**\r\n         * Optionally override component configuration for all entities\r\n         */\r\n        this.overrideUseColliderShape = false;\r\n        /**\r\n         * Optionally override component configuration for all entities\r\n         */\r\n        this.overrideUseGraphicsBounds = false;\r\n        this.lastFrameEntityToPointers = new Map();\r\n        this.currentFrameEntityToPointers = new Map();\r\n        this._sortedTransforms = [];\r\n        this._sortedEntities = [];\r\n        this._zHasChanged = false;\r\n        this._zIndexUpdate = () => {\r\n            this._zHasChanged = true;\r\n        };\r\n    }\r\n    initialize(scene) {\r\n        this._engine = scene.engine;\r\n    }\r\n    preupdate() {\r\n        // event receiver might change per frame\r\n        this._receiver = this._engine.input.pointers;\r\n        if (this._zHasChanged) {\r\n            this._sortedTransforms.sort((a, b) => {\r\n                return b.z - a.z;\r\n            });\r\n            this._sortedEntities = this._sortedTransforms.map(t => t.owner);\r\n            this._zHasChanged = false;\r\n        }\r\n    }\r\n    notify(entityAddedOrRemoved) {\r\n        if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n            const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n            this._sortedTransforms.push(tx);\r\n            this._sortedEntities.push(tx.owner);\r\n            tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n            this._zHasChanged = true;\r\n        }\r\n        else {\r\n            const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n            const index = this._sortedTransforms.indexOf(tx);\r\n            if (index > -1) {\r\n                this._sortedTransforms.splice(index, 1);\r\n                this._sortedEntities.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n    entityCurrentlyUnderPointer(entity, pointerId) {\r\n        return this.currentFrameEntityToPointers.has(entity.id) &&\r\n            this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n    }\r\n    entityWasUnderPointer(entity, pointerId) {\r\n        return this.lastFrameEntityToPointers.has(entity.id) &&\r\n            this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n    }\r\n    entered(entity, pointerId) {\r\n        return this.entityCurrentlyUnderPointer(entity, pointerId) &&\r\n            !this.lastFrameEntityToPointers.has(entity.id);\r\n    }\r\n    left(entity, pointerId) {\r\n        return !this.currentFrameEntityToPointers.has(entity.id) &&\r\n            this.entityWasUnderPointer(entity, pointerId);\r\n    }\r\n    addPointerToEntity(entity, pointerId) {\r\n        if (!this.currentFrameEntityToPointers.has(entity.id)) {\r\n            this.currentFrameEntityToPointers.set(entity.id, [pointerId]);\r\n            return;\r\n        }\r\n        const pointers = this.currentFrameEntityToPointers.get(entity.id);\r\n        this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));\r\n    }\r\n    update(_entities) {\r\n        // Locate all the pointer/entity mappings\r\n        this._processPointerToEntity(this._sortedEntities);\r\n        // Dispatch pointer events on entities\r\n        this._dispatchEvents(this._sortedEntities);\r\n        // Clear last frame's events\r\n        this._receiver.update();\r\n        this.lastFrameEntityToPointers.clear();\r\n        this.lastFrameEntityToPointers = new Map(this.currentFrameEntityToPointers);\r\n        this.currentFrameEntityToPointers.clear();\r\n        this._receiver.clear();\r\n    }\r\n    _processPointerToEntity(entities) {\r\n        var _a;\r\n        let transform;\r\n        let collider;\r\n        let graphics;\r\n        let pointer;\r\n        // TODO probably a spatial partition optimization here to quickly query bounds for pointer\r\n        // doesn't seem to cause issues tho for perf\r\n        // Pre-process find entities under pointers\r\n        for (const entity of entities) {\r\n            transform = entity.get(TransformComponent);\r\n            pointer = (_a = entity.get(PointerComponent)) !== null && _a !== void 0 ? _a : new PointerComponent;\r\n            // Check collider contains pointer\r\n            collider = entity.get(ColliderComponent);\r\n            if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {\r\n                collider.update();\r\n                const geom = collider.get();\r\n                if (geom) {\r\n                    for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n                        if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n                            this.addPointerToEntity(entity, pointerId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Check graphics contains pointer\r\n            graphics = entity.get(GraphicsComponent);\r\n            if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {\r\n                const graphicBounds = graphics.localBounds.transform(transform.get().matrix);\r\n                for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n                    if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n                        this.addPointerToEntity(entity, pointerId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _processDownAndEmit(entity) {\r\n        const lastDownPerPointer = new Map();\r\n        // Loop through down and dispatch to entities\r\n        for (const event of this._receiver.currentFrameDown) {\r\n            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n                entity.events.emit('pointerdown', event);\r\n                if (this._receiver.isDragStart(event.pointerId)) {\r\n                    entity.events.emit('pointerdragstart', event);\r\n                }\r\n            }\r\n            lastDownPerPointer.set(event.pointerId, event);\r\n        }\r\n        return lastDownPerPointer;\r\n    }\r\n    _processUpAndEmit(entity) {\r\n        const lastUpPerPointer = new Map();\r\n        // Loop through up and dispatch to entities\r\n        for (const event of this._receiver.currentFrameUp) {\r\n            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n                entity.events.emit('pointerup', event);\r\n                if (this._receiver.isDragEnd(event.pointerId)) {\r\n                    entity.events.emit('pointerdragend', event);\r\n                }\r\n            }\r\n            lastUpPerPointer.set(event.pointerId, event);\r\n        }\r\n        return lastUpPerPointer;\r\n    }\r\n    _processMoveAndEmit(entity) {\r\n        const lastMovePerPointer = new Map();\r\n        // Loop through move and dispatch to entities\r\n        for (const event of this._receiver.currentFrameMove) {\r\n            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n                // move\r\n                entity.events.emit('pointermove', event);\r\n                if (this._receiver.isDragging(event.pointerId)) {\r\n                    entity.events.emit('pointerdragmove', event);\r\n                }\r\n            }\r\n            lastMovePerPointer.set(event.pointerId, event);\r\n        }\r\n        return lastMovePerPointer;\r\n    }\r\n    _processEnterLeaveAndEmit(entity, lastUpDownMoveEvents) {\r\n        // up, down, and move are considered for enter and leave\r\n        for (const event of lastUpDownMoveEvents) {\r\n            // enter\r\n            if (event.active && entity.active && this.entered(entity, event.pointerId)) {\r\n                entity.events.emit('pointerenter', event);\r\n                if (this._receiver.isDragging(event.pointerId)) {\r\n                    entity.events.emit('pointerdragenter', event);\r\n                }\r\n                break;\r\n            }\r\n            if (event.active && entity.active &&\r\n                // leave can happen on move\r\n                (this.left(entity, event.pointerId) ||\r\n                    // or leave can happen on pointer up\r\n                    (this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === 'up'))) {\r\n                entity.events.emit('pointerleave', event);\r\n                if (this._receiver.isDragging(event.pointerId)) {\r\n                    entity.events.emit('pointerdragleave', event);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    _processCancelAndEmit(entity) {\r\n        // cancel\r\n        for (const event of this._receiver.currentFrameCancel) {\r\n            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n                entity.events.emit('pointercancel', event);\r\n            }\r\n        }\r\n    }\r\n    _processWheelAndEmit(entity) {\r\n        // wheel\r\n        for (const event of this._receiver.currentFrameWheel) {\r\n            // Currently the wheel only fires under the primary pointer '0'\r\n            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {\r\n                entity.events.emit('pointerwheel', event);\r\n            }\r\n        }\r\n    }\r\n    _dispatchEvents(entities) {\r\n        const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());\r\n        const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());\r\n        // Filter preserves z order\r\n        const entitiesWithEvents = entities.filter(e => lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));\r\n        let lastMovePerPointer;\r\n        let lastUpPerPointer;\r\n        let lastDownPerPointer;\r\n        // Dispatch events in entity z order\r\n        for (const entity of entitiesWithEvents) {\r\n            lastDownPerPointer = this._processDownAndEmit(entity);\r\n            lastUpPerPointer = this._processUpAndEmit(entity);\r\n            lastMovePerPointer = this._processMoveAndEmit(entity);\r\n            const lastUpDownMoveEvents = [\r\n                ...lastMovePerPointer.values(),\r\n                ...lastDownPerPointer.values(),\r\n                ...lastUpPerPointer.values()\r\n            ];\r\n            this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);\r\n            this._processCancelAndEmit(entity);\r\n            this._processWheelAndEmit(entity);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/ActionsSystem.ts\n\r\n\r\nclass ActionsSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.actions'];\r\n        this.systemType = SystemType.Update;\r\n        this.priority = -1;\r\n        this._actions = [];\r\n    }\r\n    notify(entityAddedOrRemoved) {\r\n        if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n            const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n            this._actions.push(action);\r\n        }\r\n        else {\r\n            const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n            const index = this._actions.indexOf(action);\r\n            if (index > -1) {\r\n                this._actions.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n    update(_entities, delta) {\r\n        for (const actions of this._actions) {\r\n            actions.update(delta);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./TileMap/IsometricEntityComponent.ts\n\r\nclass IsometricEntityComponent extends Component {\r\n    /**\r\n     * Specify the isometric map to use to position this entity's z-index\r\n     * @param map\r\n     */\r\n    constructor(map) {\r\n        super();\r\n        this.type = 'ex.isometricentity';\r\n        /**\r\n         * Vertical \"height\" in the isometric world\r\n         */\r\n        this.elevation = 0;\r\n        this.map = map;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./TileMap/IsometricEntitySystem.ts\n\r\n\r\n\r\nclass IsometricEntitySystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform', 'ex.isometricentity'];\r\n        this.systemType = SystemType.Update;\r\n        this.priority = 99;\r\n    }\r\n    update(entities, _delta) {\r\n        let transform;\r\n        let iso;\r\n        for (const entity of entities) {\r\n            transform = entity.get(TransformComponent);\r\n            iso = entity.get(IsometricEntityComponent);\r\n            const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);\r\n            const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;\r\n            transform.z = newZ;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/OffscreenSystem.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass OffscreenSystem extends System {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.types = ['ex.transform', 'ex.graphics'];\r\n        this.systemType = SystemType.Draw;\r\n        this.priority = -1;\r\n    }\r\n    initialize(scene) {\r\n        this._camera = scene.camera;\r\n    }\r\n    update(entities) {\r\n        let transform;\r\n        let graphics;\r\n        let maybeParallax;\r\n        for (const entity of entities) {\r\n            graphics = entity.get(GraphicsComponent);\r\n            transform = entity.get(TransformComponent);\r\n            maybeParallax = entity.get(ParallaxComponent);\r\n            let parallaxOffset;\r\n            if (maybeParallax) {\r\n                // We use the Tiled formula\r\n                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n                // cameraPos * (1 - parallaxFactor)\r\n                const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n                parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n            }\r\n            // Figure out if entities are offscreen\r\n            const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);\r\n            if (entityOffscreen && !entity.hasTag('ex.offscreen')) {\r\n                entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));\r\n                entity.addTag('ex.offscreen');\r\n            }\r\n            if (!entityOffscreen && entity.hasTag('ex.offscreen')) {\r\n                entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));\r\n                entity.removeTag('ex.offscreen');\r\n            }\r\n        }\r\n    }\r\n    _isOffscreen(transform, graphics, parallaxOffset) {\r\n        if (transform.coordPlane === CoordPlane.World) {\r\n            let bounds = graphics.localBounds;\r\n            if (parallaxOffset) {\r\n                bounds = bounds.translate(parallaxOffset);\r\n            }\r\n            const transformedBounds = bounds.transform(transform.get().matrix);\r\n            const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);\r\n            return graphicsOffscreen;\r\n        }\r\n        else {\r\n            // TODO screen coordinates\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Scene.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n * Excalibur. The metaphor models the same idea behind real world\r\n * actors in a scene. Only actors in scenes will be updated and drawn.\r\n *\r\n * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n */\r\nclass Scene extends Class {\r\n    constructor() {\r\n        super();\r\n        this._logger = Logger.getInstance();\r\n        /**\r\n         * Gets or sets the current camera for the scene\r\n         */\r\n        this.camera = new Camera();\r\n        /**\r\n         * The ECS world for the scene\r\n         */\r\n        this.world = new World(this);\r\n        this._isInitialized = false;\r\n        this._timers = [];\r\n        this._cancelQueue = [];\r\n        // Initialize systems\r\n        // Update\r\n        this.world.add(new ActionsSystem());\r\n        this.world.add(new MotionSystem());\r\n        this.world.add(new CollisionSystem());\r\n        this.world.add(new PointerSystem());\r\n        this.world.add(new IsometricEntitySystem());\r\n        // Draw\r\n        this.world.add(new OffscreenSystem());\r\n        this.world.add(new GraphicsSystem());\r\n        this.world.add(new DebugSystem());\r\n    }\r\n    /**\r\n     * The actors in the current scene\r\n     */\r\n    get actors() {\r\n        return this.world.entityManager.entities.filter((e) => {\r\n            return e instanceof Actor;\r\n        });\r\n    }\r\n    /**\r\n     * The entities in the current scene\r\n     */\r\n    get entities() {\r\n        return this.world.entityManager.entities;\r\n    }\r\n    /**\r\n     * The triggers in the current scene\r\n     */\r\n    get triggers() {\r\n        return this.world.entityManager.entities.filter((e) => {\r\n            return e instanceof Trigger;\r\n        });\r\n    }\r\n    /**\r\n     * The [[TileMap]]s in the scene, if any\r\n     */\r\n    get tileMaps() {\r\n        return this.world.entityManager.entities.filter((e) => {\r\n            return e instanceof TileMap;\r\n        });\r\n    }\r\n    get timers() {\r\n        return this._timers;\r\n    }\r\n    on(eventName, handler) {\r\n        super.on(eventName, handler);\r\n    }\r\n    once(eventName, handler) {\r\n        super.once(eventName, handler);\r\n    }\r\n    off(eventName, handler) {\r\n        super.off(eventName, handler);\r\n    }\r\n    /**\r\n     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n     * overridden. This is where initialization of child actors should take place.\r\n     */\r\n    onInitialize(_engine) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * This is called when the scene is made active and started. It is meant to be overridden,\r\n     * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n     */\r\n    onActivate(_context) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,\r\n     * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n     */\r\n    onDeactivate(_context) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreUpdate` is called directly before a scene is updated.\r\n     */\r\n    onPreUpdate(_engine, _delta) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostUpdate` is called directly after a scene is updated.\r\n     */\r\n    onPostUpdate(_engine, _delta) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPreDraw` is called directly before a scene is drawn.\r\n     *\r\n     */\r\n    onPreDraw(_ctx, _delta) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n     *\r\n     * `onPostDraw` is called directly after a scene is drawn.\r\n     *\r\n     */\r\n    onPostDraw(_ctx, _delta) {\r\n        // will be overridden\r\n    }\r\n    /**\r\n     * Initializes actors in the scene\r\n     */\r\n    _initializeChildren() {\r\n        for (const child of this.entities) {\r\n            child._initialize(this.engine);\r\n        }\r\n    }\r\n    /**\r\n     * Gets whether or not the [[Scene]] has been initialized\r\n     */\r\n    get isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Initializes the scene before the first update, meant to be called by engine not by users of\r\n     * Excalibur\r\n     * @internal\r\n     */\r\n    _initialize(engine) {\r\n        if (!this.isInitialized) {\r\n            this.engine = engine;\r\n            // Initialize camera first\r\n            this.camera._initialize(engine);\r\n            this.world.systemManager.initialize();\r\n            // This order is important! we want to be sure any custom init that add actors\r\n            // fire before the actor init\r\n            this.onInitialize.call(this, engine);\r\n            this._initializeChildren();\r\n            this._logger.debug('Scene.onInitialize', this, engine);\r\n            this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.\r\n     * @internal\r\n     */\r\n    _activate(context) {\r\n        this._logger.debug('Scene.onActivate', this);\r\n        this.onActivate(context);\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.\r\n     * @internal\r\n     */\r\n    _deactivate(context) {\r\n        this._logger.debug('Scene.onDeactivate', this);\r\n        this.onDeactivate(context);\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _preupdate(_engine, delta) {\r\n        this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));\r\n        this.onPreUpdate(_engine, delta);\r\n    }\r\n    /**\r\n     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n     * @internal\r\n     */\r\n    _postupdate(_engine, delta) {\r\n        this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));\r\n        this.onPostUpdate(_engine, delta);\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n     *\r\n     * @internal\r\n     */\r\n    _predraw(_ctx, _delta) {\r\n        this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));\r\n        this.onPreDraw(_ctx, _delta);\r\n    }\r\n    /**\r\n     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n     *\r\n     * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n     *\r\n     * @internal\r\n     */\r\n    _postdraw(_ctx, _delta) {\r\n        this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));\r\n        this.onPostDraw(_ctx, _delta);\r\n    }\r\n    /**\r\n     * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n     * @param engine  Reference to the current Engine\r\n     * @param delta   The number of milliseconds since the last update\r\n     */\r\n    update(engine, delta) {\r\n        this._preupdate(engine, delta);\r\n        // TODO differed entity removal for timers\r\n        let i, len;\r\n        // Remove timers in the cancel queue before updating them\r\n        for (i = 0, len = this._cancelQueue.length; i < len; i++) {\r\n            this.removeTimer(this._cancelQueue[i]);\r\n        }\r\n        this._cancelQueue.length = 0;\r\n        // Cycle through timers updating timers\r\n        for (const timer of this._timers) {\r\n            timer.update(delta);\r\n        }\r\n        this.world.update(SystemType.Update, delta);\r\n        // Camera last keeps renders smooth that are based on entity/actor\r\n        if (this.camera) {\r\n            this.camera.update(engine, delta);\r\n        }\r\n        this._collectActorStats(engine);\r\n        this._postupdate(engine, delta);\r\n    }\r\n    /**\r\n     * Draws all the actors in the Scene. Called by the [[Engine]].\r\n     *\r\n     * @param ctx    The current rendering context\r\n     * @param delta  The number of milliseconds since the last draw\r\n     */\r\n    draw(ctx, delta) {\r\n        var _a;\r\n        this._predraw(ctx, delta);\r\n        this.world.update(SystemType.Draw, delta);\r\n        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {\r\n            this.debugDraw(ctx);\r\n        }\r\n        this._postdraw(ctx, delta);\r\n    }\r\n    /**\r\n     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].\r\n     * @param ctx  The current rendering context\r\n     */\r\n    /* istanbul ignore next */\r\n    debugDraw(ctx) {\r\n        this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));\r\n        // pass\r\n        this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));\r\n    }\r\n    /**\r\n     * Checks whether an actor is contained in this scene or not\r\n     */\r\n    contains(actor) {\r\n        return this.actors.indexOf(actor) > -1;\r\n    }\r\n    add(entity) {\r\n        this.emit('entityadded', { target: entity });\r\n        this.world.add(entity);\r\n        entity.scene = this;\r\n        if (entity instanceof Timer) {\r\n            if (!contains(this._timers, entity)) {\r\n                this.addTimer(entity);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    remove(entity) {\r\n        if (entity instanceof Entity) {\r\n            this.emit('entityremoved', { target: entity });\r\n            this.world.remove(entity);\r\n        }\r\n        if (entity instanceof Timer) {\r\n            this.removeTimer(entity);\r\n        }\r\n    }\r\n    /**\r\n     * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.\r\n     *\r\n     * By default entities use deferred removal\r\n     * @param deferred\r\n     */\r\n    clear(deferred = true) {\r\n        for (const entity of this.entities) {\r\n            this.world.remove(entity, deferred);\r\n        }\r\n        for (const timer of this.timers) {\r\n            this.removeTimer(timer);\r\n        }\r\n    }\r\n    /**\r\n     * Adds a [[Timer]] to the scene\r\n     * @param timer  The timer to add\r\n     */\r\n    addTimer(timer) {\r\n        this._timers.push(timer);\r\n        timer.scene = this;\r\n        return timer;\r\n    }\r\n    /**\r\n     * Removes a [[Timer]] from the scene.\r\n     * @warning Can be dangerous, use [[cancelTimer]] instead\r\n     * @param timer  The timer to remove\r\n     */\r\n    removeTimer(timer) {\r\n        const i = this._timers.indexOf(timer);\r\n        if (i !== -1) {\r\n            this._timers.splice(i, 1);\r\n        }\r\n        return timer;\r\n    }\r\n    /**\r\n     * Cancels a [[Timer]], removing it from the scene nicely\r\n     * @param timer  The timer to cancel\r\n     */\r\n    cancelTimer(timer) {\r\n        this._cancelQueue.push(timer);\r\n        return timer;\r\n    }\r\n    /**\r\n     * Tests whether a [[Timer]] is active in the scene\r\n     */\r\n    isTimerActive(timer) {\r\n        return this._timers.indexOf(timer) > -1 && !timer.complete;\r\n    }\r\n    isCurrentScene() {\r\n        if (this.engine) {\r\n            return this.engine.currentScene === this;\r\n        }\r\n        return false;\r\n    }\r\n    _collectActorStats(engine) {\r\n        const screenElements = this.actors.filter((a) => a instanceof ScreenElement);\r\n        for (const _ui of screenElements) {\r\n            engine.stats.currFrame.actors.ui++;\r\n        }\r\n        for (const actor of this.actors) {\r\n            engine.stats.currFrame.actors.alive++;\r\n            for (const child of actor.children) {\r\n                if (isScreenElement(child)) {\r\n                    // TODO not true\r\n                    engine.stats.currFrame.actors.ui++;\r\n                }\r\n                else {\r\n                    engine.stats.currFrame.actors.alive++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/PostProcessor/ColorBlindnessMode.ts\nvar ColorBlindnessMode;\r\n(function (ColorBlindnessMode) {\r\n    ColorBlindnessMode[\"Protanope\"] = \"Protanope\";\r\n    ColorBlindnessMode[\"Deuteranope\"] = \"Deuteranope\";\r\n    ColorBlindnessMode[\"Tritanope\"] = \"Tritanope\";\r\n})(ColorBlindnessMode || (ColorBlindnessMode = {}));\r\n\n;// CONCATENATED MODULE: ./Graphics/PostProcessor/color-blind-fragment.glsl\n/* harmony default export */ const color_blind_fragment = (\"#version 300 es\\r\\nprecision mediump float;\\r\\n// our texture\\r\\nuniform sampler2D u_image;\\r\\n// the texCoords passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// color blind type\\r\\nuniform int u_type;\\r\\n\\r\\n// simulation?\\r\\nuniform bool u_simulate;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  vec4 o =  texture(u_image, v_texcoord);\\r\\n  // RGB to LMS matrix conversion\\r\\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\\r\\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\\r\\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\\r\\n  // Simulate color blindness\\r\\n  float l;\\r\\n  float m;\\r\\n  float s;\\r\\n  //MODE CODE//\\r\\n  if (u_type == 0) {\\r\\n    // Protanope\\r\\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\\r\\n  } else if (u_type == 1) {\\r\\n    // Deuteranope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\\r\\n  } else if (u_type == 2) {\\r\\n    // Tritanope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\\r\\n  }\\r\\n\\r\\n  // LMS to RGB matrix conversion\\r\\n  vec4 error; // simulate the colors\\r\\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\\r\\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\\r\\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\\r\\n  error.a = 1.0;\\r\\n  vec4 diff = o - error;\\r\\n  vec4 correction; // correct the colors\\r\\n  correction.r = 0.0;\\r\\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\\r\\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\\r\\n  correction = o + correction;\\r\\n  correction.a = o.a;\\r\\n  //SIMULATE//\\r\\n\\r\\n  // sim \\r\\n  if (u_simulate) {\\r\\n    fragColor = error.rgba;\\r\\n  } else {\\r\\n    fragColor = correction.rgba;\\r\\n  }\\r\\n}\");\n;// CONCATENATED MODULE: ./Graphics/PostProcessor/ScreenShader.ts\n\r\n\r\n\r\n/**\r\n * Helper that defines a whole screen renderer, just provide a fragment source!\r\n *\r\n * Currently supports 1 varying\r\n * - vec2 a_texcoord between 0-1 which corresponds to screen position\r\n */\r\nclass ScreenShader {\r\n    constructor(fragmentSource) {\r\n        this._shader = new Shader({\r\n            vertexSource: `#version 300 es\r\n      in vec2 a_position;\r\n      in vec2 a_texcoord;\r\n      out vec2 v_texcoord;\r\n\r\n      void main() {\r\n        gl_Position = vec4(a_position, 0.0, 1.0);\r\n        // Pass the texcoord to the fragment shader.\r\n        v_texcoord = a_texcoord;\r\n      }`,\r\n            fragmentSource: fragmentSource\r\n        });\r\n        this._shader.compile();\r\n        // Setup memory layout\r\n        this._buffer = new VertexBuffer({\r\n            type: 'static',\r\n            // clip space quad + uv since we don't need a camera\r\n            data: new Float32Array([\r\n                -1, -1, 0, 0,\r\n                -1, 1, 0, 1,\r\n                1, -1, 1, 0,\r\n                1, -1, 1, 0,\r\n                -1, 1, 0, 1,\r\n                1, 1, 1, 1\r\n            ])\r\n        });\r\n        this._layout = new VertexLayout({\r\n            shader: this._shader,\r\n            vertexBuffer: this._buffer,\r\n            attributes: [\r\n                ['a_position', 2],\r\n                ['a_texcoord', 2]\r\n            ]\r\n        });\r\n        this._buffer.upload();\r\n    }\r\n    getShader() {\r\n        return this._shader;\r\n    }\r\n    getLayout() {\r\n        return this._layout;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts\n\r\n\r\n\r\nclass ColorBlindnessPostProcessor {\r\n    constructor(_colorBlindnessMode, simulate = false) {\r\n        this._colorBlindnessMode = _colorBlindnessMode;\r\n        this._simulate = false;\r\n        this._simulate = simulate;\r\n    }\r\n    initialize(_gl) {\r\n        this._shader = new ScreenShader(color_blind_fragment);\r\n        this.simulate = this._simulate;\r\n        this.colorBlindnessMode = this._colorBlindnessMode;\r\n    }\r\n    getShader() {\r\n        return this._shader.getShader();\r\n    }\r\n    getLayout() {\r\n        return this._shader.getLayout();\r\n    }\r\n    set colorBlindnessMode(colorBlindMode) {\r\n        this._colorBlindnessMode = colorBlindMode;\r\n        if (this._shader) {\r\n            const shader = this._shader.getShader();\r\n            shader.use();\r\n            if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {\r\n                shader.setUniformInt('u_type', 0);\r\n            }\r\n            else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {\r\n                shader.setUniformInt('u_type', 1);\r\n            }\r\n            else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {\r\n                shader.setUniformInt('u_type', 2);\r\n            }\r\n        }\r\n    }\r\n    get colorBlindnessMode() {\r\n        return this._colorBlindnessMode;\r\n    }\r\n    set simulate(value) {\r\n        this._simulate = value;\r\n        if (this._shader) {\r\n            const shader = this._shader.getShader();\r\n            shader.use();\r\n            shader.setUniformBoolean('u_simulate', value);\r\n        }\r\n    }\r\n    get simulate() {\r\n        return this._simulate;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Debug/DebugFlags.ts\n\r\n\r\n\r\nclass ColorBlindFlags {\r\n    constructor(engine) {\r\n        this._engine = engine;\r\n        this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);\r\n    }\r\n    /**\r\n     * Correct colors for a specified color blindness\r\n     * @param colorBlindness\r\n     */\r\n    correct(colorBlindness) {\r\n        if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n            this.clear();\r\n            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n            this._colorBlindPostProcessor.simulate = false;\r\n            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n        }\r\n    }\r\n    /**\r\n     * Simulate colors for a specified color blindness\r\n     * @param colorBlindness\r\n     */\r\n    simulate(colorBlindness) {\r\n        if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n            this.clear();\r\n            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n            this._colorBlindPostProcessor.simulate = true;\r\n            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n        }\r\n    }\r\n    /**\r\n     * Remove color blindness post processor\r\n     */\r\n    clear() {\r\n        this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Debug/Debug.ts\n\r\n\r\n/**\r\n * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n * updated during a frame.\r\n */\r\nclass Debug {\r\n    constructor(engine) {\r\n        /**\r\n         * Performance statistics\r\n         */\r\n        this.stats = {\r\n            /**\r\n             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n             * Best accessed on [[postframe]] event. See [[FrameStats]]\r\n             */\r\n            currFrame: new FrameStats(),\r\n            /**\r\n             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]\r\n             */\r\n            prevFrame: new FrameStats()\r\n        };\r\n        /**\r\n         * Filter debug context to named entities or entity ids\r\n         */\r\n        this.filter = {\r\n            /**\r\n             * Toggle filter on or off (default off) must be on for DebugDraw to use filters\r\n             */\r\n            useFilter: false,\r\n            /**\r\n             * Query for entities by name, if the entity name contains `nameQuery` it will be included\r\n             */\r\n            nameQuery: '',\r\n            /**\r\n             * Query for Entity ids, if the id matches it will be included\r\n             */\r\n            ids: []\r\n        };\r\n        /**\r\n         * Entity debug settings\r\n         */\r\n        this.entity = {\r\n            showAll: false,\r\n            showId: true,\r\n            showName: false\r\n        };\r\n        /**\r\n         * Transform component debug settings\r\n         */\r\n        this.transform = {\r\n            showAll: false,\r\n            showPosition: false,\r\n            showPositionLabel: false,\r\n            positionColor: Color.Yellow,\r\n            showZIndex: false,\r\n            showScale: false,\r\n            scaleColor: Color.Green,\r\n            showRotation: false,\r\n            rotationColor: Color.Blue\r\n        };\r\n        /**\r\n         * Graphics component debug settings\r\n         */\r\n        this.graphics = {\r\n            showAll: false,\r\n            showBounds: true,\r\n            boundsColor: Color.Yellow\r\n        };\r\n        /**\r\n         * Collider component debug settings\r\n         */\r\n        this.collider = {\r\n            showAll: false,\r\n            showBounds: true,\r\n            boundsColor: Color.Blue,\r\n            showOwner: false,\r\n            showGeometry: true,\r\n            geometryColor: Color.Green\r\n        };\r\n        /**\r\n         * Physics simulation debug settings\r\n         */\r\n        this.physics = {\r\n            showAll: false,\r\n            showBroadphaseSpacePartitionDebug: false,\r\n            showCollisionNormals: false,\r\n            collisionNormalColor: Color.Cyan,\r\n            showCollisionContacts: true,\r\n            collisionContactColor: Color.Red\r\n        };\r\n        /**\r\n         * Motion component debug settings\r\n         */\r\n        this.motion = {\r\n            showAll: false,\r\n            showVelocity: false,\r\n            velocityColor: Color.Yellow,\r\n            showAcceleration: false,\r\n            accelerationColor: Color.Red\r\n        };\r\n        /**\r\n         * Body component debug settings\r\n         */\r\n        this.body = {\r\n            showAll: false,\r\n            showCollisionGroup: false,\r\n            showCollisionType: false,\r\n            showSleeping: false,\r\n            showMotion: false,\r\n            showMass: false\r\n        };\r\n        /**\r\n         * Camera debug settings\r\n         */\r\n        this.camera = {\r\n            showAll: false,\r\n            showFocus: false,\r\n            focusColor: Color.Red,\r\n            showZoom: false\r\n        };\r\n        this._engine = engine;\r\n        this.colorBlindMode = new ColorBlindFlags(this._engine);\r\n    }\r\n    /**\r\n     * Switch the current excalibur clock with the [[TestClock]] and return\r\n     * it in the same running state.\r\n     *\r\n     * This is useful when you need to debug frame by frame.\r\n     */\r\n    useTestClock() {\r\n        const clock = this._engine.clock;\r\n        const wasRunning = clock.isRunning();\r\n        clock.stop();\r\n        const testClock = clock.toTestClock();\r\n        if (wasRunning) {\r\n            testClock.start();\r\n        }\r\n        this._engine.clock = testClock;\r\n        return testClock;\r\n    }\r\n    /**\r\n     * Switch the current excalibur clock with the [[StandardClock]] and\r\n     * return it in the same running state.\r\n     *\r\n     * This is useful when you need to switch back to normal mode after\r\n     * debugging.\r\n     */\r\n    useStandardClock() {\r\n        const currentClock = this._engine.clock;\r\n        const wasRunning = currentClock.isRunning();\r\n        currentClock.stop();\r\n        const standardClock = currentClock.toStandardClock();\r\n        if (wasRunning) {\r\n            standardClock.start();\r\n        }\r\n        this._engine.clock = standardClock;\r\n        return standardClock;\r\n    }\r\n}\r\n/**\r\n * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n * creating instances of this every frame.\r\n */\r\nclass FrameStats {\r\n    constructor() {\r\n        this._id = 0;\r\n        this._delta = 0;\r\n        this._fps = 0;\r\n        this._actorStats = {\r\n            alive: 0,\r\n            killed: 0,\r\n            ui: 0,\r\n            get remaining() {\r\n                return this.alive - this.killed;\r\n            },\r\n            get total() {\r\n                return this.remaining + this.ui;\r\n            }\r\n        };\r\n        this._durationStats = {\r\n            update: 0,\r\n            draw: 0,\r\n            get total() {\r\n                return this.update + this.draw;\r\n            }\r\n        };\r\n        this._physicsStats = new PhysicsStats();\r\n        this._graphicsStats = {\r\n            drawCalls: 0,\r\n            drawnImages: 0\r\n        };\r\n    }\r\n    /**\r\n     * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n     *\r\n     * @param [otherStats] Optional stats to clone\r\n     */\r\n    reset(otherStats) {\r\n        if (otherStats) {\r\n            this.id = otherStats.id;\r\n            this.delta = otherStats.delta;\r\n            this.fps = otherStats.fps;\r\n            this.actors.alive = otherStats.actors.alive;\r\n            this.actors.killed = otherStats.actors.killed;\r\n            this.actors.ui = otherStats.actors.ui;\r\n            this.duration.update = otherStats.duration.update;\r\n            this.duration.draw = otherStats.duration.draw;\r\n            this._physicsStats.reset(otherStats.physics);\r\n            this.graphics.drawCalls = otherStats.graphics.drawCalls;\r\n            this.graphics.drawnImages = otherStats.graphics.drawnImages;\r\n        }\r\n        else {\r\n            this.id = this.delta = this.fps = 0;\r\n            this.actors.alive = this.actors.killed = this.actors.ui = 0;\r\n            this.duration.update = this.duration.draw = 0;\r\n            this._physicsStats.reset();\r\n            this.graphics.drawnImages = this.graphics.drawCalls = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Provides a clone of this instance.\r\n     */\r\n    clone() {\r\n        const fs = new FrameStats();\r\n        fs.reset(this);\r\n        return fs;\r\n    }\r\n    /**\r\n     * Gets the frame's id\r\n     */\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    /**\r\n     * Sets the frame's id\r\n     */\r\n    set id(value) {\r\n        this._id = value;\r\n    }\r\n    /**\r\n     * Gets the frame's delta (time since last frame)\r\n     */\r\n    get delta() {\r\n        return this._delta;\r\n    }\r\n    /**\r\n     * Sets the frame's delta (time since last frame). Internal use only.\r\n     * @internal\r\n     */\r\n    set delta(value) {\r\n        this._delta = value;\r\n    }\r\n    /**\r\n     * Gets the frame's frames-per-second (FPS)\r\n     */\r\n    get fps() {\r\n        return this._fps;\r\n    }\r\n    /**\r\n     * Sets the frame's frames-per-second (FPS). Internal use only.\r\n     * @internal\r\n     */\r\n    set fps(value) {\r\n        this._fps = value;\r\n    }\r\n    /**\r\n     * Gets the frame's actor statistics\r\n     */\r\n    get actors() {\r\n        return this._actorStats;\r\n    }\r\n    /**\r\n     * Gets the frame's duration statistics\r\n     */\r\n    get duration() {\r\n        return this._durationStats;\r\n    }\r\n    /**\r\n     * Gets the frame's physics statistics\r\n     */\r\n    get physics() {\r\n        return this._physicsStats;\r\n    }\r\n    /**\r\n     * Gets the frame's graphics statistics\r\n     */\r\n    get graphics() {\r\n        return this._graphicsStats;\r\n    }\r\n}\r\nclass PhysicsStats {\r\n    constructor() {\r\n        this._pairs = 0;\r\n        this._collisions = 0;\r\n        this._contacts = new Map();\r\n        this._fastBodies = 0;\r\n        this._fastBodyCollisions = 0;\r\n        this._broadphase = 0;\r\n        this._narrowphase = 0;\r\n    }\r\n    /**\r\n     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n     *\r\n     * @param [otherStats] Optional stats to clone\r\n     */\r\n    reset(otherStats) {\r\n        if (otherStats) {\r\n            this.pairs = otherStats.pairs;\r\n            this.collisions = otherStats.collisions;\r\n            this.contacts = otherStats.contacts;\r\n            this.fastBodies = otherStats.fastBodies;\r\n            this.fastBodyCollisions = otherStats.fastBodyCollisions;\r\n            this.broadphase = otherStats.broadphase;\r\n            this.narrowphase = otherStats.narrowphase;\r\n        }\r\n        else {\r\n            this.pairs = this.collisions = this.fastBodies = 0;\r\n            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\r\n            this.contacts.clear();\r\n        }\r\n    }\r\n    /**\r\n     * Provides a clone of this instance.\r\n     */\r\n    clone() {\r\n        const ps = new PhysicsStats();\r\n        ps.reset(this);\r\n        return ps;\r\n    }\r\n    get pairs() {\r\n        return this._pairs;\r\n    }\r\n    set pairs(value) {\r\n        this._pairs = value;\r\n    }\r\n    get collisions() {\r\n        return this._collisions;\r\n    }\r\n    set collisions(value) {\r\n        this._collisions = value;\r\n    }\r\n    get contacts() {\r\n        return this._contacts;\r\n    }\r\n    set contacts(contacts) {\r\n        this._contacts = contacts;\r\n    }\r\n    get fastBodies() {\r\n        return this._fastBodies;\r\n    }\r\n    set fastBodies(value) {\r\n        this._fastBodies = value;\r\n    }\r\n    get fastBodyCollisions() {\r\n        return this._fastBodyCollisions;\r\n    }\r\n    set fastBodyCollisions(value) {\r\n        this._fastBodyCollisions = value;\r\n    }\r\n    get broadphase() {\r\n        return this._broadphase;\r\n    }\r\n    set broadphase(value) {\r\n        this._broadphase = value;\r\n    }\r\n    get narrowphase() {\r\n        return this._narrowphase;\r\n    }\r\n    set narrowphase(value) {\r\n        this._narrowphase = value;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/PointerScope.ts\n/**\r\n * Determines the scope of handling mouse/touch events.\r\n */\r\nvar PointerScope;\r\n(function (PointerScope) {\r\n    /**\r\n     * Handle events on the `canvas` element only. Events originating outside the\r\n     * `canvas` will not be handled.\r\n     */\r\n    PointerScope[\"Canvas\"] = \"Canvas\";\r\n    /**\r\n     * Handles events on the entire document. All events will be handled by Excalibur.\r\n     */\r\n    PointerScope[\"Document\"] = \"Document\";\r\n})(PointerScope || (PointerScope = {}));\r\n\n;// CONCATENATED MODULE: ./Input/Keyboard.ts\n\r\n\r\n\r\n/**\r\n * Enum representing physical input key codes\r\n */\r\nvar Keys;\r\n(function (Keys) {\r\n    // NUMPAD\r\n    Keys[\"Num0\"] = \"Numpad0\";\r\n    Keys[\"Num1\"] = \"Numpad1\";\r\n    Keys[\"Num2\"] = \"Numpad2\";\r\n    Keys[\"Num3\"] = \"Numpad3\";\r\n    Keys[\"Num4\"] = \"Numpad4\";\r\n    Keys[\"Num5\"] = \"Numpad5\";\r\n    Keys[\"Num6\"] = \"Numpad6\";\r\n    Keys[\"Num7\"] = \"Numpad7\";\r\n    Keys[\"Num8\"] = \"Numpad8\";\r\n    Keys[\"Num9\"] = \"Numpad9\";\r\n    Keys[\"NumAdd\"] = \"NumpadAdd\";\r\n    Keys[\"NumSubtract\"] = \"NumpadSubtract\";\r\n    Keys[\"NumMultiply\"] = \"NumpadMultiply\";\r\n    Keys[\"NumDivide\"] = \"NumpadDivide\";\r\n    // NumComma = 'NumpadComma', // not x-browser\r\n    Keys[\"NumDecimal\"] = \"NumpadDecimal\";\r\n    Keys[\"Numpad0\"] = \"Numpad0\";\r\n    Keys[\"Numpad1\"] = \"Numpad1\";\r\n    Keys[\"Numpad2\"] = \"Numpad2\";\r\n    Keys[\"Numpad3\"] = \"Numpad3\";\r\n    Keys[\"Numpad4\"] = \"Numpad4\";\r\n    Keys[\"Numpad5\"] = \"Numpad5\";\r\n    Keys[\"Numpad6\"] = \"Numpad6\";\r\n    Keys[\"Numpad7\"] = \"Numpad7\";\r\n    Keys[\"Numpad8\"] = \"Numpad8\";\r\n    Keys[\"Numpad9\"] = \"Numpad9\";\r\n    Keys[\"NumpadAdd\"] = \"NumpadAdd\";\r\n    Keys[\"NumpadSubtract\"] = \"NumpadSubtract\";\r\n    Keys[\"NumpadMultiply\"] = \"NumpadMultiply\";\r\n    Keys[\"NumpadDivide\"] = \"NumpadDivide\";\r\n    // NumpadComma = 'NumpadComma', // not x-browser\r\n    Keys[\"NumpadDecimal\"] = \"NumpadDecimal\";\r\n    // MODIFIERS\r\n    Keys[\"NumLock\"] = \"NumLock\";\r\n    Keys[\"ShiftLeft\"] = \"ShiftLeft\";\r\n    Keys[\"ShiftRight\"] = \"ShiftRight\";\r\n    Keys[\"AltLeft\"] = \"AltLeft\";\r\n    Keys[\"AltRight\"] = \"AltRight\";\r\n    Keys[\"ControlLeft\"] = \"ControlLeft\";\r\n    Keys[\"ControlRight\"] = \"ControlRight\";\r\n    Keys[\"MetaLeft\"] = \"MetaLeft\";\r\n    Keys[\"MetaRight\"] = \"MetaRight\";\r\n    // NUMBERS\r\n    Keys[\"Key0\"] = \"Digit0\";\r\n    Keys[\"Key1\"] = \"Digit1\";\r\n    Keys[\"Key2\"] = \"Digit2\";\r\n    Keys[\"Key3\"] = \"Digit3\";\r\n    Keys[\"Key4\"] = \"Digit4\";\r\n    Keys[\"Key5\"] = \"Digit5\";\r\n    Keys[\"Key6\"] = \"Digit6\";\r\n    Keys[\"Key7\"] = \"Digit7\";\r\n    Keys[\"Key8\"] = \"Digit8\";\r\n    Keys[\"Key9\"] = \"Digit9\";\r\n    Keys[\"Digit0\"] = \"Digit0\";\r\n    Keys[\"Digit1\"] = \"Digit1\";\r\n    Keys[\"Digit2\"] = \"Digit2\";\r\n    Keys[\"Digit3\"] = \"Digit3\";\r\n    Keys[\"Digit4\"] = \"Digit4\";\r\n    Keys[\"Digit5\"] = \"Digit5\";\r\n    Keys[\"Digit6\"] = \"Digit6\";\r\n    Keys[\"Digit7\"] = \"Digit7\";\r\n    Keys[\"Digit8\"] = \"Digit8\";\r\n    Keys[\"Digit9\"] = \"Digit9\";\r\n    // FUNCTION KEYS\r\n    Keys[\"F1\"] = \"F1\";\r\n    Keys[\"F2\"] = \"F2\";\r\n    Keys[\"F3\"] = \"F3\";\r\n    Keys[\"F4\"] = \"F4\";\r\n    Keys[\"F5\"] = \"F5\";\r\n    Keys[\"F6\"] = \"F6\";\r\n    Keys[\"F7\"] = \"F7\";\r\n    Keys[\"F8\"] = \"F8\";\r\n    Keys[\"F9\"] = \"F9\";\r\n    Keys[\"F10\"] = \"F10\";\r\n    Keys[\"F11\"] = \"F11\";\r\n    Keys[\"F12\"] = \"F12\";\r\n    // LETTERS\r\n    Keys[\"A\"] = \"KeyA\";\r\n    Keys[\"B\"] = \"KeyB\";\r\n    Keys[\"C\"] = \"KeyC\";\r\n    Keys[\"D\"] = \"KeyD\";\r\n    Keys[\"E\"] = \"KeyE\";\r\n    Keys[\"F\"] = \"KeyF\";\r\n    Keys[\"G\"] = \"KeyG\";\r\n    Keys[\"H\"] = \"KeyH\";\r\n    Keys[\"I\"] = \"KeyI\";\r\n    Keys[\"J\"] = \"KeyJ\";\r\n    Keys[\"K\"] = \"KeyK\";\r\n    Keys[\"L\"] = \"KeyL\";\r\n    Keys[\"M\"] = \"KeyM\";\r\n    Keys[\"N\"] = \"KeyN\";\r\n    Keys[\"O\"] = \"KeyO\";\r\n    Keys[\"P\"] = \"KeyP\";\r\n    Keys[\"Q\"] = \"KeyQ\";\r\n    Keys[\"R\"] = \"KeyR\";\r\n    Keys[\"S\"] = \"KeyS\";\r\n    Keys[\"T\"] = \"KeyT\";\r\n    Keys[\"U\"] = \"KeyU\";\r\n    Keys[\"V\"] = \"KeyV\";\r\n    Keys[\"W\"] = \"KeyW\";\r\n    Keys[\"X\"] = \"KeyX\";\r\n    Keys[\"Y\"] = \"KeyY\";\r\n    Keys[\"Z\"] = \"KeyZ\";\r\n    Keys[\"KeyA\"] = \"KeyA\";\r\n    Keys[\"KeyB\"] = \"KeyB\";\r\n    Keys[\"KeyC\"] = \"KeyC\";\r\n    Keys[\"KeyD\"] = \"KeyD\";\r\n    Keys[\"KeyE\"] = \"KeyE\";\r\n    Keys[\"KeyF\"] = \"KeyF\";\r\n    Keys[\"KeyG\"] = \"KeyG\";\r\n    Keys[\"KeyH\"] = \"KeyH\";\r\n    Keys[\"KeyI\"] = \"KeyI\";\r\n    Keys[\"KeyJ\"] = \"KeyJ\";\r\n    Keys[\"KeyK\"] = \"KeyK\";\r\n    Keys[\"KeyL\"] = \"KeyL\";\r\n    Keys[\"KeyM\"] = \"KeyM\";\r\n    Keys[\"KeyN\"] = \"KeyN\";\r\n    Keys[\"KeyO\"] = \"KeyO\";\r\n    Keys[\"KeyP\"] = \"KeyP\";\r\n    Keys[\"KeyQ\"] = \"KeyQ\";\r\n    Keys[\"KeyR\"] = \"KeyR\";\r\n    Keys[\"KeyS\"] = \"KeyS\";\r\n    Keys[\"KeyT\"] = \"KeyT\";\r\n    Keys[\"KeyU\"] = \"KeyU\";\r\n    Keys[\"KeyV\"] = \"KeyV\";\r\n    Keys[\"KeyW\"] = \"KeyW\";\r\n    Keys[\"KeyX\"] = \"KeyX\";\r\n    Keys[\"KeyY\"] = \"KeyY\";\r\n    Keys[\"KeyZ\"] = \"KeyZ\";\r\n    // SYMBOLS\r\n    Keys[\"Semicolon\"] = \"Semicolon\";\r\n    Keys[\"Quote\"] = \"Quote\";\r\n    Keys[\"Comma\"] = \"Comma\";\r\n    Keys[\"Minus\"] = \"Minus\";\r\n    Keys[\"Period\"] = \"Period\";\r\n    Keys[\"Slash\"] = \"Slash\";\r\n    Keys[\"Equal\"] = \"Equal\";\r\n    Keys[\"BracketLeft\"] = \"BracketLeft\";\r\n    Keys[\"Backslash\"] = \"Backslash\";\r\n    Keys[\"BracketRight\"] = \"BracketRight\";\r\n    Keys[\"Backquote\"] = \"Backquote\";\r\n    // DIRECTIONS\r\n    Keys[\"Up\"] = \"ArrowUp\";\r\n    Keys[\"Down\"] = \"ArrowDown\";\r\n    Keys[\"Left\"] = \"ArrowLeft\";\r\n    Keys[\"Right\"] = \"ArrowRight\";\r\n    Keys[\"ArrowUp\"] = \"ArrowUp\";\r\n    Keys[\"ArrowDown\"] = \"ArrowDown\";\r\n    Keys[\"ArrowLeft\"] = \"ArrowLeft\";\r\n    Keys[\"ArrowRight\"] = \"ArrowRight\";\r\n    // OTHER\r\n    Keys[\"Space\"] = \"Space\";\r\n    Keys[\"Backspace\"] = \"Backspace\";\r\n    Keys[\"Delete\"] = \"Delete\";\r\n    Keys[\"Esc\"] = \"Escape\";\r\n    Keys[\"Escape\"] = \"Escape\";\r\n    Keys[\"Enter\"] = \"Enter\";\r\n    Keys[\"NumpadEnter\"] = \"NumpadEnter\";\r\n    Keys[\"ContextMenu\"] = \"ContextMenu\";\r\n})(Keys || (Keys = {}));\r\n/**\r\n * Event thrown on a game object for a key event\r\n */\r\nclass KeyEvent extends GameEvent {\r\n    /**\r\n     * @param key  The key responsible for throwing the event\r\n     * @param value The key's typed value the browser detected\r\n     * @param originalEvent The original keyboard event that Excalibur handled\r\n     */\r\n    constructor(key, value, originalEvent) {\r\n        super();\r\n        this.key = key;\r\n        this.value = value;\r\n        this.originalEvent = originalEvent;\r\n    }\r\n}\r\n/**\r\n * Provides keyboard support for Excalibur.\r\n */\r\nclass Keyboard extends Class {\r\n    constructor() {\r\n        super();\r\n        this._keys = [];\r\n        this._keysUp = [];\r\n        this._keysDown = [];\r\n        this._handleKeyDown = (ev) => {\r\n            const code = ev.code;\r\n            if (this._keys.indexOf(code) === -1) {\r\n                this._keys.push(code);\r\n                this._keysDown.push(code);\r\n                const keyEvent = new KeyEvent(code, ev.key, ev);\r\n                this.eventDispatcher.emit('down', keyEvent);\r\n                this.eventDispatcher.emit('press', keyEvent);\r\n            }\r\n        };\r\n        this._handleKeyUp = (ev) => {\r\n            const code = ev.code;\r\n            const key = this._keys.indexOf(code);\r\n            this._keys.splice(key, 1);\r\n            this._keysUp.push(code);\r\n            const keyEvent = new KeyEvent(code, ev.key, ev);\r\n            // alias the old api, we may want to deprecate this in the future\r\n            this.eventDispatcher.emit('up', keyEvent);\r\n            this.eventDispatcher.emit('release', keyEvent);\r\n        };\r\n    }\r\n    on(eventName, handler) {\r\n        super.on(eventName, handler);\r\n    }\r\n    /**\r\n     * Initialize Keyboard event listeners\r\n     */\r\n    init(global) {\r\n        if (!global) {\r\n            try {\r\n                // Try and listen to events on top window frame if within an iframe.\r\n                //\r\n                // See https://github.com/excaliburjs/Excalibur/issues/1294\r\n                //\r\n                // Attempt to add an event listener, which triggers a DOMException on\r\n                // cross-origin iframes\r\n                const noop = () => {\r\n                    return;\r\n                };\r\n                window.top.addEventListener('blur', noop);\r\n                window.top.removeEventListener('blur', noop);\r\n                // this will be the same as window if not embedded within an iframe\r\n                global = window.top;\r\n            }\r\n            catch (_a) {\r\n                // fallback to current frame\r\n                global = window;\r\n                Logger.getInstance().warn('Failed to bind to keyboard events to top frame. ' +\r\n                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');\r\n            }\r\n        }\r\n        global.addEventListener('blur', () => {\r\n            this._keys.length = 0; // empties array efficiently\r\n        });\r\n        // key up is on window because canvas cannot have focus\r\n        global.addEventListener('keyup', this._handleKeyUp);\r\n        // key down is on window because canvas cannot have focus\r\n        global.addEventListener('keydown', this._handleKeyDown);\r\n    }\r\n    update() {\r\n        // Reset keysDown and keysUp after update is complete\r\n        this._keysDown.length = 0;\r\n        this._keysUp.length = 0;\r\n        // Emit synthetic \"hold\" event\r\n        for (let i = 0; i < this._keys.length; i++) {\r\n            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));\r\n        }\r\n    }\r\n    /**\r\n     * Gets list of keys being pressed down\r\n     */\r\n    getKeys() {\r\n        return this._keys;\r\n    }\r\n    /**\r\n     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n     * @param key Test whether a key was just pressed\r\n     */\r\n    wasPressed(key) {\r\n        return this._keysDown.indexOf(key) > -1;\r\n    }\r\n    /**\r\n     * Tests if a certain key is held down. This is persisted between frames.\r\n     * @param key  Test whether a key is held down\r\n     */\r\n    isHeld(key) {\r\n        return this._keys.indexOf(key) > -1;\r\n    }\r\n    /**\r\n     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n     * @param key  Test whether a key was just released\r\n     */\r\n    wasReleased(key) {\r\n        return this._keysUp.indexOf(key) > -1;\r\n    }\r\n    /**\r\n     * Trigger a manual key event\r\n     * @param type\r\n     * @param key\r\n     * @param character\r\n     */\r\n    triggerEvent(type, key, character) {\r\n        if (type === 'down') {\r\n            this._handleKeyDown(new KeyboardEvent('keydown', {\r\n                code: key,\r\n                key: character !== null && character !== void 0 ? character : null\r\n            }));\r\n        }\r\n        if (type === 'up') {\r\n            this._handleKeyUp(new KeyboardEvent('keyup', {\r\n                code: key,\r\n                key: character !== null && character !== void 0 ? character : null\r\n            }));\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/Gamepad.ts\n\r\n\r\n/**\r\n * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n * to provide controller support for your games.\r\n */\r\nclass Gamepads extends Class {\r\n    constructor() {\r\n        super();\r\n        /**\r\n         * Whether or not to poll for Gamepad input (default: `false`)\r\n         */\r\n        this.enabled = false;\r\n        /**\r\n         * Whether or not Gamepad API is supported\r\n         */\r\n        this.supported = !!navigator.getGamepads;\r\n        this._gamePadTimeStamps = [0, 0, 0, 0];\r\n        this._oldPads = [];\r\n        this._pads = [];\r\n        this._initSuccess = false;\r\n        this._navigator = navigator;\r\n        this._minimumConfiguration = null;\r\n    }\r\n    init() {\r\n        if (!this.supported) {\r\n            return;\r\n        }\r\n        if (this._initSuccess) {\r\n            return;\r\n        }\r\n        // In Chrome, this will return 4 undefined items until a button is pressed\r\n        // In FF, this will not return any items until a button is pressed\r\n        this._oldPads = this._clonePads(this._navigator.getGamepads());\r\n        if (this._oldPads.length && this._oldPads[0]) {\r\n            this._initSuccess = true;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n     * all other controllers with more axis or buttons are valid as well. If no minimum\r\n     * configuration is set all pads are valid.\r\n     */\r\n    setMinimumGamepadConfiguration(config) {\r\n        this._enableAndUpdate(); // if config is used, implicitly enable\r\n        this._minimumConfiguration = config;\r\n    }\r\n    /**\r\n     * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n     */\r\n    _enableAndUpdate() {\r\n        if (!this.enabled) {\r\n            this.enabled = true;\r\n            this.update();\r\n        }\r\n    }\r\n    /**\r\n     * Checks a navigator gamepad against the minimum configuration if present.\r\n     */\r\n    _isGamepadValid(pad) {\r\n        if (!this._minimumConfiguration) {\r\n            return true;\r\n        }\r\n        if (!pad) {\r\n            return false;\r\n        }\r\n        const axesLength = pad.axes.filter((value) => {\r\n            return typeof value !== undefined;\r\n        }).length;\r\n        const buttonLength = pad.buttons.filter((value) => {\r\n            return typeof value !== undefined;\r\n        }).length;\r\n        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;\r\n    }\r\n    on(eventName, handler) {\r\n        this._enableAndUpdate(); // implicitly enable\r\n        super.on(eventName, handler);\r\n    }\r\n    off(eventName, handler) {\r\n        this._enableAndUpdate(); // implicitly enable\r\n        super.off(eventName, handler);\r\n    }\r\n    /**\r\n     * Updates Gamepad state and publishes Gamepad events\r\n     */\r\n    update() {\r\n        if (!this.enabled || !this.supported) {\r\n            return;\r\n        }\r\n        this.init();\r\n        const gamepads = this._navigator.getGamepads();\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            if (!gamepads[i]) {\r\n                const gamepad = this.at(i);\r\n                // If was connected, but now isn't emit the disconnect event\r\n                if (gamepad.connected) {\r\n                    this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));\r\n                }\r\n                // Reset connection status\r\n                gamepad.connected = false;\r\n                continue;\r\n            }\r\n            else {\r\n                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {\r\n                    this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));\r\n                }\r\n                // Set connection status\r\n                this.at(i).connected = true;\r\n            }\r\n            // Only supported in Chrome\r\n            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {\r\n                continue;\r\n            }\r\n            this._gamePadTimeStamps[i] = gamepads[i].timestamp;\r\n            // Add reference to navigator gamepad\r\n            this.at(i).navigatorGamepad = gamepads[i];\r\n            // Buttons\r\n            let b, bi, a, ai, value;\r\n            for (b in Buttons) {\r\n                bi = Buttons[b];\r\n                if (typeof bi === 'number') {\r\n                    if (gamepads[i].buttons[bi]) {\r\n                        value = gamepads[i].buttons[bi].value;\r\n                        if (value !== this._oldPads[i].getButton(bi)) {\r\n                            if (gamepads[i].buttons[bi].pressed) {\r\n                                this.at(i).updateButton(bi, value);\r\n                                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));\r\n                            }\r\n                            else {\r\n                                this.at(i).updateButton(bi, 0);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Axes\r\n            for (a in Axes) {\r\n                ai = Axes[a];\r\n                if (typeof ai === 'number') {\r\n                    value = gamepads[i].axes[ai];\r\n                    if (value !== this._oldPads[i].getAxes(ai)) {\r\n                        this.at(i).updateAxes(ai, value);\r\n                        this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));\r\n                    }\r\n                }\r\n            }\r\n            this._oldPads[i] = this._clonePad(gamepads[i]);\r\n        }\r\n    }\r\n    /**\r\n     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist\r\n     */\r\n    at(index) {\r\n        this._enableAndUpdate(); // implicitly enable gamepads when at() is called\r\n        if (index >= this._pads.length) {\r\n            // Ensure there is a pad to retrieve\r\n            for (let i = this._pads.length - 1, max = index; i < max; i++) {\r\n                this._pads.push(new Gamepad());\r\n                this._oldPads.push(new Gamepad());\r\n            }\r\n        }\r\n        return this._pads[index];\r\n    }\r\n    /**\r\n     * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n     */\r\n    getValidGamepads() {\r\n        this._enableAndUpdate();\r\n        const result = [];\r\n        for (let i = 0; i < this._pads.length; i++) {\r\n            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {\r\n                result.push(this.at(i));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Gets the number of connected gamepads\r\n     */\r\n    count() {\r\n        return this._pads.filter((p) => p.connected).length;\r\n    }\r\n    _clonePads(pads) {\r\n        const arr = [];\r\n        for (let i = 0, len = pads.length; i < len; i++) {\r\n            arr.push(this._clonePad(pads[i]));\r\n        }\r\n        return arr;\r\n    }\r\n    /**\r\n     * Fastest way to clone a known object is to do it yourself\r\n     */\r\n    _clonePad(pad) {\r\n        let i, len;\r\n        const clonedPad = new Gamepad();\r\n        if (!pad) {\r\n            return clonedPad;\r\n        }\r\n        for (i = 0, len = pad.buttons.length; i < len; i++) {\r\n            if (pad.buttons[i]) {\r\n                clonedPad.updateButton(i, pad.buttons[i].value);\r\n            }\r\n        }\r\n        for (i = 0, len = pad.axes.length; i < len; i++) {\r\n            clonedPad.updateAxes(i, pad.axes[i]);\r\n        }\r\n        return clonedPad;\r\n    }\r\n}\r\n/**\r\n * The minimum value an axis has to move before considering it a change\r\n */\r\nGamepads.MinAxisMoveThreshold = 0.05;\r\n/**\r\n * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n * for more information on handling controller input.\r\n */\r\nclass Gamepad extends Class {\r\n    constructor() {\r\n        super();\r\n        this.connected = false;\r\n        this._buttons = new Array(16);\r\n        this._axes = new Array(4);\r\n        for (let i = 0; i < this._buttons.length; i++) {\r\n            this._buttons[i] = 0;\r\n        }\r\n        for (let i = 0; i < this._axes.length; i++) {\r\n            this._axes[i] = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Whether or not the given button is pressed\r\n     * @param button     The button to query\r\n     * @param threshold  The threshold over which the button is considered to be pressed\r\n     */\r\n    isButtonPressed(button, threshold = 1) {\r\n        return this._buttons[button] >= threshold;\r\n    }\r\n    /**\r\n     * Gets the given button value between 0 and 1\r\n     */\r\n    getButton(button) {\r\n        return this._buttons[button];\r\n    }\r\n    /**\r\n     * Gets the given axis value between -1 and 1. Values below\r\n     * [[MinAxisMoveThreshold]] are considered 0.\r\n     */\r\n    getAxes(axes) {\r\n        const value = this._axes[axes];\r\n        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n    updateButton(buttonIndex, value) {\r\n        this._buttons[buttonIndex] = value;\r\n    }\r\n    updateAxes(axesIndex, value) {\r\n        this._axes[axesIndex] = value;\r\n    }\r\n}\r\n/**\r\n * Gamepad Buttons enumeration\r\n */\r\nvar Buttons;\r\n(function (Buttons) {\r\n    /**\r\n     * Face 1 button (e.g. A)\r\n     */\r\n    Buttons[Buttons[\"Face1\"] = 0] = \"Face1\";\r\n    /**\r\n     * Face 2 button (e.g. B)\r\n     */\r\n    Buttons[Buttons[\"Face2\"] = 1] = \"Face2\";\r\n    /**\r\n     * Face 3 button (e.g. X)\r\n     */\r\n    Buttons[Buttons[\"Face3\"] = 2] = \"Face3\";\r\n    /**\r\n     * Face 4 button (e.g. Y)\r\n     */\r\n    Buttons[Buttons[\"Face4\"] = 3] = \"Face4\";\r\n    /**\r\n     * Left bumper button\r\n     */\r\n    Buttons[Buttons[\"LeftBumper\"] = 4] = \"LeftBumper\";\r\n    /**\r\n     * Right bumper button\r\n     */\r\n    Buttons[Buttons[\"RightBumper\"] = 5] = \"RightBumper\";\r\n    /**\r\n     * Left trigger button\r\n     */\r\n    Buttons[Buttons[\"LeftTrigger\"] = 6] = \"LeftTrigger\";\r\n    /**\r\n     * Right trigger button\r\n     */\r\n    Buttons[Buttons[\"RightTrigger\"] = 7] = \"RightTrigger\";\r\n    /**\r\n     * Select button\r\n     */\r\n    Buttons[Buttons[\"Select\"] = 8] = \"Select\";\r\n    /**\r\n     * Start button\r\n     */\r\n    Buttons[Buttons[\"Start\"] = 9] = \"Start\";\r\n    /**\r\n     * Left analog stick press (e.g. L3)\r\n     */\r\n    Buttons[Buttons[\"LeftStick\"] = 10] = \"LeftStick\";\r\n    /**\r\n     * Right analog stick press (e.g. R3)\r\n     */\r\n    Buttons[Buttons[\"RightStick\"] = 11] = \"RightStick\";\r\n    /**\r\n     * D-pad up\r\n     */\r\n    Buttons[Buttons[\"DpadUp\"] = 12] = \"DpadUp\";\r\n    /**\r\n     * D-pad down\r\n     */\r\n    Buttons[Buttons[\"DpadDown\"] = 13] = \"DpadDown\";\r\n    /**\r\n     * D-pad left\r\n     */\r\n    Buttons[Buttons[\"DpadLeft\"] = 14] = \"DpadLeft\";\r\n    /**\r\n     * D-pad right\r\n     */\r\n    Buttons[Buttons[\"DpadRight\"] = 15] = \"DpadRight\";\r\n})(Buttons || (Buttons = {}));\r\n/**\r\n * Gamepad Axes enumeration\r\n */\r\nvar Axes;\r\n(function (Axes) {\r\n    /**\r\n     * Left analogue stick X direction\r\n     */\r\n    Axes[Axes[\"LeftStickX\"] = 0] = \"LeftStickX\";\r\n    /**\r\n     * Left analogue stick Y direction\r\n     */\r\n    Axes[Axes[\"LeftStickY\"] = 1] = \"LeftStickY\";\r\n    /**\r\n     * Right analogue stick X direction\r\n     */\r\n    Axes[Axes[\"RightStickX\"] = 2] = \"RightStickX\";\r\n    /**\r\n     * Right analogue stick Y direction\r\n     */\r\n    Axes[Axes[\"RightStickY\"] = 3] = \"RightStickY\";\r\n})(Axes || (Axes = {}));\r\n\n;// CONCATENATED MODULE: ./Util/Browser.ts\nclass BrowserComponent {\r\n    constructor(nativeComponent) {\r\n        this.nativeComponent = nativeComponent;\r\n        this._paused = false;\r\n        this._nativeHandlers = {};\r\n    }\r\n    on(eventName, handler) {\r\n        if (this._nativeHandlers[eventName]) {\r\n            this.off(eventName, this._nativeHandlers[eventName]);\r\n        }\r\n        this._nativeHandlers[eventName] = this._decorate(handler);\r\n        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);\r\n    }\r\n    off(eventName, handler) {\r\n        if (!handler) {\r\n            handler = this._nativeHandlers[eventName];\r\n        }\r\n        this.nativeComponent.removeEventListener(eventName, handler);\r\n        this._nativeHandlers[eventName] = null;\r\n    }\r\n    _decorate(handler) {\r\n        return (evt) => {\r\n            if (!this._paused) {\r\n                handler(evt);\r\n            }\r\n        };\r\n    }\r\n    pause() {\r\n        this._paused = true;\r\n    }\r\n    resume() {\r\n        this._paused = false;\r\n    }\r\n    clear() {\r\n        for (const event in this._nativeHandlers) {\r\n            this.off(event);\r\n        }\r\n    }\r\n}\r\nclass BrowserEvents {\r\n    constructor(_windowGlobal, _documentGlobal) {\r\n        this._windowGlobal = _windowGlobal;\r\n        this._documentGlobal = _documentGlobal;\r\n        this._windowComponent = new BrowserComponent(this._windowGlobal);\r\n        this._documentComponent = new BrowserComponent(this._documentGlobal);\r\n    }\r\n    get window() {\r\n        return this._windowComponent;\r\n    }\r\n    get document() {\r\n        return this._documentComponent;\r\n    }\r\n    pause() {\r\n        this.window.pause();\r\n        this.document.pause();\r\n    }\r\n    resume() {\r\n        this.window.resume();\r\n        this.document.resume();\r\n    }\r\n    clear() {\r\n        this.window.clear();\r\n        this.document.clear();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Math/global-coordinates.ts\n\r\nclass GlobalCoordinates {\r\n    constructor(worldPos, pagePos, screenPos) {\r\n        this.worldPos = worldPos;\r\n        this.pagePos = pagePos;\r\n        this.screenPos = screenPos;\r\n    }\r\n    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {\r\n        let pageX;\r\n        let pageY;\r\n        let pagePos;\r\n        let engine;\r\n        if (arguments.length === 3) {\r\n            pageX = xOrPos;\r\n            pageY = yOrEngine;\r\n            pagePos = new Vector(pageX, pageY);\r\n            engine = engineOrUndefined;\r\n        }\r\n        else {\r\n            pagePos = xOrPos;\r\n            pageX = pagePos.x;\r\n            pageY = pagePos.y;\r\n            engine = yOrEngine;\r\n        }\r\n        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);\r\n        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);\r\n        return new GlobalCoordinates(worldPos, pagePos, screenPos);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/PointerEvent.ts\nclass PointerEvent {\r\n    constructor(type, pointerId, button, pointerType, coordinates, nativeEvent) {\r\n        this.type = type;\r\n        this.pointerId = pointerId;\r\n        this.button = button;\r\n        this.pointerType = pointerType;\r\n        this.coordinates = coordinates;\r\n        this.nativeEvent = nativeEvent;\r\n        this.active = true;\r\n    }\r\n    cancel() {\r\n        this.active = false;\r\n    }\r\n    get pagePos() {\r\n        return this.coordinates.pagePos;\r\n    }\r\n    get screenPos() {\r\n        return this.coordinates.screenPos;\r\n    }\r\n    get worldPos() {\r\n        return this.coordinates.worldPos;\r\n    }\r\n    ;\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/WheelEvent.ts\nclass WheelEvent {\r\n    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.pageX = pageX;\r\n        this.pageY = pageY;\r\n        this.screenX = screenX;\r\n        this.screenY = screenY;\r\n        this.index = index;\r\n        this.deltaX = deltaX;\r\n        this.deltaY = deltaY;\r\n        this.deltaZ = deltaZ;\r\n        this.deltaMode = deltaMode;\r\n        this.ev = ev;\r\n        this.active = true;\r\n    }\r\n    cancel() {\r\n        this.active = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/PointerAbstraction.ts\n\r\n\r\nclass PointerAbstraction extends Class {\r\n    constructor() {\r\n        super();\r\n        /**\r\n         * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n         */\r\n        this.lastPagePos = Vector.Zero;\r\n        /**\r\n         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n         */\r\n        this.lastScreenPos = Vector.Zero;\r\n        /**\r\n         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n         */\r\n        this.lastWorldPos = Vector.Zero;\r\n        this._onPointerMove = (ev) => {\r\n            this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n            this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n            this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n        };\r\n        this._onPointerDown = (ev) => {\r\n            this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n            this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n            this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n        };\r\n        this.on('move', this._onPointerMove);\r\n        this.on('down', this._onPointerDown);\r\n    }\r\n    on(event, handler) {\r\n        super.on(event, handler);\r\n    }\r\n    once(event, handler) {\r\n        super.once(event, handler);\r\n    }\r\n    off(event, handler) {\r\n        super.off(event, handler);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Input/WheelDeltaMode.ts\nvar WheelDeltaMode;\r\n(function (WheelDeltaMode) {\r\n    WheelDeltaMode[\"Pixel\"] = \"Pixel\";\r\n    WheelDeltaMode[\"Line\"] = \"Line\";\r\n    WheelDeltaMode[\"Page\"] = \"Page\";\r\n})(WheelDeltaMode || (WheelDeltaMode = {}));\r\n\n;// CONCATENATED MODULE: ./Input/NativePointerButton.ts\n/**\r\n * Native browser button enumeration\r\n */\r\nvar NativePointerButton;\r\n(function (NativePointerButton) {\r\n    NativePointerButton[NativePointerButton[\"NoButton\"] = -1] = \"NoButton\";\r\n    NativePointerButton[NativePointerButton[\"Left\"] = 0] = \"Left\";\r\n    NativePointerButton[NativePointerButton[\"Middle\"] = 1] = \"Middle\";\r\n    NativePointerButton[NativePointerButton[\"Right\"] = 2] = \"Right\";\r\n    NativePointerButton[NativePointerButton[\"Unknown\"] = 3] = \"Unknown\";\r\n})(NativePointerButton || (NativePointerButton = {}));\r\n\n;// CONCATENATED MODULE: ./Input/PointerButton.ts\n/**\r\n * The mouse button being pressed.\r\n */\r\nvar PointerButton;\r\n(function (PointerButton) {\r\n    PointerButton[\"Left\"] = \"Left\";\r\n    PointerButton[\"Middle\"] = \"Middle\";\r\n    PointerButton[\"Right\"] = \"Right\";\r\n    PointerButton[\"Unknown\"] = \"Unknown\";\r\n    PointerButton[\"NoButton\"] = \"NoButton\";\r\n})(PointerButton || (PointerButton = {}));\r\n\n;// CONCATENATED MODULE: ./Input/PointerType.ts\n/**\r\n * The type of pointer for a [[PointerEvent]].\r\n */\r\nvar PointerType;\r\n(function (PointerType) {\r\n    PointerType[\"Touch\"] = \"Touch\";\r\n    PointerType[\"Mouse\"] = \"Mouse\";\r\n    PointerType[\"Pen\"] = \"Pen\";\r\n    PointerType[\"Unknown\"] = \"Unknown\";\r\n})(PointerType || (PointerType = {}));\r\n\n;// CONCATENATED MODULE: ./Input/PointerEventReceiver.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Is this event a native touch event?\r\n */\r\nfunction isTouchEvent(value) {\r\n    // Guard for Safari <= 13.1\r\n    return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;\r\n}\r\n/**\r\n * Is this event a native pointer event\r\n */\r\nfunction isPointerEvent(value) {\r\n    // Guard for Safari <= 13.1\r\n    return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;\r\n}\r\n/**\r\n * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates\r\n */\r\nclass PointerEventReceiver extends Class {\r\n    constructor(target, engine) {\r\n        super();\r\n        this.target = target;\r\n        this.engine = engine;\r\n        this.primary = new PointerAbstraction();\r\n        this._activeNativePointerIdsToNormalized = new Map();\r\n        this.lastFramePointerCoords = new Map();\r\n        this.currentFramePointerCoords = new Map();\r\n        this.currentFramePointerDown = new Map();\r\n        this.lastFramePointerDown = new Map();\r\n        this.currentFrameDown = [];\r\n        this.currentFrameUp = [];\r\n        this.currentFrameMove = [];\r\n        this.currentFrameCancel = [];\r\n        this.currentFrameWheel = [];\r\n        this._pointers = [this.primary];\r\n        this._boundHandle = this._handle.bind(this);\r\n        this._boundWheel = this._handleWheel.bind(this);\r\n    }\r\n    /**\r\n     * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event\r\n     * handlers.\r\n     * @param target\r\n     * @param engine\r\n     */\r\n    recreate(target, engine) {\r\n        const eventReceiver = new PointerEventReceiver(target, engine);\r\n        eventReceiver.primary = this.primary;\r\n        eventReceiver._pointers = this._pointers;\r\n        return eventReceiver;\r\n    }\r\n    /**\r\n     * Locates a specific pointer by id, creates it if it doesn't exist\r\n     * @param index\r\n     */\r\n    at(index) {\r\n        if (index >= this._pointers.length) {\r\n            // Ensure there is a pointer to retrieve\r\n            for (let i = this._pointers.length - 1, max = index; i < max; i++) {\r\n                this._pointers.push(new PointerAbstraction());\r\n            }\r\n        }\r\n        return this._pointers[index];\r\n    }\r\n    /**\r\n     * The number of pointers currently being tracked by excalibur\r\n     */\r\n    count() {\r\n        return this._pointers.length;\r\n    }\r\n    /**\r\n     * Is the specified pointer id down this frame\r\n     * @param pointerId\r\n     */\r\n    isDown(pointerId) {\r\n        var _a;\r\n        return (_a = this.currentFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;\r\n    }\r\n    /**\r\n     * Was the specified pointer id down last frame\r\n     * @param pointerId\r\n     */\r\n    wasDown(pointerId) {\r\n        var _a;\r\n        return (_a = this.lastFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;\r\n    }\r\n    /**\r\n     * Whether the Pointer is currently dragging.\r\n     */\r\n    isDragging(pointerId) {\r\n        return this.isDown(pointerId);\r\n    }\r\n    /**\r\n     * Whether the Pointer just started dragging.\r\n     */\r\n    isDragStart(pointerId) {\r\n        return this.isDown(pointerId) && !this.wasDown(pointerId);\r\n    }\r\n    /**\r\n     * Whether the Pointer just ended dragging.\r\n     */\r\n    isDragEnd(pointerId) {\r\n        return !this.isDown(pointerId) && this.wasDown(pointerId);\r\n    }\r\n    on(event, handler) {\r\n        super.on(event, handler);\r\n    }\r\n    once(event, handler) {\r\n        super.once(event, handler);\r\n    }\r\n    off(event, handler) {\r\n        super.off(event, handler);\r\n    }\r\n    /**\r\n     * Called internally by excalibur\r\n     *\r\n     * Updates the current frame pointer info and emits raw pointer events\r\n     *\r\n     * This does not emit events to entities, see PointerSystem\r\n     */\r\n    update() {\r\n        this.lastFramePointerDown = new Map(this.currentFramePointerDown);\r\n        this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);\r\n        for (const event of this.currentFrameDown) {\r\n            this.emit('down', event);\r\n            const pointer = this.at(event.pointerId);\r\n            pointer.emit('down', event);\r\n            this.primary.emit('pointerdown', event);\r\n        }\r\n        for (const event of this.currentFrameUp) {\r\n            this.emit('up', event);\r\n            const pointer = this.at(event.pointerId);\r\n            pointer.emit('up', event);\r\n        }\r\n        for (const event of this.currentFrameMove) {\r\n            this.emit('move', event);\r\n            const pointer = this.at(event.pointerId);\r\n            pointer.emit('move', event);\r\n        }\r\n        for (const event of this.currentFrameCancel) {\r\n            this.emit('cancel', event);\r\n            const pointer = this.at(event.pointerId);\r\n            pointer.emit('cancel', event);\r\n        }\r\n        for (const event of this.currentFrameWheel) {\r\n            this.emit('wheel', event);\r\n            this.primary.emit('pointerwheel', event);\r\n        }\r\n    }\r\n    /**\r\n     * Clears the current frame event and pointer data\r\n     */\r\n    clear() {\r\n        for (const event of this.currentFrameUp) {\r\n            this.currentFramePointerCoords.delete(event.pointerId);\r\n            const ids = this._activeNativePointerIdsToNormalized.entries();\r\n            for (const [native, normalized] of ids) {\r\n                if (normalized === event.pointerId) {\r\n                    this._activeNativePointerIdsToNormalized.delete(native);\r\n                }\r\n            }\r\n        }\r\n        this.currentFrameDown.length = 0;\r\n        this.currentFrameUp.length = 0;\r\n        this.currentFrameMove.length = 0;\r\n        this.currentFrameCancel.length = 0;\r\n        this.currentFrameWheel.length = 0;\r\n    }\r\n    /**\r\n     * Initializes the pointer event receiver so that it can start listening to native\r\n     * browser events.\r\n     */\r\n    init() {\r\n        // Disabling the touch action avoids browser/platform gestures from firing on the canvas\r\n        // It is important on mobile to have touch action 'none'\r\n        // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not\r\n        if (this.target === this.engine.canvas) {\r\n            this.engine.canvas.style.touchAction = 'none';\r\n        }\r\n        else {\r\n            document.body.style.touchAction = 'none';\r\n        }\r\n        // Preferred pointer events\r\n        if (window.PointerEvent) {\r\n            this.target.addEventListener('pointerdown', this._boundHandle);\r\n            this.target.addEventListener('pointerup', this._boundHandle);\r\n            this.target.addEventListener('pointermove', this._boundHandle);\r\n            this.target.addEventListener('pointercancel', this._boundHandle);\r\n        }\r\n        else {\r\n            // Touch Events\r\n            this.target.addEventListener('touchstart', this._boundHandle);\r\n            this.target.addEventListener('touchend', this._boundHandle);\r\n            this.target.addEventListener('touchmove', this._boundHandle);\r\n            this.target.addEventListener('touchcancel', this._boundHandle);\r\n            // Mouse Events\r\n            this.target.addEventListener('mousedown', this._boundHandle);\r\n            this.target.addEventListener('mouseup', this._boundHandle);\r\n            this.target.addEventListener('mousemove', this._boundHandle);\r\n        }\r\n        // MDN MouseWheelEvent\r\n        const wheelOptions = {\r\n            passive: !(this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n                this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)\r\n        };\r\n        if ('onwheel' in document.createElement('div')) {\r\n            // Modern Browsers\r\n            this.target.addEventListener('wheel', this._boundWheel, wheelOptions);\r\n        }\r\n        else if (document.onmousewheel !== undefined) {\r\n            // Webkit and IE\r\n            this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);\r\n        }\r\n        else {\r\n            // Remaining browser and older Firefox\r\n            this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);\r\n        }\r\n    }\r\n    detach() {\r\n        // Preferred pointer events\r\n        if (window.PointerEvent) {\r\n            this.target.removeEventListener('pointerdown', this._boundHandle);\r\n            this.target.removeEventListener('pointerup', this._boundHandle);\r\n            this.target.removeEventListener('pointermove', this._boundHandle);\r\n            this.target.removeEventListener('pointercancel', this._boundHandle);\r\n        }\r\n        else {\r\n            // Touch Events\r\n            this.target.removeEventListener('touchstart', this._boundHandle);\r\n            this.target.removeEventListener('touchend', this._boundHandle);\r\n            this.target.removeEventListener('touchmove', this._boundHandle);\r\n            this.target.removeEventListener('touchcancel', this._boundHandle);\r\n            // Mouse Events\r\n            this.target.removeEventListener('mousedown', this._boundHandle);\r\n            this.target.removeEventListener('mouseup', this._boundHandle);\r\n            this.target.removeEventListener('mousemove', this._boundHandle);\r\n        }\r\n        if ('onwheel' in document.createElement('div')) {\r\n            // Modern Browsers\r\n            this.target.removeEventListener('wheel', this._boundWheel);\r\n        }\r\n        else if (document.onmousewheel !== undefined) {\r\n            // Webkit and IE\r\n            this.target.addEventListener('mousewheel', this._boundWheel);\r\n        }\r\n        else {\r\n            // Remaining browser and older Firefox\r\n            this.target.addEventListener('MozMousePixelScroll', this._boundWheel);\r\n        }\r\n    }\r\n    /**\r\n     * Take native pointer id and map it to index in active pointers\r\n     * @param nativePointerId\r\n     */\r\n    _normalizePointerId(nativePointerId) {\r\n        // Add to the the native pointer set id\r\n        this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);\r\n        // Native pointer ids in ascending order\r\n        const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);\r\n        // The index into sorted ids will be the new id, will always have an id\r\n        const id = currentPointerIds.findIndex(p => p === nativePointerId);\r\n        // Save the mapping so we can reverse it later\r\n        this._activeNativePointerIdsToNormalized.set(nativePointerId, id);\r\n        // ignore pointer because game isn't watching\r\n        return id;\r\n    }\r\n    /**\r\n     * Responsible for handling and parsing pointer events\r\n     */\r\n    _handle(ev) {\r\n        ev.preventDefault();\r\n        const eventCoords = new Map();\r\n        let button;\r\n        let pointerType;\r\n        if (isTouchEvent(ev)) {\r\n            button = PointerButton.Unknown;\r\n            pointerType = PointerType.Touch;\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\r\n            for (let i = 0; i < ev.changedTouches.length; i++) {\r\n                const touch = ev.changedTouches[i];\r\n                const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);\r\n                const nativePointerId = i + 1;\r\n                const pointerId = this._normalizePointerId(nativePointerId);\r\n                this.currentFramePointerCoords.set(pointerId, coordinates);\r\n                eventCoords.set(pointerId, coordinates);\r\n            }\r\n        }\r\n        else {\r\n            button = this._nativeButtonToPointerButton(ev.button);\r\n            pointerType = PointerType.Mouse;\r\n            const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);\r\n            let nativePointerId = 1;\r\n            if (isPointerEvent(ev)) {\r\n                nativePointerId = ev.pointerId;\r\n                pointerType = this._stringToPointerType(ev.pointerType);\r\n            }\r\n            const pointerId = this._normalizePointerId(nativePointerId);\r\n            this.currentFramePointerCoords.set(pointerId, coordinates);\r\n            eventCoords.set(pointerId, coordinates);\r\n        }\r\n        for (const [pointerId, coord] of eventCoords.entries()) {\r\n            switch (ev.type) {\r\n                case 'mousedown':\r\n                case 'pointerdown':\r\n                case 'touchstart':\r\n                    this.currentFrameDown.push(new PointerEvent('down', pointerId, button, pointerType, coord, ev));\r\n                    this.currentFramePointerDown.set(pointerId, true);\r\n                    break;\r\n                case 'mouseup':\r\n                case 'pointerup':\r\n                case 'touchend':\r\n                    this.currentFrameUp.push(new PointerEvent('up', pointerId, button, pointerType, coord, ev));\r\n                    this.currentFramePointerDown.set(pointerId, false);\r\n                    break;\r\n                case 'mousemove':\r\n                case 'pointermove':\r\n                case 'touchmove':\r\n                    this.currentFrameMove.push(new PointerEvent('move', pointerId, button, pointerType, coord, ev));\r\n                    break;\r\n                case 'touchcancel':\r\n                case 'pointercancel':\r\n                    this.currentFrameCancel.push(new PointerEvent('cancel', pointerId, button, pointerType, coord, ev));\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    _handleWheel(ev) {\r\n        // Should we prevent page scroll because of this event\r\n        if (this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n            (this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)) {\r\n            ev.preventDefault();\r\n        }\r\n        const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));\r\n        const world = this.engine.screen.screenToWorldCoordinates(screen);\r\n        /**\r\n         * A constant used to normalize wheel events across different browsers\r\n         *\r\n         * This normalization factor is pulled from\r\n         * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n         */\r\n        const ScrollWheelNormalizationFactor = -1 / 40;\r\n        const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;\r\n        const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;\r\n        const deltaZ = ev.deltaZ || 0;\r\n        let deltaMode = WheelDeltaMode.Pixel;\r\n        if (ev.deltaMode) {\r\n            if (ev.deltaMode === 1) {\r\n                deltaMode = WheelDeltaMode.Line;\r\n            }\r\n            else if (ev.deltaMode === 2) {\r\n                deltaMode = WheelDeltaMode.Page;\r\n            }\r\n        }\r\n        const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);\r\n        this.currentFrameWheel.push(we);\r\n    }\r\n    /**\r\n     * Triggers an excalibur pointer event in a world space pos\r\n     *\r\n     * Useful for testing pointers in excalibur\r\n     * @param type\r\n     * @param pos\r\n     */\r\n    triggerEvent(type, pos) {\r\n        const page = this.engine.screen.worldToPageCoordinates(pos);\r\n        // Send an event to the event receiver\r\n        if (window.PointerEvent) {\r\n            this._handle(new window.PointerEvent('pointer' + type, {\r\n                pointerId: 0,\r\n                clientX: page.x,\r\n                clientY: page.y\r\n            }));\r\n        }\r\n        else {\r\n            // Safari hack\r\n            this._handle(new window.MouseEvent('mouse' + type, {\r\n                clientX: page.x,\r\n                clientY: page.y\r\n            }));\r\n        }\r\n        // Force update pointer system\r\n        const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);\r\n        const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);\r\n        pointerSystem.preupdate();\r\n        pointerSystem.update(transformEntities.getEntities());\r\n    }\r\n    _nativeButtonToPointerButton(s) {\r\n        switch (s) {\r\n            case NativePointerButton.NoButton:\r\n                return PointerButton.NoButton;\r\n            case NativePointerButton.Left:\r\n                return PointerButton.Left;\r\n            case NativePointerButton.Middle:\r\n                return PointerButton.Middle;\r\n            case NativePointerButton.Right:\r\n                return PointerButton.Right;\r\n            case NativePointerButton.Unknown:\r\n                return PointerButton.Unknown;\r\n            default:\r\n                return fail(s);\r\n        }\r\n    }\r\n    _stringToPointerType(s) {\r\n        switch (s) {\r\n            case 'touch':\r\n                return PointerType.Touch;\r\n            case 'mouse':\r\n                return PointerType.Mouse;\r\n            case 'pen':\r\n                return PointerType.Pen;\r\n            default:\r\n                return PointerType.Unknown;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Fps.ts\nclass FpsSampler {\r\n    constructor(options) {\r\n        var _a;\r\n        this._samplePeriod = 100;\r\n        this._currentFrameTime = 0;\r\n        this._frames = 0;\r\n        this._previousSampleTime = 0;\r\n        this._beginFrameTime = 0;\r\n        this._fps = options.initialFps;\r\n        this._samplePeriod = (_a = options.samplePeriod) !== null && _a !== void 0 ? _a : this._samplePeriod;\r\n        this._currentFrameTime = 1000 / options.initialFps;\r\n        this._nowFn = options.nowFn;\r\n        this._previousSampleTime = this._nowFn();\r\n    }\r\n    /**\r\n     * Start of code block to sample FPS for\r\n     */\r\n    start() {\r\n        this._beginFrameTime = this._nowFn();\r\n    }\r\n    /**\r\n     * End of code block to sample FPS for\r\n     */\r\n    end() {\r\n        this._frames++;\r\n        const time = this._nowFn();\r\n        this._currentFrameTime = time - this._beginFrameTime;\r\n        if (time >= this._previousSampleTime + this._samplePeriod) {\r\n            this._fps = (this._frames * 1000) / (time - this._previousSampleTime);\r\n            this._previousSampleTime = time;\r\n            this._frames = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Return the currently sampled fps over the last sample period, by default every 100ms\r\n     */\r\n    get fps() {\r\n        return this._fps;\r\n    }\r\n    /**\r\n     * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time\r\n     */\r\n    get instant() {\r\n        return 1000 / this._currentFrameTime;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Util/Clock.ts\n\r\n\r\n/**\r\n * Abstract Clock is the base type of all Clocks\r\n *\r\n * It has a few opinions\r\n * 1. It manages the calculation of what \"elapsed\" time means and thus maximum fps\r\n * 2. The default timing api is implemented in now()\r\n *\r\n * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever\r\n * method is unique to your clock implementation.\r\n */\r\nclass Clock {\r\n    constructor(options) {\r\n        var _a, _b, _c;\r\n        this._onFatalException = () => { };\r\n        this._maxFps = Infinity;\r\n        this._lastTime = 0;\r\n        this._elapsed = 1;\r\n        this._scheduledCbs = [];\r\n        this._totalElapsed = 0;\r\n        this._options = options;\r\n        this.tick = options.tick;\r\n        this._lastTime = (_a = this.now()) !== null && _a !== void 0 ? _a : 0;\r\n        this._maxFps = (_b = options.maxFps) !== null && _b !== void 0 ? _b : this._maxFps;\r\n        this._onFatalException = (_c = options.onFatalException) !== null && _c !== void 0 ? _c : this._onFatalException;\r\n        this.fpsSampler = new FpsSampler({\r\n            initialFps: 60,\r\n            nowFn: () => this.now()\r\n        });\r\n    }\r\n    /**\r\n     * Get the elapsed time for the last completed frame\r\n     */\r\n    elapsed() {\r\n        return this._elapsed;\r\n    }\r\n    /**\r\n     * Get the current time in milliseconds\r\n     */\r\n    now() {\r\n        return performance.now();\r\n    }\r\n    toTestClock() {\r\n        const testClock = new TestClock({\r\n            ...this._options,\r\n            defaultUpdateMs: 16.6\r\n        });\r\n        return testClock;\r\n    }\r\n    toStandardClock() {\r\n        const clock = new StandardClock({\r\n            ...this._options\r\n        });\r\n        return clock;\r\n    }\r\n    setFatalExceptionHandler(handler) {\r\n        this._onFatalException = handler;\r\n    }\r\n    /**\r\n     * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]\r\n     *\r\n     * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the\r\n     * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is\r\n     * stopped or paused.\r\n     *\r\n     * @param cb callback to fire\r\n     * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick\r\n     */\r\n    schedule(cb, timeoutMs = 0) {\r\n        // Scheduled based on internal elapsed time\r\n        const scheduledTime = this._totalElapsed + timeoutMs;\r\n        this._scheduledCbs.push([cb, scheduledTime]);\r\n    }\r\n    _runScheduledCbs() {\r\n        // walk backwards to delete items as we loop\r\n        for (let i = this._scheduledCbs.length - 1; i > -1; i--) {\r\n            if (this._scheduledCbs[i][1] <= this._totalElapsed) {\r\n                this._scheduledCbs[i][0]();\r\n                this._scheduledCbs.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n    update(overrideUpdateMs) {\r\n        try {\r\n            this.fpsSampler.start();\r\n            // Get the time to calculate time-elapsed\r\n            const now = this.now();\r\n            let elapsed = now - this._lastTime || 1; // first frame\r\n            // Constrain fps\r\n            const fpsInterval = (1000 / this._maxFps);\r\n            // only run frame if enough time has elapsed\r\n            if (elapsed >= fpsInterval) {\r\n                let leftover = 0;\r\n                if (fpsInterval !== 0) {\r\n                    leftover = (elapsed % fpsInterval);\r\n                    elapsed = elapsed - leftover; // shift elapsed to be \"in phase\" with the current loop fps\r\n                }\r\n                // Resolves issue #138 if the game has been paused, or blurred for\r\n                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability\r\n                // and provides more expected behavior when the engine comes back\r\n                // into focus\r\n                if (elapsed > 200) {\r\n                    elapsed = 1;\r\n                }\r\n                // tick the mainloop and run scheduled callbacks\r\n                this._elapsed = overrideUpdateMs || elapsed;\r\n                this._totalElapsed += this._elapsed;\r\n                this._runScheduledCbs();\r\n                this.tick(overrideUpdateMs || elapsed);\r\n                if (fpsInterval !== 0) {\r\n                    this._lastTime = now - leftover;\r\n                }\r\n                else {\r\n                    this._lastTime = now;\r\n                }\r\n                this.fpsSampler.end();\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._onFatalException(e);\r\n            this.stop();\r\n        }\r\n    }\r\n}\r\n/**\r\n * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()\r\n */\r\nclass StandardClock extends Clock {\r\n    constructor(options) {\r\n        super(options);\r\n        this._running = false;\r\n    }\r\n    isRunning() {\r\n        return this._running;\r\n    }\r\n    start() {\r\n        if (this._running) {\r\n            return;\r\n        }\r\n        this._running = true;\r\n        const mainloop = () => {\r\n            // stop the loop\r\n            if (!this._running) {\r\n                return;\r\n            }\r\n            try {\r\n                // request next loop\r\n                this._requestId = window.requestAnimationFrame(mainloop);\r\n                this.update();\r\n            }\r\n            catch (e) {\r\n                window.cancelAnimationFrame(this._requestId);\r\n                throw e;\r\n            }\r\n        };\r\n        // begin the first frame\r\n        mainloop();\r\n    }\r\n    stop() {\r\n        this._running = false;\r\n    }\r\n}\r\n/**\r\n * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test\r\n */\r\nclass TestClock extends Clock {\r\n    constructor(options) {\r\n        super({\r\n            ...options\r\n        });\r\n        this._logger = Logger.getInstance();\r\n        this._running = false;\r\n        this._currentTime = 0;\r\n        this._updateMs = options.defaultUpdateMs;\r\n    }\r\n    /**\r\n     * Get the current time in milliseconds\r\n     */\r\n    now() {\r\n        var _a;\r\n        return (_a = this._currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    isRunning() {\r\n        return this._running;\r\n    }\r\n    start() {\r\n        this._running = true;\r\n    }\r\n    stop() {\r\n        this._running = false;\r\n    }\r\n    /**\r\n     * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds\r\n     * @param overrideUpdateMs\r\n     */\r\n    step(overrideUpdateMs) {\r\n        const time = overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs;\r\n        if (this._running) {\r\n            // to be comparable to RAF this needs to be a full blown Task\r\n            // For example, images cannot decode synchronously in a single step\r\n            this.update(time);\r\n            this._currentTime += time;\r\n        }\r\n        else {\r\n            this._logger.warn('The clock is not running, no step will be performed');\r\n        }\r\n    }\r\n    /**\r\n     * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds\r\n     * @param numberOfSteps\r\n     * @param overrideUpdateMs\r\n     */\r\n    run(numberOfSteps, overrideUpdateMs) {\r\n        for (let i = 0; i < numberOfSteps; i++) {\r\n            this.step(overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs);\r\n        }\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./Util/Toaster.css\nvar Util_Toaster = __webpack_require__(7379);\n;// CONCATENATED MODULE: ./Util/Toaster.ts\n\r\n/**\r\n * The Toaster is only meant to be called from inside Excalibur to display messages to players\r\n */\r\nclass Toaster {\r\n    constructor() {\r\n        this._toasterCss = Util_Toaster/* default.toString */.Z.toString();\r\n        this._isInitialized = false;\r\n    }\r\n    _initialize() {\r\n        if (!this._isInitialized) {\r\n            this._container = document.createElement('div');\r\n            this._container.id = 'ex-toast-container';\r\n            document.body.appendChild(this._container);\r\n            this._isInitialized = true;\r\n            this._styleBlock = document.createElement('style');\r\n            this._styleBlock.textContent = this._toasterCss;\r\n            document.head.appendChild(this._styleBlock);\r\n        }\r\n    }\r\n    dispose() {\r\n        this._container.parentElement.removeChild(this._container);\r\n        this._styleBlock.parentElement.removeChild(this._styleBlock);\r\n        this._isInitialized = false;\r\n    }\r\n    _createFragment(message) {\r\n        const toastMessage = document.createElement('span');\r\n        toastMessage.innerText = message;\r\n        return toastMessage;\r\n    }\r\n    /**\r\n     * Display a toast message to a player\r\n     * @param message Text of the message, messages may have a single \"[LINK]\" to influence placement\r\n     * @param linkTarget Optionally specify a link location\r\n     * @param linkName Optionally specify a name for that link location\r\n     */\r\n    toast(message, linkTarget, linkName) {\r\n        this._initialize();\r\n        const toast = document.createElement('div');\r\n        toast.className = 'ex-toast-message';\r\n        const messageFragments = message.split('[LINK]').map(message => this._createFragment(message));\r\n        if (linkTarget) {\r\n            const link = document.createElement('a');\r\n            link.href = linkTarget;\r\n            if (linkName) {\r\n                link.innerText = linkName;\r\n            }\r\n            else {\r\n                link.innerText = linkTarget;\r\n            }\r\n            messageFragments.splice(1, 0, link);\r\n        }\r\n        // Assembly message\r\n        const finalMessage = document.createElement('div');\r\n        messageFragments.forEach(message => {\r\n            finalMessage.appendChild(message);\r\n        });\r\n        toast.appendChild(finalMessage);\r\n        // Dismiss button\r\n        const dismissBtn = document.createElement('button');\r\n        dismissBtn.innerText = 'x';\r\n        dismissBtn.addEventListener('click', () => {\r\n            this._container.removeChild(toast);\r\n        });\r\n        toast.appendChild(dismissBtn);\r\n        // Escape to dismiss\r\n        const keydownHandler = (evt) => {\r\n            if (evt.key === 'Escape') {\r\n                try {\r\n                    this._container.removeChild(toast);\r\n                }\r\n                catch (_a) {\r\n                    // pass\r\n                }\r\n            }\r\n            document.removeEventListener('keydown', keydownHandler);\r\n        };\r\n        document.addEventListener('keydown', keydownHandler);\r\n        // Insert into container\r\n        const first = this._container.firstChild;\r\n        this._container.insertBefore(toast, first);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Engine.ts\n\r\n\r\n\r\npolyfill();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Enum representing the different mousewheel event bubble prevention\r\n */\r\nvar ScrollPreventionMode;\r\n(function (ScrollPreventionMode) {\r\n    /**\r\n     * Do not prevent any page scrolling\r\n     */\r\n    ScrollPreventionMode[ScrollPreventionMode[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Prevent page scroll if mouse is over the game canvas\r\n     */\r\n    ScrollPreventionMode[ScrollPreventionMode[\"Canvas\"] = 1] = \"Canvas\";\r\n    /**\r\n     * Prevent all page scrolling via mouse wheel\r\n     */\r\n    ScrollPreventionMode[ScrollPreventionMode[\"All\"] = 2] = \"All\";\r\n})(ScrollPreventionMode || (ScrollPreventionMode = {}));\r\n/**\r\n * The Excalibur Engine\r\n *\r\n * The [[Engine]] is the main driver for a game. It is responsible for\r\n * starting/stopping the game, maintaining state, transmitting events,\r\n * loading resources, and managing the scene.\r\n */\r\nclass Engine extends Class {\r\n    /**\r\n     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,\r\n     * the game will be rendered full screen (taking up all available browser window space).\r\n     * You can customize the game rendering through [[EngineOptions]].\r\n     *\r\n     * Example:\r\n     *\r\n     * ```js\r\n     * var game = new ex.Engine({\r\n     *   width: 0, // the width of the canvas\r\n     *   height: 0, // the height of the canvas\r\n     *   enableCanvasTransparency: true, // the transparencySection of the canvas\r\n     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own\r\n     *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine\r\n     * });\r\n     *\r\n     * // call game.start, which is a Promise\r\n     * game.start().then(function () {\r\n     *   // ready, set, go!\r\n     * });\r\n     * ```\r\n     */\r\n    constructor(options) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        super();\r\n        /**\r\n         * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n         *\r\n         * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n         * one that bounces between 30fps and 60fps\r\n         */\r\n        this.maxFps = Number.POSITIVE_INFINITY;\r\n        /**\r\n         * Contains all the scenes currently registered with Excalibur\r\n         */\r\n        this.scenes = {};\r\n        this._suppressPlayButton = false;\r\n        /**\r\n         * Indicates whether audio should be paused when the game is no longer visible.\r\n         */\r\n        this.pauseAudioWhenHidden = true;\r\n        /**\r\n         * Indicates whether the engine should draw with debug information\r\n         */\r\n        this._isDebug = false;\r\n        /**\r\n         * Sets the Transparency for the engine.\r\n         */\r\n        this.enableCanvasTransparency = true;\r\n        /**\r\n         * The action to take when a fatal exception is thrown\r\n         */\r\n        this.onFatalException = (e) => {\r\n            Logger.getInstance().fatal(e);\r\n        };\r\n        this._toaster = new Toaster();\r\n        this._timescale = 1.0;\r\n        this._isInitialized = false;\r\n        this._deferredGoTo = null;\r\n        this._originalOptions = {};\r\n        this._performanceThresholdTriggered = false;\r\n        this._fpsSamples = [];\r\n        this._loadingComplete = false;\r\n        this._isReady = false;\r\n        this._isReadyPromise = new Promise(resolve => {\r\n            this._isReadyResolve = resolve;\r\n        });\r\n        /**\r\n         * Returns the current frames elapsed milliseconds\r\n         */\r\n        this.currentFrameElapsedMs = 0;\r\n        /**\r\n         * Returns the current frame lag when in fixed update mode\r\n         */\r\n        this.currentFrameLagMs = 0;\r\n        this._lagMs = 0;\r\n        this._screenShotRequests = [];\r\n        options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };\r\n        this._originalOptions = options;\r\n        Flags.freeze();\r\n        // Initialize browser events facade\r\n        this.browser = new BrowserEvents(window, document);\r\n        // Check compatibility\r\n        const detector = new Detector();\r\n        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {\r\n            const message = document.createElement('div');\r\n            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';\r\n            document.body.appendChild(message);\r\n            detector.failedTests.forEach(function (test) {\r\n                const testMessage = document.createElement('div');\r\n                testMessage.innerText = 'Browser feature missing ' + test;\r\n                document.body.appendChild(testMessage);\r\n            });\r\n            if (options.canvasElementId) {\r\n                const canvas = document.getElementById(options.canvasElementId);\r\n                if (canvas) {\r\n                    canvas.parentElement.removeChild(canvas);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            this._compatible = true;\r\n        }\r\n        // Use native console API for color fun\r\n        // eslint-disable-next-line no-console\r\n        if (console.log && !options.suppressConsoleBootMessage) {\r\n            // eslint-disable-next-line no-console\r\n            console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');\r\n            // eslint-disable-next-line no-console\r\n            console.log('\\n\\\r\n      /| ________________\\n\\\r\nO|===|* >________________>\\n\\\r\n      \\\\|');\r\n            // eslint-disable-next-line no-console\r\n            console.log('Visit', 'http://excaliburjs.com', 'for more information');\r\n        }\r\n        // Suppress play button\r\n        if (options.suppressPlayButton) {\r\n            this._suppressPlayButton = true;\r\n        }\r\n        this._logger = Logger.getInstance();\r\n        // If debug is enabled, let's log browser features to the console.\r\n        if (this._logger.defaultLevel === LogLevel.Debug) {\r\n            detector.logBrowserFeatures();\r\n        }\r\n        this._logger.debug('Building engine...');\r\n        this.canvasElementId = options.canvasElementId;\r\n        if (options.canvasElementId) {\r\n            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);\r\n            this.canvas = document.getElementById(options.canvasElementId);\r\n        }\r\n        else if (options.canvasElement) {\r\n            this._logger.debug('Using Canvas element specified:', options.canvasElement);\r\n            this.canvas = options.canvasElement;\r\n        }\r\n        else {\r\n            this._logger.debug('Using generated canvas element');\r\n            this.canvas = document.createElement('canvas');\r\n        }\r\n        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;\r\n        if ((options.width && options.height) || options.viewport) {\r\n            if (options.displayMode === undefined) {\r\n                displayMode = DisplayMode.Fixed;\r\n            }\r\n            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);\r\n        }\r\n        else if (!options.displayMode) {\r\n            this._logger.debug('Engine viewport is fit');\r\n            displayMode = DisplayMode.FitScreen;\r\n        }\r\n        this._originalDisplayMode = displayMode;\r\n        // Canvas 2D fallback can be flagged on\r\n        let useCanvasGraphicsContext = Flags.isEnabled('use-canvas-context');\r\n        if (!useCanvasGraphicsContext) {\r\n            // Attempt webgl first\r\n            try {\r\n                this.graphicsContext = new ExcaliburGraphicsContextWebGL({\r\n                    canvasElement: this.canvas,\r\n                    enableTransparency: this.enableCanvasTransparency,\r\n                    smoothing: options.antialiasing,\r\n                    backgroundColor: options.backgroundColor,\r\n                    snapToPixel: options.snapToPixel,\r\n                    useDrawSorting: options.useDrawSorting\r\n                });\r\n            }\r\n            catch (e) {\r\n                this._logger.warn(`Excalibur could not load webgl for some reason (${e.message}) and loaded a Canvas 2D fallback. ` +\r\n                    `Some features of Excalibur will not work in this mode. \\n\\n` +\r\n                    'Read more about this issue at https://excaliburjs.com/docs/webgl');\r\n                // fallback to canvas in case of failure\r\n                useCanvasGraphicsContext = true;\r\n            }\r\n        }\r\n        if (useCanvasGraphicsContext) {\r\n            this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n                canvasElement: this.canvas,\r\n                enableTransparency: this.enableCanvasTransparency,\r\n                smoothing: options.antialiasing,\r\n                backgroundColor: options.backgroundColor,\r\n                snapToPixel: options.snapToPixel,\r\n                useDrawSorting: options.useDrawSorting\r\n            });\r\n        }\r\n        this.screen = new Screen({\r\n            canvas: this.canvas,\r\n            context: this.graphicsContext,\r\n            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,\r\n            browser: this.browser,\r\n            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n            resolution: options.resolution,\r\n            displayMode,\r\n            pixelRatio: options.suppressHiDPIScaling ? 1 : ((_d = options.pixelRatio) !== null && _d !== void 0 ? _d : null)\r\n        });\r\n        // Set default filtering based on antialiasing\r\n        TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;\r\n        if (options.backgroundColor) {\r\n            this.backgroundColor = options.backgroundColor.clone();\r\n        }\r\n        this.maxFps = (_e = options.maxFps) !== null && _e !== void 0 ? _e : this.maxFps;\r\n        this.fixedUpdateFps = (_f = options.fixedUpdateFps) !== null && _f !== void 0 ? _f : this.fixedUpdateFps;\r\n        this.clock = new StandardClock({\r\n            maxFps: this.maxFps,\r\n            tick: this._mainloop.bind(this),\r\n            onFatalException: (e) => this.onFatalException(e)\r\n        });\r\n        this.enableCanvasTransparency = options.enableCanvasTransparency;\r\n        this._loader = new Loader();\r\n        this._loader.wireEngine(this);\r\n        this.debug = new Debug(this);\r\n        this._initialize(options);\r\n        this.rootScene = this.currentScene = new Scene();\r\n        this.addScene('root', this.rootScene);\r\n        window.___EXCALIBUR_DEVTOOL = this;\r\n    }\r\n    /**\r\n     * The width of the game canvas in pixels (physical width component of the\r\n     * resolution of the canvas element)\r\n     */\r\n    get canvasWidth() {\r\n        return this.screen.canvasWidth;\r\n    }\r\n    /**\r\n     * Returns half width of the game canvas in pixels (half physical width component)\r\n     */\r\n    get halfCanvasWidth() {\r\n        return this.screen.halfCanvasWidth;\r\n    }\r\n    /**\r\n     * The height of the game canvas in pixels, (physical height component of\r\n     * the resolution of the canvas element)\r\n     */\r\n    get canvasHeight() {\r\n        return this.screen.canvasHeight;\r\n    }\r\n    /**\r\n     * Returns half height of the game canvas in pixels (half physical height component)\r\n     */\r\n    get halfCanvasHeight() {\r\n        return this.screen.halfCanvasHeight;\r\n    }\r\n    /**\r\n     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get drawWidth() {\r\n        return this.screen.drawWidth;\r\n    }\r\n    /**\r\n     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get halfDrawWidth() {\r\n        return this.screen.halfDrawWidth;\r\n    }\r\n    /**\r\n     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get drawHeight() {\r\n        return this.screen.drawHeight;\r\n    }\r\n    /**\r\n     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n     */\r\n    get halfDrawHeight() {\r\n        return this.screen.halfDrawHeight;\r\n    }\r\n    /**\r\n     * Returns whether excalibur detects the current screen to be HiDPI\r\n     */\r\n    get isHiDpi() {\r\n        return this.screen.isHiDpi;\r\n    }\r\n    /**\r\n     * Access [[stats]] that holds frame statistics.\r\n     */\r\n    get stats() {\r\n        return this.debug.stats;\r\n    }\r\n    /**\r\n     * Indicates whether the engine is set to fullscreen or not\r\n     */\r\n    get isFullscreen() {\r\n        return this.screen.isFullScreen;\r\n    }\r\n    /**\r\n     * Indicates the current [[DisplayMode]] of the engine.\r\n     */\r\n    get displayMode() {\r\n        return this.screen.displayMode;\r\n    }\r\n    /**\r\n     * Returns the calculated pixel ration for use in rendering\r\n     */\r\n    get pixelRatio() {\r\n        return this.screen.pixelRatio;\r\n    }\r\n    get isDebug() {\r\n        return this._isDebug;\r\n    }\r\n    /**\r\n     * Hints the graphics context to truncate fractional world space coordinates\r\n     */\r\n    get snapToPixel() {\r\n        return this.graphicsContext.snapToPixel;\r\n    }\r\n    ;\r\n    set snapToPixel(shouldSnapToPixel) {\r\n        this.graphicsContext.snapToPixel = shouldSnapToPixel;\r\n    }\r\n    ;\r\n    on(eventName, handler) {\r\n        super.on(eventName, handler);\r\n    }\r\n    once(eventName, handler) {\r\n        super.once(eventName, handler);\r\n    }\r\n    off(eventName, handler) {\r\n        super.off(eventName, handler);\r\n    }\r\n    _monitorPerformanceThresholdAndTriggerFallback() {\r\n        const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n        let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n        if (threshold === undefined) {\r\n            threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;\r\n        }\r\n        if (showPlayerMessage === undefined) {\r\n            showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;\r\n        }\r\n        if (!Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {\r\n            // Calculate Average fps for last X number of frames after start\r\n            if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n                this._fpsSamples.splice(0, 1);\r\n            }\r\n            this._fpsSamples.push(this.clock.fpsSampler.fps);\r\n            let total = 0;\r\n            for (let i = 0; i < this._fpsSamples.length; i++) {\r\n                total += this._fpsSamples[i];\r\n            }\r\n            const average = total / this._fpsSamples.length;\r\n            if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n                if (average <= threshold.fps) {\r\n                    this._performanceThresholdTriggered = true;\r\n                    this._logger.warn(`Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\\n` +\r\n                        'this might mean your browser doesn\\'t have webgl enabled or hardware acceleration is unavailable.\\n\\n' +\r\n                        'If in Chrome:\\n' +\r\n                        '  * Visit Settings > Advanced > System, and ensure \"Use Hardware Acceleration\" is checked.\\n' +\r\n                        '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure \"Override software rendering list\" is \"enabled\"\\n' +\r\n                        'If in Firefox, visit about:config\\n' +\r\n                        '  * Ensure webgl.disabled = false\\n' +\r\n                        '  * Ensure webgl.force-enabled = true\\n' +\r\n                        '  * Ensure layers.acceleration.force-enabled = true\\n\\n' +\r\n                        'Read more about this issue at https://excaliburjs.com/docs/performance');\r\n                    if (showPlayerMessage) {\r\n                        this._toaster.toast('Excalibur is encountering performance issues. ' +\r\n                            'It\\'s possible that your browser doesn\\'t have hardware acceleration enabled. ' +\r\n                            'Visit [LINK] for more information and potential solutions.', 'https://excaliburjs.com/docs/performance');\r\n                    }\r\n                    this.useCanvas2DFallback();\r\n                    this.emit('fallbackgraphicscontext', this.graphicsContext);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Switches the engine's graphics context to the 2D Canvas.\r\n     * @warning Some features of Excalibur will not work in this mode.\r\n     */\r\n    useCanvas2DFallback() {\r\n        var _a, _b, _c;\r\n        // Swap out the canvas\r\n        const newCanvas = this.canvas.cloneNode(false);\r\n        this.canvas.parentNode.replaceChild(newCanvas, this.canvas);\r\n        this.canvas = newCanvas;\r\n        const options = this._originalOptions;\r\n        const displayMode = this._originalDisplayMode;\r\n        // New graphics context\r\n        this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n            canvasElement: this.canvas,\r\n            enableTransparency: this.enableCanvasTransparency,\r\n            smoothing: options.antialiasing,\r\n            backgroundColor: options.backgroundColor,\r\n            snapToPixel: options.snapToPixel,\r\n            useDrawSorting: options.useDrawSorting\r\n        });\r\n        // Reset screen\r\n        if (this.screen) {\r\n            this.screen.dispose();\r\n        }\r\n        this.screen = new Screen({\r\n            canvas: this.canvas,\r\n            context: this.graphicsContext,\r\n            antialiasing: (_a = options.antialiasing) !== null && _a !== void 0 ? _a : true,\r\n            browser: this.browser,\r\n            viewport: (_b = options.viewport) !== null && _b !== void 0 ? _b : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n            resolution: options.resolution,\r\n            displayMode,\r\n            pixelRatio: options.suppressHiDPIScaling ? 1 : ((_c = options.pixelRatio) !== null && _c !== void 0 ? _c : null)\r\n        });\r\n        this.screen.setCurrentCamera(this.currentScene.camera);\r\n        // Reset pointers\r\n        this.input.pointers.detach();\r\n        const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;\r\n        this.input.pointers = this.input.pointers.recreate(pointerTarget, this);\r\n        this.input.pointers.init();\r\n    }\r\n    /**\r\n     * Returns a BoundingBox of the top left corner of the screen\r\n     * and the bottom right corner of the screen.\r\n     */\r\n    getWorldBounds() {\r\n        return this.screen.getWorldBounds();\r\n    }\r\n    /**\r\n     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n     */\r\n    get timescale() {\r\n        return this._timescale;\r\n    }\r\n    /**\r\n     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n     * when using time-based movement.\r\n     */\r\n    set timescale(value) {\r\n        if (value <= 0) {\r\n            Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');\r\n            return;\r\n        }\r\n        this._timescale = value;\r\n    }\r\n    /**\r\n     * Adds a [[Timer]] to the [[currentScene]].\r\n     * @param timer  The timer to add to the [[currentScene]].\r\n     */\r\n    addTimer(timer) {\r\n        return this.currentScene.addTimer(timer);\r\n    }\r\n    /**\r\n     * Removes a [[Timer]] from the [[currentScene]].\r\n     * @param timer  The timer to remove to the [[currentScene]].\r\n     */\r\n    removeTimer(timer) {\r\n        return this.currentScene.removeTimer(timer);\r\n    }\r\n    /**\r\n     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n     * would levels or menus.\r\n     *\r\n     * @param key  The name of the scene, must be unique\r\n     * @param scene The scene to add to the engine\r\n     */\r\n    addScene(key, scene) {\r\n        if (this.scenes[key]) {\r\n            this._logger.warn('Scene', key, 'already exists overwriting');\r\n        }\r\n        this.scenes[key] = scene;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    removeScene(entity) {\r\n        if (entity instanceof Scene) {\r\n            // remove scene\r\n            for (const key in this.scenes) {\r\n                if (this.scenes.hasOwnProperty(key)) {\r\n                    if (this.scenes[key] === entity) {\r\n                        delete this.scenes[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (typeof entity === 'string') {\r\n            // remove scene\r\n            delete this.scenes[entity];\r\n        }\r\n    }\r\n    add(entity) {\r\n        if (arguments.length === 2) {\r\n            this.addScene(arguments[0], arguments[1]);\r\n            return;\r\n        }\r\n        if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {\r\n            this.scenes[this._deferredGoTo].add(entity);\r\n        }\r\n        else {\r\n            this.currentScene.add(entity);\r\n        }\r\n    }\r\n    remove(entity) {\r\n        if (entity instanceof Entity) {\r\n            this.currentScene.remove(entity);\r\n        }\r\n        if (entity instanceof Scene) {\r\n            this.removeScene(entity);\r\n        }\r\n        if (typeof entity === 'string') {\r\n            this.removeScene(entity);\r\n        }\r\n    }\r\n    /**\r\n     * Changes the currently updating and drawing scene to a different,\r\n     * named scene. Calls the [[Scene]] lifecycle events.\r\n     * @param key  The key of the scene to transition to.\r\n     * @param data Optional data to send to the scene's onActivate method\r\n     */\r\n    goToScene(key, data) {\r\n        // if not yet initialized defer goToScene\r\n        if (!this.isInitialized) {\r\n            this._deferredGoTo = key;\r\n            return;\r\n        }\r\n        if (this.scenes[key]) {\r\n            const previousScene = this.currentScene;\r\n            const nextScene = this.scenes[key];\r\n            this._logger.debug('Going to scene:', key);\r\n            // only deactivate when initialized\r\n            if (this.currentScene.isInitialized) {\r\n                const context = { engine: this, previousScene, nextScene };\r\n                this.currentScene._deactivate.apply(this.currentScene, [context, nextScene]);\r\n                this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(context, this.currentScene));\r\n            }\r\n            // set current scene to new one\r\n            this.currentScene = nextScene;\r\n            this.screen.setCurrentCamera(nextScene.camera);\r\n            // initialize the current scene if has not been already\r\n            this.currentScene._initialize(this);\r\n            const context = { engine: this, previousScene, nextScene, data };\r\n            this.currentScene._activate.apply(this.currentScene, [context, nextScene]);\r\n            this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(context, this.currentScene));\r\n        }\r\n        else {\r\n            this._logger.error('Scene', key, 'does not exist!');\r\n        }\r\n    }\r\n    /**\r\n     * Transforms the current x, y from screen coordinates to world coordinates\r\n     * @param point  Screen coordinate to convert\r\n     */\r\n    screenToWorldCoordinates(point) {\r\n        return this.screen.screenToWorldCoordinates(point);\r\n    }\r\n    /**\r\n     * Transforms a world coordinate, to a screen coordinate\r\n     * @param point  World coordinate to convert\r\n     */\r\n    worldToScreenCoordinates(point) {\r\n        return this.screen.worldToScreenCoordinates(point);\r\n    }\r\n    /**\r\n     * Initializes the internal canvas, rendering context, display mode, and native event listeners\r\n     */\r\n    _initialize(options) {\r\n        this.pageScrollPreventionMode = options.scrollPreventionMode;\r\n        // initialize inputs\r\n        const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;\r\n        this.input = {\r\n            keyboard: new Keyboard(),\r\n            pointers: new PointerEventReceiver(pointerTarget, this),\r\n            gamepads: new Gamepads()\r\n        };\r\n        this.input.keyboard.init();\r\n        this.input.pointers.init();\r\n        this.input.gamepads.init();\r\n        // Issue #385 make use of the visibility api\r\n        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\r\n        let hidden, visibilityChange;\r\n        if (typeof document.hidden !== 'undefined') {\r\n            // Opera 12.10 and Firefox 18 and later support\r\n            hidden = 'hidden';\r\n            visibilityChange = 'visibilitychange';\r\n        }\r\n        else if ('msHidden' in document) {\r\n            hidden = 'msHidden';\r\n            visibilityChange = 'msvisibilitychange';\r\n        }\r\n        else if ('webkitHidden' in document) {\r\n            hidden = 'webkitHidden';\r\n            visibilityChange = 'webkitvisibilitychange';\r\n        }\r\n        this.browser.document.on(visibilityChange, () => {\r\n            if (document[hidden]) {\r\n                this.eventDispatcher.emit('hidden', new HiddenEvent(this));\r\n                this._logger.debug('Window hidden');\r\n            }\r\n            else {\r\n                this.eventDispatcher.emit('visible', new VisibleEvent(this));\r\n                this._logger.debug('Window visible');\r\n            }\r\n        });\r\n        if (!this.canvasElementId && !options.canvasElement) {\r\n            document.body.appendChild(this.canvas);\r\n        }\r\n    }\r\n    onInitialize(_engine) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * If supported by the browser, this will set the antialiasing flag on the\r\n     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your\r\n     * image resources.\r\n     * @param isSmooth  Set smoothing to true or false\r\n     */\r\n    setAntialiasing(isSmooth) {\r\n        this.screen.antialiasing = isSmooth;\r\n    }\r\n    /**\r\n     * Return the current smoothing status of the canvas\r\n     */\r\n    getAntialiasing() {\r\n        return this.screen.antialiasing;\r\n    }\r\n    /**\r\n     * Gets whether the actor is Initialized\r\n     */\r\n    get isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n    _overrideInitialize(engine) {\r\n        if (!this.isInitialized) {\r\n            this.onInitialize(engine);\r\n            super.emit('initialize', new InitializeEvent(engine, this));\r\n            this._isInitialized = true;\r\n            if (this._deferredGoTo) {\r\n                const deferredScene = this._deferredGoTo;\r\n                this._deferredGoTo = null;\r\n                this.goToScene(deferredScene);\r\n            }\r\n            else {\r\n                this.goToScene('root');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Updates the entire state of the game\r\n     * @param delta  Number of milliseconds elapsed since the last update.\r\n     */\r\n    _update(delta) {\r\n        if (!this.ready) {\r\n            // suspend updates until loading is finished\r\n            this._loader.update(this, delta);\r\n            // Update input listeners\r\n            this.input.keyboard.update();\r\n            this.input.gamepads.update();\r\n            return;\r\n        }\r\n        // Publish preupdate events\r\n        this._preupdate(delta);\r\n        // process engine level events\r\n        this.currentScene.update(this, delta);\r\n        // Publish update event\r\n        this._postupdate(delta);\r\n        // Update input listeners\r\n        this.input.keyboard.update();\r\n        this.input.gamepads.update();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _preupdate(delta) {\r\n        this.emit('preupdate', new PreUpdateEvent(this, delta, this));\r\n        this.onPreUpdate(this, delta);\r\n    }\r\n    onPreUpdate(_engine, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _postupdate(delta) {\r\n        this.emit('postupdate', new PostUpdateEvent(this, delta, this));\r\n        this.onPostUpdate(this, delta);\r\n    }\r\n    onPostUpdate(_engine, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * Draws the entire game\r\n     * @param delta  Number of milliseconds elapsed since the last draw.\r\n     */\r\n    _draw(delta) {\r\n        this.graphicsContext.beginDrawLifecycle();\r\n        this.graphicsContext.clear();\r\n        this._predraw(this.graphicsContext, delta);\r\n        // Drawing nothing else while loading\r\n        if (!this._isReady) {\r\n            this._loader.canvas.draw(this.graphicsContext, 0, 0);\r\n            this.graphicsContext.flush();\r\n            return;\r\n        }\r\n        this.graphicsContext.backgroundColor = this.backgroundColor;\r\n        this.currentScene.draw(this.graphicsContext, delta);\r\n        this._postdraw(this.graphicsContext, delta);\r\n        // Flush any pending drawings\r\n        this.graphicsContext.flush();\r\n        this.graphicsContext.endDrawLifecycle();\r\n        this._checkForScreenShots();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _predraw(_ctx, delta) {\r\n        this.emit('predraw', new PreDrawEvent(_ctx, delta, this));\r\n        this.onPreDraw(_ctx, delta);\r\n    }\r\n    onPreDraw(_ctx, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _postdraw(_ctx, delta) {\r\n        this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));\r\n        this.onPostDraw(_ctx, delta);\r\n    }\r\n    onPostDraw(_ctx, _delta) {\r\n        // Override me\r\n    }\r\n    /**\r\n     * Enable or disable Excalibur debugging functionality.\r\n     * @param toggle a value that debug drawing will be changed to\r\n     */\r\n    showDebug(toggle) {\r\n        this._isDebug = toggle;\r\n    }\r\n    /**\r\n     * Toggle Excalibur debugging functionality.\r\n     */\r\n    toggleDebug() {\r\n        this._isDebug = !this._isDebug;\r\n        return this._isDebug;\r\n    }\r\n    /**\r\n     * Returns true when loading is totally complete and the player has clicked start\r\n     */\r\n    get loadingComplete() {\r\n        return this._loadingComplete;\r\n    }\r\n    get ready() {\r\n        return this._isReady;\r\n    }\r\n    isReady() {\r\n        return this._isReadyPromise;\r\n    }\r\n    /**\r\n     * Starts the internal game loop for Excalibur after loading\r\n     * any provided assets.\r\n     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n     * custom loader.\r\n     *\r\n     * Note: start() only resolves AFTER the user has clicked the play button\r\n     */\r\n    async start(loader) {\r\n        if (!this._compatible) {\r\n            throw new Error('Excalibur is incompatible with your browser');\r\n        }\r\n        // Wire loader if we have it\r\n        if (loader) {\r\n            // Push the current user entered resolution/viewport\r\n            this.screen.pushResolutionAndViewport();\r\n            // Configure resolution for loader, it expects resolution === viewport\r\n            this.screen.resolution = this.screen.viewport;\r\n            this.screen.applyResolutionAndViewport();\r\n            this._loader = loader;\r\n            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;\r\n            this._loader.wireEngine(this);\r\n        }\r\n        // Start the excalibur clock which drives the mainloop\r\n        // has started is a slight misnomer, it's really mainloop started\r\n        this._logger.debug('Starting game clock...');\r\n        this.browser.resume();\r\n        this.clock.start();\r\n        this._logger.debug('Game clock started');\r\n        if (loader) {\r\n            await this.load(this._loader);\r\n            this._loadingComplete = true;\r\n            // reset back to previous user resolution/viewport\r\n            this.screen.popResolutionAndViewport();\r\n            this.screen.applyResolutionAndViewport();\r\n        }\r\n        this._loadingComplete = true;\r\n        // Initialize before ready\r\n        this._overrideInitialize(this);\r\n        this._isReady = true;\r\n        this._isReadyResolve();\r\n        this.emit('start', new GameStartEvent(this));\r\n        return this._isReadyPromise;\r\n    }\r\n    _mainloop(elapsed) {\r\n        this.emit('preframe', new PreFrameEvent(this, this.stats.prevFrame));\r\n        const delta = elapsed * this.timescale;\r\n        this.currentFrameElapsedMs = delta;\r\n        // reset frame stats (reuse existing instances)\r\n        const frameId = this.stats.prevFrame.id + 1;\r\n        this.stats.currFrame.reset();\r\n        this.stats.currFrame.id = frameId;\r\n        this.stats.currFrame.delta = delta;\r\n        this.stats.currFrame.fps = this.clock.fpsSampler.fps;\r\n        GraphicsDiagnostics.clear();\r\n        const beforeUpdate = this.clock.now();\r\n        const fixedTimestepMs = 1000 / this.fixedUpdateFps;\r\n        if (this.fixedUpdateFps) {\r\n            this._lagMs += delta;\r\n            while (this._lagMs >= fixedTimestepMs) {\r\n                this._update(fixedTimestepMs);\r\n                this._lagMs -= fixedTimestepMs;\r\n            }\r\n        }\r\n        else {\r\n            this._update(delta);\r\n        }\r\n        const afterUpdate = this.clock.now();\r\n        this.currentFrameLagMs = this._lagMs;\r\n        this._draw(delta);\r\n        const afterDraw = this.clock.now();\r\n        this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\r\n        this.stats.currFrame.duration.draw = afterDraw - afterUpdate;\r\n        this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\r\n        this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\r\n        this.emit('postframe', new PostFrameEvent(this, this.stats.currFrame));\r\n        this.stats.prevFrame.reset(this.stats.currFrame);\r\n        this._monitorPerformanceThresholdAndTriggerFallback();\r\n    }\r\n    /**\r\n     * Stops Excalibur's main loop, useful for pausing the game.\r\n     */\r\n    stop() {\r\n        if (this.clock.isRunning()) {\r\n            this.emit('stop', new GameStopEvent(this));\r\n            this.browser.pause();\r\n            this.clock.stop();\r\n            this._logger.debug('Game stopped');\r\n        }\r\n    }\r\n    /**\r\n     * Returns the Engine's running status, Useful for checking whether engine is running or paused.\r\n     */\r\n    isRunning() {\r\n        return this.clock.isRunning();\r\n    }\r\n    /**\r\n     * Takes a screen shot of the current viewport and returns it as an\r\n     * HTML Image Element.\r\n     * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false\r\n     */\r\n    screenshot(preserveHiDPIResolution = false) {\r\n        const screenShotPromise = new Promise((resolve) => {\r\n            this._screenShotRequests.push({ preserveHiDPIResolution, resolve });\r\n        });\r\n        return screenShotPromise;\r\n    }\r\n    _checkForScreenShots() {\r\n        // We must grab the draw buffer before we yield to the browser\r\n        // the draw buffer is cleared after compositing\r\n        // the reason for the asynchrony is setting `preserveDrawingBuffer: true`\r\n        // forces the browser to copy buffers which can have a mass perf impact on mobile\r\n        for (const request of this._screenShotRequests) {\r\n            const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;\r\n            const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;\r\n            const screenshot = document.createElement('canvas');\r\n            screenshot.width = finalWidth;\r\n            screenshot.height = finalHeight;\r\n            const ctx = screenshot.getContext('2d');\r\n            ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);\r\n            const result = new Image();\r\n            const raw = screenshot.toDataURL('image/png');\r\n            result.src = raw;\r\n            request.resolve(result);\r\n        }\r\n        // Reset state\r\n        this._screenShotRequests.length = 0;\r\n    }\r\n    /**\r\n     * Another option available to you to load resources into the game.\r\n     * Immediately after calling this the game will pause and the loading screen\r\n     * will appear.\r\n     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n     */\r\n    async load(loader) {\r\n        try {\r\n            await loader.load();\r\n        }\r\n        catch (e) {\r\n            this._logger.error('Error loading resources, things may not behave properly', e);\r\n            await Promise.resolve();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Default [[EngineOptions]]\r\n */\r\nEngine._DEFAULT_ENGINE_OPTIONS = {\r\n    width: 0,\r\n    height: 0,\r\n    enableCanvasTransparency: true,\r\n    useDrawSorting: true,\r\n    configurePerformanceCanvas2DFallback: {\r\n        allow: true,\r\n        showPlayerMessage: false,\r\n        threshold: { fps: 20, numberOfFrames: 100 }\r\n    },\r\n    canvasElementId: '',\r\n    canvasElement: undefined,\r\n    snapToPixel: false,\r\n    pointerScope: PointerScope.Canvas,\r\n    suppressConsoleBootMessage: null,\r\n    suppressMinimumBrowserFeatureDetection: null,\r\n    suppressHiDPIScaling: null,\r\n    suppressPlayButton: null,\r\n    scrollPreventionMode: ScrollPreventionMode.Canvas,\r\n    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue\r\n};\r\n\n;// CONCATENATED MODULE: ./Math/Index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Debug/index.ts\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Label.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Labels are the way to draw small amounts of text to the screen. They are\r\n * actors and inherit all of the benefits and capabilities.\r\n */\r\nclass Label extends Actor {\r\n    /**\r\n     * Build a new label\r\n     * @param options\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n        this._font = new Font();\r\n        this._text = new Text({ text: '', font: this._font });\r\n        const { text, pos, x, y, spriteFont, font, color } = options;\r\n        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? vec(x, y) : this.pos);\r\n        this.text = text !== null && text !== void 0 ? text : this.text;\r\n        this.font = font !== null && font !== void 0 ? font : this.font;\r\n        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;\r\n        this._text.color = color !== null && color !== void 0 ? color : this.color;\r\n        const gfx = this.get(GraphicsComponent);\r\n        gfx.anchor = Vector.Zero;\r\n        gfx.use(this._text);\r\n    }\r\n    get font() {\r\n        return this._font;\r\n    }\r\n    set font(newFont) {\r\n        this._font = newFont;\r\n        this._text.font = newFont;\r\n    }\r\n    /**\r\n     * The text to draw.\r\n     */\r\n    get text() {\r\n        return this._text.text;\r\n    }\r\n    set text(text) {\r\n        this._text.text = text;\r\n    }\r\n    get color() {\r\n        return this._text.color;\r\n    }\r\n    set color(color) {\r\n        if (this._text) {\r\n            this._text.color = color;\r\n        }\r\n    }\r\n    get opacity() {\r\n        return this._text.opacity;\r\n    }\r\n    set opacity(opacity) {\r\n        this._text.opacity = opacity;\r\n    }\r\n    /**\r\n     * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.\r\n     */\r\n    get spriteFont() {\r\n        return this._spriteFont;\r\n    }\r\n    set spriteFont(sf) {\r\n        if (sf) {\r\n            this._spriteFont = sf;\r\n            this._text.font = this._spriteFont;\r\n        }\r\n    }\r\n    _initialize(engine) {\r\n        super._initialize(engine);\r\n    }\r\n    /**\r\n     * Returns the width of the text in the label (in pixels);\r\n     */\r\n    getTextWidth() {\r\n        return this._text.width;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./TileMap/IsometricMap.ts\n\r\n\r\n\r\n\r\n\r\nclass IsometricTile extends Entity {\r\n    /**\r\n     * Construct a new IsometricTile\r\n     * @param x tile coordinate in x (not world position)\r\n     * @param y tile coordinate in y (not world position)\r\n     * @param graphicsOffset offset that tile should be shifted by (default (0, 0))\r\n     * @param map reference to owning IsometricMap\r\n     */\r\n    constructor(x, y, graphicsOffset, map) {\r\n        super([\r\n            new TransformComponent(),\r\n            new GraphicsComponent({\r\n                offset: graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : Vector.Zero,\r\n                onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)\r\n            }),\r\n            new IsometricEntityComponent(map)\r\n        ]);\r\n        /**\r\n         * Indicates whether this tile is solid\r\n         */\r\n        this.solid = false;\r\n        this._tileBounds = new BoundingBox();\r\n        this._graphics = [];\r\n        /**\r\n         * Tile colliders\r\n         */\r\n        this._colliders = [];\r\n        this.x = x;\r\n        this.y = y;\r\n        this.map = map;\r\n        this._transform = this.get(TransformComponent);\r\n        this._isometricEntityComponent = this.get(IsometricEntityComponent);\r\n        const halfTileWidth = this.map.tileWidth / 2;\r\n        const halfTileHeight = this.map.tileHeight / 2;\r\n        // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n        // The x position shifts left with every y step\r\n        const xPos = (this.x - this.y) * halfTileWidth;\r\n        // The y position needs to go down with every x step\r\n        const yPos = (this.x + this.y) * halfTileHeight;\r\n        this._transform.pos = vec(xPos, yPos);\r\n        this._isometricEntityComponent.elevation = 0;\r\n        this._gfx = this.get(GraphicsComponent);\r\n        this._gfx.visible = false; // start not visible\r\n        const totalWidth = this.map.tileWidth;\r\n        const totalHeight = this.map.tileHeight;\r\n        // initial guess at gfx bounds based on the tile\r\n        const offset = vec(0, (this.map.renderFromTopOfGraphic ? totalHeight : 0));\r\n        this._gfx.localBounds = this._tileBounds = new BoundingBox({\r\n            left: -totalWidth / 2,\r\n            top: -totalHeight,\r\n            right: totalWidth / 2,\r\n            bottom: totalHeight\r\n        }).translate(offset);\r\n    }\r\n    getGraphics() {\r\n        return this._graphics;\r\n    }\r\n    /**\r\n     * Tile graphics\r\n     */\r\n    addGraphic(graphic) {\r\n        this._graphics.push(graphic);\r\n        this._gfx.visible = true;\r\n        this._gfx.localBounds = this._recalculateBounds();\r\n    }\r\n    _recalculateBounds() {\r\n        let bounds = this._tileBounds.clone();\r\n        for (const graphic of this._graphics) {\r\n            const offset = vec(this.map.graphicsOffset.x - this.map.tileWidth / 2, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n            bounds = bounds.combine(graphic.localBounds.translate(offset));\r\n        }\r\n        return bounds;\r\n    }\r\n    removeGraphic(graphic) {\r\n        const index = this._graphics.indexOf(graphic);\r\n        if (index > -1) {\r\n            this._graphics.splice(index, 1);\r\n        }\r\n        this._gfx.localBounds = this._recalculateBounds();\r\n    }\r\n    clearGraphics() {\r\n        this._graphics.length = 0;\r\n        this._gfx.visible = false;\r\n        this._gfx.localBounds = this._recalculateBounds();\r\n    }\r\n    getColliders() {\r\n        return this._colliders;\r\n    }\r\n    /**\r\n     * Adds a collider to the IsometricTile\r\n     *\r\n     * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n     * @param collider\r\n     */\r\n    addCollider(collider) {\r\n        this._colliders.push(collider);\r\n        this.map.flagCollidersDirty();\r\n    }\r\n    /**\r\n     * Removes a collider from the IsometricTile\r\n     * @param collider\r\n     */\r\n    removeCollider(collider) {\r\n        const index = this._colliders.indexOf(collider);\r\n        if (index > -1) {\r\n            this._colliders.splice(index, 1);\r\n        }\r\n        this.map.flagCollidersDirty();\r\n    }\r\n    /**\r\n     * Clears all colliders from the IsometricTile\r\n     */\r\n    clearColliders() {\r\n        this._colliders.length = 0;\r\n        this.map.flagCollidersDirty();\r\n    }\r\n    /**\r\n     * Returns the top left corner of the [[IsometricTile]] in world space\r\n     */\r\n    get pos() {\r\n        return this.map.tileToWorld(vec(this.x, this.y));\r\n    }\r\n    /**\r\n     * Returns the center of the [[IsometricTile]]\r\n     */\r\n    get center() {\r\n        return this.pos.add(vec(0, this.map.tileHeight / 2));\r\n    }\r\n    draw(gfx, _elapsed) {\r\n        const halfTileWidth = this.map.tileWidth / 2;\r\n        gfx.save();\r\n        // shift left origin to corner of map, not the left corner of the first sprite\r\n        gfx.translate(-halfTileWidth, 0);\r\n        for (const graphic of this._graphics) {\r\n            graphic.draw(gfx, this.map.graphicsOffset.x, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n        }\r\n        gfx.restore();\r\n    }\r\n}\r\n/**\r\n * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur\r\n *\r\n * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.\r\n * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.\r\n *\r\n * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given\r\n * your art assets.\r\n */\r\nclass IsometricMap extends Entity {\r\n    constructor(options) {\r\n        super([\r\n            new TransformComponent(),\r\n            new BodyComponent({\r\n                type: CollisionType.Fixed\r\n            }),\r\n            new ColliderComponent(),\r\n            new DebugGraphicsComponent((ctx) => this.debug(ctx), false)\r\n        ], options.name);\r\n        /**\r\n         * Render the tile graphic from the top instead of the bottom\r\n         *\r\n         * default is `false` meaning rendering from the bottom\r\n         */\r\n        this.renderFromTopOfGraphic = false;\r\n        this.graphicsOffset = vec(0, 0);\r\n        this._collidersDirty = false;\r\n        this._originalOffsets = new WeakMap();\r\n        const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;\r\n        this.transform = this.get(TransformComponent);\r\n        if (pos) {\r\n            this.transform.pos = pos;\r\n        }\r\n        this.collider = this.get(ColliderComponent);\r\n        if (this.collider) {\r\n            this.collider.set(this._composite = new CompositeCollider([]));\r\n        }\r\n        this.renderFromTopOfGraphic = renderFromTopOfGraphic !== null && renderFromTopOfGraphic !== void 0 ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;\r\n        this.graphicsOffset = graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : this.graphicsOffset;\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n        this.columns = width;\r\n        this.rows = height;\r\n        this.tiles = new Array(width * height);\r\n        // build up tile representation\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const tile = new IsometricTile(x, y, this.graphicsOffset, this);\r\n                this.tiles[x + y * width] = tile;\r\n                this.addChild(tile);\r\n                // TODO row/columns helpers\r\n            }\r\n        }\r\n    }\r\n    update() {\r\n        if (this._collidersDirty) {\r\n            this.updateColliders();\r\n            this._collidersDirty = false;\r\n        }\r\n    }\r\n    flagCollidersDirty() {\r\n        this._collidersDirty = true;\r\n    }\r\n    _getOrSetColliderOriginalOffset(collider) {\r\n        if (!this._originalOffsets.has(collider)) {\r\n            const originalOffset = collider.offset;\r\n            this._originalOffsets.set(collider, originalOffset);\r\n            return originalOffset;\r\n        }\r\n        else {\r\n            return this._originalOffsets.get(collider);\r\n        }\r\n    }\r\n    updateColliders() {\r\n        this._composite.clearColliders();\r\n        const pos = this.get(TransformComponent).pos;\r\n        for (const tile of this.tiles) {\r\n            if (tile.solid) {\r\n                for (const collider of tile.getColliders()) {\r\n                    const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n                    collider.offset = this.tileToWorld(vec(tile.x, tile.y))\r\n                        .sub(pos)\r\n                        .add(originalOffset)\r\n                        .sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing\r\n                    collider.owner = this;\r\n                    this._composite.addCollider(collider);\r\n                }\r\n            }\r\n        }\r\n        this.collider.update();\r\n    }\r\n    /**\r\n     * Convert world space coordinates to the tile x, y coordinate\r\n     * @param worldCoordinate\r\n     */\r\n    worldToTile(worldCoordinate) {\r\n        worldCoordinate = worldCoordinate.sub(this.transform.globalPos);\r\n        const halfTileWidth = this.tileWidth / 2;\r\n        const halfTileHeight = this.tileHeight / 2;\r\n        // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n        return vec(~~((worldCoordinate.x / halfTileWidth + (worldCoordinate.y / halfTileHeight)) / 2), ~~((worldCoordinate.y / halfTileHeight - (worldCoordinate.x / halfTileWidth)) / 2));\r\n    }\r\n    /**\r\n     * Given a tile coordinate, return the top left corner in world space\r\n     * @param tileCoordinate\r\n     */\r\n    tileToWorld(tileCoordinate) {\r\n        const halfTileWidth = this.tileWidth / 2;\r\n        const halfTileHeight = this.tileHeight / 2;\r\n        // The x position shifts left with every y step\r\n        const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;\r\n        // The y position needs to go down with every x step\r\n        const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;\r\n        return vec(xPos, yPos).add(this.transform.pos);\r\n    }\r\n    /**\r\n     * Returns the [[IsometricTile]] by its x and y coordinates\r\n     */\r\n    getTile(x, y) {\r\n        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n            return null;\r\n        }\r\n        return this.tiles[x + y * this.columns];\r\n    }\r\n    /**\r\n     * Returns the [[IsometricTile]] by testing a point in world coordinates,\r\n     * returns `null` if no Tile was found.\r\n     */\r\n    getTileByPoint(point) {\r\n        const tileCoord = this.worldToTile(point);\r\n        const tile = this.getTile(tileCoord.x, tileCoord.y);\r\n        return tile;\r\n    }\r\n    _getMaxZIndex() {\r\n        let maxZ = Number.NEGATIVE_INFINITY;\r\n        for (const tile of this.tiles) {\r\n            const currentZ = tile.get(TransformComponent).z;\r\n            if (currentZ > maxZ) {\r\n                maxZ = currentZ;\r\n            }\r\n        }\r\n        return maxZ;\r\n    }\r\n    /**\r\n     * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on\r\n     * @param gfx\r\n     */\r\n    debug(gfx) {\r\n        gfx.save();\r\n        gfx.z = this._getMaxZIndex() + 0.5;\r\n        for (let y = 0; y < this.rows + 1; y++) {\r\n            const left = this.tileToWorld(vec(0, y));\r\n            const right = this.tileToWorld(vec(this.columns, y));\r\n            gfx.drawLine(left, right, Color.Red, 2);\r\n        }\r\n        for (let x = 0; x < this.columns + 1; x++) {\r\n            const top = this.tileToWorld(vec(x, 0));\r\n            const bottom = this.tileToWorld(vec(x, this.rows));\r\n            gfx.drawLine(top, bottom, Color.Red, 2);\r\n        }\r\n        for (const tile of this.tiles) {\r\n            gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);\r\n        }\r\n        gfx.restore();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./TileMap/index.ts\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Actions/Action/ActionSequence.ts\n\r\n/**\r\n * Action that can represent a sequence of actions, this can be useful in conjunction with\r\n * [[ParallelActions]] to run multiple sequences in parallel.\r\n */\r\nclass ActionSequence {\r\n    constructor(entity, actionBuilder) {\r\n        this._stopped = false;\r\n        this._sequenceBuilder = actionBuilder;\r\n        this._sequenceContext = new ActionContext(entity);\r\n        this._actionQueue = this._sequenceContext.getQueue();\r\n        this._sequenceBuilder(this._sequenceContext);\r\n    }\r\n    update(delta) {\r\n        this._actionQueue.update(delta);\r\n    }\r\n    isComplete() {\r\n        return this._stopped || this._actionQueue.isComplete();\r\n    }\r\n    stop() {\r\n        this._stopped = true;\r\n    }\r\n    reset() {\r\n        this._stopped = false;\r\n        this._actionQueue.reset();\r\n    }\r\n    clone(entity) {\r\n        return new ActionSequence(entity, this._sequenceBuilder);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Action/ParallelActions.ts\n/**\r\n * Action that can run multiple [[Action]]s or [[ActionSequence]]s at the same time\r\n */\r\nclass ParallelActions {\r\n    constructor(parallelActions) {\r\n        this._actions = parallelActions;\r\n    }\r\n    update(delta) {\r\n        for (let i = 0; i < this._actions.length; i++) {\r\n            this._actions[i].update(delta);\r\n        }\r\n    }\r\n    isComplete(entity) {\r\n        return this._actions.every(a => a.isComplete(entity));\r\n    }\r\n    reset() {\r\n        this._actions.forEach(a => a.reset());\r\n    }\r\n    stop() {\r\n        this._actions.forEach(a => a.stop());\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Actions/Index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Collision/Group/CollisionGroupManager.ts\n\r\n/**\r\n * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur\r\n */\r\nclass CollisionGroupManager {\r\n    /**\r\n     * Create a new named collision group up to a max of 32.\r\n     * @param name Name for the collision group\r\n     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one\r\n     */\r\n    static create(name, mask) {\r\n        if (this._CURRENT_GROUP > this._MAX_GROUPS) {\r\n            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);\r\n        }\r\n        if (this._GROUPS.get(name)) {\r\n            throw new Error(`Collision group ${name} already exists`);\r\n        }\r\n        const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);\r\n        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;\r\n        this._CURRENT_GROUP++;\r\n        this._GROUPS.set(name, group);\r\n        return group;\r\n    }\r\n    /**\r\n     * Get all collision groups currently tracked by excalibur\r\n     */\r\n    static get groups() {\r\n        return Array.from(this._GROUPS.values());\r\n    }\r\n    /**\r\n     * Get a collision group by it's name\r\n     * @param name\r\n     */\r\n    static groupByName(name) {\r\n        return this._GROUPS.get(name);\r\n    }\r\n    /**\r\n     * Resets the managers internal group management state\r\n     */\r\n    static reset() {\r\n        this._GROUPS = new Map();\r\n        this._CURRENT_BIT = this._STARTING_BIT;\r\n        this._CURRENT_GROUP = 1;\r\n    }\r\n}\r\n// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.\r\nCollisionGroupManager._STARTING_BIT = 0b1 | 0;\r\nCollisionGroupManager._MAX_GROUPS = 32;\r\nCollisionGroupManager._CURRENT_GROUP = 1;\r\nCollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;\r\nCollisionGroupManager._GROUPS = new Map();\r\n\n;// CONCATENATED MODULE: ./Collision/Index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Interfaces/LifecycleEvents.ts\n/**\r\n * Type guard checking for internal initialize method\r\n * @internal\r\n * @param a\r\n */\r\nfunction has_initialize(a) {\r\n    return !!a._initialize;\r\n}\r\n/**\r\n *\r\n */\r\nfunction hasOnInitialize(a) {\r\n    return !!a.onInitialize;\r\n}\r\n/**\r\n *\r\n */\r\nfunction has_preupdate(a) {\r\n    return !!a._preupdate;\r\n}\r\n/**\r\n *\r\n */\r\nfunction hasOnPreUpdate(a) {\r\n    return !!a.onPreUpdate;\r\n}\r\n/**\r\n *\r\n */\r\nfunction has_postupdate(a) {\r\n    return !!a.onPostUpdate;\r\n}\r\n/**\r\n *\r\n */\r\nfunction hasOnPostUpdate(a) {\r\n    return !!a.onPostUpdate;\r\n}\r\n/**\r\n *\r\n */\r\nfunction hasPreDraw(a) {\r\n    return !!a.onPreDraw;\r\n}\r\n/**\r\n *\r\n */\r\nfunction hasPostDraw(a) {\r\n    return !!a.onPostDraw;\r\n}\r\n\n;// CONCATENATED MODULE: ./Interfaces/Index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Resources/Sound/Index.ts\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Resources/Gif.ts\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n */\r\nclass Gif {\r\n    /**\r\n     * @param path       Path to the image resource\r\n     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]\r\n     * @param bustCache  Optionally load texture with cache busting\r\n     */\r\n    constructor(path, color = Color.Magenta, bustCache = true) {\r\n        this.path = path;\r\n        this.color = color;\r\n        this.bustCache = bustCache;\r\n        this._stream = null;\r\n        this._gif = null;\r\n        this._textures = [];\r\n        this._animation = null;\r\n        this._transparentColor = null;\r\n        this._resource = new Resource(path, 'arraybuffer', bustCache);\r\n        this._transparentColor = color;\r\n    }\r\n    /**\r\n     * Begins loading the texture and returns a promise to be resolved on completion\r\n     */\r\n    async load() {\r\n        const arraybuffer = await this._resource.load();\r\n        this._stream = new Stream(arraybuffer);\r\n        this._gif = new ParseGif(this._stream, this._transparentColor);\r\n        const images = this._gif.images.map(i => new ImageSource(i.src, false));\r\n        // Load all textures\r\n        await Promise.all(images.map(t => t.load()));\r\n        return this.data = this._textures = images;\r\n    }\r\n    isLoaded() {\r\n        return !!this.data;\r\n    }\r\n    /**\r\n     * Return a frame of the gif as a sprite by id\r\n     * @param id\r\n     */\r\n    toSprite(id = 0) {\r\n        const sprite = this._textures[id].toSprite();\r\n        return sprite;\r\n    }\r\n    /**\r\n     * Return the gif as a spritesheet\r\n     */\r\n    toSpriteSheet() {\r\n        const sprites = this._textures.map((image) => {\r\n            return image.toSprite();\r\n        });\r\n        return new SpriteSheet({ sprites });\r\n    }\r\n    /**\r\n     * Transform the GIF into an animation with duration per frame\r\n     */\r\n    toAnimation(durationPerFrameMs) {\r\n        const spriteSheet = this.toSpriteSheet();\r\n        const length = spriteSheet.sprites.length;\r\n        this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);\r\n        return this._animation;\r\n    }\r\n    get readCheckBytes() {\r\n        return this._gif.checkBytes;\r\n    }\r\n}\r\nconst bitsToNum = (ba) => {\r\n    return ba.reduce(function (s, n) {\r\n        return s * 2 + n;\r\n    }, 0);\r\n};\r\nconst byteToBitArr = (bite) => {\r\n    const a = [];\r\n    for (let i = 7; i >= 0; i--) {\r\n        a.push(!!(bite & (1 << i)));\r\n    }\r\n    return a;\r\n};\r\nclass Stream {\r\n    constructor(dataArray) {\r\n        this.data = null;\r\n        this.len = 0;\r\n        this.position = 0;\r\n        this.readByte = () => {\r\n            if (this.position >= this.data.byteLength) {\r\n                throw new Error('Attempted to read past end of stream.');\r\n            }\r\n            return this.data[this.position++];\r\n        };\r\n        this.readBytes = (n) => {\r\n            const bytes = [];\r\n            for (let i = 0; i < n; i++) {\r\n                bytes.push(this.readByte());\r\n            }\r\n            return bytes;\r\n        };\r\n        this.read = (n) => {\r\n            let s = '';\r\n            for (let i = 0; i < n; i++) {\r\n                s += String.fromCharCode(this.readByte());\r\n            }\r\n            return s;\r\n        };\r\n        this.readUnsigned = () => {\r\n            // Little-endian.\r\n            const a = this.readBytes(2);\r\n            return (a[1] << 8) + a[0];\r\n        };\r\n        this.data = new Uint8Array(dataArray);\r\n        this.len = this.data.byteLength;\r\n        if (this.len === 0) {\r\n            throw new Error('No data loaded from file');\r\n        }\r\n    }\r\n}\r\nconst lzwDecode = function (minCodeSize, data) {\r\n    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\r\n    let pos = 0; // Maybe this streaming thing should be merged with the Stream?\r\n    const readCode = function (size) {\r\n        let code = 0;\r\n        for (let i = 0; i < size; i++) {\r\n            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\r\n                code |= 1 << i;\r\n            }\r\n            pos++;\r\n        }\r\n        return code;\r\n    };\r\n    const output = [];\r\n    const clearCode = 1 << minCodeSize;\r\n    const eoiCode = clearCode + 1;\r\n    let codeSize = minCodeSize + 1;\r\n    let dict = [];\r\n    const clear = function () {\r\n        dict = [];\r\n        codeSize = minCodeSize + 1;\r\n        for (let i = 0; i < clearCode; i++) {\r\n            dict[i] = [i];\r\n        }\r\n        dict[clearCode] = [];\r\n        dict[eoiCode] = null;\r\n    };\r\n    let code;\r\n    let last;\r\n    while (true) {\r\n        last = code;\r\n        code = readCode(codeSize);\r\n        if (code === clearCode) {\r\n            clear();\r\n            continue;\r\n        }\r\n        if (code === eoiCode) {\r\n            break;\r\n        }\r\n        if (code < dict.length) {\r\n            if (last !== clearCode) {\r\n                dict.push(dict[last].concat(dict[code][0]));\r\n            }\r\n        }\r\n        else {\r\n            if (code !== dict.length) {\r\n                throw new Error('Invalid LZW code.');\r\n            }\r\n            dict.push(dict[last].concat(dict[last][0]));\r\n        }\r\n        output.push.apply(output, dict[code]);\r\n        if (dict.length === 1 << codeSize && codeSize < 12) {\r\n            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\r\n            codeSize++;\r\n        }\r\n    }\r\n    // I don't know if this is technically an error, but some GIFs do it.\r\n    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\r\n    return output;\r\n};\r\n// The actual parsing; returns an object with properties.\r\nclass ParseGif {\r\n    constructor(stream, color = Color.Magenta) {\r\n        this._st = null;\r\n        this._handler = {};\r\n        this._transparentColor = null;\r\n        this.frames = [];\r\n        this.images = [];\r\n        this.globalColorTable = [];\r\n        this.checkBytes = [];\r\n        // LZW (GIF-specific)\r\n        this.parseColorTable = (entries) => {\r\n            // Each entry is 3 bytes, for RGB.\r\n            const ct = [];\r\n            for (let i = 0; i < entries; i++) {\r\n                const rgb = this._st.readBytes(3);\r\n                const rgba = '#' +\r\n                    rgb\r\n                        .map((x) => {\r\n                        const hex = x.toString(16);\r\n                        return hex.length === 1 ? '0' + hex : hex;\r\n                    })\r\n                        .join('');\r\n                ct.push(rgba);\r\n            }\r\n            return ct;\r\n        };\r\n        this.readSubBlocks = () => {\r\n            let size, data;\r\n            data = '';\r\n            do {\r\n                size = this._st.readByte();\r\n                data += this._st.read(size);\r\n            } while (size !== 0);\r\n            return data;\r\n        };\r\n        this.parseHeader = () => {\r\n            const hdr = {\r\n                sig: null,\r\n                ver: null,\r\n                width: null,\r\n                height: null,\r\n                colorRes: null,\r\n                globalColorTableSize: null,\r\n                gctFlag: null,\r\n                sorted: null,\r\n                globalColorTable: [],\r\n                bgColor: null,\r\n                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n            };\r\n            hdr.sig = this._st.read(3);\r\n            hdr.ver = this._st.read(3);\r\n            if (hdr.sig !== 'GIF') {\r\n                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\r\n            }\r\n            hdr.width = this._st.readUnsigned();\r\n            hdr.height = this._st.readUnsigned();\r\n            const bits = byteToBitArr(this._st.readByte());\r\n            hdr.gctFlag = bits.shift();\r\n            hdr.colorRes = bitsToNum(bits.splice(0, 3));\r\n            hdr.sorted = bits.shift();\r\n            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));\r\n            hdr.bgColor = this._st.readByte();\r\n            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n            if (hdr.gctFlag) {\r\n                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));\r\n                this.globalColorTable = hdr.globalColorTable;\r\n            }\r\n            if (this._handler.hdr && this._handler.hdr(hdr)) {\r\n                this.checkBytes.push(this._handler.hdr);\r\n            }\r\n        };\r\n        this.parseExt = (block) => {\r\n            const parseGCExt = (block) => {\r\n                this.checkBytes.push(this._st.readByte()); // Always 4\r\n                const bits = byteToBitArr(this._st.readByte());\r\n                block.reserved = bits.splice(0, 3); // Reserved; should be 000.\r\n                block.disposalMethod = bitsToNum(bits.splice(0, 3));\r\n                block.userInput = bits.shift();\r\n                block.transparencyGiven = bits.shift();\r\n                block.delayTime = this._st.readUnsigned();\r\n                block.transparencyIndex = this._st.readByte();\r\n                block.terminator = this._st.readByte();\r\n                if (this._handler.gce && this._handler.gce(block)) {\r\n                    this.checkBytes.push(this._handler.gce);\r\n                }\r\n            };\r\n            const parseComExt = (block) => {\r\n                block.comment = this.readSubBlocks();\r\n                if (this._handler.com && this._handler.com(block)) {\r\n                    this.checkBytes.push(this._handler.com);\r\n                }\r\n            };\r\n            const parsePTExt = (block) => {\r\n                this.checkBytes.push(this._st.readByte()); // Always 12\r\n                block.ptHeader = this._st.readBytes(12);\r\n                block.ptData = this.readSubBlocks();\r\n                if (this._handler.pte && this._handler.pte(block)) {\r\n                    this.checkBytes.push(this._handler.pte);\r\n                }\r\n            };\r\n            const parseAppExt = (block) => {\r\n                const parseNetscapeExt = (block) => {\r\n                    this.checkBytes.push(this._st.readByte()); // Always 3\r\n                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?\r\n                    block.iterations = this._st.readUnsigned();\r\n                    block.terminator = this._st.readByte();\r\n                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {\r\n                        this.checkBytes.push(this._handler.app);\r\n                    }\r\n                };\r\n                const parseUnknownAppExt = (block) => {\r\n                    block.appData = this.readSubBlocks();\r\n                    // FIXME: This won't work if a handler wants to match on any identifier.\r\n                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {\r\n                        this.checkBytes.push(this._handler.app[block.identifier]);\r\n                    }\r\n                };\r\n                this.checkBytes.push(this._st.readByte()); // Always 11\r\n                block.identifier = this._st.read(8);\r\n                block.authCode = this._st.read(3);\r\n                switch (block.identifier) {\r\n                    case 'NETSCAPE':\r\n                        parseNetscapeExt(block);\r\n                        break;\r\n                    default:\r\n                        parseUnknownAppExt(block);\r\n                        break;\r\n                }\r\n            };\r\n            const parseUnknownExt = (block) => {\r\n                block.data = this.readSubBlocks();\r\n                if (this._handler.unknown && this._handler.unknown(block)) {\r\n                    this.checkBytes.push(this._handler.unknown);\r\n                }\r\n            };\r\n            block.label = this._st.readByte();\r\n            switch (block.label) {\r\n                case 0xf9:\r\n                    block.extType = 'gce';\r\n                    parseGCExt(block);\r\n                    break;\r\n                case 0xfe:\r\n                    block.extType = 'com';\r\n                    parseComExt(block);\r\n                    break;\r\n                case 0x01:\r\n                    block.extType = 'pte';\r\n                    parsePTExt(block);\r\n                    break;\r\n                case 0xff:\r\n                    block.extType = 'app';\r\n                    parseAppExt(block);\r\n                    break;\r\n                default:\r\n                    block.extType = 'unknown';\r\n                    parseUnknownExt(block);\r\n                    break;\r\n            }\r\n        };\r\n        this.parseImg = (img) => {\r\n            const deinterlace = (pixels, width) => {\r\n                // Of course this defeats the purpose of interlacing. And it's *probably*\r\n                // the least efficient way it's ever been implemented. But nevertheless...\r\n                const newPixels = new Array(pixels.length);\r\n                const rows = pixels.length / width;\r\n                const cpRow = (toRow, fromRow) => {\r\n                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\r\n                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\r\n                };\r\n                const offsets = [0, 4, 2, 1];\r\n                const steps = [8, 8, 4, 2];\r\n                let fromRow = 0;\r\n                for (let pass = 0; pass < 4; pass++) {\r\n                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\r\n                        cpRow(toRow, fromRow);\r\n                        fromRow++;\r\n                    }\r\n                }\r\n                return newPixels;\r\n            };\r\n            img.leftPos = this._st.readUnsigned();\r\n            img.topPos = this._st.readUnsigned();\r\n            img.width = this._st.readUnsigned();\r\n            img.height = this._st.readUnsigned();\r\n            const bits = byteToBitArr(this._st.readByte());\r\n            img.lctFlag = bits.shift();\r\n            img.interlaced = bits.shift();\r\n            img.sorted = bits.shift();\r\n            img.reserved = bits.splice(0, 2);\r\n            img.lctSize = bitsToNum(bits.splice(0, 3));\r\n            if (img.lctFlag) {\r\n                img.lct = this.parseColorTable(1 << (img.lctSize + 1));\r\n            }\r\n            img.lzwMinCodeSize = this._st.readByte();\r\n            const lzwData = this.readSubBlocks();\r\n            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\r\n            if (img.interlaced) {\r\n                // Move\r\n                img.pixels = deinterlace(img.pixels, img.width);\r\n            }\r\n            this.frames.push(img);\r\n            this.arrayToImage(img);\r\n            if (this._handler.img && this._handler.img(img)) {\r\n                this.checkBytes.push(this._handler);\r\n            }\r\n        };\r\n        this.parseBlock = () => {\r\n            const block = {\r\n                sentinel: this._st.readByte(),\r\n                type: ''\r\n            };\r\n            const blockChar = String.fromCharCode(block.sentinel);\r\n            switch (blockChar) {\r\n                case '!':\r\n                    block.type = 'ext';\r\n                    this.parseExt(block);\r\n                    break;\r\n                case ',':\r\n                    block.type = 'img';\r\n                    this.parseImg(block);\r\n                    break;\r\n                case ';':\r\n                    block.type = 'eof';\r\n                    if (this._handler.eof && this._handler.eof(block)) {\r\n                        this.checkBytes.push(this._handler.eof);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));\r\n            }\r\n            if (block.type !== 'eof') {\r\n                this.parseBlock();\r\n            }\r\n        };\r\n        this.arrayToImage = (frame) => {\r\n            let count = 0;\r\n            const c = document.createElement('canvas');\r\n            c.id = count.toString();\r\n            c.width = frame.width;\r\n            c.height = frame.height;\r\n            count++;\r\n            const context = c.getContext('2d');\r\n            const pixSize = 1;\r\n            let y = 0;\r\n            let x = 0;\r\n            for (let i = 0; i < frame.pixels.length; i++) {\r\n                if (x % frame.width === 0) {\r\n                    y++;\r\n                    x = 0;\r\n                }\r\n                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {\r\n                    context.fillStyle = `rgba(0, 0, 0, 0)`;\r\n                }\r\n                else {\r\n                    context.fillStyle = this.globalColorTable[frame.pixels[i]];\r\n                }\r\n                context.fillRect(x, y, pixSize, pixSize);\r\n                x++;\r\n            }\r\n            const img = new Image();\r\n            img.src = c.toDataURL();\r\n            this.images.push(img);\r\n        };\r\n        this._st = stream;\r\n        this._handler = {};\r\n        this._transparentColor = color;\r\n        this.parseHeader();\r\n        this.parseBlock();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Resources/Index.ts\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./EntityComponentSystem/index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Graphics/Line.ts\n\r\n\r\n\r\nclass Line extends Graphic {\r\n    constructor(options) {\r\n        super();\r\n        this.color = Color.Black;\r\n        this.thickness = 1;\r\n        const { start, end, color, thickness } = options;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.color = color !== null && color !== void 0 ? color : this.color;\r\n        this.thickness = thickness !== null && thickness !== void 0 ? thickness : this.thickness;\r\n        const { width, height } = BoundingBox.fromPoints([start, end]);\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    _drawImage(ctx, _x, _y) {\r\n        ctx.drawLine(this.start, this.end, this.color, this.thickness);\r\n    }\r\n    clone() {\r\n        return new Line({\r\n            start: this.start,\r\n            end: this.end,\r\n            color: this.color,\r\n            thickness: this.thickness\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/Polygon.ts\n\r\n\r\n\r\n/**\r\n * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Polygons default to [[ImageFiltering.Blended]]\r\n */\r\nclass Polygon extends Raster {\r\n    constructor(options) {\r\n        super(options);\r\n        this.points = options.points;\r\n        this.filtering = ImageFiltering.Blended;\r\n        this.rasterize();\r\n    }\r\n    get points() {\r\n        return this._points;\r\n    }\r\n    set points(points) {\r\n        this._points = points;\r\n        const min = this.minPoint;\r\n        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;\r\n        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;\r\n        this.flagDirty();\r\n    }\r\n    get minPoint() {\r\n        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);\r\n        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);\r\n        return vec(minX, minY);\r\n    }\r\n    clone() {\r\n        return new Polygon({\r\n            points: this.points.map((p) => p.clone()),\r\n            ...this.cloneGraphicOptions(),\r\n            ...this.cloneRasterOptions()\r\n        });\r\n    }\r\n    execute(ctx) {\r\n        if (this.points && this.points.length) {\r\n            ctx.beginPath();\r\n            // Iterate through the supplied points and construct a 'polygon'\r\n            const min = this.minPoint.negate();\r\n            const firstPoint = this.points[0].add(min);\r\n            ctx.moveTo(firstPoint.x, firstPoint.y);\r\n            this.points.forEach((point) => {\r\n                ctx.lineTo(point.x + min.x, point.y + min.y);\r\n            });\r\n            ctx.lineTo(firstPoint.x, firstPoint.y);\r\n            ctx.closePath();\r\n            if (this.color) {\r\n                ctx.fill();\r\n            }\r\n            if (this.strokeColor) {\r\n                ctx.stroke();\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./Graphics/index.ts\n// Graphics\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Graphics ECS\r\n\r\n\r\n\r\n\r\n\r\n// Raster graphics\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Post Processor\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Rendering\r\n\r\n\r\n\r\n\r\n\r\n// Util\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Input/Index.ts\n/**\r\n * @module\r\n * Provides support for mice, keyboards, and controllers.\r\n */\r\n/**\r\n * @typedoc\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Util/Index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./Util/Semaphore.ts\n\r\nclass AsyncWaitQueue {\r\n    constructor() {\r\n        // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e\r\n        this._queue = [];\r\n    }\r\n    get length() {\r\n        return this._queue.length;\r\n    }\r\n    enqueue() {\r\n        const future = new Future();\r\n        this._queue.push(future);\r\n        return future.promise;\r\n    }\r\n    dequeue(value) {\r\n        const future = this._queue.shift();\r\n        future.resolve(value);\r\n    }\r\n}\r\n/**\r\n * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`\r\n *\r\n * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work\r\n * around browser limitations like max Image.decode() calls in chromium being 256.\r\n */\r\nclass Semaphore {\r\n    constructor(_count) {\r\n        this._count = _count;\r\n        this._waitQueue = new AsyncWaitQueue();\r\n    }\r\n    get count() {\r\n        return this._count;\r\n    }\r\n    get waiting() {\r\n        return this._waitQueue.length;\r\n    }\r\n    async enter() {\r\n        if (this._count !== 0) {\r\n            this._count--;\r\n            return Promise.resolve();\r\n        }\r\n        return this._waitQueue.enqueue();\r\n    }\r\n    exit(count = 1) {\r\n        if (count === 0) {\r\n            return;\r\n        }\r\n        while (count !== 0 && this._waitQueue.length !== 0) {\r\n            this._waitQueue.dequeue(null);\r\n            count--;\r\n        }\r\n        this._count += count;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./index.ts\n/**\r\n * The current Excalibur version string\r\n * @description `process.env.__EX_VERSION` gets replaced by Webpack on build\r\n */\r\nconst EX_VERSION = \"0.27.0\";\r\n\r\npolyfill();\r\n// This file is used as the bundle entry point and exports everything\r\n// that will be exposed as the `ex` global variable.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ex.Events namespace\r\n\r\n\r\n// ex.Input namespace\r\n\r\n\r\n\r\n\r\n// ex.Util namespaces\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ex.Deprecated\r\n// import * as deprecated from './Deprecated';\r\n// export { deprecated as Deprecated };\r\n// export * from './Deprecated';\r\n\n})();\n\nvar __webpack_exports__ActionContext = __webpack_exports__.fWn;\nvar __webpack_exports__ActionQueue = __webpack_exports__.Ia8;\nvar __webpack_exports__ActionSequence = __webpack_exports__.rqv;\nvar __webpack_exports__ActionsComponent = __webpack_exports__.hLI;\nvar __webpack_exports__ActionsSystem = __webpack_exports__.yyv;\nvar __webpack_exports__ActivateEvent = __webpack_exports__.tX5;\nvar __webpack_exports__Actor = __webpack_exports__.vtX;\nvar __webpack_exports__AddedComponent = __webpack_exports__.r7K;\nvar __webpack_exports__AddedEntity = __webpack_exports__.lCh;\nvar __webpack_exports__AffineMatrix = __webpack_exports__.cE4;\nvar __webpack_exports__Animation = __webpack_exports__.fwF;\nvar __webpack_exports__AnimationDirection = __webpack_exports__.sce;\nvar __webpack_exports__AnimationStrategy = __webpack_exports__._c7;\nvar __webpack_exports__ArcadeSolver = __webpack_exports__.KUs;\nvar __webpack_exports__AudioContextFactory = __webpack_exports__.Ajp;\nvar __webpack_exports__Axis = __webpack_exports__.RDh;\nvar __webpack_exports__BaseAlign = __webpack_exports__._H9;\nvar __webpack_exports__Blink = __webpack_exports__.mxs;\nvar __webpack_exports__BodyComponent = __webpack_exports__.OmD;\nvar __webpack_exports__BoundingBox = __webpack_exports__.kBf;\nvar __webpack_exports__BroadphaseStrategy = __webpack_exports__.C4F;\nvar __webpack_exports__BrowserComponent = __webpack_exports__.NQt;\nvar __webpack_exports__BrowserEvents = __webpack_exports__.JjN;\nvar __webpack_exports__Camera = __webpack_exports__.V1s;\nvar __webpack_exports__Canvas = __webpack_exports__.Xz7;\nvar __webpack_exports__Circle = __webpack_exports__.Cdc;\nvar __webpack_exports__CircleCollider = __webpack_exports__.FKn;\nvar __webpack_exports__Class = __webpack_exports__.wTW;\nvar __webpack_exports__Clock = __webpack_exports__.SUY;\nvar __webpack_exports__ClosestLine = __webpack_exports__.ab2;\nvar __webpack_exports__ClosestLineJumpTable = __webpack_exports__.GfZ;\nvar __webpack_exports__Collider = __webpack_exports__.YMS;\nvar __webpack_exports__ColliderComponent = __webpack_exports__.oyv;\nvar __webpack_exports__CollisionContact = __webpack_exports__.aUb;\nvar __webpack_exports__CollisionEndEvent = __webpack_exports__.SdD;\nvar __webpack_exports__CollisionGroup = __webpack_exports__.JUv;\nvar __webpack_exports__CollisionGroupManager = __webpack_exports__.jEj;\nvar __webpack_exports__CollisionJumpTable = __webpack_exports__.TFq;\nvar __webpack_exports__CollisionPostSolveEvent = __webpack_exports__.HDU;\nvar __webpack_exports__CollisionPreSolveEvent = __webpack_exports__.R_y;\nvar __webpack_exports__CollisionResolutionStrategy = __webpack_exports__.ydN;\nvar __webpack_exports__CollisionStartEvent = __webpack_exports__.t50;\nvar __webpack_exports__CollisionSystem = __webpack_exports__.s$$;\nvar __webpack_exports__CollisionType = __webpack_exports__.v2G;\nvar __webpack_exports__Color = __webpack_exports__.Ilk;\nvar __webpack_exports__ColorBlindFlags = __webpack_exports__.s9i;\nvar __webpack_exports__ColorBlindnessMode = __webpack_exports__.dxL;\nvar __webpack_exports__ColorBlindnessPostProcessor = __webpack_exports__.LLX;\nvar __webpack_exports__Component = __webpack_exports__.wA2;\nvar __webpack_exports__CompositeCollider = __webpack_exports__.R_p;\nvar __webpack_exports__Configurable = __webpack_exports__.IQ$;\nvar __webpack_exports__ConsoleAppender = __webpack_exports__.I5F;\nvar __webpack_exports__ContactConstraintPoint = __webpack_exports__.X8$;\nvar __webpack_exports__ContactEndEvent = __webpack_exports__.FR6;\nvar __webpack_exports__ContactStartEvent = __webpack_exports__.U8o;\nvar __webpack_exports__CoordPlane = __webpack_exports__.kbG;\nvar __webpack_exports__DeactivateEvent = __webpack_exports__.iS_;\nvar __webpack_exports__Debug = __webpack_exports__.cGG;\nvar __webpack_exports__DebugGraphicsComponent = __webpack_exports__.RPN;\nvar __webpack_exports__DebugSystem = __webpack_exports__.skb;\nvar __webpack_exports__DebugText = __webpack_exports__.SLU;\nvar __webpack_exports__DegreeOfFreedom = __webpack_exports__.RdJ;\nvar __webpack_exports__Delay = __webpack_exports__.cNu;\nvar __webpack_exports__Detector = __webpack_exports__.gU7;\nvar __webpack_exports__Die = __webpack_exports__.LSk;\nvar __webpack_exports__Direction = __webpack_exports__.Nmp;\nvar __webpack_exports__DisplayMode = __webpack_exports__.d1Y;\nvar __webpack_exports__DynamicTree = __webpack_exports__.xrL;\nvar __webpack_exports__DynamicTreeCollisionProcessor = __webpack_exports__.sRW;\nvar __webpack_exports__EX_VERSION = __webpack_exports__.cmV;\nvar __webpack_exports__EaseBy = __webpack_exports__.qWz;\nvar __webpack_exports__EaseTo = __webpack_exports__.N0Q;\nvar __webpack_exports__EasingFunctions = __webpack_exports__.q8b;\nvar __webpack_exports__EdgeCollider = __webpack_exports__.ynB;\nvar __webpack_exports__ElasticToActorStrategy = __webpack_exports__.jT9;\nvar __webpack_exports__EmitterType = __webpack_exports__.wAz;\nvar __webpack_exports__Engine = __webpack_exports__.D4V;\nvar __webpack_exports__EnterTriggerEvent = __webpack_exports__.N6H;\nvar __webpack_exports__EnterViewPortEvent = __webpack_exports__.W1A;\nvar __webpack_exports__Entity = __webpack_exports__.JHW;\nvar __webpack_exports__EntityManager = __webpack_exports__.v2K;\nvar __webpack_exports__EventDispatcher = __webpack_exports__.pBf;\nvar __webpack_exports__EventTypes = __webpack_exports__.GMl;\nvar __webpack_exports__Events = __webpack_exports__.zW2;\nvar __webpack_exports__ExResponse = __webpack_exports__.B0K;\nvar __webpack_exports__ExcaliburGraphicsContext2DCanvas = __webpack_exports__.Nv7;\nvar __webpack_exports__ExcaliburGraphicsContextWebGL = __webpack_exports__.C_p;\nvar __webpack_exports__ExcaliburWebGLContextAccessor = __webpack_exports__.iqw;\nvar __webpack_exports__ExitTriggerEvent = __webpack_exports__.MUA;\nvar __webpack_exports__ExitViewPortEvent = __webpack_exports__.xqU;\nvar __webpack_exports__Fade = __webpack_exports__.pTp;\nvar __webpack_exports__Flags = __webpack_exports__.vUK;\nvar __webpack_exports__Follow = __webpack_exports__.j9l;\nvar __webpack_exports__Font = __webpack_exports__.Zxw;\nvar __webpack_exports__FontStyle = __webpack_exports__.Hdx;\nvar __webpack_exports__FontUnit = __webpack_exports__.Z$d;\nvar __webpack_exports__FpsSampler = __webpack_exports__.iqV;\nvar __webpack_exports__FrameStats = __webpack_exports__.o$7;\nvar __webpack_exports__Future = __webpack_exports__.olM;\nvar __webpack_exports__GameEvent = __webpack_exports__.Zm$;\nvar __webpack_exports__GameStartEvent = __webpack_exports__.$QH;\nvar __webpack_exports__GameStopEvent = __webpack_exports__.i78;\nvar __webpack_exports__GamepadAxisEvent = __webpack_exports__.h6u;\nvar __webpack_exports__GamepadButtonEvent = __webpack_exports__.hts;\nvar __webpack_exports__GamepadConnectEvent = __webpack_exports__.j88;\nvar __webpack_exports__GamepadDisconnectEvent = __webpack_exports__.VME;\nvar __webpack_exports__Gif = __webpack_exports__.nt;\nvar __webpack_exports__GlobalCoordinates = __webpack_exports__.Ukr;\nvar __webpack_exports__Graphic = __webpack_exports__.zsu;\nvar __webpack_exports__GraphicsComponent = __webpack_exports__.oA6;\nvar __webpack_exports__GraphicsGroup = __webpack_exports__.TVh;\nvar __webpack_exports__GraphicsLayer = __webpack_exports__.TwZ;\nvar __webpack_exports__GraphicsLayers = __webpack_exports__.GTT;\nvar __webpack_exports__GraphicsSystem = __webpack_exports__.xxj;\nvar __webpack_exports__HiddenEvent = __webpack_exports__.XdK;\nvar __webpack_exports__ImageFiltering = __webpack_exports__.Jmb;\nvar __webpack_exports__ImageSource = __webpack_exports__.cXo;\nvar __webpack_exports__InitializeEvent = __webpack_exports__.Dm5;\nvar __webpack_exports__Input = __webpack_exports__.IIB;\nvar __webpack_exports__Integrator = __webpack_exports__.zI0;\nvar __webpack_exports__IsometricEntityComponent = __webpack_exports__.LYD;\nvar __webpack_exports__IsometricEntitySystem = __webpack_exports__.cEG;\nvar __webpack_exports__IsometricMap = __webpack_exports__.SEl;\nvar __webpack_exports__IsometricTile = __webpack_exports__.t9V;\nvar __webpack_exports__KillEvent = __webpack_exports__.SKZ;\nvar __webpack_exports__Label = __webpack_exports__.__J;\nvar __webpack_exports__LimitCameraBoundsStrategy = __webpack_exports__.RI$;\nvar __webpack_exports__Line = __webpack_exports__.x12;\nvar __webpack_exports__LineSegment = __webpack_exports__.ccz;\nvar __webpack_exports__Loader = __webpack_exports__.aNw;\nvar __webpack_exports__LockCameraToActorAxisStrategy = __webpack_exports__.xwn;\nvar __webpack_exports__LockCameraToActorStrategy = __webpack_exports__.dNK;\nvar __webpack_exports__LogLevel = __webpack_exports__.ini;\nvar __webpack_exports__Logger = __webpack_exports__.YdH;\nvar __webpack_exports__Matrix = __webpack_exports__.y3G;\nvar __webpack_exports__MatrixLocations = __webpack_exports__.l57;\nvar __webpack_exports__MediaEvent = __webpack_exports__.xn0;\nvar __webpack_exports__Meet = __webpack_exports__.t2V;\nvar __webpack_exports__MotionComponent = __webpack_exports__.uxB;\nvar __webpack_exports__MotionSystem = __webpack_exports__.cpd;\nvar __webpack_exports__MoveBy = __webpack_exports__.fiy;\nvar __webpack_exports__MoveTo = __webpack_exports__.$XZ;\nvar __webpack_exports__NativeSoundEvent = __webpack_exports__.uqK;\nvar __webpack_exports__NativeSoundProcessedEvent = __webpack_exports__.STE;\nvar __webpack_exports__Observable = __webpack_exports__.y$z;\nvar __webpack_exports__OffscreenSystem = __webpack_exports__.mAD;\nvar __webpack_exports__Pair = __webpack_exports__.sOq;\nvar __webpack_exports__ParallaxComponent = __webpack_exports__.hUw;\nvar __webpack_exports__ParallelActions = __webpack_exports__._0G;\nvar __webpack_exports__ParseGif = __webpack_exports__.Sqs;\nvar __webpack_exports__Particle = __webpack_exports__.hpZ;\nvar __webpack_exports__ParticleEmitter = __webpack_exports__.Vol;\nvar __webpack_exports__Physics = __webpack_exports__.wIZ;\nvar __webpack_exports__PhysicsStats = __webpack_exports__.cBi;\nvar __webpack_exports__PointerComponent = __webpack_exports__.RFv;\nvar __webpack_exports__PointerSystem = __webpack_exports__.kfC;\nvar __webpack_exports__Polygon = __webpack_exports__.mgq;\nvar __webpack_exports__PolygonCollider = __webpack_exports__.YVA;\nvar __webpack_exports__Pool = __webpack_exports__.Kgp;\nvar __webpack_exports__PostCollisionEvent = __webpack_exports__.HH$;\nvar __webpack_exports__PostDebugDrawEvent = __webpack_exports__.M_d;\nvar __webpack_exports__PostDrawEvent = __webpack_exports__.rgh;\nvar __webpack_exports__PostFrameEvent = __webpack_exports__.Ra6;\nvar __webpack_exports__PostKillEvent = __webpack_exports__.KhR;\nvar __webpack_exports__PostUpdateEvent = __webpack_exports__.BS5;\nvar __webpack_exports__PreCollisionEvent = __webpack_exports__.xhz;\nvar __webpack_exports__PreDebugDrawEvent = __webpack_exports__.xOq;\nvar __webpack_exports__PreDrawEvent = __webpack_exports__.a9j;\nvar __webpack_exports__PreFrameEvent = __webpack_exports__.bHk;\nvar __webpack_exports__PreKillEvent = __webpack_exports__.CgK;\nvar __webpack_exports__PreUpdateEvent = __webpack_exports__.cuY;\nvar __webpack_exports__Projection = __webpack_exports__.kvE;\nvar __webpack_exports__QuadIndexBuffer = __webpack_exports__.SBu;\nvar __webpack_exports__Query = __webpack_exports__.AE_;\nvar __webpack_exports__QueryManager = __webpack_exports__.ctO;\nvar __webpack_exports__RadiusAroundActorStrategy = __webpack_exports__.OLH;\nvar __webpack_exports__Random = __webpack_exports__.kky;\nvar __webpack_exports__Raster = __webpack_exports__.nSF;\nvar __webpack_exports__Ray = __webpack_exports__.zHn;\nvar __webpack_exports__RealisticSolver = __webpack_exports__.zwx;\nvar __webpack_exports__Rectangle = __webpack_exports__.AeJ;\nvar __webpack_exports__RemovedComponent = __webpack_exports__.hLz;\nvar __webpack_exports__RemovedEntity = __webpack_exports__.D9g;\nvar __webpack_exports__Repeat = __webpack_exports__.wA;\nvar __webpack_exports__RepeatForever = __webpack_exports__.jhr;\nvar __webpack_exports__Resolution = __webpack_exports__.GVs;\nvar __webpack_exports__Resource = __webpack_exports__._zO;\nvar __webpack_exports__RotateBy = __webpack_exports__.w6$;\nvar __webpack_exports__RotateTo = __webpack_exports__.mhV;\nvar __webpack_exports__RotationType = __webpack_exports__.MOD;\nvar __webpack_exports__ScaleBy = __webpack_exports__.kwd;\nvar __webpack_exports__ScaleTo = __webpack_exports__.Lmr;\nvar __webpack_exports__Scene = __webpack_exports__.xsS;\nvar __webpack_exports__Screen = __webpack_exports__.lLr;\nvar __webpack_exports__ScreenAppender = __webpack_exports__.Z$r;\nvar __webpack_exports__ScreenElement = __webpack_exports__.IXb;\nvar __webpack_exports__ScreenShader = __webpack_exports__.SGH;\nvar __webpack_exports__ScrollPreventionMode = __webpack_exports__.SMj;\nvar __webpack_exports__Semaphore = __webpack_exports__.L34;\nvar __webpack_exports__Shader = __webpack_exports__.exe;\nvar __webpack_exports__Shape = __webpack_exports__.bnF;\nvar __webpack_exports__Side = __webpack_exports__.MFA;\nvar __webpack_exports__Sound = __webpack_exports__.$uU;\nvar __webpack_exports__Sprite = __webpack_exports__.jyi;\nvar __webpack_exports__SpriteFont = __webpack_exports__.E03;\nvar __webpack_exports__SpriteSheet = __webpack_exports__.V6q;\nvar __webpack_exports__StandardClock = __webpack_exports__.rg2;\nvar __webpack_exports__StateMachine = __webpack_exports__.DVW;\nvar __webpack_exports__StrategyContainer = __webpack_exports__.nVo;\nvar __webpack_exports__Stream = __webpack_exports__.F6N;\nvar __webpack_exports__System = __webpack_exports__.xP7;\nvar __webpack_exports__SystemManager = __webpack_exports__.Odq;\nvar __webpack_exports__SystemType = __webpack_exports__.Zif;\nvar __webpack_exports__TagComponent = __webpack_exports__.ZGJ;\nvar __webpack_exports__TestClock = __webpack_exports__.MJk;\nvar __webpack_exports__Text = __webpack_exports__.xvT;\nvar __webpack_exports__TextAlign = __webpack_exports__.PHM;\nvar __webpack_exports__TextureLoader = __webpack_exports__.dpR;\nvar __webpack_exports__Tile = __webpack_exports__.n9L;\nvar __webpack_exports__TileMap = __webpack_exports__.KwO;\nvar __webpack_exports__Timer = __webpack_exports__.B7y;\nvar __webpack_exports__Toaster = __webpack_exports__.x7r;\nvar __webpack_exports__Transform = __webpack_exports__.wx7;\nvar __webpack_exports__TransformComponent = __webpack_exports__.Uvn;\nvar __webpack_exports__TreeNode = __webpack_exports__.OFT;\nvar __webpack_exports__Trigger = __webpack_exports__.xzN;\nvar __webpack_exports__TwoPI = __webpack_exports__.M5Z;\nvar __webpack_exports__Util = __webpack_exports__.ZrN;\nvar __webpack_exports__Vector = __webpack_exports__.OWs;\nvar __webpack_exports__VectorView = __webpack_exports__.dF9;\nvar __webpack_exports__VertexBuffer = __webpack_exports__.oZy;\nvar __webpack_exports__VertexLayout = __webpack_exports__.rD2;\nvar __webpack_exports__VisibleEvent = __webpack_exports__.VHo;\nvar __webpack_exports__WebAudio = __webpack_exports__.ohE;\nvar __webpack_exports__WebAudioInstance = __webpack_exports__.R$E;\nvar __webpack_exports__World = __webpack_exports__.q3I;\nvar __webpack_exports__canonicalizeAngle = __webpack_exports__.Pab;\nvar __webpack_exports__clamp = __webpack_exports__.uZ5;\nvar __webpack_exports__createId = __webpack_exports__.McK;\nvar __webpack_exports__frac = __webpack_exports__.F9c;\nvar __webpack_exports__hasGraphicsTick = __webpack_exports__.k0b;\nvar __webpack_exports__hasOnInitialize = __webpack_exports__.hnT;\nvar __webpack_exports__hasOnPostUpdate = __webpack_exports__.RSJ;\nvar __webpack_exports__hasOnPreUpdate = __webpack_exports__.Mku;\nvar __webpack_exports__hasPostDraw = __webpack_exports__.h90;\nvar __webpack_exports__hasPreDraw = __webpack_exports__.rms;\nvar __webpack_exports__has_initialize = __webpack_exports__.ErP;\nvar __webpack_exports__has_postupdate = __webpack_exports__.aVg;\nvar __webpack_exports__has_preupdate = __webpack_exports__.lPc;\nvar __webpack_exports__isAddedComponent = __webpack_exports__.Z8E;\nvar __webpack_exports__isAddedSystemEntity = __webpack_exports__._N2;\nvar __webpack_exports__isRemoveSystemEntity = __webpack_exports__.yFn;\nvar __webpack_exports__isRemovedComponent = __webpack_exports__.lNv;\nvar __webpack_exports__isScreenElement = __webpack_exports__.cu9;\nvar __webpack_exports__maxMessages = __webpack_exports__.MZQ;\nvar __webpack_exports__obsolete = __webpack_exports__.FUM;\nvar __webpack_exports__pixelSnapEpsilon = __webpack_exports__.BxR;\nvar __webpack_exports__randomInRange = __webpack_exports__.vdf;\nvar __webpack_exports__randomIntInRange = __webpack_exports__.iaL;\nvar __webpack_exports__range = __webpack_exports__.w6H;\nvar __webpack_exports__resetObsoleteCounter = __webpack_exports__.Q4c;\nvar __webpack_exports__sign = __webpack_exports__.Xxe;\nvar __webpack_exports__toDegrees = __webpack_exports__.Uxb;\nvar __webpack_exports__toRadians = __webpack_exports__.Yr5;\nvar __webpack_exports__vec = __webpack_exports__.Bhw;\nvar __webpack_exports__webgl = __webpack_exports__.yOA;\nexport { __webpack_exports__ActionContext as ActionContext, __webpack_exports__ActionQueue as ActionQueue, __webpack_exports__ActionSequence as ActionSequence, __webpack_exports__ActionsComponent as ActionsComponent, __webpack_exports__ActionsSystem as ActionsSystem, __webpack_exports__ActivateEvent as ActivateEvent, __webpack_exports__Actor as Actor, __webpack_exports__AddedComponent as AddedComponent, __webpack_exports__AddedEntity as AddedEntity, __webpack_exports__AffineMatrix as AffineMatrix, __webpack_exports__Animation as Animation, __webpack_exports__AnimationDirection as AnimationDirection, __webpack_exports__AnimationStrategy as AnimationStrategy, __webpack_exports__ArcadeSolver as ArcadeSolver, __webpack_exports__AudioContextFactory as AudioContextFactory, __webpack_exports__Axis as Axis, __webpack_exports__BaseAlign as BaseAlign, __webpack_exports__Blink as Blink, __webpack_exports__BodyComponent as BodyComponent, __webpack_exports__BoundingBox as BoundingBox, __webpack_exports__BroadphaseStrategy as BroadphaseStrategy, __webpack_exports__BrowserComponent as BrowserComponent, __webpack_exports__BrowserEvents as BrowserEvents, __webpack_exports__Camera as Camera, __webpack_exports__Canvas as Canvas, __webpack_exports__Circle as Circle, __webpack_exports__CircleCollider as CircleCollider, __webpack_exports__Class as Class, __webpack_exports__Clock as Clock, __webpack_exports__ClosestLine as ClosestLine, __webpack_exports__ClosestLineJumpTable as ClosestLineJumpTable, __webpack_exports__Collider as Collider, __webpack_exports__ColliderComponent as ColliderComponent, __webpack_exports__CollisionContact as CollisionContact, __webpack_exports__CollisionEndEvent as CollisionEndEvent, __webpack_exports__CollisionGroup as CollisionGroup, __webpack_exports__CollisionGroupManager as CollisionGroupManager, __webpack_exports__CollisionJumpTable as CollisionJumpTable, __webpack_exports__CollisionPostSolveEvent as CollisionPostSolveEvent, __webpack_exports__CollisionPreSolveEvent as CollisionPreSolveEvent, __webpack_exports__CollisionResolutionStrategy as CollisionResolutionStrategy, __webpack_exports__CollisionStartEvent as CollisionStartEvent, __webpack_exports__CollisionSystem as CollisionSystem, __webpack_exports__CollisionType as CollisionType, __webpack_exports__Color as Color, __webpack_exports__ColorBlindFlags as ColorBlindFlags, __webpack_exports__ColorBlindnessMode as ColorBlindnessMode, __webpack_exports__ColorBlindnessPostProcessor as ColorBlindnessPostProcessor, __webpack_exports__Component as Component, __webpack_exports__CompositeCollider as CompositeCollider, __webpack_exports__Configurable as Configurable, __webpack_exports__ConsoleAppender as ConsoleAppender, __webpack_exports__ContactConstraintPoint as ContactConstraintPoint, __webpack_exports__ContactEndEvent as ContactEndEvent, __webpack_exports__ContactStartEvent as ContactStartEvent, __webpack_exports__CoordPlane as CoordPlane, __webpack_exports__DeactivateEvent as DeactivateEvent, __webpack_exports__Debug as Debug, __webpack_exports__DebugGraphicsComponent as DebugGraphicsComponent, __webpack_exports__DebugSystem as DebugSystem, __webpack_exports__DebugText as DebugText, __webpack_exports__DegreeOfFreedom as DegreeOfFreedom, __webpack_exports__Delay as Delay, __webpack_exports__Detector as Detector, __webpack_exports__Die as Die, __webpack_exports__Direction as Direction, __webpack_exports__DisplayMode as DisplayMode, __webpack_exports__DynamicTree as DynamicTree, __webpack_exports__DynamicTreeCollisionProcessor as DynamicTreeCollisionProcessor, __webpack_exports__EX_VERSION as EX_VERSION, __webpack_exports__EaseBy as EaseBy, __webpack_exports__EaseTo as EaseTo, __webpack_exports__EasingFunctions as EasingFunctions, __webpack_exports__EdgeCollider as EdgeCollider, __webpack_exports__ElasticToActorStrategy as ElasticToActorStrategy, __webpack_exports__EmitterType as EmitterType, __webpack_exports__Engine as Engine, __webpack_exports__EnterTriggerEvent as EnterTriggerEvent, __webpack_exports__EnterViewPortEvent as EnterViewPortEvent, __webpack_exports__Entity as Entity, __webpack_exports__EntityManager as EntityManager, __webpack_exports__EventDispatcher as EventDispatcher, __webpack_exports__EventTypes as EventTypes, __webpack_exports__Events as Events, __webpack_exports__ExResponse as ExResponse, __webpack_exports__ExcaliburGraphicsContext2DCanvas as ExcaliburGraphicsContext2DCanvas, __webpack_exports__ExcaliburGraphicsContextWebGL as ExcaliburGraphicsContextWebGL, __webpack_exports__ExcaliburWebGLContextAccessor as ExcaliburWebGLContextAccessor, __webpack_exports__ExitTriggerEvent as ExitTriggerEvent, __webpack_exports__ExitViewPortEvent as ExitViewPortEvent, __webpack_exports__Fade as Fade, __webpack_exports__Flags as Flags, __webpack_exports__Follow as Follow, __webpack_exports__Font as Font, __webpack_exports__FontStyle as FontStyle, __webpack_exports__FontUnit as FontUnit, __webpack_exports__FpsSampler as FpsSampler, __webpack_exports__FrameStats as FrameStats, __webpack_exports__Future as Future, __webpack_exports__GameEvent as GameEvent, __webpack_exports__GameStartEvent as GameStartEvent, __webpack_exports__GameStopEvent as GameStopEvent, __webpack_exports__GamepadAxisEvent as GamepadAxisEvent, __webpack_exports__GamepadButtonEvent as GamepadButtonEvent, __webpack_exports__GamepadConnectEvent as GamepadConnectEvent, __webpack_exports__GamepadDisconnectEvent as GamepadDisconnectEvent, __webpack_exports__Gif as Gif, __webpack_exports__GlobalCoordinates as GlobalCoordinates, __webpack_exports__Graphic as Graphic, __webpack_exports__GraphicsComponent as GraphicsComponent, __webpack_exports__GraphicsGroup as GraphicsGroup, __webpack_exports__GraphicsLayer as GraphicsLayer, __webpack_exports__GraphicsLayers as GraphicsLayers, __webpack_exports__GraphicsSystem as GraphicsSystem, __webpack_exports__HiddenEvent as HiddenEvent, __webpack_exports__ImageFiltering as ImageFiltering, __webpack_exports__ImageSource as ImageSource, __webpack_exports__InitializeEvent as InitializeEvent, __webpack_exports__Input as Input, __webpack_exports__Integrator as Integrator, __webpack_exports__IsometricEntityComponent as IsometricEntityComponent, __webpack_exports__IsometricEntitySystem as IsometricEntitySystem, __webpack_exports__IsometricMap as IsometricMap, __webpack_exports__IsometricTile as IsometricTile, __webpack_exports__KillEvent as KillEvent, __webpack_exports__Label as Label, __webpack_exports__LimitCameraBoundsStrategy as LimitCameraBoundsStrategy, __webpack_exports__Line as Line, __webpack_exports__LineSegment as LineSegment, __webpack_exports__Loader as Loader, __webpack_exports__LockCameraToActorAxisStrategy as LockCameraToActorAxisStrategy, __webpack_exports__LockCameraToActorStrategy as LockCameraToActorStrategy, __webpack_exports__LogLevel as LogLevel, __webpack_exports__Logger as Logger, __webpack_exports__Matrix as Matrix, __webpack_exports__MatrixLocations as MatrixLocations, __webpack_exports__MediaEvent as MediaEvent, __webpack_exports__Meet as Meet, __webpack_exports__MotionComponent as MotionComponent, __webpack_exports__MotionSystem as MotionSystem, __webpack_exports__MoveBy as MoveBy, __webpack_exports__MoveTo as MoveTo, __webpack_exports__NativeSoundEvent as NativeSoundEvent, __webpack_exports__NativeSoundProcessedEvent as NativeSoundProcessedEvent, __webpack_exports__Observable as Observable, __webpack_exports__OffscreenSystem as OffscreenSystem, __webpack_exports__Pair as Pair, __webpack_exports__ParallaxComponent as ParallaxComponent, __webpack_exports__ParallelActions as ParallelActions, __webpack_exports__ParseGif as ParseGif, __webpack_exports__Particle as Particle, __webpack_exports__ParticleEmitter as ParticleEmitter, __webpack_exports__Physics as Physics, __webpack_exports__PhysicsStats as PhysicsStats, __webpack_exports__PointerComponent as PointerComponent, __webpack_exports__PointerSystem as PointerSystem, __webpack_exports__Polygon as Polygon, __webpack_exports__PolygonCollider as PolygonCollider, __webpack_exports__Pool as Pool, __webpack_exports__PostCollisionEvent as PostCollisionEvent, __webpack_exports__PostDebugDrawEvent as PostDebugDrawEvent, __webpack_exports__PostDrawEvent as PostDrawEvent, __webpack_exports__PostFrameEvent as PostFrameEvent, __webpack_exports__PostKillEvent as PostKillEvent, __webpack_exports__PostUpdateEvent as PostUpdateEvent, __webpack_exports__PreCollisionEvent as PreCollisionEvent, __webpack_exports__PreDebugDrawEvent as PreDebugDrawEvent, __webpack_exports__PreDrawEvent as PreDrawEvent, __webpack_exports__PreFrameEvent as PreFrameEvent, __webpack_exports__PreKillEvent as PreKillEvent, __webpack_exports__PreUpdateEvent as PreUpdateEvent, __webpack_exports__Projection as Projection, __webpack_exports__QuadIndexBuffer as QuadIndexBuffer, __webpack_exports__Query as Query, __webpack_exports__QueryManager as QueryManager, __webpack_exports__RadiusAroundActorStrategy as RadiusAroundActorStrategy, __webpack_exports__Random as Random, __webpack_exports__Raster as Raster, __webpack_exports__Ray as Ray, __webpack_exports__RealisticSolver as RealisticSolver, __webpack_exports__Rectangle as Rectangle, __webpack_exports__RemovedComponent as RemovedComponent, __webpack_exports__RemovedEntity as RemovedEntity, __webpack_exports__Repeat as Repeat, __webpack_exports__RepeatForever as RepeatForever, __webpack_exports__Resolution as Resolution, __webpack_exports__Resource as Resource, __webpack_exports__RotateBy as RotateBy, __webpack_exports__RotateTo as RotateTo, __webpack_exports__RotationType as RotationType, __webpack_exports__ScaleBy as ScaleBy, __webpack_exports__ScaleTo as ScaleTo, __webpack_exports__Scene as Scene, __webpack_exports__Screen as Screen, __webpack_exports__ScreenAppender as ScreenAppender, __webpack_exports__ScreenElement as ScreenElement, __webpack_exports__ScreenShader as ScreenShader, __webpack_exports__ScrollPreventionMode as ScrollPreventionMode, __webpack_exports__Semaphore as Semaphore, __webpack_exports__Shader as Shader, __webpack_exports__Shape as Shape, __webpack_exports__Side as Side, __webpack_exports__Sound as Sound, __webpack_exports__Sprite as Sprite, __webpack_exports__SpriteFont as SpriteFont, __webpack_exports__SpriteSheet as SpriteSheet, __webpack_exports__StandardClock as StandardClock, __webpack_exports__StateMachine as StateMachine, __webpack_exports__StrategyContainer as StrategyContainer, __webpack_exports__Stream as Stream, __webpack_exports__System as System, __webpack_exports__SystemManager as SystemManager, __webpack_exports__SystemType as SystemType, __webpack_exports__TagComponent as TagComponent, __webpack_exports__TestClock as TestClock, __webpack_exports__Text as Text, __webpack_exports__TextAlign as TextAlign, __webpack_exports__TextureLoader as TextureLoader, __webpack_exports__Tile as Tile, __webpack_exports__TileMap as TileMap, __webpack_exports__Timer as Timer, __webpack_exports__Toaster as Toaster, __webpack_exports__Transform as Transform, __webpack_exports__TransformComponent as TransformComponent, __webpack_exports__TreeNode as TreeNode, __webpack_exports__Trigger as Trigger, __webpack_exports__TwoPI as TwoPI, __webpack_exports__Util as Util, __webpack_exports__Vector as Vector, __webpack_exports__VectorView as VectorView, __webpack_exports__VertexBuffer as VertexBuffer, __webpack_exports__VertexLayout as VertexLayout, __webpack_exports__VisibleEvent as VisibleEvent, __webpack_exports__WebAudio as WebAudio, __webpack_exports__WebAudioInstance as WebAudioInstance, __webpack_exports__World as World, __webpack_exports__canonicalizeAngle as canonicalizeAngle, __webpack_exports__clamp as clamp, __webpack_exports__createId as createId, __webpack_exports__frac as frac, __webpack_exports__hasGraphicsTick as hasGraphicsTick, __webpack_exports__hasOnInitialize as hasOnInitialize, __webpack_exports__hasOnPostUpdate as hasOnPostUpdate, __webpack_exports__hasOnPreUpdate as hasOnPreUpdate, __webpack_exports__hasPostDraw as hasPostDraw, __webpack_exports__hasPreDraw as hasPreDraw, __webpack_exports__has_initialize as has_initialize, __webpack_exports__has_postupdate as has_postupdate, __webpack_exports__has_preupdate as has_preupdate, __webpack_exports__isAddedComponent as isAddedComponent, __webpack_exports__isAddedSystemEntity as isAddedSystemEntity, __webpack_exports__isRemoveSystemEntity as isRemoveSystemEntity, __webpack_exports__isRemovedComponent as isRemovedComponent, __webpack_exports__isScreenElement as isScreenElement, __webpack_exports__maxMessages as maxMessages, __webpack_exports__obsolete as obsolete, __webpack_exports__pixelSnapEpsilon as pixelSnapEpsilon, __webpack_exports__randomInRange as randomInRange, __webpack_exports__randomIntInRange as randomIntInRange, __webpack_exports__range as range, __webpack_exports__resetObsoleteCounter as resetObsoleteCounter, __webpack_exports__sign as sign, __webpack_exports__toDegrees as toDegrees, __webpack_exports__toRadians as toRadians, __webpack_exports__vec as vec, __webpack_exports__webgl as webgl };\n\n//# sourceMappingURL=excalibur.js.map","require('../../modules/es.array.sort');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'sort');\n","require('../../modules/es.object.keys');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.keys;\n","var isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + ' is not a function');\n};\n","var isObject = require('../internals/is-object');\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n","var toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar createProperty = require('../internals/create-property');\n\nvar $Array = Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n","var arraySlice = require('../internals/array-slice-simple');\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice(array, 0, middle), comparefn),\n    mergeSort(arraySlice(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nmodule.exports = mergeSort;\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n","var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n","var hasOwn = require('../internals/has-own-property');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","'use strict';\nvar toPropertyKey = require('../internals/to-property-key');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","var isCallable = require('../internals/is-callable');\nvar definePropertyModule = require('../internals/object-define-property');\nvar makeBuiltIn = require('../internals/make-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n","var global = require('../internals/global');\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","'use strict';\nvar tryToString = require('../internals/try-to-string');\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (O, P) {\n  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var userAgent = require('../internals/engine-user-agent');\n\nvar firefox = userAgent.match(/firefox\\/(\\d+)/i);\n\nmodule.exports = !!firefox && +firefox[1];\n","var UA = require('../internals/engine-user-agent');\n\nmodule.exports = /MSIE|Trident/.test(UA);\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n","var userAgent = require('../internals/engine-user-agent');\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nmodule.exports = !!webkit && +webkit[1];\n","var global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = function (CONSTRUCTOR, METHOD) {\n  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n","var NATIVE_BIND = require('../internals/function-bind-native');\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar hasOwn = require('../internals/has-own-property');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","var NATIVE_BIND = require('../internals/function-bind-native');\n\nvar FunctionPrototype = Function.prototype;\nvar bind = FunctionPrototype.bind;\nvar call = FunctionPrototype.call;\nvar uncurryThis = NATIVE_BIND && bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis(fn);\n} : function (fn) {\n  return fn && function () {\n    return call.apply(fn, arguments);\n  };\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","var aCallable = require('../internals/a-callable');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n","var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar toObject = require('../internals/to-object');\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n","module.exports = {};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis(store.get);\n  var wmhas = uncurryThis(store.has);\n  var wmset = uncurryThis(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument == 'function';\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n","module.exports = false;\n","var getBuiltIn = require('../internals/get-built-in');\nvar isCallable = require('../internals/is-callable');\nvar isPrototypeOf = require('../internals/object-is-prototype-of');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n","var toLength = require('../internals/to-length');\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar hasOwn = require('../internals/has-own-property');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n","/* eslint-disable es-x/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar call = require('../internals/function-call');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar hasOwn = require('../internals/has-own-property');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar hasOwn = require('../internals/has-own-property');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","var call = require('../internals/function-call');\nvar isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError(\"Can't convert object to primitive value\");\n};\n","var getBuiltIn = require('../internals/get-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n","var global = require('../internals/global');\n\nmodule.exports = global;\n","var $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw $TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","var global = require('../internals/global');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","var trunc = require('../internals/math-trunc');\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n","var call = require('../internals/function-call');\nvar isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","var toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n","var classof = require('../internals/classof');\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n","var $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n","/* eslint-disable es-x/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar hasOwn = require('../internals/has-own-property');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar aCallable = require('../internals/a-callable');\nvar toObject = require('../internals/to-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar deletePropertyOrThrow = require('../internals/delete-property-or-throw');\nvar toString = require('../internals/to-string');\nvar fails = require('../internals/fails');\nvar internalSort = require('../internals/array-sort');\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar FF = require('../internals/engine-ff-version');\nvar IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');\nvar V8 = require('../internals/engine-v8-version');\nvar WEBKIT = require('../internals/engine-webkit-version');\n\nvar test = [];\nvar un$Sort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD = arrayMethodIsStrict('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable(comparefn);\n\n    var array = toObject(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n","var $ = require('../internals/export');\nvar toObject = require('../internals/to-object');\nvar nativeKeys = require('../internals/object-keys');\nvar fails = require('../internals/fails');\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject(it));\n  }\n});\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./Loader.css\"],\"names\":[],\"mappings\":\"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF\",\"sourcesContent\":[\"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./Util/Toaster.css\"],\"names\":[],\"mappings\":\";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB\",\"sourcesContent\":[\"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import 'core-js/es/array/sort';\r\nimport 'core-js/es/object/keys';\r\n\r\n/**\r\n * Polyfill adding function\r\n */\r\nexport function polyfill() {\r\n  /* istanbul ignore next */\r\n  if (typeof window === 'undefined') {\r\n    window = <any>{\r\n      audioContext: function () {\r\n        return;\r\n      }\r\n    };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.requestAnimationFrame) {\r\n    (<any>window).requestAnimationFrame =\r\n      (<any>window).webkitRequestAnimationFrame ||\r\n      (<any>window).mozRequestAnimationFrame ||\r\n      function (callback: Function) {\r\n        window.setInterval(callback, 1000 / 60);\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {\r\n    (<any>window).cancelAnimationFrame =\r\n      (<any>window).webkitCancelAnimationFrame ||\r\n      (<any>window).mozCancelAnimationFrame ||\r\n      function () {\r\n        return;\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).AudioContext) {\r\n    if ((<any>window).webkitAudioContext) {\r\n      const ctx = (<any>window).webkitAudioContext;\r\n      const replaceMe = ctx.prototype.decodeAudioData;\r\n      (<any>window).webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer: ArrayBuffer) {\r\n        return new Promise((resolve, reject) => {\r\n          replaceMe.call(this, arrayBuffer, resolve, reject);\r\n        });\r\n      };\r\n    }\r\n\r\n    (<any>window).AudioContext =\r\n      (<any>window).AudioContext ||\r\n      (<any>window).webkitAudioContext ||\r\n      (<any>window).mozAudioContext ||\r\n      (<any>window).msAudioContext ||\r\n      (<any>window).oAudioContext;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).devicePixelRatio) {\r\n    (<any>window).devicePixelRatio = window.devicePixelRatio || 1;\r\n  }\r\n}\r\n","\r\n/**\r\n * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**\r\n * after which they are frozen and are read-only.\r\n *\r\n * Flags are used to enable experimental or preview features in Excalibur.\r\n */\r\nexport class Flags {\r\n  private static _FROZEN = false;\r\n  private static _FLAGS: Record<string, boolean> = {};\r\n\r\n\r\n  /**\r\n   * Force excalibur to load the Canvas 2D graphics context fallback\r\n   *\r\n   * @warning not all features of excalibur are supported in the Canvas 2D fallback\r\n   */\r\n  public static useCanvasGraphicsContext() {\r\n    Flags.enable('use-canvas-context');\r\n  }\r\n\r\n  /**\r\n   * Freeze all flag modifications making them readonly\r\n   */\r\n  public static freeze() {\r\n    Flags._FROZEN = true;\r\n  }\r\n\r\n  /**\r\n   * Resets internal flag state, not meant to be called by users. Only used for testing.\r\n   *\r\n   * Calling this in your game is UNSUPPORTED\r\n   * @internal\r\n   */\r\n  public static _reset() {\r\n    Flags._FROZEN = false;\r\n    Flags._FLAGS = {};\r\n  }\r\n  /**\r\n   * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static enable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be enabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = true;\r\n  }\r\n\r\n  /**\r\n   * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static disable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be disabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = false;\r\n  }\r\n\r\n  /**\r\n   * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned\r\n   * @param flagName\r\n   */\r\n  public static isEnabled(flagName: string): boolean {\r\n    return !!Flags._FLAGS[flagName];\r\n  }\r\n\r\n  /**\r\n   * Show a list of currently known flags\r\n   */\r\n  public static show(): string[] {\r\n    return Object.keys(Flags._FLAGS);\r\n  }\r\n}\r\n","export type Id<T extends string> = {\r\n  type: T,\r\n  value: number\r\n};\r\n\r\n/**\r\n * Create a branded ID type from a number\r\n */\r\nexport function createId<T extends string>(type: T, value: number): Id<T> {\r\n  return { type, value };\r\n};\r\n","/**\r\n * @module\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n */\r\n\r\n/**\r\n * 32-bit mask\r\n */\r\nconst BITMASK32: number = 0xffffffff;\r\n\r\n/**\r\n * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n * of numbers each time it is called.\r\n * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n *\r\n * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n */\r\nexport class Random {\r\n  // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\r\n  private _lowerMask: number = 0x7fffffff; // 31 bits same as _r\r\n  private _upperMask: number = 0x80000000; // 34 high bits\r\n\r\n  // Word size, 64 bits\r\n  private _w: number = 32;\r\n\r\n  // Degree of recurrence\r\n  private _n: number = 624;\r\n\r\n  // Middle word, an offset used in the recurrence defining the series x, 1<=m<n\r\n  private _m: number = 397;\r\n  // coefficients of teh rational normal form twist matrix\r\n  private _a: number = 0x9908b0df;\r\n\r\n  // tempering bit shifts and masks\r\n  private _u: number = 11;\r\n  private _s: number = 7;\r\n  private _b: number = 0x9d2c5680;\r\n  private _t: number = 15;\r\n  private _c: number = 0xefc60000;\r\n  private _l: number = 18;\r\n  private _f: number = 1812433253;\r\n\r\n  private _mt: number[];\r\n\r\n  private _index: number;\r\n\r\n  /**\r\n   * If no seed is specified, the Date.now() is used\r\n   */\r\n  constructor(public seed?: number) {\r\n    this._mt = new Array<number>(this._n);\r\n    // need to mask to support higher bit machines\r\n    this._mt[0] = (seed || Date.now()) >>> 0;\r\n\r\n    for (let i = 1; i < this._n; i++) {\r\n      const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));\r\n      // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits\r\n      this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;\r\n    }\r\n    this._index = this._n;\r\n  }\r\n\r\n  /**\r\n   * Apply the twist\r\n   */\r\n  private _twist(): void {\r\n    const mag01 = [0x0, this._a];\r\n    let y = 0,\r\n      i = 0;\r\n    for (; i < this._n - this._m; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    for (; i < this._n - 1; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);\r\n    this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n\r\n    this._index = 0;\r\n  }\r\n\r\n  /**\r\n   * Return next 32 bit integer number in sequence\r\n   */\r\n  public nextInt(): number {\r\n    if (this._index >= this._n) {\r\n      this._twist();\r\n    }\r\n\r\n    let y = this._mt[this._index++];\r\n\r\n    y ^= y >>> this._u;\r\n    y ^= (y << this._s) & this._b;\r\n    y ^= (y << this._t) & this._c;\r\n    y ^= y >>> this._l;\r\n\r\n    return y >>> 0;\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point number between [0, 1)\r\n   */\r\n  public next(): number {\r\n    return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point in range [min, max) min is included, max is not included\r\n   */\r\n  public floating(min: number, max: number): number {\r\n    return (max - min) * this.next() + min;\r\n  }\r\n\r\n  /**\r\n   * Return a random integer in range [min, max] min is included, max is included.\r\n   * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n   */\r\n  public integer(min: number, max: number): number {\r\n    return Math.floor((max - min + 1) * this.next() + min);\r\n  }\r\n\r\n  /**\r\n   * Returns true or false randomly with 50/50 odds by default.\r\n   * By default the likelihood of returning a true is .5 (50%).\r\n   * @param likelihood takes values between [0, 1]\r\n   */\r\n  public bool(likelihood: number = 0.5): boolean {\r\n    return this.next() <= likelihood;\r\n  }\r\n\r\n  /**\r\n   * Returns one element from an array at random\r\n   */\r\n  public pickOne<T>(array: Array<T>): T {\r\n    return array[this.integer(0, array.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original\r\n   * @param array Original array to pick from\r\n   * @param numPicks can be any positive number\r\n   * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n   * just that it is possible)\r\n   */\r\n  public pickSet<T>(array: Array<T>, numPicks: number, allowDuplicates: boolean = false): Array<T> {\r\n    if (allowDuplicates) {\r\n      return this._pickSetWithDuplicates(array, numPicks);\r\n    } else {\r\n      return this._pickSetWithoutDuplicates(array, numPicks);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new array randomly picking elements in the original (not reused)\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks must be less than or equal to the number of elements in the array.\r\n   */\r\n  private _pickSetWithoutDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    if (numPicks > array.length || numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');\r\n    }\r\n    if (numPicks === array.length) {\r\n      return array;\r\n    }\r\n\r\n    const result: Array<T> = new Array<T>(numPicks);\r\n    let currentPick = 0;\r\n    const tempArray = array.slice(0);\r\n    while (currentPick < numPicks) {\r\n      const index = this.integer(0, tempArray.length - 1);\r\n      result[currentPick++] = tempArray[index];\r\n      tempArray.splice(index, 1);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original allowing duplicates\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks can be any positive number\r\n   */\r\n  private _pickSetWithDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\r\n    if (numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');\r\n    }\r\n    const result = new Array<T>(numPicks);\r\n    for (let i = 0; i < numPicks; i++) {\r\n      result[i] = this.pickOne(array);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n   */\r\n  public shuffle<T>(array: Array<T>): Array<T> {\r\n    const tempArray = array.slice(0);\r\n    let swap: T = null;\r\n    for (let i = 0; i < tempArray.length - 2; i++) {\r\n      const randomIndex = this.integer(i, tempArray.length - 1);\r\n      swap = tempArray[i];\r\n      tempArray[i] = tempArray[randomIndex];\r\n      tempArray[randomIndex] = swap;\r\n    }\r\n\r\n    return tempArray;\r\n  }\r\n\r\n  /**\r\n   * Generate a list of random integer numbers\r\n   * @param length the length of the final array\r\n   * @param min the minimum integer number to generate inclusive\r\n   * @param max the maximum integer number to generate inclusive\r\n   */\r\n  public range(length: number, min: number, max: number): Array<number> {\r\n    const result: Array<number> = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      result[i] = this.integer(min, max);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d4 dice roll\r\n   */\r\n  public d4() {\r\n    return this.integer(1, 4);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d6 dice roll\r\n   */\r\n  public d6() {\r\n    return this.integer(1, 6);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d8 dice roll\r\n   */\r\n  public d8() {\r\n    return this.integer(1, 8);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d10 dice roll\r\n   */\r\n  public d10() {\r\n    return this.integer(1, 10);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d12 dice roll\r\n   */\r\n  public d12() {\r\n    return this.integer(1, 12);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d20 dice roll\r\n   */\r\n  public d20() {\r\n    return this.integer(1, 20);\r\n  }\r\n}\r\n","import { Random } from './Random';\r\n\r\n/**\r\n * Two PI constant\r\n */\r\nexport const TwoPI: number = Math.PI * 2;\r\n\r\n/**\r\n * Returns the fractional part of a number\r\n * @param x\r\n */\r\nexport function frac(x: number): number {\r\n  if (x >= 0) {\r\n    return x - Math.floor(x);\r\n  } else {\r\n    return x - Math.ceil(x);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the sign of a number, if 0 returns 0\r\n */\r\nexport function sign(val: number): number {\r\n  if (val === 0) {\r\n    return 0;\r\n  }\r\n  return val < 0 ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Clamps a value between a min and max inclusive\r\n */\r\nexport function clamp(val: number, min: number, max: number) {\r\n  return Math.min(Math.max(min, val), max);\r\n}\r\n\r\n\r\n/**\r\n * Convert an angle to be the equivalent in the range [0, 2PI]\r\n */\r\nexport function canonicalizeAngle(angle: number): number {\r\n  let tmpAngle = angle;\r\n  if (angle > TwoPI) {\r\n    while (tmpAngle > TwoPI) {\r\n      tmpAngle -= TwoPI;\r\n    }\r\n  }\r\n\r\n  if (angle < 0) {\r\n    while (tmpAngle < 0) {\r\n      tmpAngle += TwoPI;\r\n    }\r\n  }\r\n  return tmpAngle;\r\n}\r\n\r\n/**\r\n * Convert radians to degrees\r\n */\r\nexport function toDegrees(radians: number): number {\r\n  return (180 / Math.PI) * radians;\r\n}\r\n\r\n/**\r\n * Convert degrees to radians\r\n */\r\nexport function toRadians(degrees: number): number {\r\n  return (degrees / 180) * Math.PI;\r\n}\r\n\r\n/**\r\n * Generate a range of numbers\r\n * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]\r\n * @param from inclusive\r\n * @param to inclusive\r\n */\r\nexport const range = (from: number, to: number) => Array.from(new Array(to - from + 1), (_x, i) => i + from);\r\n\r\n/**\r\n * Find a random floating point number in range\r\n */\r\nexport function randomInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.floating(min, max) : min + Math.random() * (max - min);\r\n}\r\n\r\n/**\r\n * Find a random integer in a range\r\n */\r\nexport function randomIntInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.integer(min, max) : Math.round(randomInRange(min, max));\r\n}","import { Clonable } from '../Interfaces/Clonable';\r\nimport { clamp } from './util';\r\n\r\n/**\r\n * A 2D vector on a plane.\r\n */\r\n\r\nexport class Vector implements Clonable<Vector> {\r\n  /**\r\n   * A (0, 0) vector\r\n   */\r\n  public static get Zero() {\r\n    return new Vector(0, 0);\r\n  }\r\n\r\n  /**\r\n   * A (1, 1) vector\r\n   */\r\n  public static get One() {\r\n    return new Vector(1, 1);\r\n  }\r\n\r\n  /**\r\n   * A (0.5, 0.5) vector\r\n   */\r\n  public static get Half() {\r\n    return new Vector(0.5, 0.5);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing up (0, -1)\r\n   */\r\n  public static get Up() {\r\n    return new Vector(0, -1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing down (0, 1)\r\n   */\r\n  public static get Down() {\r\n    return new Vector(0, 1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing left (-1, 0)\r\n   */\r\n  public static get Left() {\r\n    return new Vector(-1, 0);\r\n  }\r\n  /**\r\n   * A unit vector pointing right (1, 0)\r\n   */\r\n  public static get Right() {\r\n    return new Vector(1, 0);\r\n  }\r\n\r\n  /**\r\n   * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n   * @param angle The angle to generate the vector\r\n   */\r\n  public static fromAngle(angle: number) {\r\n    return new Vector(Math.cos(angle), Math.sin(angle));\r\n  }\r\n\r\n  /**\r\n   * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n   */\r\n  public static isValid(vec: Vector) {\r\n    if (vec === null || vec === undefined) {\r\n      return false;\r\n    }\r\n    if (isNaN(vec.x) || isNaN(vec.y)) {\r\n      return false;\r\n    }\r\n\r\n    if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculates distance between two Vectors\r\n   * @param vec1\r\n   * @param vec2\r\n   */\r\n  public static distance(vec1: Vector, vec2: Vector) {\r\n    return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\r\n  }\r\n\r\n  public static min(vec1: Vector, vec2: Vector) {\r\n    return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));\r\n  }\r\n\r\n  public static max(vec1: Vector, vec2: Vector) {\r\n    return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));\r\n  }\r\n\r\n  /**\r\n   * @param x  X component of the Vector\r\n   * @param y  Y component of the Vector\r\n   */\r\n  constructor(x: number, y: number) {\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  protected _x = 0;\r\n  /**\r\n   * Get the x component of the vector\r\n   */\r\n  public get x(): number {\r\n    return this._x;\r\n  }\r\n\r\n  /**\r\n   * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set x(val: number) {\r\n    this._x = val;\r\n  }\r\n\r\n  protected _y = 0;\r\n  /**\r\n   * Get the y component of the vector\r\n   */\r\n  public get y(): number {\r\n    return this._y;\r\n  }\r\n\r\n  /**\r\n   * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set y(val: number) {\r\n    this._y = val;\r\n  }\r\n\r\n  /**\r\n   * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   *\r\n   * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  setTo(x: number, y: number) {\r\n    (this.x as number) = x;\r\n    (this.y as number) = y;\r\n  }\r\n\r\n  /**\r\n   * Compares this point against another and tests for equality\r\n   * @param vector The other point to compare to\r\n   * @param tolerance Amount of euclidean distance off we are willing to tolerate\r\n   */\r\n  public equals(vector: Vector, tolerance: number = 0.001): boolean {\r\n    return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\r\n  }\r\n\r\n  /**\r\n   * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n   * @param v  The other vector. Leave blank to use origin vector.\r\n   */\r\n  public distance(v?: Vector): number {\r\n    if (!v) {\r\n      return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n    const deltaX = this.x - v.x;\r\n    const deltaY = this.y - v.y;\r\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n  }\r\n\r\n  public squareDistance(v?: Vector): number {\r\n    if (!v) {\r\n      v = Vector.Zero;\r\n    }\r\n    const deltaX = this.x - v.x;\r\n    const deltaY = this.y - v.y;\r\n    return deltaX * deltaX + deltaY * deltaY;\r\n  }\r\n\r\n  /**\r\n   * Clamps the current vector's magnitude mutating it\r\n   * @param magnitude\r\n   */\r\n  public clampMagnitude(magnitude: number): Vector {\r\n    const size = this.size;\r\n    const newSize = clamp(size, 0, magnitude);\r\n    this.size = newSize;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * The size (magnitude) of the Vector\r\n   */\r\n  public get size(): number {\r\n    return this.distance();\r\n  }\r\n\r\n  /**\r\n   * Setting the size mutates the current vector\r\n   *\r\n   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  public set size(newLength: number) {\r\n    const v = this.normalize().scale(newLength);\r\n    this.setTo(v.x, v.y);\r\n  }\r\n\r\n  /**\r\n   * Normalizes a vector to have a magnitude of 1.\r\n   */\r\n  public normalize(): Vector {\r\n    const d = this.distance();\r\n    if (d > 0) {\r\n      return new Vector(this.x / d, this.y / d);\r\n    } else {\r\n      return new Vector(0, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the average (midpoint) between the current point and the specified\r\n   */\r\n  public average(vec: Vector): Vector {\r\n    return this.add(vec).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Scales a vector's by a factor of size\r\n   * @param size  The factor to scale the magnitude by\r\n   * @param dest  Optionally provide a destination vector for the result\r\n   */\r\n  public scale(scale: Vector, dest?: Vector): Vector;\r\n  public scale(size: number, dest?: Vector): Vector;\r\n  public scale(sizeOrScale: number | Vector, dest?: Vector): Vector {\r\n    const result = dest || new Vector(0, 0);\r\n    if (sizeOrScale instanceof Vector) {\r\n      result.x = this.x * sizeOrScale.x;\r\n      result.y = this.y * sizeOrScale.y;\r\n    } else {\r\n      result.x = this.x * sizeOrScale;\r\n      result.y = this.y * sizeOrScale;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to another\r\n   * @param v The vector to add\r\n   * @param dest Optionally copy the result into a provided vector\r\n   */\r\n  public add(v: Vector, dest?: Vector): Vector {\r\n    if (dest) {\r\n      dest.x = this.x + v.x;\r\n      dest.y = this.y + v.y;\r\n      return dest;\r\n    }\r\n    return new Vector(this.x + v.x, this.y + v.y);\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B\r\n   * @param v The vector to subtract\r\n   */\r\n  public sub(v: Vector): Vector {\r\n    return new Vector(this.x - v.x, this.y - v.y);\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to this one modifying the original\r\n   * @param v The vector to add\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public addEqual(v: Vector): Vector {\r\n    this.setTo(this.x + v.x, this.y + v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from this one modifying the original\r\n   * @param v The vector to subtract\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public subEqual(v: Vector): Vector {\r\n    this.setTo(this.x - v.x, this.y - v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales this vector by a factor of size and modifies the original\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public scaleEqual(size: number): Vector {\r\n    this.setTo(this.x * size, this.y * size);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs a dot product with another vector\r\n   * @param v  The vector to dot\r\n   */\r\n  public dot(v: Vector): number {\r\n    return this.x * v.x + this.y * v.y;\r\n  }\r\n\r\n  /**\r\n   * Performs a 2D cross product with scalar. 2D cross products with a scalar return a vector.\r\n   * @param v  The scalar to cross\r\n   */\r\n  public cross(v: number): Vector;\r\n  /**\r\n   * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.\r\n   * @param v  The vector to cross\r\n   */\r\n  public cross(v: Vector): number;\r\n  public cross(v: any): any {\r\n    if (v instanceof Vector) {\r\n      return this.x * v.y - this.y * v.x;\r\n    } else if (typeof v === 'number') {\r\n      return new Vector(v * this.y, -v * this.x);\r\n    }\r\n  }\r\n\r\n  static cross(num: number, vec: Vector): Vector {\r\n    return new Vector(-num * vec.y, num * vec.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the perpendicular vector to this one\r\n   */\r\n  public perpendicular(): Vector {\r\n    return new Vector(this.y, -this.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the normal vector to this one, same as the perpendicular of length 1\r\n   */\r\n  public normal(): Vector {\r\n    return this.perpendicular().normalize();\r\n  }\r\n\r\n  /**\r\n   * Negate the current vector\r\n   */\r\n  public negate(): Vector {\r\n    return this.scale(-1);\r\n  }\r\n\r\n  /**\r\n   * Returns the angle of this vector.\r\n   */\r\n  public toAngle(): number {\r\n    return Math.atan2(this.y, this.x);\r\n  }\r\n\r\n  /**\r\n   * Rotates the current vector around a point by a certain number of\r\n   * degrees in radians\r\n   */\r\n  public rotate(angle: number, anchor?: Vector): Vector {\r\n    if (!anchor) {\r\n      anchor = new Vector(0, 0);\r\n    }\r\n    const sinAngle = Math.sin(angle);\r\n    const cosAngle = Math.cos(angle);\r\n    const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n    const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n    return new Vector(x, y);\r\n  }\r\n\r\n  /**\r\n   * Creates new vector that has the same values as the previous.\r\n   */\r\n  public clone(dest?: Vector): Vector {\r\n    const v = dest ?? new Vector(0, 0);\r\n    v.x = this.x;\r\n    v.y = this.y;\r\n    return v;\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of the vector.\r\n   */\r\n  public toString(fixed?: number): string {\r\n    if (fixed) {\r\n      return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;\r\n    }\r\n    return `(${this.x}, ${this.y})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Shorthand for creating new Vectors - returns a new Vector instance with the\r\n * provided X and Y components.\r\n *\r\n * @param x  X component of the Vector\r\n * @param y  Y component of the Vector\r\n */\r\nexport function vec(x: number, y: number): Vector {\r\n  return new Vector(x, y);\r\n}\r\n","/* eslint-disable no-console */\r\n/**\r\n * Logging level that Excalibur will tag\r\n */\r\nexport enum LogLevel {\r\n  Debug,\r\n  Info,\r\n  Warn,\r\n  Error,\r\n  Fatal\r\n}\r\n\r\n/**\r\n * Static singleton that represents the logging facility for Excalibur.\r\n * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n * Derive from [[Appender]] to create your own logging appenders.\r\n */\r\nexport class Logger {\r\n  private static _INSTANCE: Logger = null;\r\n  private _appenders: Appender[] = [];\r\n\r\n  constructor() {\r\n    if (Logger._INSTANCE) {\r\n      throw new Error('Logger is a singleton');\r\n    }\r\n    Logger._INSTANCE = this;\r\n    // Default console appender\r\n    Logger._INSTANCE.addAppender(new ConsoleAppender());\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the default logging level. Excalibur will only log\r\n   * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n   */\r\n  public defaultLevel: LogLevel = LogLevel.Info;\r\n\r\n  /**\r\n   * Gets the current static instance of Logger\r\n   */\r\n  public static getInstance(): Logger {\r\n    if (Logger._INSTANCE == null) {\r\n      Logger._INSTANCE = new Logger();\r\n    }\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Adds a new [[Appender]] to the list of appenders to write to\r\n   */\r\n  public addAppender(appender: Appender): void {\r\n    this._appenders.push(appender);\r\n  }\r\n\r\n  /**\r\n   * Clears all appenders from the logger\r\n   */\r\n  public clearAppenders(): void {\r\n    this._appenders.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Logs a message at a given LogLevel\r\n   * @param level  The LogLevel`to log the message at\r\n   * @param args   An array of arguments to write to an appender\r\n   */\r\n  private _log(level: LogLevel, args: any[]): void {\r\n    if (level == null) {\r\n      level = this.defaultLevel;\r\n    }\r\n\r\n    const len = this._appenders.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (level >= this.defaultLevel) {\r\n        this._appenders[i].log(level, args);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Debug]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public debug(...args: any[]): void {\r\n    this._log(LogLevel.Debug, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Info]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public info(...args: any[]): void {\r\n    this._log(LogLevel.Info, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Warn]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public warn(...args: any[]): void {\r\n    this._log(LogLevel.Warn, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Error]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public error(...args: any[]): void {\r\n    this._log(LogLevel.Error, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Fatal]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public fatal(...args: any[]): void {\r\n    this._log(LogLevel.Fatal, args);\r\n  }\r\n}\r\n\r\n/**\r\n * Contract for any log appender (such as console/screen)\r\n */\r\nexport interface Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  log(level: LogLevel, args: any[]): void;\r\n}\r\n\r\n/**\r\n * Console appender for browsers (i.e. `console.log`)\r\n */\r\nexport class ConsoleAppender implements Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    // Check for console support\r\n    if (!console && !console.log && console.warn && console.error) {\r\n      // todo maybe do something better than nothing\r\n      return;\r\n    }\r\n\r\n    // Create a new console args array\r\n    const consoleArgs: any[] = [];\r\n    consoleArgs.unshift.apply(consoleArgs, args);\r\n    consoleArgs.unshift('[' + LogLevel[level] + '] : ');\r\n\r\n    if (level < LogLevel.Warn) {\r\n      // Call .log for Debug/Info\r\n      if (console.log.apply) {\r\n        // this is required on some older browsers that don't support apply on console.log :(\r\n        console.log.apply(console, consoleArgs);\r\n      } else {\r\n        console.log(consoleArgs.join(' '));\r\n      }\r\n    } else if (level < LogLevel.Error) {\r\n      // Call .warn for Warn\r\n      if (console.warn.apply) {\r\n        console.warn.apply(console, consoleArgs);\r\n      } else {\r\n        console.warn(consoleArgs.join(' '));\r\n      }\r\n    } else {\r\n      // Call .error for Error/Fatal\r\n      if (console.error.apply) {\r\n        console.error.apply(console, consoleArgs);\r\n      } else {\r\n        console.error(consoleArgs.join(' '));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * On-screen (canvas) appender\r\n */\r\nexport class ScreenAppender implements Appender {\r\n  // @todo Clean this up\r\n\r\n  private _messages: string[] = [];\r\n  private _canvas: HTMLCanvasElement;\r\n  private _ctx: CanvasRenderingContext2D;\r\n\r\n  /**\r\n   * @param width   Width of the screen appender in pixels\r\n   * @param height  Height of the screen appender in pixels\r\n   */\r\n  constructor(width?: number, height?: number) {\r\n    this._canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    this._canvas.width = width || window.innerWidth;\r\n    this._canvas.height = height || window.innerHeight;\r\n    this._canvas.style.position = 'absolute';\r\n    // eslint-disable-next-line\r\n    this._ctx = <CanvasRenderingContext2D>this._canvas.getContext('2d'); // eslint-disable-line\r\n    document.body.appendChild(this._canvas);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    const message = args.join(',');\r\n\r\n    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n\r\n    this._messages.unshift('[' + LogLevel[level] + '] : ' + message);\r\n\r\n    let pos = 10;\r\n    let opacity = 1.0;\r\n    for (let i = 0; i < this._messages.length; i++) {\r\n      this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';\r\n      this._ctx.fillText(this._messages[i], 200, pos);\r\n      pos += 10;\r\n      opacity = opacity > 0 ? opacity - 0.05 : 0;\r\n    }\r\n  }\r\n}\r\n","\r\n/**\r\n * Provides standard colors (e.g. [[Color.Black]])\r\n * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n */\r\nexport class Color {\r\n  /**\r\n   * Red channel\r\n   */\r\n  public r: number;\r\n  /**\r\n   * Green channel\r\n   */\r\n  public g: number;\r\n  /**\r\n   * Blue channel\r\n   */\r\n  public b: number;\r\n  /**\r\n   * Alpha channel (between 0 and 1)\r\n   */\r\n  public a: number;\r\n\r\n  /**\r\n   * Hue\r\n   */\r\n  public h: number;\r\n  /**\r\n   * Saturation\r\n   */\r\n  public s: number;\r\n  /**\r\n   * Lightness\r\n   */\r\n  public l: number;\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  constructor(r: number, g: number, b: number, a?: number) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a != null ? a : 1;\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  public static fromRGB(r: number, g: number, b: number, a?: number): Color {\r\n    return new Color(r, g, b, a);\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a rgb string\r\n   *\r\n   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)\r\n   */\r\n  public static fromRGBString(string: string): Color {\r\n    const rgbaRegEx: RegExp = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/i;\r\n    let match = null;\r\n    if ((match = string.match(rgbaRegEx))) {\r\n      const r = parseInt(match[1], 10);\r\n      const g = parseInt(match[2], 10);\r\n      const b = parseInt(match[3], 10);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseFloat(match[4]);\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid rgb/a string: ' + string);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a hex string\r\n   *\r\n   * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n   */\r\n  public static fromHex(hex: string): Color {\r\n    const hexRegEx: RegExp = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\r\n    let match = null;\r\n    if ((match = hex.match(hexRegEx))) {\r\n      const r = parseInt(match[1], 16);\r\n      const g = parseInt(match[2], 16);\r\n      const b = parseInt(match[3], 16);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseInt(match[4], 16) / 255;\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid hex string: ' + hex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from hsla values\r\n   *\r\n   * @param h  Hue is represented [0-1]\r\n   * @param s  Saturation is represented [0-1]\r\n   * @param l  Luminance is represented [0-1]\r\n   * @param a  Alpha is represented [0-1]\r\n   */\r\n  public static fromHSL(h: number, s: number, l: number, a: number = 1.0): Color {\r\n    const temp = new HSLColor(h, s, l, a);\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Lightens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to lighten by [0-1]\r\n   */\r\n  public lighten(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l += (1 - temp.l) * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Darkens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to darken by [0-1]\r\n   */\r\n  public darken(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l -= temp.l * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Saturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to saturate by [0-1]\r\n   */\r\n  public saturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s += temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Desaturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to desaturate by [0-1]\r\n   */\r\n  public desaturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s -= temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Multiplies a color by another, results in a darker color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public multiply(color: Color): Color {\r\n    const newR = (((color.r / 255) * this.r) / 255) * 255;\r\n    const newG = (((color.g / 255) * this.g) / 255) * 255;\r\n    const newB = (((color.b / 255) * this.b) / 255) * 255;\r\n    const newA = color.a * this.a;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  /**\r\n   * Screens a color by another, results in a lighter color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public screen(color: Color): Color {\r\n    const color1 = color.invert();\r\n    const color2 = color.invert();\r\n    return color1.multiply(color2).invert();\r\n  }\r\n\r\n  /**\r\n   * Inverts the current color\r\n   */\r\n  public invert(): Color {\r\n    return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\r\n  }\r\n\r\n  /**\r\n   * Averages the current color with another\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public average(color: Color): Color {\r\n    const newR = (color.r + this.r) / 2;\r\n    const newG = (color.g + this.g) / 2;\r\n    const newB = (color.b + this.b) / 2;\r\n    const newA = (color.a + this.a) / 2;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  public equal(color: Color): boolean {\r\n    return this.toString() === color.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   *\r\n   * @param format Color representation, accepts: rgb, hsl, or hex\r\n   */\r\n  public toString(format: 'rgb' | 'hsl' | 'hex' = 'rgb') {\r\n    switch (format) {\r\n      case 'rgb':\r\n        return this.toRGBA();\r\n      case 'hsl':\r\n        return this.toHSLA();\r\n      case 'hex':\r\n        return this.toHex();\r\n      default:\r\n        throw new Error('Invalid Color format');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Hex Value of a color component\r\n   * @param c color component\r\n   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n   */\r\n  private _componentToHex(c: number) {\r\n    const hex = c.toString(16);\r\n    return hex.length === 1 ? '0' + hex : hex;\r\n  }\r\n\r\n  /**\r\n   * Return Hex representation of a color.\r\n   */\r\n  public toHex() {\r\n    return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\r\n  }\r\n\r\n  /**\r\n   * Return RGBA representation of a color.\r\n   */\r\n  public toRGBA() {\r\n    const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));\r\n    if (this.a !== undefined || this.a !== null) {\r\n      return 'rgba(' + result + ', ' + String(this.a) + ')';\r\n    }\r\n    return 'rgb(' + result + ')';\r\n  }\r\n\r\n  /**\r\n   * Return HSLA representation of a color.\r\n   */\r\n  public toHSLA() {\r\n    return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   */\r\n  public fillStyle() {\r\n    return this.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of the current color.\r\n   */\r\n  public clone(): Color {\r\n    return new Color(this.r, this.g, this.b, this.a);\r\n  }\r\n\r\n  /**\r\n   * Black (#000000)\r\n   */\r\n  public static get Black(): Color {\r\n    return Color.fromHex('#000000');\r\n  }\r\n\r\n  /**\r\n   * White (#FFFFFF)\r\n   */\r\n  public static get White(): Color {\r\n    return Color.fromHex('#FFFFFF');\r\n  }\r\n\r\n  /**\r\n   * Gray (#808080)\r\n   */\r\n  public static get Gray(): Color {\r\n    return Color.fromHex('#808080');\r\n  }\r\n\r\n  /**\r\n   * Light gray (#D3D3D3)\r\n   */\r\n  public static get LightGray(): Color {\r\n    return Color.fromHex('#D3D3D3');\r\n  }\r\n\r\n  /**\r\n   * Dark gray (#A9A9A9)\r\n   */\r\n  public static get DarkGray(): Color {\r\n    return Color.fromHex('#A9A9A9');\r\n  }\r\n\r\n  /**\r\n   * Yellow (#FFFF00)\r\n   */\r\n  public static get Yellow(): Color {\r\n    return Color.fromHex('#FFFF00');\r\n  }\r\n\r\n  /**\r\n   * Orange (#FFA500)\r\n   */\r\n  public static get Orange(): Color {\r\n    return Color.fromHex('#FFA500');\r\n  }\r\n\r\n  /**\r\n   * Red (#FF0000)\r\n   */\r\n  public static get Red(): Color {\r\n    return Color.fromHex('#FF0000');\r\n  }\r\n\r\n  /**\r\n   * Vermilion (#FF5B31)\r\n   */\r\n  public static get Vermilion(): Color {\r\n    return Color.fromHex('#FF5B31');\r\n  }\r\n\r\n  /**\r\n   * Rose (#FF007F)\r\n   */\r\n  public static get Rose(): Color {\r\n    return Color.fromHex('#FF007F');\r\n  }\r\n\r\n  /**\r\n   * Magenta (#FF00FF)\r\n   */\r\n  public static get Magenta(): Color {\r\n    return Color.fromHex('#FF00FF');\r\n  }\r\n\r\n  /**\r\n   * Violet (#7F00FF)\r\n   */\r\n  public static get Violet(): Color {\r\n    return Color.fromHex('#7F00FF');\r\n  }\r\n\r\n  /**\r\n   * Blue (#0000FF)\r\n   */\r\n  public static get Blue(): Color {\r\n    return Color.fromHex('#0000FF');\r\n  }\r\n\r\n  /**\r\n   * Azure (#007FFF)\r\n   */\r\n  public static get Azure(): Color {\r\n    return Color.fromHex('#007FFF');\r\n  }\r\n\r\n  /**\r\n   * Cyan (#00FFFF)\r\n   */\r\n  public static get Cyan(): Color {\r\n    return Color.fromHex('#00FFFF');\r\n  }\r\n\r\n  /**\r\n   * Viridian (#59978F)\r\n   */\r\n  public static get Viridian(): Color {\r\n    return Color.fromHex('#59978F');\r\n  }\r\n\r\n  /**\r\n   * Green (#00FF00)\r\n   */\r\n  public static get Green(): Color {\r\n    return Color.fromHex('#00FF00');\r\n  }\r\n\r\n  /**\r\n   * Chartreuse (#7FFF00)\r\n   */\r\n  public static get Chartreuse(): Color {\r\n    return Color.fromHex('#7FFF00');\r\n  }\r\n\r\n  /**\r\n   * Transparent (#FFFFFF00)\r\n   */\r\n  public static get Transparent(): Color {\r\n    return Color.fromHex('#FFFFFF00');\r\n  }\r\n\r\n  /**\r\n   * ExcaliburBlue (#176BAA)\r\n   */\r\n  public static get ExcaliburBlue(): Color {\r\n    return Color.fromHex('#176BAA');\r\n  }\r\n}\r\n\r\n/**\r\n * Internal HSL Color representation\r\n *\r\n * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n */\r\nclass HSLColor {\r\n  constructor(public h: number, public s: number, public l: number, public a: number) {}\r\n\r\n  public static hue2rgb(p: number, q: number, t: number): number {\r\n    if (t < 0) {\r\n      t += 1;\r\n    }\r\n    if (t > 1) {\r\n      t -= 1;\r\n    }\r\n    if (t < 1 / 6) {\r\n      return p + (q - p) * 6 * t;\r\n    }\r\n    if (t < 1 / 2) {\r\n      return q;\r\n    }\r\n    if (t < 2 / 3) {\r\n      return p + (q - p) * (2 / 3 - t) * 6;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public static fromRGBA(r: number, g: number, b: number, a: number): HSLColor {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n    const max = Math.max(r, g, b),\r\n      min = Math.min(r, g, b);\r\n    let h, s;\r\n    const l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // achromatic\r\n    } else {\r\n      const d = max - min;\r\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      switch (max) {\r\n        case r:\r\n          h = (g - b) / d + (g < b ? 6 : 0);\r\n          break;\r\n        case g:\r\n          h = (b - r) / d + 2;\r\n          break;\r\n        case b:\r\n          h = (r - g) / d + 4;\r\n          break;\r\n      }\r\n      h /= 6;\r\n    }\r\n\r\n    return new HSLColor(h, s, l, a);\r\n  }\r\n\r\n  public toRGBA(): Color {\r\n    let r: number, g: number, b: number;\r\n\r\n    if (this.s === 0) {\r\n      r = g = b = this.l; // achromatic\r\n    } else {\r\n      const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\r\n      const p = 2 * this.l - q;\r\n      r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\r\n      g = HSLColor.hue2rgb(p, q, this.h);\r\n      b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\r\n    }\r\n\r\n    return new Color(r * 255, g * 255, b * 255, this.a);\r\n  }\r\n\r\n  public toString(): string {\r\n    const h = this.h.toFixed(0),\r\n      s = this.s.toFixed(0),\r\n      l = this.l.toFixed(0),\r\n      a = this.a.toFixed(0);\r\n    return `hsla(${h}, ${s}, ${l}, ${a})`;\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * An enum that describes the sides of an axis aligned box for collision\r\n */\r\nexport enum Side {\r\n  None = 'None',\r\n  Top = 'Top',\r\n  Bottom = 'Bottom',\r\n  Left = 'Left',\r\n  Right = 'Right'\r\n}\r\n\r\nexport module Side {\r\n  /**\r\n   * Returns the opposite side from the current\r\n   */\r\n  export function getOpposite(side: Side): Side {\r\n    if (side === Side.Top) {\r\n      return Side.Bottom;\r\n    }\r\n    if (side === Side.Bottom) {\r\n      return Side.Top;\r\n    }\r\n    if (side === Side.Left) {\r\n      return Side.Right;\r\n    }\r\n    if (side === Side.Right) {\r\n      return Side.Left;\r\n    }\r\n\r\n    return Side.None;\r\n  }\r\n\r\n  /**\r\n   * Given a vector, return the Side most in that direction (via dot product)\r\n   */\r\n  export function fromDirection(direction: Vector): Side {\r\n    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];\r\n    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];\r\n\r\n    let max = -Number.MAX_VALUE;\r\n    let maxIndex = -1;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      if (directions[i].dot(direction) > max) {\r\n        max = directions[i].dot(direction);\r\n        maxIndex = i;\r\n      }\r\n    }\r\n    return directionEnum[maxIndex];\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Ray } from '../Math/ray';\r\nimport { Color } from '../Color';\r\nimport { Side } from './Side';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { AffineMatrix } from '../Math/affine-matrix';\r\n\r\nexport interface BoundingBoxOptions {\r\n  left: number;\r\n  right: number;\r\n  top: number;\r\n  bottom: number;\r\n}\r\n\r\n/**\r\n * Axis Aligned collision primitive for Excalibur.\r\n */\r\nexport class BoundingBox {\r\n  public top: number;\r\n  public right: number;\r\n  public bottom: number;\r\n  public left: number;\r\n\r\n  /**\r\n   * Constructor allows passing of either an object with all coordinate components,\r\n   * or the coordinate components passed separately.\r\n   * @param leftOrOptions    Either x coordinate of the left edge or an options object\r\n   * containing the four coordinate components.\r\n   * @param top     y coordinate of the top edge\r\n   * @param right   x coordinate of the right edge\r\n   * @param bottom  y coordinate of the bottom edge\r\n   */\r\n  constructor(leftOrOptions: number | BoundingBoxOptions = 0, top: number = 0, right: number = 0, bottom: number = 0) {\r\n    if (typeof leftOrOptions === 'object') {\r\n      this.left = leftOrOptions.left;\r\n      this.top = leftOrOptions.top;\r\n      this.right = leftOrOptions.right;\r\n      this.bottom = leftOrOptions.bottom;\r\n    } else if (typeof leftOrOptions === 'number') {\r\n      this.left = leftOrOptions;\r\n      this.top = top;\r\n      this.right = right;\r\n      this.bottom = bottom;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of [[BoundingBox]] that is a copy of the current instance\r\n   */\r\n  public clone(): BoundingBox {\r\n    return new BoundingBox(this.left, this.top, this.right, this.bottom);\r\n  }\r\n\r\n  /**\r\n   * Given bounding box A & B, returns the side relative to A when intersection is performed.\r\n   * @param intersection Intersection vector between 2 bounding boxes\r\n   */\r\n  public static getSideFromIntersection(intersection: Vector): Side {\r\n    if (!intersection) {\r\n      return Side.None;\r\n    }\r\n    if (intersection) {\r\n      if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\r\n        if (intersection.x < 0) {\r\n          return Side.Right;\r\n        }\r\n        return Side.Left;\r\n      } else {\r\n        if (intersection.y < 0) {\r\n          return Side.Bottom;\r\n        }\r\n        return Side.Top;\r\n      }\r\n    }\r\n    return Side.None;\r\n  }\r\n\r\n  public static fromPoints(points: Vector[]): BoundingBox {\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n    for (let i = 0; i < points.length; i++) {\r\n      if (points[i].x < minX) {\r\n        minX = points[i].x;\r\n      }\r\n      if (points[i].x > maxX) {\r\n        maxX = points[i].x;\r\n      }\r\n      if (points[i].y < minY) {\r\n        minY = points[i].y;\r\n      }\r\n      if (points[i].y > maxY) {\r\n        maxY = points[i].y;\r\n      }\r\n    }\r\n    return new BoundingBox(minX, minY, maxX, maxY);\r\n  }\r\n\r\n  public static fromDimension(width: number, height: number, anchor: Vector = Vector.Half, pos: Vector = Vector.Zero) {\r\n    return new BoundingBox(\r\n      -width * anchor.x + pos.x,\r\n      -height * anchor.y + pos.y,\r\n      width - width * anchor.x + pos.x,\r\n      height - height * anchor.y + pos.y\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the calculated width of the bounding box\r\n   */\r\n  public get width() {\r\n    return this.right - this.left;\r\n  }\r\n\r\n  /**\r\n   * Returns the calculated height of the bounding box\r\n   */\r\n  public get height() {\r\n    return this.bottom - this.top;\r\n  }\r\n\r\n  /**\r\n   * Return whether the bounding box has zero dimensions in height,width or both\r\n   */\r\n  public hasZeroDimensions() {\r\n    return this.width === 0 || this.height === 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the center of the bounding box\r\n   */\r\n  public get center(): Vector {\r\n    return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n  }\r\n\r\n  public translate(pos: Vector): BoundingBox {\r\n    return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);\r\n  }\r\n\r\n  /**\r\n   * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding\r\n   * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.\r\n   */\r\n  public rotate(angle: number, point: Vector = Vector.Zero): BoundingBox {\r\n    const points = this.getPoints().map((p) => p.rotate(angle, point));\r\n    return BoundingBox.fromPoints(points);\r\n  }\r\n\r\n  /**\r\n   * Scale a bounding box by a scale factor, optionally provide a point\r\n   * @param scale\r\n   * @param point\r\n   */\r\n  public scale(scale: Vector, point: Vector = Vector.Zero): BoundingBox {\r\n    const shifted = this.translate(point);\r\n    return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);\r\n  }\r\n\r\n  /**\r\n   * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box\r\n   * @param matrix\r\n   */\r\n  public transform(matrix: AffineMatrix) {\r\n    // inlined these calculations to not use vectors would speed it up slightly\r\n    // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);\r\n    // const xa = matFirstColumn.scale(this.left);\r\n    const xa1 = matrix.data[0] * this.left;\r\n    const xa2 = matrix.data[1] * this.left;\r\n\r\n    // const xb = matFirstColumn.scale(this.right);\r\n    const xb1 = matrix.data[0] * this.right;\r\n    const xb2 = matrix.data[1] * this.right;\r\n\r\n    // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);\r\n    // const ya = matSecondColumn.scale(this.top);\r\n    const ya1 = matrix.data[2] * this.top;\r\n    const ya2 = matrix.data[3] * this.top;\r\n\r\n    // const yb = matSecondColumn.scale(this.bottom);\r\n    const yb1 = matrix.data[2] * this.bottom;\r\n    const yb2 = matrix.data[3] * this.bottom;\r\n\r\n    const matrixPos = matrix.getPosition();\r\n    // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);\r\n    // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);\r\n    const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;\r\n    const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;\r\n    const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;\r\n    const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;\r\n\r\n    return new BoundingBox({\r\n      left,//: topLeft.x,\r\n      top,//: topLeft.y,\r\n      right,//: bottomRight.x,\r\n      bottom//: bottomRight.y\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the perimeter of the bounding box\r\n   */\r\n  public getPerimeter(): number {\r\n    const wx = this.width;\r\n    const wy = this.height;\r\n    return 2 * (wx + wy);\r\n  }\r\n\r\n  public getPoints(): Vector[] {\r\n    const results = [];\r\n    results.push(new Vector(this.left, this.top));\r\n    results.push(new Vector(this.right, this.top));\r\n    results.push(new Vector(this.right, this.bottom));\r\n    results.push(new Vector(this.left, this.bottom));\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Determines whether a ray intersects with a bounding box\r\n   */\r\n  public rayCast(ray: Ray, farClipDistance = Infinity): boolean {\r\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n    let tmin = -Infinity;\r\n    let tmax = +Infinity;\r\n\r\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n\r\n    const tx1 = (this.left - ray.pos.x) * xinv;\r\n    const tx2 = (this.right - ray.pos.x) * xinv;\r\n    tmin = Math.min(tx1, tx2);\r\n    tmax = Math.max(tx1, tx2);\r\n\r\n    const ty1 = (this.top - ray.pos.y) * yinv;\r\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n\r\n    return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\r\n  }\r\n\r\n  public rayCastTime(ray: Ray, farClipDistance = Infinity): number {\r\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n    let tmin = -Infinity;\r\n    let tmax = +Infinity;\r\n\r\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n\r\n    const tx1 = (this.left - ray.pos.x) * xinv;\r\n    const tx2 = (this.right - ray.pos.x) * xinv;\r\n    tmin = Math.min(tx1, tx2);\r\n    tmax = Math.max(tx1, tx2);\r\n\r\n    const ty1 = (this.top - ray.pos.y) * yinv;\r\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n\r\n    if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {\r\n      return tmin;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a point is contained within the bounding box\r\n   * @param p  The point to test\r\n   */\r\n  public contains(p: Vector): boolean;\r\n\r\n  /**\r\n   * Tests whether another bounding box is totally contained in this one\r\n   * @param bb  The bounding box to test\r\n   */\r\n  public contains(bb: BoundingBox): boolean;\r\n  public contains(val: any): boolean {\r\n    if (val instanceof Vector) {\r\n      return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;\r\n    } else if (val instanceof BoundingBox) {\r\n      if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Combines this bounding box and another together returning a new bounding box\r\n   * @param other  The bounding box to combine\r\n   */\r\n  public combine(other: BoundingBox): BoundingBox {\r\n    const compositeBB = new BoundingBox(\r\n      Math.min(this.left, other.left),\r\n      Math.min(this.top, other.top),\r\n      Math.max(this.right, other.right),\r\n      Math.max(this.bottom, other.bottom)\r\n    );\r\n    return compositeBB;\r\n  }\r\n\r\n  public get dimensions(): Vector {\r\n    return new Vector(this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the bounding boxes overlap.\r\n   * @param other\r\n   * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.\r\n   * This epsilon is useful in stable collision simulations.\r\n   */\r\n  public overlaps(other: BoundingBox, epsilon?: number): boolean {\r\n    const e = epsilon || 0;\r\n    if (other.hasZeroDimensions()){\r\n      return this.contains(other);\r\n    }\r\n    if (this.hasZeroDimensions()) {\r\n      return other.contains(this);\r\n    }\r\n    const totalBoundingBox = this.combine(other);\r\n    return totalBoundingBox.width + e < other.width + this.width &&\r\n           totalBoundingBox.height + e < other.height + this.height;\r\n  }\r\n\r\n  /**\r\n   * Test wether this bounding box intersects with another returning\r\n   * the intersection vector that can be used to resolve the collision. If there\r\n   * is no intersection null is returned.\r\n   *\r\n   * @param other  Other [[BoundingBox]] to test intersection with\r\n   * @returns A Vector in the direction of the current BoundingBox, this <- other\r\n   */\r\n  public intersect(other: BoundingBox): Vector {\r\n    const totalBoundingBox = this.combine(other);\r\n\r\n    // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision\r\n    if (\r\n      totalBoundingBox.width < other.width + this.width &&\r\n      totalBoundingBox.height < other.height + this.height &&\r\n      !totalBoundingBox.dimensions.equals(other.dimensions) &&\r\n      !totalBoundingBox.dimensions.equals(this.dimensions)\r\n    ) {\r\n      // collision\r\n      let overlapX = 0;\r\n      // right edge is between the other's left and right edge\r\n      /**\r\n       *     +-this-+\r\n       *     |      |\r\n       *     |    +-other-+\r\n       *     +----|-+     |\r\n       *          |       |\r\n       *          +-------+\r\n       *         <---\r\n       *          ^ overlap\r\n       */\r\n      if (this.right >= other.left && this.right <= other.right) {\r\n        overlapX = other.left - this.right;\r\n        // right edge is past the other's right edge\r\n        /**\r\n         *     +-other-+\r\n         *     |       |\r\n         *     |    +-this-+\r\n         *     +----|--+   |\r\n         *          |      |\r\n         *          +------+\r\n         *          --->\r\n         *          ^ overlap\r\n         */\r\n      } else {\r\n        overlapX = other.right - this.left;\r\n      }\r\n\r\n      let overlapY = 0;\r\n      // top edge is between the other's top and bottom edge\r\n      /**\r\n       *     +-other-+\r\n       *     |       |\r\n       *     |    +-this-+   | <- overlap\r\n       *     +----|--+   |   |\r\n       *          |      |  \\ /\r\n       *          +------+   '\r\n       */\r\n      if (this.top <= other.bottom && this.top >= other.top) {\r\n        overlapY = other.bottom - this.top;\r\n        // top edge is above the other top edge\r\n        /**\r\n         *     +-this-+         .\r\n         *     |      |        / \\\r\n         *     |    +-other-+   | <- overlap\r\n         *     +----|-+     |   |\r\n         *          |       |\r\n         *          +-------+\r\n         */\r\n      } else {\r\n        overlapY = other.top - this.bottom;\r\n      }\r\n\r\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n        return new Vector(overlapX, 0);\r\n      } else {\r\n        return new Vector(0, overlapY);\r\n      }\r\n      // Case of total containment of one bounding box by another\r\n    } else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {\r\n      let overlapX = 0;\r\n      // this is wider than the other\r\n      if (this.width - other.width >= 0) {\r\n        // This right edge is closest to the others right edge\r\n        if (this.right - other.right <= other.left - this.left) {\r\n          overlapX = other.left - this.right;\r\n          // This left edge is closest to the others left edge\r\n        } else {\r\n          overlapX = other.right - this.left;\r\n        }\r\n        // other is wider than this\r\n      } else {\r\n        // This right edge is closest to the others right edge\r\n        if (other.right - this.right <= this.left - other.left) {\r\n          overlapX = this.left - other.right;\r\n          // This left edge is closest to the others left edge\r\n        } else {\r\n          overlapX = this.right - other.left;\r\n        }\r\n      }\r\n\r\n      let overlapY = 0;\r\n      // this is taller than other\r\n      if (this.height - other.height >= 0) {\r\n        // The bottom edge is closest to the others bottom edge\r\n        if (this.bottom - other.bottom <= other.top - this.top) {\r\n          overlapY = other.top - this.bottom;\r\n        } else {\r\n          overlapY = other.bottom - this.top;\r\n        }\r\n        // other is taller than this\r\n      } else {\r\n        // The bottom edge is closest to the others bottom edge\r\n        if (other.bottom - this.bottom <= this.top - other.top) {\r\n          overlapY = this.top - other.bottom;\r\n        } else {\r\n          overlapY = this.bottom - other.top;\r\n        }\r\n      }\r\n\r\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n        return new Vector(overlapX, 0);\r\n      } else {\r\n        return new Vector(0, overlapY);\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.\r\n   * @param bb The other actor to test\r\n   */\r\n  public intersectWithSide(bb: BoundingBox): Side {\r\n    const intersect = this.intersect(bb);\r\n    return BoundingBox.getSideFromIntersection(intersect);\r\n  }\r\n\r\n  /**\r\n   * Draw a debug bounding box\r\n   * @param ex\r\n   * @param color\r\n   */\r\n  public draw(ex: ExcaliburGraphicsContext, color: Color = Color.Yellow) {\r\n    ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });\r\n  }\r\n}\r\n","\r\n/**\r\n * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time\r\n */\r\nexport class Future<T> {\r\n  // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e\r\n  private _resolver: (value: T) => void;\r\n  private _rejecter: (error: Error) => void;\r\n  private _isCompleted: boolean = false;\r\n\r\n  constructor() {\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this._resolver = resolve;\r\n      this._rejecter = reject;\r\n    });\r\n  }\r\n\r\n  public readonly promise: Promise<T>;\r\n\r\n  public get isCompleted(): boolean {\r\n    return this._isCompleted;\r\n  }\r\n\r\n  public resolve(value: T): void {\r\n    if (this._isCompleted) {\r\n      return;\r\n    }\r\n    this._isCompleted = true;\r\n    this._resolver(value);\r\n  }\r\n\r\n  public reject(error: Error): void {\r\n    if (this._isCompleted) {\r\n      return;\r\n    }\r\n    this._isCompleted = true;\r\n    this._rejecter(error);\r\n  }\r\n}","import { Vector } from '../Math/vector';\r\nimport { Clock } from './Clock';\r\nimport { Future } from './Future';\r\n\r\n/**\r\n * Find the screen position of an HTML element\r\n */\r\nexport function getPosition(el: HTMLElement): Vector {\r\n  let oLeft: number = 0,\r\n    oTop: number = 0;\r\n\r\n  const calcOffsetLeft = (parent: HTMLElement) => {\r\n    oLeft += parent.offsetLeft;\r\n\r\n    if (parent.offsetParent) {\r\n      calcOffsetLeft(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n  const calcOffsetTop = (parent: HTMLElement) => {\r\n    oTop += parent.offsetTop;\r\n    if (parent.offsetParent) {\r\n      calcOffsetTop(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n\r\n  calcOffsetLeft(el);\r\n  calcOffsetTop(el);\r\n\r\n  return new Vector(oLeft, oTop);\r\n}\r\n\r\n/**\r\n * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function addItemToArray<T>(item: T, array: T[]): boolean {\r\n  if (array.indexOf(item) === -1) {\r\n    array.push(item);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Remove an item from an list\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function removeItemFromArray<T>(item: T, array: T[]): boolean {\r\n  let index = -1;\r\n  if ((index = array.indexOf(item)) > -1) {\r\n    array.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * See if an array contains something\r\n */\r\nexport function contains(array: Array<any>, obj: any): boolean {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (array[i] === obj) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Used for exhaustive checks at compile time\r\n */\r\nexport function fail(message: never): never {\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Create a promise that resolves after a certain number of milliseconds\r\n *\r\n * It is strongly recommended you pass the excalibur clock so delays are bound to the\r\n * excalibur clock which would be unaffected by stop/pause.\r\n * @param milliseconds\r\n * @param clock\r\n */\r\nexport function delay(milliseconds: number, clock?: Clock): Promise<void> {\r\n  const future = new Future<void>();\r\n  const schedule = clock?.schedule.bind(clock) ?? setTimeout;\r\n  schedule(() => {\r\n    future.resolve();\r\n  }, milliseconds);\r\n  return future.promise;\r\n}\r\n","import { sign } from './util';\r\nimport { Vector, vec } from './vector';\r\nimport { canonicalizeAngle } from './util';\r\n\r\nexport enum MatrixLocations {\r\n  X = 12,\r\n  Y = 13\r\n}\r\n\r\n/**\r\n * Excalibur Matrix helper for 4x4 matrices\r\n *\r\n * Useful for webgl 4x4 matrices\r\n */\r\nexport class Matrix {\r\n  /**\r\n   *  4x4 matrix in column major order\r\n   *\r\n   * |         |         |          |          |\r\n   * | ------- | ------- | -------- | -------- |\r\n   * | data[0] | data[4] | data[8]  | data[12] |\r\n   * | data[1] | data[5] | data[9]  | data[13] |\r\n   * | data[2] | data[6] | data[10] | data[14] |\r\n   * | data[3] | data[7] | data[11] | data[15] |\r\n   *\r\n   */\r\n  public data: Float32Array = new Float32Array(16);\r\n\r\n  /**\r\n   * Creates an orthographic (flat non-perspective) projection\r\n   * https://en.wikipedia.org/wiki/Orthographic_projection\r\n   * @param left\r\n   * @param right\r\n   * @param bottom\r\n   * @param top\r\n   * @param near\r\n   * @param far\r\n   */\r\n  public static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix {\r\n    const mat = new Matrix();\r\n    mat.data[0] = 2 / (right - left);\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 2 / (top - bottom);\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = -2 / (far - near);\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = -(right + left) / (right - left);\r\n    mat.data[13] = -(top + bottom) / (top - bottom);\r\n    mat.data[14] = -(far + near) / (far - near);\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Matrix with the same data as the current 4x4\r\n   */\r\n  public clone(dest?: Matrix): Matrix {\r\n    const mat = dest || new Matrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n    mat.data[2] = this.data[2];\r\n    mat.data[3] = this.data[3];\r\n\r\n    mat.data[4] = this.data[4];\r\n    mat.data[5] = this.data[5];\r\n    mat.data[6] = this.data[6];\r\n    mat.data[7] = this.data[7];\r\n\r\n    mat.data[8] = this.data[8];\r\n    mat.data[9] = this.data[9];\r\n    mat.data[10] = this.data[10];\r\n    mat.data[11] = this.data[11];\r\n\r\n    mat.data[12] = this.data[12];\r\n    mat.data[13] = this.data[13];\r\n    mat.data[14] = this.data[14];\r\n    mat.data[15] = this.data[15];\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Converts the current matrix into a DOMMatrix\r\n   *\r\n   * This is useful when working with the browser Canvas context\r\n   * @returns {DOMMatrix} DOMMatrix\r\n   */\r\n  public toDOMMatrix(): DOMMatrix {\r\n    return new DOMMatrix([...this.data]);\r\n  }\r\n\r\n  public static fromFloat32Array(data: Float32Array) {\r\n    const matrix =  new Matrix();\r\n    matrix.data = data;\r\n    return matrix;\r\n  }\r\n\r\n  /**\r\n   * Creates a new identity matrix (a matrix that when applied does nothing)\r\n   */\r\n  public static identity(): Matrix {\r\n    const mat = new Matrix();\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 1;\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = 0;\r\n    mat.data[13] = 0;\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Resets the current matrix to the identity matrix, mutating it\r\n   * @returns {Matrix} Current matrix as identity\r\n   */\r\n  public reset(): Matrix {\r\n    const mat = this;\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 1;\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = 0;\r\n    mat.data[13] = 0;\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new translation matrix at the specified 3d point\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public static translation(x: number, y: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[12] = x;\r\n    mat.data[13] = y;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new scaling matrix with the specified scaling factor\r\n   * @param sx\r\n   * @param sy\r\n   */\r\n  public static scale(sx: number, sy: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[0] = sx;\r\n    mat.data[5] = sy;\r\n    mat.data[10] = 1;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new rotation matrix with the specified angle\r\n   * @param angleRadians\r\n   */\r\n  public static rotation(angleRadians: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[0] = Math.cos(angleRadians);\r\n    mat.data[4] = -Math.sin(angleRadians);\r\n    mat.data[1] = Math.sin(angleRadians);\r\n    mat.data[5] = Math.cos(angleRadians);\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Multiply the current matrix by a vector producing a new vector\r\n   * @param vector\r\n   * @param dest\r\n   */\r\n  multiply(vector: Vector, dest?: Vector): Vector;\r\n  /**\r\n   * Multiply the current matrix by another matrix producing a new matrix\r\n   * @param matrix\r\n   * @param dest\r\n   */\r\n  multiply(matrix: Matrix, dest?: Matrix): Matrix;\r\n  multiply(vectorOrMatrix: Vector | Matrix, dest?: Vector | Matrix): Vector | Matrix {\r\n    if (vectorOrMatrix instanceof Vector) {\r\n      const result = (dest as Vector) || new Vector(0, 0);\r\n      const vector = vectorOrMatrix;\r\n      // these shenanigans are to allow dest and vector to be the same instance\r\n      const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];\r\n      const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];\r\n\r\n      result.x = resultX;\r\n      result.y = resultY;\r\n      return result;\r\n    } else {\r\n      const result = (dest as Matrix) || new Matrix();\r\n      const other = vectorOrMatrix;\r\n      const a11 = this.data[0];\r\n      const a21 = this.data[1];\r\n      const a31 = this.data[2];\r\n      const a41 = this.data[3];\r\n\r\n      const a12 = this.data[4];\r\n      const a22 = this.data[5];\r\n      const a32 = this.data[6];\r\n      const a42 = this.data[7];\r\n\r\n      const a13 = this.data[8];\r\n      const a23 = this.data[9];\r\n      const a33 = this.data[10];\r\n      const a43 = this.data[11];\r\n\r\n      const a14 = this.data[12];\r\n      const a24 = this.data[13];\r\n      const a34 = this.data[14];\r\n      const a44 = this.data[15];\r\n\r\n      const b11 = other.data[0];\r\n      const b21 = other.data[1];\r\n      const b31 = other.data[2];\r\n      const b41 = other.data[3];\r\n\r\n      const b12 = other.data[4];\r\n      const b22 = other.data[5];\r\n      const b32 = other.data[6];\r\n      const b42 = other.data[7];\r\n\r\n      const b13 = other.data[8];\r\n      const b23 = other.data[9];\r\n      const b33 = other.data[10];\r\n      const b43 = other.data[11];\r\n\r\n      const b14 = other.data[12];\r\n      const b24 = other.data[13];\r\n      const b34 = other.data[14];\r\n      const b44 = other.data[15];\r\n\r\n      result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n      result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n      result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n      result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\r\n      result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n      result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n      result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n      result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\r\n      result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n      result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n      result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n      result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\r\n      result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n      result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n      result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n      result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n      const s = this.getScale();\r\n      result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n      result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Applies translation to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    const a13 = this.data[8];\r\n    const a23 = this.data[9];\r\n    const a33 = this.data[10];\r\n    const a43 = this.data[11];\r\n\r\n    const a14 = this.data[12];\r\n    const a24 = this.data[13];\r\n    const a34 = this.data[14];\r\n    const a44 = this.data[15];\r\n\r\n    // Doesn't change z\r\n    const z = 0;\r\n    const w = 1;\r\n    this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;\r\n    this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;\r\n    this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;\r\n    this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;\r\n\r\n    return this;\r\n  }\r\n\r\n  public setPosition(x: number, y: number) {\r\n    this.data[12] = x;\r\n    this.data[13] = y;\r\n  }\r\n\r\n  public getPosition(): Vector {\r\n    return vec(this.data[12], this.data[13]);\r\n  }\r\n\r\n  /**\r\n   * Applies rotation to the current matrix mutating it\r\n   * @param angle in Radians\r\n   */\r\n  rotate(angle: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * a11 + sine * a12;\r\n    this.data[1] = cosine * a21 + sine * a22;\r\n    this.data[2] = cosine * a31 + sine * a32;\r\n    this.data[3] = cosine * a41 + sine * a42;\r\n\r\n    this.data[4] = cosine * a12 - sine * a11;\r\n    this.data[5] = cosine * a22 - sine * a21;\r\n    this.data[6] = cosine * a32 - sine * a31;\r\n    this.data[7] = cosine * a42 - sine * a41;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies scaling to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    this.data[0] = a11 * x;\r\n    this.data[1] = a21 * x;\r\n    this.data[2] = a31 * x;\r\n    this.data[3] = a41 * x;\r\n\r\n    this.data[4] = a12 * y;\r\n    this.data[5] = a22 * y;\r\n    this.data[6] = a32 * y;\r\n    this.data[7] = a42 * y;\r\n\r\n    return this;\r\n  }\r\n\r\n  public setRotation(angle: number) {\r\n    const currentScale = this.getScale();\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * currentScale.x;\r\n    this.data[1] = sine * currentScale.y;\r\n    this.data[4] = -sine * currentScale.x;\r\n    this.data[5] = cosine * currentScale.y;\r\n  }\r\n\r\n  public getRotation(): number {\r\n    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n    return canonicalizeAngle(angle);\r\n  }\r\n\r\n  public getScaleX(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const xscale = vec(this.data[0], this.data[4]).size;\r\n    return this._scaleSignX * xscale;\r\n  }\r\n\r\n  public getScaleY(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const yscale = vec(this.data[1], this.data[5]).size;\r\n    return this._scaleSignY * yscale;\r\n  }\r\n\r\n  /**\r\n   * Get the scale of the matrix\r\n   */\r\n  public getScale(): Vector {\r\n    return vec(this.getScaleX(), this.getScaleY());\r\n  }\r\n\r\n  private _scaleX = 1;\r\n  private _scaleSignX = 1;\r\n  public setScaleX(val: number) {\r\n    if (this._scaleX === val) {\r\n      return;\r\n    }\r\n\r\n    this._scaleSignX = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();\r\n    this.data[0] = xscale.x * val;\r\n    this.data[4] = xscale.y * val;\r\n    this._scaleX = val;\r\n  }\r\n\r\n  private _scaleY = 1;\r\n  private _scaleSignY = 1;\r\n  public setScaleY(val: number) {\r\n    if (this._scaleY === val) {\r\n      return;\r\n    }\r\n    this._scaleSignY = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();\r\n    this.data[1] = yscale.x * val;\r\n    this.data[5] = yscale.y * val;\r\n    this._scaleY = val;\r\n  }\r\n\r\n  public setScale(scale: Vector) {\r\n    this.setScaleX(scale.x);\r\n    this.setScaleY(scale.y);\r\n  }\r\n\r\n  /**\r\n   * Determinant of the upper left 2x2 matrix\r\n   */\r\n  public getBasisDeterminant() {\r\n    return this.data[0] * this.data[5] - this.data[1] * this.data[4];\r\n  }\r\n\r\n  /**\r\n   * Return the affine inverse, optionally store it in a target matrix.\r\n   *\r\n   * It's recommended you call .reset() the target unless you know what you're doing\r\n   * @param target\r\n   */\r\n  public getAffineInverse(target?: Matrix): Matrix {\r\n    // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n    // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n    // Since we are actually only doing 2D transformations we can use this hack\r\n    // We don't actually use the 3rd or 4th dimension\r\n\r\n    const det = this.getBasisDeterminant();\r\n    const inverseDet = 1 / det; // todo zero check\r\n    const a = this.data[0];\r\n    const b = this.data[4];\r\n    const c = this.data[1];\r\n    const d = this.data[5];\r\n\r\n    const m = target || Matrix.identity();\r\n    // inverts rotation and scale\r\n    m.data[0] = d * inverseDet;\r\n    m.data[1] = -c * inverseDet;\r\n    m.data[4] = -b * inverseDet;\r\n    m.data[5] = a * inverseDet;\r\n\r\n    const tx = this.data[12];\r\n    const ty = this.data[13];\r\n    // invert translation\r\n    // transform translation into the matrix basis created by rot/scale\r\n    m.data[12] = -(tx * m.data[0] + ty * m.data[4]);\r\n    m.data[13] = -(tx * m.data[1] + ty * m.data[5]);\r\n\r\n    return m;\r\n  }\r\n\r\n  public isIdentity(): boolean {\r\n    return (\r\n      this.data[0] === 1 &&\r\n      this.data[1] === 0 &&\r\n      this.data[2] === 0 &&\r\n      this.data[3] === 0 &&\r\n      this.data[4] === 0 &&\r\n      this.data[5] === 1 &&\r\n      this.data[6] === 0 &&\r\n      this.data[7] === 0 &&\r\n      this.data[8] === 0 &&\r\n      this.data[9] === 0 &&\r\n      this.data[10] === 1 &&\r\n      this.data[11] === 0 &&\r\n      this.data[12] === 0 &&\r\n      this.data[13] === 0 &&\r\n      this.data[14] === 0 &&\r\n      this.data[15] === 1\r\n    );\r\n  }\r\n\r\n  public toString() {\r\n    return `\r\n[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]\r\n[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]\r\n[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]\r\n[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]\r\n`;\r\n  }\r\n}\r\n","import { Matrix } from './matrix';\r\nimport { canonicalizeAngle, sign } from './util';\r\nimport { vec, Vector } from './vector';\r\n\r\n\r\nexport class AffineMatrix {\r\n  /**\r\n   * |         |         |          |\r\n   * | ------- | ------- | -------- |\r\n   * | data[0] | data[2] | data[4]  |\r\n   * | data[1] | data[3] | data[5]  |\r\n   * |   0     |    0    |    1     |\r\n   */\r\n  public data = new Float64Array(6);\r\n\r\n  /**\r\n   * Converts the current matrix into a DOMMatrix\r\n   *\r\n   * This is useful when working with the browser Canvas context\r\n   * @returns {DOMMatrix} DOMMatrix\r\n   */\r\n  public toDOMMatrix(): DOMMatrix {\r\n    return new DOMMatrix([...this.data]);\r\n  }\r\n\r\n  public static identity(): AffineMatrix {\r\n    const mat = new AffineMatrix();\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 1;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 0;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new translation matrix at the specified 3d point\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public static translation(x: number, y: number): AffineMatrix {\r\n    const mat = AffineMatrix.identity();\r\n    mat.data[4] = x;\r\n    mat.data[5] = y;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new scaling matrix with the specified scaling factor\r\n   * @param sx\r\n   * @param sy\r\n   */\r\n  public static scale(sx: number, sy: number): AffineMatrix {\r\n    const mat = AffineMatrix.identity();\r\n    mat.data[0] = sx;\r\n    mat.data[3] = sy;\r\n    mat._scale[0] = sx;\r\n    mat._scale[1] = sy;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new rotation matrix with the specified angle\r\n   * @param angleRadians\r\n   */\r\n  public static rotation(angleRadians: number): AffineMatrix {\r\n    const mat = AffineMatrix.identity();\r\n    mat.data[0] = Math.cos(angleRadians);\r\n    mat.data[1] = Math.sin(angleRadians);\r\n    mat.data[2] = -Math.sin(angleRadians);\r\n    mat.data[3] = Math.cos(angleRadians);\r\n    return mat;\r\n  }\r\n\r\n  public setPosition(x: number, y: number) {\r\n    this.data[4] = x;\r\n    this.data[5] = y;\r\n  }\r\n\r\n  public getPosition(): Vector {\r\n    return vec(this.data[4], this.data[5]);\r\n  }\r\n\r\n  /**\r\n   * Applies rotation to the current matrix mutating it\r\n   * @param angle in Radians\r\n   */\r\n  rotate(angle: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n\r\n    const a12 = this.data[2];\r\n    const a22 = this.data[3];\r\n\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * a11 + sine * a12;\r\n    this.data[1] = cosine * a21 + sine * a22;\r\n\r\n    this.data[2] = cosine * a12 - sine * a11;\r\n    this.data[3] = cosine * a22 - sine * a21;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies translation to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    // const a31 = 0;\r\n\r\n    const a12 = this.data[2];\r\n    const a22 = this.data[3];\r\n    // const a32 = 0;\r\n\r\n    const a13 = this.data[4];\r\n    const a23 = this.data[5];\r\n    // const a33 = 1;\r\n\r\n    // Doesn't change z\r\n    this.data[4] = a11 * x + a12 * y + a13;\r\n    this.data[5] = a21 * x + a22 * y + a23;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies scaling to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n\r\n    const a12 = this.data[2];\r\n    const a22 = this.data[3];\r\n\r\n    this.data[0] = a11 * x;\r\n    this.data[1] = a21 * x;\r\n\r\n    this.data[2] = a12 * y;\r\n    this.data[3] = a22 * y;\r\n\r\n    this._scale[0] = x;\r\n    this._scale[1] = y;\r\n    return this;\r\n  }\r\n\r\n  public determinant() {\r\n    return this.data[0] * this.data[3] - this.data[1] * this.data[2];\r\n  }\r\n\r\n  /**\r\n   * Return the affine inverse, optionally store it in a target matrix.\r\n   *\r\n   * It's recommended you call .reset() the target unless you know what you're doing\r\n   * @param target\r\n   */\r\n  public inverse(target?: AffineMatrix): AffineMatrix {\r\n    // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n    // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n    // Since we are actually only doing 2D transformations we can use this hack\r\n    // We don't actually use the 3rd or 4th dimension\r\n\r\n    const det = this.determinant();\r\n    const inverseDet = 1 / det; // TODO zero check\r\n    const a = this.data[0];\r\n    const b = this.data[2];\r\n    const c = this.data[1];\r\n    const d = this.data[3];\r\n\r\n    const m = target || AffineMatrix.identity();\r\n    // inverts rotation and scale\r\n    m.data[0] = d * inverseDet;\r\n    m.data[1] = -c * inverseDet;\r\n    m.data[2] = -b * inverseDet;\r\n    m.data[3] = a * inverseDet;\r\n\r\n    const tx = this.data[4];\r\n    const ty = this.data[5];\r\n    // invert translation\r\n    // transform translation into the matrix basis created by rot/scale\r\n    m.data[4] = -(tx * m.data[0] + ty * m.data[2]);\r\n    m.data[5] = -(tx * m.data[1] + ty * m.data[3]);\r\n\r\n    return m;\r\n  }\r\n\r\n  /**\r\n   * Multiply the current matrix by a vector producing a new vector\r\n   * @param vector\r\n   * @param dest\r\n   */\r\n  multiply(vector: Vector, dest?: Vector): Vector;\r\n  /**\r\n   * Multiply the current matrix by another matrix producing a new matrix\r\n   * @param matrix\r\n   * @param dest\r\n   */\r\n  multiply(matrix: AffineMatrix, dest?: AffineMatrix): AffineMatrix;\r\n  multiply(vectorOrMatrix: Vector | AffineMatrix, dest?: Vector | AffineMatrix): Vector | AffineMatrix {\r\n    if (vectorOrMatrix instanceof Vector) {\r\n      const result = (dest as Vector) || new Vector(0, 0);\r\n      const vector = vectorOrMatrix;\r\n      // these shenanigans are to allow dest and vector to be the same instance\r\n      const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];\r\n      const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];\r\n\r\n      result.x = resultX;\r\n      result.y = resultY;\r\n      return result;\r\n    } else {\r\n      const result = (dest as AffineMatrix) || new AffineMatrix();\r\n      const other = vectorOrMatrix;\r\n      const a11 = this.data[0];\r\n      const a21 = this.data[1];\r\n      //  const a31 = 0;\r\n\r\n      const a12 = this.data[2];\r\n      const a22 = this.data[3];\r\n      //  const a32 = 0;\r\n\r\n      const a13 = this.data[4];\r\n      const a23 = this.data[5];\r\n      //  const a33 = 1;\r\n\r\n      const b11 = other.data[0];\r\n      const b21 = other.data[1];\r\n      //  const b31 = 0;\r\n\r\n      const b12 = other.data[2];\r\n      const b22 = other.data[3];\r\n      //  const b32 = 0;\r\n\r\n      const b13 = other.data[4];\r\n      const b23 = other.data[5];\r\n      //  const b33 = 1;\r\n\r\n\r\n      result.data[0] = a11 * b11 + a12 * b21;// + a13 * b31; // zero\r\n      result.data[1] = a21 * b11 + a22 * b21;// + a23 * b31; // zero\r\n\r\n      result.data[2] = a11 * b12 + a12 * b22;// + a13 * b32; // zero\r\n      result.data[3] = a21 * b12 + a22 * b22;// + a23 * b32; // zero\r\n\r\n      result.data[4] = a11 * b13 + a12 * b23 + a13;// * b33; // one\r\n      result.data[5] = a21 * b13 + a22 * b23 + a23;// * b33; // one\r\n\r\n      const s = this.getScale();\r\n      result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n      result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  to4x4() {\r\n    const mat = new Matrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = this.data[2];\r\n    mat.data[5] = this.data[3];\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = this.data[4];\r\n    mat.data[13] = this.data[5];\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  public setRotation(angle: number) {\r\n    const currentScale = this.getScale();\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * currentScale.x;\r\n    this.data[1] = sine * currentScale.y;\r\n    this.data[2] = -sine * currentScale.x;\r\n    this.data[3] = cosine * currentScale.y;\r\n  }\r\n\r\n  public getRotation(): number {\r\n    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n    return canonicalizeAngle(angle);\r\n  }\r\n\r\n  public getScaleX(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const xscale = vec(this.data[0], this.data[2]).distance();\r\n    return this._scaleSignX * xscale;\r\n  }\r\n\r\n  public getScaleY(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const yscale = vec(this.data[1], this.data[3]).distance();\r\n    return this._scaleSignY * yscale;\r\n  }\r\n\r\n  /**\r\n   * Get the scale of the matrix\r\n   */\r\n  public getScale(): Vector {\r\n    return vec(this.getScaleX(), this.getScaleY());\r\n  }\r\n\r\n  private _scale = new Float64Array([1, 1]);\r\n  private _scaleSignX = 1;\r\n  public setScaleX(val: number) {\r\n    if (val === this._scale[0]) {\r\n      return;\r\n    }\r\n    this._scaleSignX = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();\r\n    this.data[0] = xscale.x * val;\r\n    this.data[2] = xscale.y * val;\r\n    this._scale[0] = val;\r\n  }\r\n\r\n  private _scaleSignY = 1;\r\n  public setScaleY(val: number) {\r\n    if (val === this._scale[1]) {\r\n      return;\r\n    }\r\n    this._scaleSignY = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();\r\n    this.data[1] = yscale.x * val;\r\n    this.data[3] = yscale.y * val;\r\n    this._scale[1] = val;\r\n  }\r\n\r\n  public setScale(scale: Vector) {\r\n    this.setScaleX(scale.x);\r\n    this.setScaleY(scale.y);\r\n  }\r\n\r\n  public isIdentity(): boolean {\r\n    return (\r\n      this.data[0] === 1 &&\r\n      this.data[1] === 0 &&\r\n      this.data[2] === 0 &&\r\n      this.data[3] === 1 &&\r\n      this.data[4] === 0 &&\r\n      this.data[5] === 0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Resets the current matrix to the identity matrix, mutating it\r\n   * @returns {AffineMatrix} Current matrix as identity\r\n   */\r\n  public reset(): AffineMatrix {\r\n    const mat = this;\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 1;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 0;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Matrix with the same data as the current 4x4\r\n   */\r\n  public clone(dest?: AffineMatrix): AffineMatrix {\r\n    const mat = dest || new AffineMatrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n\r\n    mat.data[2] = this.data[2];\r\n    mat.data[3] = this.data[3];\r\n\r\n    mat.data[4] = this.data[4];\r\n    mat.data[5] = this.data[5];\r\n    return mat;\r\n  }\r\n\r\n  public toString() {\r\n    return `\r\n[${this.data[0]} ${this.data[2]} ${this.data[4]}]\r\n[${this.data[1]} ${this.data[3]} ${this.data[5]}]\r\n[0 0 1]\r\n`;\r\n  }\r\n\r\n}","import { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport class TransformStack {\r\n  private _transforms: AffineMatrix[] = [];\r\n  private _currentTransform: AffineMatrix = AffineMatrix.identity();\r\n\r\n  public save(): void {\r\n    this._transforms.push(this._currentTransform);\r\n    this._currentTransform = this._currentTransform.clone();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentTransform = this._transforms.pop();\r\n  }\r\n\r\n  public translate(x: number, y: number): AffineMatrix {\r\n    return this._currentTransform.translate(x, y);\r\n  }\r\n\r\n  public rotate(angle: number): AffineMatrix {\r\n    return this._currentTransform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): AffineMatrix {\r\n    return this._currentTransform.scale(x, y);\r\n  }\r\n\r\n  public set current(matrix: AffineMatrix) {\r\n    this._currentTransform = matrix;\r\n  }\r\n\r\n  public get current(): AffineMatrix {\r\n    return this._currentTransform;\r\n  }\r\n}\r\n","import { Color } from '../../Color';\r\nimport { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class StateStack {\r\n  private _states: ExcaliburGraphicsContextState[] = [];\r\n  private _currentState: ExcaliburGraphicsContextState = this._getDefaultState();\r\n\r\n  private _getDefaultState() {\r\n    return {\r\n      opacity: 1,\r\n      z: 0,\r\n      tint: Color.White\r\n    };\r\n  }\r\n\r\n  private _cloneState() {\r\n    return {\r\n      opacity: this._currentState.opacity,\r\n      z: this._currentState.z,\r\n      tint: this._currentState.tint.clone()\r\n    };\r\n  }\r\n\r\n  public save(): void {\r\n    this._states.push(this._currentState);\r\n    this._currentState = this._cloneState();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentState = this._states.pop();\r\n  }\r\n\r\n  public get current(): ExcaliburGraphicsContextState {\r\n    return this._currentState;\r\n  }\r\n\r\n  public set current(val: ExcaliburGraphicsContextState) {\r\n    this._currentState = val;\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { Vector } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { Trigger } from './Trigger';\r\nimport { FrameStats } from './Debug';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Side } from './Collision/Side';\r\nimport * as Input from './Input/Index';\r\nimport { CollisionContact } from './Collision/Detection/CollisionContact';\r\nimport { Collider } from './Collision/Colliders/Collider';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate, SceneActivationContext } from './Interfaces/LifecycleEvents';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { ExcaliburGraphicsContext } from './Graphics';\r\n\r\nexport enum EventTypes {\r\n  Kill = 'kill',\r\n  PreKill = 'prekill',\r\n  PostKill = 'postkill',\r\n\r\n  PreDraw = 'predraw',\r\n  PostDraw = 'postdraw',\r\n\r\n  PreDebugDraw = 'predebugdraw',\r\n  PostDebugDraw = 'postdebugdraw',\r\n\r\n  PreUpdate = 'preupdate',\r\n  PostUpdate = 'postupdate',\r\n\r\n  PreFrame = 'preframe',\r\n  PostFrame = 'postframe',\r\n\r\n  PreCollision = 'precollision',\r\n  CollisionStart = 'collisionstart',\r\n  CollisionEnd = 'collisionend',\r\n  PostCollision = 'postcollision',\r\n\r\n  Initialize = 'initialize',\r\n  Activate = 'activate',\r\n  Deactivate = 'deactivate',\r\n\r\n  ExitViewport = 'exitviewport',\r\n  EnterViewport = 'enterviewport',\r\n\r\n  ExitTrigger = 'exit',\r\n  EnterTrigger = 'enter',\r\n\r\n  Connect = 'connect',\r\n  Disconnect = 'disconnect',\r\n  Button = 'button',\r\n  Axis = 'axis',\r\n\r\n  Visible = 'visible',\r\n  Hidden = 'hidden',\r\n  Start = 'start',\r\n  Stop = 'stop',\r\n\r\n  PointerUp = 'pointerup',\r\n  PointerDown = 'pointerdown',\r\n  PointerMove = 'pointermove',\r\n  PointerEnter = 'pointerenter',\r\n  PointerLeave = 'pointerleave',\r\n  PointerCancel = 'pointercancel',\r\n  PointerWheel = 'pointerwheel',\r\n\r\n  Up = 'up',\r\n  Down = 'down',\r\n  Move = 'move',\r\n  Enter = 'enter',\r\n  Leave = 'leave',\r\n  Cancel = 'cancel',\r\n  Wheel = 'wheel',\r\n\r\n  Press = 'press',\r\n  Release = 'release',\r\n  Hold = 'hold',\r\n\r\n  PointerDragStart = 'pointerdragstart',\r\n  PointerDragEnd = 'pointerdragend',\r\n  PointerDragEnter = 'pointerdragenter',\r\n  PointerDragLeave = 'pointerdragleave',\r\n  PointerDragMove = 'pointerdragmove'\r\n}\r\n\r\n/* istanbul ignore next */\r\n/* compiler only: these are internal to lib */\r\nexport type kill = 'kill';\r\nexport type prekill = 'prekill';\r\nexport type postkill = 'postkill';\r\n\r\nexport type predraw = 'predraw';\r\nexport type postdraw = 'postdraw';\r\n\r\nexport type predebugdraw = 'predebugdraw';\r\nexport type postdebugdraw = 'postdebugdraw';\r\n\r\nexport type preupdate = 'preupdate';\r\nexport type postupdate = 'postupdate';\r\n\r\nexport type preframe = 'preframe';\r\nexport type postframe = 'postframe';\r\n\r\nexport type precollision = 'precollision';\r\nexport type collisionstart = 'collisionstart';\r\nexport type collisionend = 'collisionend';\r\nexport type postcollision = 'postcollision';\r\n\r\nexport type initialize = 'initialize';\r\nexport type activate = 'activate';\r\nexport type deactivate = 'deactivate';\r\n\r\nexport type exitviewport = 'exitviewport';\r\nexport type enterviewport = 'enterviewport';\r\n\r\nexport type exittrigger = 'exit';\r\nexport type entertrigger = 'enter';\r\n\r\nexport type connect = 'connect';\r\nexport type disconnect = 'disconnect';\r\nexport type button = 'button';\r\nexport type axis = 'axis';\r\n\r\nexport type subscribe = 'subscribe';\r\nexport type unsubscribe = 'unsubscribe';\r\n\r\nexport type visible = 'visible';\r\nexport type hidden = 'hidden';\r\nexport type start = 'start';\r\nexport type stop = 'stop';\r\n\r\nexport type pointerup = 'pointerup';\r\nexport type pointerdown = 'pointerdown';\r\nexport type pointermove = 'pointermove';\r\nexport type pointerenter = 'pointerenter';\r\nexport type pointerleave = 'pointerleave';\r\nexport type pointercancel = 'pointercancel';\r\nexport type pointerwheel = 'pointerwheel';\r\n\r\nexport type up = 'up';\r\nexport type down = 'down';\r\nexport type move = 'move';\r\nexport type enter = 'enter';\r\nexport type leave = 'leave';\r\nexport type cancel = 'cancel';\r\nexport type wheel = 'wheel';\r\n\r\nexport type press = 'press';\r\nexport type release = 'release';\r\nexport type hold = 'hold';\r\n\r\nexport type pointerdragstart = 'pointerdragstart';\r\nexport type pointerdragend = 'pointerdragend';\r\nexport type pointerdragenter = 'pointerdragenter';\r\nexport type pointerdragleave = 'pointerdragleave';\r\nexport type pointerdragmove = 'pointerdragmove';\r\n\r\n/**\r\n * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\r\n * some events are unique to a type, others are not.\r\n *\r\n */\r\nexport class GameEvent<T, U = T> {\r\n  /**\r\n   * Target object for this event.\r\n   */\r\n  public target: T;\r\n\r\n  /**\r\n   * Other target object for this event\r\n   */\r\n  public other: U | null;\r\n\r\n  /**\r\n   * If set to false, prevents event from propagating to other actors. If true it will be propagated\r\n   * to all actors that apply.\r\n   */\r\n  public get bubbles(): boolean {\r\n    return this._bubbles;\r\n  }\r\n\r\n  public set bubbles(value: boolean) {\r\n    this._bubbles = value;\r\n  }\r\n\r\n  private _bubbles: boolean = true;\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation() {\r\n    this.bubbles = false;\r\n  }\r\n}\r\n\r\n/**\r\n * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.\r\n */\r\nexport class KillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'prekill' event is emitted directly before an actor is killed.\r\n */\r\nexport class PreKillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postkill' event is emitted directly after the actor is killed.\r\n */\r\nexport class PostKillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'start' event is emitted on engine when has started and is ready for interaction.\r\n */\r\nexport class GameStartEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.\r\n */\r\nexport class GameStopEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nexport class PreDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public delta: number, public target: Entity | Scene | Engine | TileMap) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nexport class PostDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public delta: number, public target: Entity | Scene | Engine | TileMap) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.\r\n */\r\nexport class PreDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public target: Entity | Actor | Scene | Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.\r\n */\r\nexport class PostDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public target: Entity | Actor | Scene | Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.\r\n */\r\nexport class PreUpdateEvent<T extends OnPreUpdate = Entity> extends GameEvent<T> {\r\n  constructor(public engine: Engine, public delta: number, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.\r\n */\r\nexport class PostUpdateEvent<T extends OnPostUpdate = Entity> extends GameEvent<T> {\r\n  constructor(public engine: Engine, public delta: number, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'preframe' event is emitted on the engine, before the frame begins.\r\n */\r\nexport class PreFrameEvent extends GameEvent<Engine> {\r\n  constructor(public engine: Engine, public prevStats: FrameStats) {\r\n    super();\r\n    this.target = engine;\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postframe' event is emitted on the engine, after a frame ends.\r\n */\r\nexport class PostFrameEvent extends GameEvent<Engine> {\r\n  constructor(public engine: Engine, public stats: FrameStats) {\r\n    super();\r\n    this.target = engine;\r\n  }\r\n}\r\n\r\n/**\r\n * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\r\n */\r\nexport class GamepadConnectEvent extends GameEvent<Input.Gamepad> {\r\n  constructor(public index: number, public gamepad: Input.Gamepad) {\r\n    super();\r\n    this.target = gamepad;\r\n  }\r\n}\r\n\r\n/**\r\n * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\r\n */\r\nexport class GamepadDisconnectEvent extends GameEvent<Input.Gamepad> {\r\n  constructor(public index: number, public gamepad: Input.Gamepad) {\r\n    super();\r\n    this.target = gamepad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nexport class GamepadButtonEvent extends GameEvent<Input.Gamepad> {\r\n  /**\r\n   * @param button  The Gamepad button\r\n   * @param value   A numeric value between 0 and 1\r\n   */\r\n  constructor(public button: Input.Buttons, public value: number, public target: Input.Gamepad) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nexport class GamepadAxisEvent extends GameEvent<Input.Gamepad> {\r\n  /**\r\n   * @param axis  The Gamepad axis\r\n   * @param value A numeric value between -1 and 1\r\n   */\r\n  constructor(public axis: Input.Axes, public value: number, public target: Input.Gamepad) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event received by the [[Engine]] when the browser window is visible on a screen.\r\n */\r\nexport class VisibleEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event received by the [[Engine]] when the browser window is hidden from all screens.\r\n */\r\nexport class HiddenEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\r\n */\r\nexport class PreCollisionEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   * @param actor         The actor the event was thrown on\r\n   * @param other         The actor that will collided with the current actor\r\n   * @param side          The side that will be collided with the current actor\r\n   * @param intersection  Intersection vector\r\n   */\r\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\r\n */\r\nexport class PostCollisionEvent<T extends Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   * @param actor         The actor the event was thrown on\r\n   * @param other         The actor that did collide with the current actor\r\n   * @param side          The side that did collide with the current actor\r\n   * @param intersection  Intersection vector\r\n   */\r\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\nexport class ContactStartEvent<T> {\r\n  constructor(public target: T, public other: T, public contact: CollisionContact) {}\r\n}\r\n\r\nexport class ContactEndEvent<T> {\r\n  constructor(public target: T, public other: T) {}\r\n}\r\n\r\nexport class CollisionPreSolveEvent<T> {\r\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\r\n}\r\n\r\nexport class CollisionPostSolveEvent<T> {\r\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\r\n}\r\n\r\n/**\r\n * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\r\n */\r\nexport class CollisionStartEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   *\r\n   * @param actor\r\n   * @param other\r\n   * @param contact\r\n   */\r\n  constructor(actor: T, public other: T, public contact: CollisionContact) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown when the [[Actor|actor]] is no longer colliding with another\r\n */\r\nexport class CollisionEndEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   *\r\n   */\r\n  constructor(actor: T, public other: T) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\r\n */\r\nexport class InitializeEvent<T extends OnInitialize = Entity> extends GameEvent<T> {\r\n  /**\r\n   * @param engine  The reference to the current engine\r\n   */\r\n  constructor(public engine: Engine, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on a [[Scene]] on activation\r\n */\r\nexport class ActivateEvent<TData = undefined> extends GameEvent<Scene> {\r\n  /**\r\n   * @param context  The context for the scene activation\r\n   */\r\n  constructor(public context: SceneActivationContext<TData>, public target: Scene) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on a [[Scene]] on deactivation\r\n */\r\nexport class DeactivateEvent extends GameEvent<Scene> {\r\n  /**\r\n   * @param context  The context for the scene deactivation\r\n   */\r\n  constructor(public context: SceneActivationContext<never>, public target: Scene) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nexport class ExitViewPortEvent extends GameEvent<Entity> {\r\n  constructor(public target: Entity) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nexport class EnterViewPortEvent extends GameEvent<Entity> {\r\n  constructor(public target: Entity) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class EnterTriggerEvent extends GameEvent<Actor> {\r\n  constructor(public target: Trigger, public actor: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class ExitTriggerEvent extends GameEvent<Actor> {\r\n  constructor(public target: Trigger, public actor: Actor) {\r\n    super();\r\n  }\r\n}\r\n","import { GameEvent } from './Events';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\nexport class EventDispatcher<T = any> implements Eventable {\r\n  private _handlers: { [key: string]: { (event: GameEvent<T>): void }[] } = {};\r\n  private _wiredEventDispatchers: Eventable[] = [];\r\n\r\n  /**\r\n   * Clears any existing handlers or wired event dispatchers on this event dispatcher\r\n   */\r\n  public clear() {\r\n    this._handlers = {};\r\n    this._wiredEventDispatchers = [];\r\n  }\r\n\r\n  private _deferedHandlerRemovals: {name: string, handler?: (...args: any[]) => any }[] = [];\r\n  private _processDeferredHandlerRemovals() {\r\n    for (const eventHandler of this._deferedHandlerRemovals) {\r\n      this._removeHandler(eventHandler.name, eventHandler.handler);\r\n    }\r\n    this._deferedHandlerRemovals.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Emits an event for target\r\n   * @param eventName  The name of the event to publish\r\n   * @param event      Optionally pass an event data object to the handler\r\n   */\r\n  public emit(eventName: string, event: GameEvent<T>) {\r\n    this._processDeferredHandlerRemovals();\r\n    if (!eventName) {\r\n      // key not mapped\r\n      return;\r\n    }\r\n    eventName = eventName.toLowerCase();\r\n    if (!event) {\r\n      event = new GameEvent();\r\n    }\r\n    let i: number, len: number;\r\n\r\n    if (this._handlers[eventName]) {\r\n      i = 0;\r\n      len = this._handlers[eventName].length;\r\n      for (i; i < len; i++) {\r\n        this._handlers[eventName][i](event);\r\n      }\r\n    }\r\n\r\n    i = 0;\r\n    len = this._wiredEventDispatchers.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this._wiredEventDispatchers[i].emit(eventName, event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n   * @param eventName  The name of the event to subscribe to\r\n   * @param handler    The handler callback to fire on this event\r\n   */\r\n  public on(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    this._processDeferredHandlerRemovals();\r\n    eventName = eventName.toLowerCase();\r\n\r\n    if (!this._handlers[eventName]) {\r\n      this._handlers[eventName] = [];\r\n    }\r\n    this._handlers[eventName].push(handler);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe an event handler(s) from an event. If a specific handler\r\n   * is specified for an event, only that handler will be unsubscribed.\r\n   * Otherwise all handlers will be unsubscribed for that event.\r\n   *\r\n   * @param eventName  The name of the event to unsubscribe\r\n   * @param handler    Optionally the specific handler to unsubscribe\r\n   */\r\n  public off(eventName: string, handler?: (event: GameEvent<T>) => void) {\r\n    this._deferedHandlerRemovals.push({name: eventName, handler});\r\n  }\r\n\r\n  private _removeHandler(eventName: string, handler?: (event: GameEvent<T>) => void) {\r\n    eventName = eventName.toLowerCase();\r\n    const eventHandlers = this._handlers[eventName];\r\n\r\n    if (eventHandlers) {\r\n      // if no explicit handler is give with the event name clear all handlers\r\n      if (!handler) {\r\n        this._handlers[eventName].length = 0;\r\n      } else {\r\n        const index = eventHandlers.indexOf(handler);\r\n        if (index > -1) {\r\n          this._handlers[eventName].splice(index, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    this._processDeferredHandlerRemovals();\r\n    const metaHandler = (event: GameEvent<T>) => {\r\n      const ev = event || new GameEvent();\r\n      this.off(eventName, metaHandler);\r\n      handler(ev);\r\n    };\r\n\r\n    this.on(eventName, metaHandler);\r\n  }\r\n\r\n  /**\r\n   * Wires this event dispatcher to also receive events from another\r\n   */\r\n  public wire(eventDispatcher: EventDispatcher): void {\r\n    eventDispatcher._wiredEventDispatchers.push(this);\r\n  }\r\n\r\n  /**\r\n   * Unwires this event dispatcher from another\r\n   */\r\n  public unwire(eventDispatcher: EventDispatcher): void {\r\n    const index = eventDispatcher._wiredEventDispatchers.indexOf(this);\r\n    if (index > -1) {\r\n      eventDispatcher._wiredEventDispatchers.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n","import { Loadable } from '../Interfaces/Loadable';\r\nimport { Logger } from '../Util/Log';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\n\r\n/**\r\n * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n */\r\nexport class Resource<T> implements Loadable<T> {\r\n  public data: T = null;\r\n  public logger: Logger = Logger.getInstance();\r\n  public events: EventDispatcher = new EventDispatcher();\r\n\r\n  /**\r\n   * @param path          Path to the remote resource\r\n   * @param responseType  The type to expect as a response: \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\n   * @param bustCache     Whether or not to cache-bust requests\r\n   */\r\n  constructor(\r\n    public path: string,\r\n    public responseType: '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text',\r\n    public bustCache: boolean = true\r\n  ) {}\r\n\r\n  /**\r\n   * Returns true if the Resource is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    return this.data !== null;\r\n  }\r\n\r\n\r\n  private _cacheBust(uri: string): string {\r\n    const query: RegExp = /\\?\\w*=\\w*/;\r\n    if (query.test(uri)) {\r\n      uri += '&__=' + Date.now();\r\n    } else {\r\n      uri += '?__=' + Date.now();\r\n    }\r\n    return uri;\r\n  }\r\n  /**\r\n   * Begin loading the resource and returns a promise to be resolved on completion\r\n   */\r\n  public load(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      // Exit early if we already have data\r\n      if (this.data !== null) {\r\n        this.logger.debug('Already have data for resource', this.path);\r\n        this.events.emit('complete', this.data as any);\r\n        resolve(this.data);\r\n        return;\r\n      }\r\n\r\n      const request = new XMLHttpRequest();\r\n      request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);\r\n      request.responseType = this.responseType;\r\n      request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e as any));\r\n      request.addEventListener('progress', (e) => this.events.emit('progress', e as any));\r\n      request.addEventListener('error', (e) => this.events.emit('error', e as any));\r\n      request.addEventListener('load', (e) => this.events.emit('load', e as any));\r\n      request.addEventListener('load', () => {\r\n        // XHR on file:// success status is 0, such as with PhantomJS\r\n        if (request.status !== 0 && request.status !== 200) {\r\n          this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);\r\n          this.events.emit('error', request.response);\r\n          reject(new Error(request.statusText));\r\n          return;\r\n        }\r\n\r\n        this.data = request.response;\r\n        this.events.emit('complete', this.data as any);\r\n        this.logger.debug('Completed loading resource', this.path);\r\n        resolve(this.data);\r\n      });\r\n      request.send();\r\n    });\r\n  }\r\n}\r\n","/**\r\n * Watch an object with a proxy, only fires if property value is different\r\n */\r\nexport function watch<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        if ((obj as any)[prop] !== value) {\r\n          (obj as any)[prop] = value;\r\n          // Avoid watching private junk\r\n          if (typeof prop === 'string') {\r\n            if (prop[0] !== '_') {\r\n              change(obj);\r\n            }\r\n          }\r\n        }\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n\r\n/**\r\n * Watch an object with a proxy, fires change on any property value change\r\n */\r\nexport function watchAny<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        (obj as any)[prop] = value;\r\n        // Avoid watching private junk\r\n        if (typeof prop === 'string') {\r\n          if (prop[0] !== '_') {\r\n            change(obj);\r\n          }\r\n        }\r\n\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { watch } from '../Util/Watch';\r\nimport { AffineMatrix } from '../Math/affine-matrix';\r\n\r\nexport interface GraphicOptions {\r\n  /**\r\n   * The width of the graphic\r\n   */\r\n  width?: number;\r\n  /**\r\n   * The height of the graphic\r\n   */\r\n  height?: number;\r\n  /**\r\n   * Should the graphic be flipped horizontally\r\n   */\r\n  flipHorizontal?: boolean;\r\n  /**\r\n   * Should the graphic be flipped vertically\r\n   */\r\n  flipVertical?: boolean;\r\n  /**\r\n   * The rotation of the graphic\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * The scale of the graphic\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * The opacity of the graphic\r\n   */\r\n  opacity?: number;\r\n  /**\r\n   * The tint of the graphic, this color will be multiplied by the original pixel colors\r\n   */\r\n  tint?: Color;\r\n  /**\r\n   * The origin of the drawing in pixels to use when applying transforms, by default it will be the center of the image\r\n   */\r\n  origin?: Vector;\r\n}\r\n\r\n/**\r\n * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].\r\n * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the\r\n * [[Graphic]] abstract class.\r\n *\r\n * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic\r\n * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]\r\n */\r\nexport abstract class Graphic {\r\n  private static _ID: number = 0;\r\n  readonly id = Graphic._ID++;\r\n\r\n  public transform: AffineMatrix = AffineMatrix.identity();\r\n  public tint: Color = null;\r\n\r\n  private _transformStale = true;\r\n  public isStale() {\r\n    return this._transformStale;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets wether to show debug information about the graphic\r\n   */\r\n  public showDebug: boolean = false;\r\n\r\n\r\n  private _flipHorizontal = false;\r\n  /**\r\n   * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)\r\n   */\r\n  public get flipHorizontal(): boolean {\r\n    return this._flipHorizontal;\r\n  }\r\n\r\n  public set flipHorizontal(value: boolean) {\r\n    this._flipHorizontal = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _flipVertical = false;\r\n  /**\r\n   * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)\r\n   */\r\n  public get flipVertical(): boolean {\r\n    return this._flipVertical;\r\n  }\r\n\r\n  public set flipVertical(value: boolean) {\r\n    this._flipVertical = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _rotation = 0;\r\n  /**\r\n   * Gets or sets the rotation of the graphic\r\n   */\r\n  public get rotation(): number {\r\n    return this._rotation;\r\n  }\r\n\r\n  public set rotation(value: number) {\r\n    this._rotation = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  private _scale = Vector.One;\r\n  /**\r\n   * Gets or sets the scale of the graphic, this affects the width and\r\n   */\r\n  public get scale() {\r\n    return this._scale;\r\n  }\r\n\r\n  public set scale(value: Vector) {\r\n    this._scale = watch(value, () => {\r\n      this._transformStale = true;\r\n    });\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _origin: Vector | null = null;\r\n  /**\r\n   * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin\r\n   */\r\n  public get origin(): Vector | null {\r\n    return this._origin;\r\n  }\r\n\r\n  public set origin(value: Vector | null) {\r\n    this._origin = watch(value, () => {\r\n      this._transformStale = true;\r\n    });\r\n    this._transformStale = true;\r\n  }\r\n\r\n  constructor(options?: GraphicOptions) {\r\n    if (options) {\r\n      this.origin = options.origin ?? this.origin;\r\n      this.flipHorizontal = options.flipHorizontal ?? this.flipHorizontal;\r\n      this.flipVertical = options.flipVertical ?? this.flipVertical;\r\n      this.rotation = options.rotation ?? this.rotation;\r\n      this.opacity = options.opacity ?? this.opacity;\r\n      this.scale = options.scale ?? this.scale;\r\n    }\r\n  }\r\n\r\n  public cloneGraphicOptions(): GraphicOptions {\r\n    return {\r\n      origin: this.origin ? this.origin.clone() : null,\r\n      flipHorizontal: this.flipHorizontal,\r\n      flipVertical: this.flipVertical,\r\n      rotation: this.rotation,\r\n      opacity: this.opacity,\r\n      scale: this.scale ? this.scale.clone() : null\r\n    };\r\n  }\r\n\r\n  private _width: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the width of the graphic (always positive)\r\n   */\r\n  public get width() {\r\n    return Math.abs(this._width * this.scale.x);\r\n  }\r\n\r\n  private _height: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the height of the graphic (always positive)\r\n   */\r\n  public get height() {\r\n    return Math.abs(this._height * this.scale.y);\r\n  }\r\n\r\n  public set width(value: number) {\r\n    this._width = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  public set height(value: number) {\r\n    this._height = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  /**\r\n   * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);\r\n  }\r\n\r\n  /**\r\n   * Draw the whole graphic to the context including transform\r\n   * @param ex The excalibur graphics context\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public draw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    this._preDraw(ex, x, y);\r\n    this._drawImage(ex, 0, 0);\r\n    this._postDraw(ex);\r\n  }\r\n\r\n  /**\r\n   * Meant to be overridden by the graphic implementation to draw the underlying image (HTMLCanvasElement or HTMLImageElement)\r\n   * to the graphics context without transform. Transformations like position, rotation, and scale are handled by [[Graphic._preDraw]]\r\n   * and [[Graphic._postDraw]]\r\n   * @param ex The excalibur graphics context\r\n   * @param x\r\n   * @param y\r\n   */\r\n  protected abstract _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void;\r\n\r\n  /**\r\n   * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]\r\n   * @param ex\r\n   * @param x\r\n   * @param y\r\n   */\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    ex.save();\r\n    ex.translate(x, y);\r\n    if (this._transformStale) {\r\n      this.transform.reset();\r\n      this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\r\n      this._rotate(this.transform);\r\n      this._flip(this.transform);\r\n      this._transformStale = false;\r\n    }\r\n    ex.multiply(this.transform);\r\n    // it is important to multiply alphas so graphics respect the current context\r\n    ex.opacity = ex.opacity * this.opacity;\r\n    if (this.tint) {\r\n      ex.tint = this.tint;\r\n    }\r\n  }\r\n\r\n  protected _rotate(ex: ExcaliburGraphicsContext | AffineMatrix) {\r\n    const scaleDirX = this.scale.x > 0 ? 1 : -1;\r\n    const scaleDirY = this.scale.y > 0 ? 1 : -1;\r\n    const origin = this.origin ?? vec(this.width / 2, this.height / 2);\r\n    ex.translate(origin.x, origin.y);\r\n    ex.rotate(this.rotation);\r\n    // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\r\n    ex.scale(scaleDirX, scaleDirY);\r\n    ex.translate(-origin.x, -origin.y);\r\n  }\r\n\r\n  protected _flip(ex: ExcaliburGraphicsContext | AffineMatrix) {\r\n    if (this.flipHorizontal) {\r\n      ex.translate(this.width / this.scale.x, 0);\r\n      ex.scale(-1, 1);\r\n    }\r\n\r\n    if (this.flipVertical) {\r\n      ex.translate(0, this.height / this.scale.y);\r\n      ex.scale(1, -1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply any additional work after [[Graphic._drawImage]] and restore the context state.\r\n   * @param ex\r\n   */\r\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\r\n    if (this.showDebug) {\r\n      ex.debug.drawRect(0, 0, this.width, this.height);\r\n    }\r\n    ex.restore();\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of the graphic that has the same properties\r\n   */\r\n  abstract clone(): Graphic;\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ImageSource } from './ImageSource';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Logger } from '../Util/Log';\r\n\r\nexport type SourceView = { x: number; y: number; width: number; height: number };\r\nexport type DestinationSize = { width: number; height: number };\r\n\r\nexport interface SpriteOptions {\r\n  /**\r\n   * Image to create a sprite from\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * By default the source is the entire dimension of the [[ImageSource]]\r\n   */\r\n  sourceView?: { x: number; y: number; width: number; height: number };\r\n  /**\r\n   * By default the size of the final sprite is the size of the [[ImageSource]]\r\n   */\r\n  destSize?: { width: number; height: number };\r\n}\r\n\r\nexport class Sprite extends Graphic {\r\n  private _logger = Logger.getInstance();\r\n  public image: ImageSource;\r\n  public sourceView: SourceView;\r\n  public destSize: DestinationSize;\r\n  private _dirty = true;\r\n\r\n  public static from(image: ImageSource): Sprite {\r\n    return new Sprite({\r\n      image: image\r\n    });\r\n  }\r\n\r\n  constructor(options: GraphicOptions & SpriteOptions) {\r\n    super(options);\r\n    this.image = options.image;\r\n    const { width, height } = options;\r\n    this.sourceView = options.sourceView ?? { x: 0, y: 0, width: width ?? 0, height: height ?? 0 };\r\n    this.destSize = options.destSize ?? { width: width ?? 0, height: height ?? 0 };\r\n    this._updateSpriteDimensions();\r\n    this.image.ready.then(() => {\r\n      this._updateSpriteDimensions();\r\n    });\r\n  }\r\n\r\n  public override get width(): number {\r\n    return Math.abs(this.destSize.width * this.scale.x);\r\n  }\r\n\r\n  public override get height(): number {\r\n    return Math.abs(this.destSize.height * this.scale.y);\r\n  }\r\n\r\n  public override set width(newWidth: number) {\r\n    newWidth /= Math.abs(this.scale.x);\r\n    this.destSize.width = newWidth;\r\n    super.width = Math.ceil(this.destSize.width);\r\n  }\r\n\r\n  public override set height(newHeight: number) {\r\n    newHeight /= Math.abs(this.scale.y);\r\n    this.destSize.height = newHeight;\r\n    super.height = Math.ceil(this.destSize.height);\r\n  }\r\n\r\n  private _updateSpriteDimensions() {\r\n    const { width: nativeWidth, height: nativeHeight } = this.image;\r\n    // This code uses || to avoid 0's\r\n    // If the source is not specified, use the native dimension\r\n    this.sourceView.width = this.sourceView?.width || nativeWidth;\r\n    this.sourceView.height = this.sourceView?.height || nativeHeight;\r\n\r\n    // If the destination is not specified, use the source if specified, then native\r\n    this.destSize.width = this.destSize?.width || this.sourceView?.width || nativeWidth;\r\n    this.destSize.height = this.destSize?.height || this.sourceView?.height || nativeHeight;\r\n\r\n    this.width = Math.ceil(this.destSize.width) * this.scale.x;\r\n    this.height = Math.ceil(this.destSize.height) * this.scale.y;\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded() && this._dirty) {\r\n      this._dirty = false;\r\n      this._updateSpriteDimensions();\r\n    }\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  private _logNotLoadedWarning = false;\r\n  public _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded()) {\r\n      ex.drawImage(\r\n        this.image.image,\r\n        this.sourceView.x,\r\n        this.sourceView.y,\r\n        this.sourceView.width,\r\n        this.sourceView.height,\r\n        x,\r\n        y,\r\n        this.destSize.width,\r\n        this.destSize.height\r\n      );\r\n    } else {\r\n      if (!this._logNotLoadedWarning) {\r\n        this._logger.warn(\r\n          `ImageSource ${this.image.path}` +\r\n          ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\\n\\n` +\r\n          `Read https://excaliburjs.com/docs/imagesource for more information.`\r\n        );\r\n      }\r\n      this._logNotLoadedWarning = true;\r\n    }\r\n  }\r\n\r\n  public clone(): Sprite {\r\n    return new Sprite({\r\n      image: this.image,\r\n      sourceView: { ...this.sourceView },\r\n      destSize: { ...this.destSize },\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n}\r\n","\r\n/**\r\n * Describes the different image filtering modes\r\n */\r\nexport enum ImageFiltering {\r\n\r\n  /**\r\n   * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.\r\n   *\r\n   * Useful for Pixel art aesthetics.\r\n   */\r\n  Pixel = 'Pixel',\r\n\r\n  /**\r\n   * Blended is useful when you have high resolution artwork and would like it blended and smoothed\r\n   */\r\n  Blended = 'Blended'\r\n}","import { Logger } from '../../Util/Log';\r\nimport { ImageFiltering } from '../Filtering';\r\nimport { HTMLImageSource } from './ExcaliburGraphicsContext';\r\n\r\n/**\r\n * Manages loading image sources into webgl textures, a unique id is associated with all sources\r\n */\r\nexport class TextureLoader {\r\n  private static _LOGGER = Logger.getInstance();\r\n  /**\r\n   * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]\r\n   */\r\n  public static filtering: ImageFiltering = ImageFiltering.Blended;\r\n\r\n  private static _GL: WebGLRenderingContext;\r\n\r\n  private static _TEXTURE_MAP = new Map<HTMLImageSource, WebGLTexture>();\r\n\r\n  private static _MAX_TEXTURE_SIZE: number  = 0;\r\n\r\n  public static register(context: WebGLRenderingContext): void {\r\n    TextureLoader._GL = context;\r\n    TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL Texture from a source image\r\n   * @param image\r\n   */\r\n  public static get(image: HTMLImageSource): WebGLTexture {\r\n    return TextureLoader._TEXTURE_MAP.get(image);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a source image has been loaded as a texture\r\n   * @param image\r\n   */\r\n  public static has(image: HTMLImageSource): boolean {\r\n    return TextureLoader._TEXTURE_MAP.has(image);\r\n  }\r\n\r\n  /**\r\n   * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered\r\n   * @param image Source graphic\r\n   * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture\r\n   * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed\r\n   */\r\n  public static load(image: HTMLImageSource, filtering?: ImageFiltering, forceUpdate = false): WebGLTexture {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    // If reuse the texture if it's from the same source\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n    }\r\n\r\n    // Update existing webgl texture and return early\r\n    if (tex) {\r\n      if (forceUpdate) {\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n      }\r\n      return tex;\r\n    }\r\n\r\n    // No texture exists create a new one\r\n    tex = gl.createTexture();\r\n\r\n    TextureLoader.checkImageSizeSupportedAndLog(image);\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    // NEAREST for pixel art, LINEAR for hi-res\r\n    const filterMode = filtering ?? TextureLoader.filtering;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\r\n    TextureLoader._TEXTURE_MAP.set(image, tex);\r\n    return tex;\r\n  }\r\n\r\n  public static delete(image: HTMLImageSource): void {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n      gl.deleteTexture(tex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Takes an image and returns if it meets size criteria for hardware\r\n   * @param image\r\n   * @returns if the image will be supported at runtime\r\n   */\r\n  public static checkImageSizeSupportedAndLog(image: HTMLImageSource) {\r\n    const originalSrc = image.dataset.originalSrc ?? 'internal canvas bitmap';\r\n    if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {\r\n      TextureLoader._LOGGER.error(\r\n        `The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of `+\r\n        `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image `\r\n        +`for excalibur to render properly.\\n\\nImages will likely render as black rectangles.\\n\\n`+\r\n        `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n      return false;\r\n    } else if (image.width > 4096 || image.height > 4096) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits\r\n      TextureLoader._LOGGER.warn(\r\n        `The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, `+\r\n        `it is recommended you resize images to a maximum (4096x4096).\\n\\n` +\r\n        `Images will likely render as black rectangles on some mobile platforms.\\n\\n` +\r\n        `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import { Resource } from '../Resources/Resource';\r\nimport { Sprite } from './Sprite';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { Logger } from '../Util/Log';\r\nimport { TextureLoader } from '.';\r\nimport { ImageFiltering } from './Filtering';\r\nimport { Future } from '../Util/Future';\r\n\r\nexport class ImageSource implements Loadable<HTMLImageElement> {\r\n  private _logger = Logger.getInstance();\r\n  private _resource: Resource<Blob>;\r\n  private _filtering: ImageFiltering;\r\n\r\n  /**\r\n   * The original size of the source image in pixels\r\n   */\r\n  public get width() {\r\n    return this.image.naturalWidth;\r\n  }\r\n\r\n  /**\r\n   * The original height of the source image in pixels\r\n   */\r\n  public get height() {\r\n    return this.image.naturalHeight;\r\n  }\r\n\r\n  private _src: string;\r\n  /**\r\n   * Returns true if the Texture is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    if (!this._src) {\r\n      // this boosts speed of access\r\n      this._src = this.data.src;\r\n    }\r\n    return !!this._src;\r\n  }\r\n\r\n  /**\r\n   * Access to the underlying html image element\r\n   */\r\n  public data: HTMLImageElement = new Image();\r\n  public get image(): HTMLImageElement {\r\n    return this.data;\r\n  }\r\n\r\n  private _readyFuture = new Future<HTMLImageElement>();\r\n  /**\r\n   * Promise the resolves when the image is loaded and ready for use, does not initiate loading\r\n   */\r\n  public ready: Promise<HTMLImageElement> = this._readyFuture.promise;\r\n\r\n  /**\r\n   * The path to the image, can also be a data url like 'data:image/'\r\n   * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute\r\n   * @param bustCache {boolean} Should excalibur add a cache busting querystring?\r\n   * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]\r\n   */\r\n  constructor(public readonly path: string, bustCache: boolean = false, filtering?: ImageFiltering) {\r\n    this._resource = new Resource(path, 'blob', bustCache);\r\n    this._filtering = filtering;\r\n    if (path.endsWith('.svg') || path.endsWith('.gif')) {\r\n      this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Begins loading the image and returns a promise that resolves when the image is loaded\r\n   */\r\n  async load(): Promise<HTMLImageElement> {\r\n    if (this.isLoaded()) {\r\n      return this.data;\r\n    }\r\n    try {\r\n      // Load base64 or blob if needed\r\n      let url: string;\r\n      if (!this.path.includes('data:image/')) {\r\n        const blob = await this._resource.load();\r\n        url = URL.createObjectURL(blob);\r\n      } else {\r\n        url = this.path;\r\n      }\r\n\r\n      // Decode the image\r\n      const image = new Image();\r\n      // Use Image.onload over Image.decode()\r\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7\r\n      // Otherwise chrome will throw still Image.decode() failures for large textures\r\n      const loadedFuture = new Future<void>();\r\n      image.onload = () => loadedFuture.resolve();\r\n      image.src = url;\r\n      image.setAttribute('data-original-src', this.path);\r\n\r\n      await loadedFuture.promise;\r\n\r\n      // Set results\r\n      this.data = image;\r\n    } catch (error) {\r\n      throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;\r\n    }\r\n    TextureLoader.load(this.data, this._filtering);\r\n    // todo emit complete\r\n    this._readyFuture.resolve(this.data);\r\n    return this.data;\r\n  }\r\n\r\n  /**\r\n   * Build a sprite from this ImageSource\r\n   */\r\n  public toSprite(): Sprite {\r\n    return Sprite.from(this);\r\n  }\r\n\r\n  /**\r\n   * Unload images from memory\r\n   */\r\n  unload(): void {\r\n    this.data = new Image();\r\n  }\r\n}\r\n","import { ImageSource } from './ImageSource';\r\nimport { SourceView, Sprite } from './Sprite';\r\nimport { Logger } from '../Util/Log';\r\n\r\n/**\r\n * Specify sprite sheet spacing options, useful if your sprites are not tightly packed\r\n * and have space between them.\r\n */\r\nexport interface SpriteSheetSpacingDimensions {\r\n  /**\r\n   * The starting point to offset and start slicing the sprite sheet from the top left of the image.\r\n   * Default is (0, 0)\r\n   */\r\n  originOffset?: { x?: number, y?: number };\r\n\r\n  /**\r\n   * The margin between sprites.\r\n   * Default is (0, 0)\r\n   */\r\n  margin?: {x?: number, y?: number};\r\n}\r\n\r\n/**\r\n * Sprite sheet options for slicing up images\r\n */\r\nexport interface SpriteSheetGridOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * Grid definition for the sprite sheet\r\n   */\r\n  grid: {\r\n    /**\r\n     * Number of rows in the sprite sheet\r\n     */\r\n    rows: number;\r\n    /**\r\n     * Number of columns in the sprite sheet\r\n     */\r\n    columns: number;\r\n    /**\r\n     * Width of each individual sprite\r\n     */\r\n    spriteWidth: number;\r\n    /**\r\n     * Height of each individual sprite\r\n     */\r\n    spriteHeight: number;\r\n  };\r\n  /**\r\n   * Optionally specify any spacing information between sprites\r\n   */\r\n  spacing?: SpriteSheetSpacingDimensions;\r\n}\r\n\r\nexport interface SpriteSheetSparseOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * List of source view rectangles to create a sprite sheet from\r\n   */\r\n  sourceViews: SourceView[];\r\n}\r\n\r\nexport interface SpriteSheetOptions {\r\n  /**\r\n   * Source sprites for the sprite sheet\r\n   */\r\n  sprites: Sprite[];\r\n  /**\r\n   * Optionally specify the number of rows in a sprite sheet (default 1 row)\r\n   */\r\n  rows?: number;\r\n  /**\r\n   * Optionally specify the number of columns in a sprite sheet (default sprites.length)\r\n   */\r\n  columns?: number;\r\n}\r\n\r\n/**\r\n * Represents a collection of sprites from a source image with some organization in a grid\r\n */\r\nexport class SpriteSheet {\r\n  private _logger = Logger.getInstance();\r\n  public readonly sprites: Sprite[] = [];\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  /**\r\n   * Build a new sprite sheet from a list of sprites\r\n   *\r\n   * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   * @param options\r\n   */\r\n  constructor(options: SpriteSheetOptions) {\r\n    const { sprites, rows, columns } = options;\r\n    this.sprites = sprites;\r\n    this.rows = rows ?? 1;\r\n    this.columns = columns ?? this.sprites.length;\r\n  }\r\n\r\n  /**\r\n   * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public getSprite(x: number, y: number): Sprite | null {\r\n    if (x >= this.columns || x < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);\r\n      return null;\r\n    }\r\n    if (y >= this.rows || y < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);\r\n      return null;\r\n    }\r\n    const spriteIndex = x + y * this.columns;\r\n    return this.sprites[spriteIndex];\r\n  }\r\n\r\n  /**\r\n   * Create a sprite sheet from a sparse set of [[SourceView]] rectangles\r\n   * @param options\r\n   */\r\n  public static fromImageSourceWithSourceViews(options: SpriteSheetSparseOptions): SpriteSheet {\r\n    const sprites: Sprite[] = options.sourceViews.map(sourceView => {\r\n      return new Sprite({\r\n        image: options.image,\r\n        sourceView\r\n      });\r\n    });\r\n    return new SpriteSheet({sprites});\r\n  }\r\n\r\n  /**\r\n   * Create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   *\r\n   * Example:\r\n   * ```\r\n   * const spriteSheet = SpriteSheet.fromImageSource({\r\n   *   image: imageSource,\r\n   *   grid: {\r\n   *     rows: 5,\r\n   *     columns: 2,\r\n   *     spriteWidth: 32, // pixels\r\n   *     spriteHeight: 32 // pixels\r\n   *   },\r\n   *   // Optionally specify spacing\r\n   *   spacing: {\r\n   *     // pixels from the top left to start the sprite parsing\r\n   *     originOffset: {\r\n   *       x: 5,\r\n   *       y: 5\r\n   *     },\r\n   *     // pixels between each sprite while parsing\r\n   *     margin: {\r\n   *       x: 1,\r\n   *       y: 1\r\n   *     }\r\n   *   }\r\n   * })\r\n   * ```\r\n   *\r\n   * @param options\r\n   */\r\n  public static fromImageSource(options: SpriteSheetGridOptions): SpriteSheet {\r\n    const sprites: Sprite[] = [];\r\n    options.spacing = options.spacing ?? {};\r\n    const {\r\n      image,\r\n      grid: { rows, columns: cols, spriteWidth, spriteHeight },\r\n      spacing: { originOffset, margin }\r\n    } = options;\r\n    const offsetDefaults = { x: 0, y: 0, ...originOffset};\r\n    const marginDefaults = { x: 0, y: 0, ...margin};\r\n    for (let x = 0; x < cols; x++) {\r\n      for (let y = 0; y < rows; y++) {\r\n        sprites[x + y * cols] = new Sprite({\r\n          image: image,\r\n          sourceView: {\r\n            x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,\r\n            y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,\r\n            width: spriteWidth,\r\n            height: spriteHeight\r\n          },\r\n          destSize: { height: spriteHeight, width: spriteWidth }\r\n        });\r\n      }\r\n    }\r\n    return new SpriteSheet({\r\n      sprites: sprites,\r\n      rows: rows,\r\n      columns: cols\r\n    });\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { FontRenderer } from './FontCommon';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Sprite } from './Sprite';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { BoundingBox, Color } from '..';\r\n\r\nexport interface SpriteFontOptions {\r\n  /**\r\n   * Alphabet string in spritesheet order (default is row column order)\r\n   * example: 'abcdefghijklmnopqrstuvwxyz'\r\n   */\r\n  alphabet: string;\r\n  /**\r\n   * [[SpriteSheet]] to source character sprites from\r\n   */\r\n  spriteSheet: SpriteSheet;\r\n  /**\r\n   * Optionally ignore case in the supplied text;\r\n   */\r\n  caseInsensitive?: boolean;\r\n  /**\r\n   * Optionally adjust the spacing between character sprites\r\n   */\r\n  spacing?: number;\r\n  /**\r\n   * Optionally specify a \"shadow\"\r\n   */\r\n  shadow?: { offset: Vector };\r\n}\r\n\r\nexport class SpriteFont extends Graphic implements FontRenderer {\r\n  private _text: string = '';\r\n  public alphabet: string = '';\r\n  public spriteSheet: SpriteSheet;\r\n\r\n  public shadow: { offset: Vector } = null;\r\n  public caseInsensitive = false;\r\n  public spacing: number = 0;\r\n\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(options: SpriteFontOptions & GraphicOptions) {\r\n    super(options);\r\n    const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;\r\n    this.alphabet = alphabet;\r\n    this.spriteSheet = spriteSheet;\r\n    this.caseInsensitive = caseInsensitive ?? this.caseInsensitive;\r\n    this.spacing = spacing ?? this.spacing;\r\n    this.shadow = shadow ?? this.shadow;\r\n  }\r\n\r\n  private _alreadyWarnedAlphabet = false;\r\n  private _alreadyWarnedSpriteSheet = false;\r\n  private _getCharacterSprites(text: string): Sprite[] {\r\n    const results: Sprite[] = [];\r\n    // handle case insensitive\r\n    const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;\r\n    const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;\r\n\r\n    // for each letter in text\r\n    for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {\r\n      // find the sprite index in alphabet , if there is an error pick the first\r\n      const letter = textToRender[letterIndex];\r\n      let spriteIndex = alphabet.indexOf(letter);\r\n      if (spriteIndex === -1) {\r\n        spriteIndex = 0;\r\n        if (!this._alreadyWarnedAlphabet) {\r\n          this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);\r\n          this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n          this._alreadyWarnedAlphabet = true;\r\n        }\r\n      }\r\n\r\n      const letterSprite = this.spriteSheet.sprites[spriteIndex];\r\n      if (letterSprite) {\r\n        results.push(letterSprite);\r\n      } else {\r\n        if (!this._alreadyWarnedSpriteSheet) {\r\n          this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);\r\n          this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n          this._alreadyWarnedSpriteSheet = true;\r\n        }\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  public measureText(text: string): BoundingBox {\r\n    const lines = text.split('\\n');\r\n    const maxWidthLine = lines.reduce((a, b) => {\r\n      return a.length > b.length ? a : b;\r\n    });\r\n    const sprites = this._getCharacterSprites(maxWidthLine);\r\n    let width = 0;\r\n    let height = 0;\r\n    for (const sprite of sprites) {\r\n      width += sprite.width + this.spacing;\r\n      height = Math.max(height, sprite.height);\r\n    }\r\n    return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    let xCursor = 0;\r\n    let yCursor = 0;\r\n    let height = 0;\r\n    const lines = this._text.split('\\n');\r\n    for (const line of lines) {\r\n      for (const sprite of this._getCharacterSprites(line)) {\r\n        // draw it in the right spot and increase the cursor by sprite width\r\n        sprite.draw(ex, x + xCursor, y + yCursor);\r\n        xCursor += sprite.width + this.spacing;\r\n        height = Math.max(height, sprite.height);\r\n      }\r\n      xCursor = 0;\r\n      yCursor += height;\r\n    }\r\n  }\r\n\r\n  render(ex: ExcaliburGraphicsContext, text: string, _color: Color, x: number, y: number) {\r\n    // SpriteFont doesn't support _color, yet...\r\n    this._text = text;\r\n    const bounds = this.measureText(text);\r\n    this.width = bounds.width;\r\n    this.height = bounds.height;\r\n    if (this.shadow) {\r\n      ex.save();\r\n      ex.translate(this.shadow.offset.x, this.shadow.offset.y);\r\n      this.draw(ex, x, y);\r\n      ex.restore();\r\n    }\r\n\r\n    this.draw(ex, x, y);\r\n  }\r\n\r\n  clone(): SpriteFont {\r\n    return new SpriteFont({\r\n      alphabet: this.alphabet,\r\n      spriteSheet: this.spriteSheet,\r\n      spacing: this.spacing\r\n    });\r\n  }\r\n}\r\n","export default \"data:image/png;base64,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\"","import { ExcaliburGraphicsContext, ImageSource, SpriteFont, SpriteSheet } from '..';\r\nimport { Vector } from '../..';\r\nimport debugFont from './debug-font.png';\r\n\r\n/**\r\n * Internal debugtext helper\r\n */\r\nexport class DebugText {\r\n  constructor() {\r\n    this.load();\r\n  }\r\n\r\n  /**\r\n   * base64 font\r\n   */\r\n  public readonly fontSheet = debugFont;\r\n  public size: number = 16;\r\n  private _imageSource: ImageSource;\r\n  private _spriteSheet: SpriteSheet;\r\n  private _spriteFont: SpriteFont;\r\n  public load() {\r\n    this._imageSource = new ImageSource(this.fontSheet);\r\n    return this._imageSource.load().then(() => {\r\n      this._spriteSheet = SpriteSheet.fromImageSource({\r\n        image: this._imageSource,\r\n        grid: {\r\n          rows: 3,\r\n          columns: 16,\r\n          spriteWidth: 16,\r\n          spriteHeight: 16\r\n        }\r\n      });\r\n      this._spriteFont = new SpriteFont({\r\n        alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\\'&.\"?-()+ ',\r\n        caseInsensitive: true,\r\n        spriteSheet: this._spriteSheet,\r\n        spacing: -6\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Writes debug text using the built in sprint font\r\n   * @param ctx\r\n   * @param text\r\n   * @param pos\r\n   */\r\n  public write(ctx: ExcaliburGraphicsContext, text: string, pos: Vector) {\r\n    if (this._imageSource.isLoaded()) {\r\n      this._spriteFont.render(ctx, text, null, pos.x, pos.y);\r\n    }\r\n  }\r\n}\r\n","export class RenderSource {\r\n  constructor(\r\n    private _gl: WebGLRenderingContext,\r\n    private _texture: WebGLTexture) {}\r\n\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this._texture);\r\n  }\r\n\r\n  public disable() {\r\n    const gl = this._gl;\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n  }\r\n}","import { RenderSource } from './render-source';\r\n\r\nexport class RenderTarget {\r\n  width: number;\r\n  height: number;\r\n  private _gl: WebGLRenderingContext;\r\n  constructor(options: {gl: WebGLRenderingContext, width: number, height: number}) {\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this._gl = options.gl;\r\n    this._setupFramebuffer();\r\n  }\r\n\r\n  setResolution(width: number, height: number) {\r\n    const gl = this._gl;\r\n    this.width = width;\r\n    this.height = height;\r\n    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n  }\r\n\r\n  private _frameBuffer: WebGLFramebuffer;\r\n  public get frameBuffer() {\r\n    return this._frameBuffer;\r\n  }\r\n  private _frameTexture: WebGLTexture;\r\n  public get frameTexture() {\r\n    return this._frameTexture;\r\n  }\r\n  private _setupFramebuffer() {\r\n    // Allocates frame buffer\r\n    const gl = this._gl;\r\n    this._frameTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n\r\n    // set the filtering so we don't need mips\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n\r\n    // attach the texture as the first color attachment\r\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\r\n\r\n    // After this bind all draw calls will draw to this framebuffer texture\r\n    this._frameBuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);\r\n    // Reset after initialized\r\n    this.disable();\r\n  }\r\n\r\n  public toRenderSource() {\r\n    const source = new RenderSource(this._gl, this._frameTexture);\r\n    return source;\r\n  }\r\n\r\n  /**\r\n   * When called, all drawing gets redirected to this render target\r\n   */\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n    // very important to set the viewport to the size of the framebuffer texture\r\n    gl.viewport(0, 0, this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * When called, all drawing is sent back to the canvas\r\n   */\r\n  public disable() {\r\n    const gl = this._gl;\r\n    // passing null switches rendering back to the canvas\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n  }\r\n}","\r\n/**\r\n * Must be accessed after Engine construction time to ensure the context has been created\r\n */\r\nexport class ExcaliburWebGLContextAccessor {\r\n  private static _GL: WebGL2RenderingContext;\r\n  public static clear() {\r\n    ExcaliburWebGLContextAccessor._GL = null;\r\n  }\r\n  public static register(gl: WebGL2RenderingContext) {\r\n    ExcaliburWebGLContextAccessor._GL = gl;\r\n  }\r\n  // current webgl context\r\n  public static get gl(): WebGL2RenderingContext {\r\n    if (!ExcaliburWebGLContextAccessor._GL) {\r\n      throw Error('Attempted gl access before init');\r\n    }\r\n    return ExcaliburWebGLContextAccessor._GL;\r\n  }\r\n}","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\nout lowp vec4 v_color;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Passthrough the color\\r\\n   v_color = a_color;\\r\\n}\";","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Color\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  fragColor = v_color;\\r\\n}\";","/**\r\n * Return the size of the GlType in bytes\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getGlTypeSizeBytes(gl: WebGLRenderingContext, type: number): number {\r\n  switch (type) {\r\n    case gl.FLOAT:\r\n      return 4;\r\n    case gl.SHORT:\r\n      return 2;\r\n    case gl.UNSIGNED_SHORT:\r\n      return 2;\r\n    case gl.BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_BYTE:\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Based on the type return the number of attribute components\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getAttributeComponentSize(gl: WebGLRenderingContext, type: number): number {\r\n  switch (type) {\r\n    case gl.LOW_FLOAT:\r\n    case gl.HIGH_FLOAT:\r\n    case gl.FLOAT:\r\n      return 1;\r\n    case gl.FLOAT_VEC2:\r\n      return 2;\r\n    case gl.FLOAT_VEC3:\r\n      return 3;\r\n    case gl.FLOAT_VEC4:\r\n      return 4;\r\n    case gl.BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_SHORT:\r\n    case gl.SHORT:\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Based on the attribute return the corresponding supported attrib pointer type\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n *\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getAttributePointerType(gl: WebGLRenderingContext, type: number) {\r\n  switch (type) {\r\n    case gl.LOW_FLOAT:\r\n    case gl.HIGH_FLOAT:\r\n    case gl.FLOAT:\r\n    case gl.FLOAT_VEC2:\r\n    case gl.FLOAT_VEC3:\r\n    case gl.FLOAT_VEC4:\r\n      return gl.FLOAT;\r\n    case gl.BYTE:\r\n      return gl.BYTE;\r\n    case gl.UNSIGNED_BYTE:\r\n      return gl.UNSIGNED_BYTE;\r\n    case gl.SHORT:\r\n      return gl.SHORT;\r\n    case gl.UNSIGNED_SHORT:\r\n      return gl.UNSIGNED_SHORT;\r\n    default:\r\n      return gl.FLOAT;\r\n  }\r\n}","import { Vector } from '../..';\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { getAttributeComponentSize, getAttributePointerType } from './webgl-util';\r\n\r\nexport type UniformTypeNames =\r\n  'uniform1f' |\r\n  'uniform1i' |\r\n  'uniform2f' |\r\n  'uniform2i' |\r\n  'uniform3f' |\r\n  'uniform3i' |\r\n  'uniform4f' |\r\n  'uniform4i' |\r\n  'uniform1fv' |\r\n  'uniform1iv' |\r\n  'uniform2fv' |\r\n  'uniform2iv' |\r\n  'uniform3fv' |\r\n  'uniform3iv' |\r\n  'uniform4fv' |\r\n  'uniform4iv' |\r\n  'uniformMatrix2fv' |\r\n  'uniformMatrix3fv' |\r\n  'uniformMatrix4fv';\r\n\r\ntype RemoveFirstFromTuple<T extends any[]> =\r\n  T['length'] extends 0 ? undefined :\r\n    (((...b: T) => void) extends (a: any, ...b: infer I) => void ? I : [])\r\n\r\ntype UniformParameters<TUniformType extends UniformTypeNames> = RemoveFirstFromTuple<Parameters<WebGLRenderingContext[TUniformType]>>\r\n\r\nexport interface UniformDefinition {\r\n  name: string;\r\n  glType: number;\r\n  location: WebGLUniformLocation;\r\n}\r\n\r\n\r\nexport interface VertexAttributeDefinition {\r\n  /**\r\n   * string name of the attribute in the shader program, commonly `a_nameofmyvariable`\r\n   */\r\n  name: string;\r\n  /**\r\n   * Number of components for a given attribute\r\n   * Must be 1, 2, 3, or 4\r\n   *\r\n   * For example a vec4 attribute would be `4` floats, so 4\r\n   */\r\n  size: number;\r\n  /**\r\n   * Supported types in webgl 1\r\n   * * gl.BYTE\r\n   * * gl.SHORT\r\n   * * gl.UNSIGNED_BYTE\r\n   * * gl.UNSIGNED_SHORT\r\n   * * gl.FLOAT\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n   */\r\n  glType: number;\r\n  /**\r\n   * Is the attribute normalized between (0-1)\r\n   */\r\n  normalized: boolean;\r\n  /**\r\n   * Location index in the shader program\r\n   */\r\n  location: number;\r\n}\r\n\r\nexport interface ShaderOptions {\r\n  vertexSource: string;\r\n  fragmentSource: string;\r\n}\r\n\r\nexport class Shader {\r\n  private static _ACTIVE_SHADER_INSTANCE: Shader = null;\r\n  private _gl: WebGLRenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  public program: WebGLProgram;\r\n  public uniforms: { [variableName: string]: UniformDefinition } = {};\r\n  public attributes: { [variableName: string]: VertexAttributeDefinition } = {};\r\n  private _compiled = false;\r\n  public readonly vertexSource: string;\r\n  public readonly fragmentSource: string;\r\n\r\n  public get compiled() {\r\n    return this._compiled;\r\n  }\r\n\r\n  /**\r\n   * Create a shader program in excalibur\r\n   * @param options specify shader vertex and fragment source\r\n   */\r\n  constructor(options?: ShaderOptions) {\r\n    const { vertexSource, fragmentSource } = options;\r\n    this.vertexSource = vertexSource;\r\n    this.fragmentSource = fragmentSource;\r\n  }\r\n\r\n  /**\r\n   * Binds the shader program\r\n   */\r\n  use() {\r\n    const gl = this._gl;\r\n    gl.useProgram(this.program);\r\n    Shader._ACTIVE_SHADER_INSTANCE = this;\r\n  }\r\n\r\n  isCurrentlyBound() {\r\n    return Shader._ACTIVE_SHADER_INSTANCE === this;\r\n  }\r\n\r\n  /**\r\n   * Compile the current shader against a webgl context\r\n   */\r\n  compile(): WebGLProgram {\r\n    const gl = this._gl;\r\n    const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);\r\n    const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);\r\n    this.program = this._createProgram(gl, vertexShader, fragmentShader);\r\n\r\n    const attributes = this.getAttributes();\r\n    for (const attribute of attributes) {\r\n      this.attributes[attribute.name] = attribute;\r\n    }\r\n    const uniforms = this.getUniforms();\r\n    for (const uniform of uniforms) {\r\n      this.uniforms[uniform.name] = uniform;\r\n    }\r\n\r\n    this._compiled = true;\r\n    return this.program;\r\n  }\r\n\r\n  getUniforms(): UniformDefinition[] {\r\n    const gl = this._gl;\r\n    const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\r\n    const uniforms: UniformDefinition[] = [];\r\n    for (let i = 0; i < uniformCount; i++) {\r\n      const uniform = gl.getActiveUniform(this.program, i);\r\n      const uniformLocation = gl.getUniformLocation(this.program, uniform.name);\r\n      uniforms.push({\r\n        name: uniform.name,\r\n        glType: uniform.type,\r\n        location: uniformLocation\r\n      });\r\n    }\r\n    return uniforms;\r\n  }\r\n\r\n  getAttributes(): VertexAttributeDefinition[] {\r\n    const gl = this._gl;\r\n    const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\r\n    const attributes: VertexAttributeDefinition[] = [];\r\n    for (let i = 0; i < attributeCount; i++) {\r\n      const attribute = gl.getActiveAttrib(this.program, i);\r\n      const attributeLocation = gl.getAttribLocation(this.program, attribute.name);\r\n      attributes.push({\r\n        name: attribute.name,\r\n        glType: getAttributePointerType(gl, attribute.type),\r\n        size: getAttributeComponentSize(gl, attribute.type),\r\n        location: attributeLocation,\r\n        normalized: false\r\n      });\r\n    }\r\n    return attributes;\r\n  }\r\n\r\n  /**\r\n   * Set a texture in a gpu texture slot\r\n   * @param slotNumber\r\n   * @param texture\r\n   */\r\n  setTexture(slotNumber: number, texture: WebGLTexture) {\r\n    const gl = this._gl;\r\n    gl.activeTexture(gl.TEXTURE0 + slotNumber);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  }\r\n\r\n  /**\r\n   * Set an integer uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformInt(name: string, value: number) {\r\n    this.setUniform('uniform1i', name, ~~value);\r\n  }\r\n\r\n  /**\r\n   * Set an integer array uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformIntArray(name: string, value: number[]) {\r\n    this.setUniform('uniform1iv', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a boolean uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformBoolean(name: string, value: boolean) {\r\n    this.setUniform('uniform1i', name, value ? 1 : 0);\r\n  }\r\n\r\n  /**\r\n   * Set a float uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloat(name: string, value: number) {\r\n    this.setUniform('uniform1f', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a float array uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloatArray(name: string, value: number[]) {\r\n    this.setUniform('uniform1fv', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a [[Vector]] uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloatVector(name: string, value: Vector) {\r\n    this.setUniform('uniform2f', name, value.x, value.y);\r\n  }\r\n\r\n  /**\r\n   * Set an [[Matrix]] uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformMatrix(name: string, value: Matrix) {\r\n    this.setUniform('uniformMatrix4fv', name, false, value.data);\r\n  }\r\n\r\n  /**\r\n   * Set any available uniform type in webgl\r\n   *\r\n   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);\r\n   */\r\n  setUniform<TUniformType extends UniformTypeNames>(uniformType: TUniformType, name: string, ...value: UniformParameters<TUniformType>) {\r\n    if (!this._compiled) {\r\n      throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);\r\n    }\r\n    if (!this.isCurrentlyBound()) {\r\n      throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +\r\n      ' must call `shader.use()` before setting uniforms');\r\n    }\r\n    const gl = this._gl;\r\n    const location = gl.getUniformLocation(this.program, name);\r\n    if (location) {\r\n      const args = [location, ...value];\r\n      this._gl[uniformType].apply(this._gl, args);\r\n    } else {\r\n      throw Error(`Uniform ${uniformType}:${name} doesn\\'t exist or is not used in the shader source code,`+\r\n      ' unused uniforms are optimized away by most browsers');\r\n    }\r\n  }\r\n\r\n  private _createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\r\n    const program = gl.createProgram();\r\n    if (program === null) {\r\n      throw Error('Could not create graphics shader program');\r\n    }\r\n\r\n    // attach the shaders.\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n\r\n    // link the program.\r\n    gl.linkProgram(program);\r\n\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!success) {\r\n      throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  private _compileShader(gl: WebGLRenderingContext, source: string, type: number): WebGLShader {\r\n    const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';\r\n    const shader = gl.createShader(type);\r\n    if (shader === null) {\r\n      throw Error(`Could not build shader: [${source}]`);\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!success) {\r\n      const errorInfo = gl.getShaderInfoLog(shader);\r\n      throw Error(`Could not compile ${typeName} shader:\\n\\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  private _processSourceForError(source: string, errorInfo: string) {\r\n    const lines = source.split('\\n');\r\n    const errorLineStart = errorInfo.search(/\\d:\\d/);\r\n    const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);\r\n    const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(':').map(v => Number(v));\r\n    for (let i = 0; i < lines.length; i++) {\r\n      lines[i] = `${i+1}: ${lines[i]}${error2 === (i+1)? ' <----- ERROR!' : ''}`;\r\n    }\r\n\r\n    return '\\n\\nSource:\\n' + lines.join('\\n');\r\n  }\r\n}","import { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\n\r\nexport interface VertexBufferOptions {\r\n  /**\r\n   * Size in number of floats, so [4.2, 4.0, 2.1] is size = 3\r\n   *\r\n   * Ignored if data is passed directly\r\n   */\r\n  size?: number;\r\n  /**\r\n   * If the vertices never change switching 'static' can be more efficient on the gpu\r\n   *\r\n   * Default is 'dynamic'\r\n   */\r\n  type?: 'static' | 'dynamic';\r\n\r\n  /**\r\n   * Optionally pass pre-seeded data, size parameter is ignored\r\n   */\r\n  data?: Float32Array\r\n}\r\n\r\n/**\r\n * Helper around vertex buffer to simplify creating and uploading geometry\r\n *\r\n * Under the hood uses Float32Array\r\n */\r\nexport class VertexBuffer {\r\n  private _gl: WebGL2RenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n\r\n  /**\r\n   * Access to the webgl buffer handle\r\n   */\r\n  public readonly buffer: WebGLBuffer;\r\n  /**\r\n   * Access to the raw data of the vertex buffer\r\n   */\r\n  public readonly bufferData: Float32Array;\r\n\r\n  /**\r\n   * If the vertices never change switching 'static' can be more efficient on the gpu\r\n   *\r\n   * Default is 'dynamic'\r\n   */\r\n  public type: 'static' | 'dynamic' = 'dynamic';\r\n\r\n  constructor(options: VertexBufferOptions) {\r\n    const { size, type, data } = options;\r\n    this.buffer = this._gl.createBuffer();\r\n    if (!data && !size) {\r\n      throw Error('Must either provide data or a size to the VertexBuffer');\r\n    }\r\n\r\n    if (!data) {\r\n      this.bufferData = new Float32Array(size);\r\n    } else {\r\n      this.bufferData = data;\r\n    }\r\n    this.type = type ?? this.type;\r\n    // Allocate buffer\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n  }\r\n\r\n  /**\r\n   * Bind this vertex buffer\r\n   */\r\n  bind() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n\r\n  }\r\n\r\n  /**\r\n   * Upload vertex buffer geometry to the GPU\r\n   */\r\n  upload(count?: number) {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    if (count) {\r\n      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);\r\n    } else {\r\n      // TODO always use bufferSubData? need to perf test it\r\n      gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n    }\r\n  }\r\n}","import { Logger } from '../..';\r\nimport { Shader, VertexAttributeDefinition } from './shader';\r\nimport { VertexBuffer } from './vertex-buffer';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { getGlTypeSizeBytes } from './webgl-util';\r\n\r\n\r\nexport interface VertexLayoutOptions {\r\n  /**\r\n   * Shader that this layout will be for\r\n   */\r\n  shader: Shader;\r\n  /**\r\n   * Vertex buffer to use for vertex data\r\n   */\r\n  vertexBuffer: VertexBuffer,\r\n  /**\r\n   * Specify the attributes that will exist in the vertex buffer\r\n   *\r\n   * **Important** must specify them in the order that they will be in the vertex buffer!!\r\n   */\r\n  attributes: [name: string, numberOfComponents: number][]\r\n}\r\n\r\n/**\r\n * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing\r\n * the memory layout for your vertices inside a particular buffer\r\n *\r\n * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.\r\n *\r\n * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you\r\n */\r\nexport class VertexLayout {\r\n  private _gl: WebGLRenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  private _logger = Logger.getInstance();\r\n  private _shader: Shader;\r\n  private _layout: VertexAttributeDefinition[] = [];\r\n  private _attributes: [name: string, numberOfComponents: number][] = [];\r\n  private _vertexBuffer: VertexBuffer;\r\n  public get vertexBuffer() {\r\n    return this._vertexBuffer;\r\n  }\r\n\r\n  public get attributes(): readonly [name: string, numberOfComponents: number][] {\r\n    return this._attributes;\r\n  }\r\n\r\n  constructor(options: VertexLayoutOptions) {\r\n    const {shader, vertexBuffer, attributes} = options;\r\n    this._vertexBuffer = vertexBuffer;\r\n    this._attributes = attributes;\r\n    this._shader = shader;\r\n    this.initialize();\r\n  }\r\n\r\n  private _vertexTotalSizeBytes = 0;\r\n  /**\r\n   * Total number of bytes that the vertex will take up\r\n   */\r\n  public get totalVertexSizeBytes(): number {\r\n    return this._vertexTotalSizeBytes;\r\n  }\r\n\r\n  /**\r\n   * Layouts need shader locations and must be bound to a shader\r\n   */\r\n  initialize() {\r\n    if (!this._shader.compiled) {\r\n      throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');\r\n    }\r\n    this._layout.length = 0;\r\n    const shaderAttributes = this._shader.attributes;\r\n    for (const attribute of this._attributes) {\r\n      const attrib = shaderAttributes[attribute[0]];\r\n      if (!attrib) {\r\n        throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}`+\r\n        ` not found in the shader source code:\\n ${this._shader.vertexSource}`);\r\n      }\r\n      if (attrib.size !== attribute[1]) {\r\n        throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],`\r\n        +` doesnt match shader source size ${attrib.size}:\\n ${this._shader.vertexSource}`);\r\n      }\r\n      this._layout.push(attrib);\r\n    }\r\n\r\n    // calc size\r\n    let componentsPerVertex = 0;\r\n    for (const vertAttribute of this._layout) {\r\n      const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);\r\n      this._vertexTotalSizeBytes += typeSize * vertAttribute.size;\r\n      componentsPerVertex += vertAttribute.size;\r\n    }\r\n\r\n    if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {\r\n      this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer`\r\n      +` (${this._vertexBuffer.bufferData.length})`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind this layout with it's associated vertex buffer\r\n   *\r\n   * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout\r\n   */\r\n  use(uploadBuffer = false, count?: number) {\r\n    const gl = this._gl;\r\n    if (!this._shader.isCurrentlyBound()) {\r\n      throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');\r\n    }\r\n    this._vertexBuffer.bind();\r\n    if (uploadBuffer) {\r\n      this._vertexBuffer.upload(count);\r\n    }\r\n    let offset = 0;\r\n    // TODO switch to VAOs if the extension is\r\n    for (const vert of this._layout) {\r\n      gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);\r\n      gl.enableVertexAttribArray(vert.location);\r\n      offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;\r\n    }\r\n  }\r\n}","export class GraphicsDiagnostics {\r\n  public static DrawCallCount: number = 0;\r\n  public static DrawnImagesCount: number = 0;\r\n  public static clear(): void {\r\n    GraphicsDiagnostics.DrawCallCount = 0;\r\n    GraphicsDiagnostics.DrawnImagesCount = 0;\r\n  }\r\n}\r\n","import { Vector } from '../../../Math/vector';\r\nimport { Color } from '../../../Color';\r\nimport lineVertexSource from './line-vertex.glsl';\r\nimport lineFragmentSource from './line-fragment.glsl';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader, VertexBuffer, VertexLayout } from '../..';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\n\r\nexport class LineRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.line';\r\n  public priority: number = 0;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _maxLines: number = 10922;\r\n  private _vertexBuffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _vertexIndex = 0;\r\n  private _lineCount = 0;\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      vertexSource: lineVertexSource,\r\n      fragmentSource: lineFragmentSource\r\n    });\r\n    this._shader.compile();\r\n    this._shader.use();\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    this._vertexBuffer = new VertexBuffer({\r\n      size: 6 * 2 * this._maxLines,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      vertexBuffer: this._vertexBuffer,\r\n      shader: this._shader,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_color', 4]\r\n      ]\r\n    });\r\n  }\r\n\r\n  draw(start: Vector, end: Vector, color: Color): void {\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._lineCount++;\r\n\r\n    const transform = this._context.getTransform();\r\n    const finalStart = transform.multiply(start);\r\n    const finalEnd = transform.multiply(end);\r\n\r\n\r\n    const vertexBuffer = this._vertexBuffer.bufferData;\r\n    // Start\r\n    vertexBuffer[this._vertexIndex++] = finalStart.x;\r\n    vertexBuffer[this._vertexIndex++] = finalStart.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n\r\n    // End\r\n    vertexBuffer[this._vertexIndex++] = finalEnd.x;\r\n    vertexBuffer[this._vertexIndex++] = finalEnd.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._lineCount >= this._maxLines) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._lineCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._lineCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use(true);\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._lineCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // reset\r\n    this._vertexIndex = 0;\r\n    this._lineCount = 0;\r\n  }\r\n}\r\n","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\nin float a_size;\\r\\nout lowp vec4 v_color;\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n  gl_PointSize = a_size * 2.0;\\r\\n  v_color = a_color;\\r\\n}\";","export default \"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  float r = 0.0, delta = 0.0, alpha = 1.0;\\r\\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\r\\n  r = dot(cxy, cxy);\\r\\n\\r\\n  delta = fwidth(r);\\r\\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\r\\n  // \\\"premultiply\\\" the color by alpha\\r\\n  vec4 color = v_color;\\r\\n  color.a = color.a * alpha;\\r\\n  color.rgb = color.rgb * color.a;\\r\\n  fragColor = color;\\r\\n}\";","import pointVertexSource from './point-vertex.glsl';\r\nimport pointFragmentSource from './point-fragment.glsl';\r\nimport { Vector } from '../../../Math/vector';\r\nimport { Color } from '../../../Color';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\n\r\nexport class PointRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.point';\r\n  public priority: number = 0;\r\n  private _shader: Shader;\r\n  private _maxPoints: number = 10922;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _gl: WebGLRenderingContext;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _pointCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      vertexSource: pointVertexSource,\r\n      fragmentSource: pointFragmentSource\r\n    });\r\n    this._shader.compile();\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n    this._buffer = new VertexBuffer({\r\n      size: 7 * this._maxPoints,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_color', 4],\r\n        ['a_size', 1]\r\n      ]\r\n    });\r\n  }\r\n\r\n  draw(point: Vector, color: Color, size: number): void {\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._pointCount++;\r\n\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const finalPoint = transform.multiply(point);\r\n\r\n    if (snapToPixel) {\r\n      finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);\r\n      finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    const vertexBuffer = this._buffer.bufferData;\r\n    vertexBuffer[this._vertexIndex++] = finalPoint.x;\r\n    vertexBuffer[this._vertexIndex++] = finalPoint.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a * opacity;\r\n    vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._pointCount >= this._maxPoints) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._pointCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._pointCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use(true);\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    gl.drawArrays(gl.POINTS, 0, this._pointCount);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._pointCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    this._pointCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n}\r\n","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n  // Pass the texcoord to the fragment shader.\\r\\n  v_texcoord = a_texcoord;\\r\\n}\";","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// The texture.\\r\\nuniform sampler2D u_texture;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   fragColor = texture(u_texture, v_texcoord);\\r\\n}\";","\r\nimport screenVertex from './screen-vertex.glsl';\r\nimport screenFragment from './screen-fragment.glsl';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { PostProcessor } from '../../PostProcessor/PostProcessor';\r\n\r\n/**\r\n * This is responsible for painting the entire screen during the render passes\r\n */\r\nexport class ScreenPassPainter {\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  constructor(gl: WebGLRenderingContext) {\r\n    this._gl = gl;\r\n    this._shader = new Shader({\r\n      vertexSource: screenVertex,\r\n      fragmentSource: screenFragment\r\n    });\r\n    this._shader.compile();\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      type: 'static',\r\n      // clip space quad + uv since we don't need a camera\r\n      data: new Float32Array([\r\n        -1, -1,          0, 0,\r\n        -1, 1,           0, 1,\r\n        1, -1,           1, 0,\r\n\r\n        1, -1,            1, 0,\r\n        -1, 1,           0, 1,\r\n        1, 1,            1, 1\r\n      ])\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_texcoord', 2]\r\n      ]\r\n    });\r\n    this._buffer.upload();\r\n  }\r\n\r\n  renderWithPostProcessor(postprocessor: PostProcessor): void {\r\n    const gl = this._gl;\r\n    postprocessor.getShader().use();\r\n    postprocessor.getLayout().use();\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n\r\n  renderToScreen(): void {\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use();\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n}","import { Logger } from '../..';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\n\r\n/**\r\n * Helper that defines and index buffer for quad geometry\r\n *\r\n * Index buffers allow you to save space in vertex buffers when you share vertices in geometry\r\n * it is almost always worth it in terms of performance to use an index buffer.\r\n */\r\nexport class QuadIndexBuffer {\r\n  private _gl: WebGL2RenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Access to the webgl buffer handle\r\n   */\r\n  public buffer: WebGLBuffer;\r\n  /**\r\n   * Access to the raw data of the index buffer\r\n   */\r\n  public bufferData: Uint16Array | Uint32Array;\r\n  /**\r\n   * Depending on the browser this is either gl.UNSIGNED_SHORT or gl.UNSIGNED_INT\r\n   */\r\n  public bufferGlType: number;\r\n\r\n  /**\r\n   * @param numberOfQuads Specify the max number of quads you want to draw\r\n   * @param useUint16 Optionally force a uint16 buffer\r\n   */\r\n  constructor(numberOfQuads: number, useUint16?: boolean) {\r\n    const gl = this._gl;\r\n    this.buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n\r\n    const totalVertices = numberOfQuads * 6;\r\n\r\n    if (!useUint16) {\r\n      this.bufferData = new Uint32Array(totalVertices);\r\n    } else {\r\n      // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck\r\n      const maxUint16 = 65_535;\r\n      const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads\r\n\r\n      this.bufferGlType = gl.UNSIGNED_SHORT;\r\n      this.bufferData = new Uint16Array(totalVertices);\r\n      // TODO Should we error if this happens?? maybe not might crash mid game\r\n      if (numberOfQuads > maxUint16Index) {\r\n        this._logger.warn(\r\n          `Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);\r\n      }\r\n    }\r\n\r\n\r\n    let currentQuad = 0;\r\n    for (let i = 0; i < totalVertices; i += 6) {\r\n      // first triangle\r\n      this.bufferData[i + 0] = currentQuad + 0;\r\n      this.bufferData[i + 1] = currentQuad + 1;\r\n      this.bufferData[i + 2] = currentQuad + 2;\r\n      // second triangle\r\n      this.bufferData[i + 3] = currentQuad + 2;\r\n      this.bufferData[i + 4] = currentQuad + 1;\r\n      this.bufferData[i + 5] = currentQuad + 3;\r\n      currentQuad += 4;\r\n    }\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n  }\r\n\r\n  public get size() {\r\n    return this.bufferData.length;\r\n  }\r\n\r\n  /**\r\n   * Upload data to the GPU\r\n   */\r\n  public upload() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n  }\r\n\r\n  /**\r\n   * Bind this index buffer\r\n   */\r\n  public bind() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n  }\r\n}","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// Texture index\\r\\nin lowp float v_textureIndex;\\r\\n\\r\\n// Textures in the current draw\\r\\nuniform sampler2D u_textures[%%count%%];\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nin vec4 v_tint;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   // In order to support the most efficient sprite batching, we have multiple\\r\\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\\r\\n   // that do not apply to a particular sprite.\\r\\n\\r\\n   vec4 color = vec4(1.0, 0, 0, 1.0);\\r\\n\\r\\n   // GLSL is templated out to pick the right texture and set the vec4 color\\r\\n   %%texture_picker%%\\r\\n\\r\\n   color.rgb = color.rgb * v_opacity;\\r\\n   color.a = color.a * v_opacity;\\r\\n   fragColor = color * v_tint;\\r\\n}\";","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_texcoord;\\r\\nout vec2 v_texcoord;\\r\\n\\r\\n// Texture number\\r\\nin lowp float a_textureIndex;\\r\\nout lowp float v_textureIndex;\\r\\n\\r\\nin vec4 a_tint;\\r\\nout vec4 v_tint;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the UV coord to the fragment shader\\r\\n   v_texcoord = a_texcoord;\\r\\n   // Pass through the texture number to the fragment shader\\r\\n   v_textureIndex = a_textureIndex;\\r\\n   // Pass through the tint\\r\\n   v_tint = a_tint;\\r\\n}\";","import { vec } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { HTMLImageSource } from '../ExcaliburGraphicsContext';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { TextureLoader } from '../texture-loader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport frag from './image-renderer.frag.glsl';\r\nimport vert from './image-renderer.vert.glsl';\r\n\r\nexport class ImageRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.image';\r\n  public priority: number = 0;\r\n\r\n  private _maxImages: number = 10922; // max(uint16) / 6 verts\r\n  private _maxTextures: number = 0;\r\n\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n\r\n  // Per flush vars\r\n  private _imageCount: number = 0;\r\n  private _textures: WebGLTexture[] = [];\r\n  private _vertexIndex: number = 0;\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    // Transform shader source\r\n    // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...\r\n    this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);\r\n    const transformedFrag = this._transformFragmentSource(frag, this._maxTextures);\r\n    // Compile shader\r\n    this._shader = new Shader({\r\n      fragmentSource: transformedFrag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n    // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]\r\n    this._shader.setUniformIntArray(\r\n      'u_textures',\r\n      [...Array(this._maxTextures)].map((_, i) => i)\r\n    );\r\n\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      size: 10 * 4 * this._maxImages, // 10 components * 4 verts\r\n      type: 'dynamic'\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_opacity', 1],\r\n        ['a_texcoord', 2],\r\n        ['a_textureIndex', 1],\r\n        ['a_tint', 4]\r\n      ]\r\n    });\r\n\r\n    // Setup index buffer\r\n    this._quads = new QuadIndexBuffer(this._maxImages, true);\r\n  }\r\n\r\n  private _transformFragmentSource(source: string, maxTextures: number): string {\r\n    let newSource = source.replace('%%count%%', maxTextures.toString());\r\n    let texturePickerBuilder = '';\r\n    for (let i = 0; i < maxTextures; i++) {\r\n      if (i === 0) {\r\n        texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\\n`;\r\n      } else {\r\n        texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\\n`;\r\n      }\r\n      texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\\n`;\r\n      texturePickerBuilder += `   }\\n`;\r\n    }\r\n    newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);\r\n    return newSource;\r\n  }\r\n\r\n  private _addImageAsTexture(image: HTMLImageSource) {\r\n    const texture = TextureLoader.load(image);\r\n    if (this._textures.indexOf(texture) === -1) {\r\n      this._textures.push(texture);\r\n    }\r\n  }\r\n\r\n  private _bindTextures(gl: WebGLRenderingContext) {\r\n    // Bind textures in the correct order\r\n    for (let i = 0; i < this._maxTextures; i++) {\r\n      gl.activeTexture(gl.TEXTURE0 + i);\r\n      gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);\r\n    }\r\n  }\r\n\r\n  private _getTextureIdForImage(image: HTMLImageSource) {\r\n    if (image) {\r\n      return this._textures.indexOf(TextureLoader.get(image));\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._imageCount >= this._maxImages) {\r\n      return true;\r\n    }\r\n    if (this._textures.length >= this._maxTextures) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  draw(image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number): void {\r\n\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._imageCount++;\r\n    this._addImageAsTexture(image);\r\n\r\n    let width = image?.width || swidth || 0;\r\n    let height = image?.height || sheight || 0;\r\n    let view = [0, 0, swidth ?? image?.width ?? 0, sheight ?? image?.height ?? 0];\r\n    let dest = [sx ?? 1, sy ?? 1];\r\n    // If destination is specified, update view and dest\r\n    if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {\r\n      view = [sx ?? 1, sy ?? 1, swidth ?? image?.width ?? 0, sheight ?? image?.height ?? 0];\r\n      dest = [dx, dy];\r\n      width = dwidth;\r\n      height = dheight;\r\n    }\r\n\r\n    sx = view[0];\r\n    sy = view[1];\r\n    const sw = view[2];\r\n    const sh = view[3];\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    let topLeft = vec(dest[0], dest[1]);\r\n    let topRight = vec(dest[0] + width, dest[1]);\r\n    let bottomLeft = vec(dest[0], dest[1] + height);\r\n    let bottomRight = vec(dest[0] + width, dest[1] + height);\r\n\r\n    topLeft = transform.multiply(topLeft);\r\n    topRight = transform.multiply(topRight);\r\n    bottomLeft = transform.multiply(bottomLeft);\r\n    bottomRight = transform.multiply(bottomRight);\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n\r\n      topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n      topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n\r\n      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n\r\n      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    const tint = this._context.tint;\r\n\r\n    const textureId = this._getTextureIdForImage(image);\r\n    const imageWidth = image.width || width;\r\n    const imageHeight = image.height || height;\r\n\r\n    const uvx0 = (sx) / imageWidth;\r\n    const uvy0 = (sy) / imageHeight;\r\n    const uvx1 = (sx + sw - 0.01) / imageWidth;\r\n    const uvy1 = (sy + sh - 0.01) / imageHeight;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n    vertexBuffer[this._vertexIndex++] = tint.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = tint.a;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._imageCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._imageCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true, 4 * 10 * this._imageCount);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind textures to\r\n    this._bindTextures(gl);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._imageCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._imageCount = 0;\r\n    this._vertexIndex = 0;\r\n    this._textures.length = 0;\r\n  }\r\n}","export default \"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\nin vec2 v_size; // in pixels\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness; // in pixels\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\\r\\n    vec2 uv = v_uv;\\r\\n    vec2 fragCoord = uv * v_size;\\r\\n    float maxX = v_size.x - v_strokeThickness;\\r\\n    float minX = v_strokeThickness;\\r\\n    float maxY = v_size.y - v_strokeThickness;\\r\\n    float minY = v_strokeThickness;\\r\\n\\r\\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\\r\\n        fragCoord.y < maxY && fragCoord.y > minY) {\\r\\n      fragColor = v_color;\\r\\n    } else {\\r\\n      fragColor = v_strokeColor;\\r\\n    }\\r\\n    fragColor.a *= v_opacity;\\r\\n    fragColor.rgb *= fragColor.a;\\r\\n\\r\\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\\r\\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\\r\\n\\r\\n    // float fHalfBorderDist      = 0.0;\\r\\n    // float fHalfBorderThickness = 0.0;\\r\\n\\r\\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \\r\\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \\r\\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else\\r\\n    // {\\r\\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\\r\\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\\r\\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\\r\\n        \\r\\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\\r\\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\\r\\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \\r\\n            \\r\\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\\r\\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\\r\\n    // }\\r\\n\\r\\n    // vec4 v4FromColor = v_strokeColor;\\r\\n    // v4FromColor.rgb *= v4FromColor.a;\\r\\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\\r\\n    // if (fHalfBorderDist < 0.0) {\\r\\n    //     v4ToColor = v_color;\\r\\n    //     v4ToColor.rgb *= v4ToColor.a;\\r\\n    // }\\r\\n\\r\\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\\r\\n\\r\\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\\r\\n    // gl_FragColor = finalColor;\\r\\n}\";","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\nin vec2 a_size;\\r\\nout vec2 v_size;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through size\\r\\n   v_size = a_size;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\";","import { Color } from '../../../Color';\r\nimport { vec, Vector } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\n\r\nimport frag from './rectangle-renderer.frag.glsl';\r\nimport vert from './rectangle-renderer.vert.glsl';\r\n\r\nexport class RectangleRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.rectangle';\r\n  public priority: number = 0;\r\n\r\n  private _maxRectangles: number = 10922; // max(uint16) / 6 verts\r\n\r\n  private _shader: Shader;\r\n  private _gl: WebGLRenderingContext;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n  private _rectangleCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    this._shader = new Shader({\r\n      fragmentSource: frag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n\r\n    this._buffer = new VertexBuffer({\r\n      size: 16 * 4 * this._maxRectangles,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_uv', 2],\r\n        ['a_size', 2],\r\n        ['a_opacity', 1],\r\n        ['a_color', 4],\r\n        ['a_strokeColor', 4],\r\n        ['a_strokeThickness', 1]\r\n      ]\r\n    });\r\n    this._quads = new QuadIndexBuffer(this._maxRectangles, true);\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._rectangleCount >= this._maxRectangles) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  draw(...args: any[]): void {\r\n    if (args[0] instanceof Vector && args[1] instanceof Vector) {\r\n      this.drawLine.apply(this, args);\r\n    } else {\r\n      this.drawRectangle.apply(this, args);\r\n    }\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, color: Color, thickness: number = 1) {\r\n\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._rectangleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const dir = end.sub(start);\r\n    const length = dir.size;\r\n    const normal = dir.normalize().perpendicular();\r\n    const halfThick = thickness / 2;\r\n\r\n    /**\r\n     *    +---------------------^----------------------+\r\n     *    |                     | (normal)             |\r\n     *   (startx, starty)------------------>(endx, endy)\r\n     *    |                                            |\r\n     *    + -------------------------------------------+\r\n     */\r\n    const startTop = transform.multiply(normal.scale(halfThick).add(start));\r\n    const startBottom = transform.multiply(normal.scale(-halfThick).add(start));\r\n    const endTop = transform.multiply(normal.scale(halfThick).add(end));\r\n    const endBottom = transform.multiply(normal.scale(-halfThick).add(end));\r\n\r\n    if (snapToPixel) {\r\n      startTop.x = ~~(startTop.x + pixelSnapEpsilon);\r\n      startTop.y = ~~(startTop.y + pixelSnapEpsilon);\r\n\r\n      endTop.x = ~~(endTop.x + pixelSnapEpsilon);\r\n      endTop.y = ~~(endTop.y + pixelSnapEpsilon);\r\n\r\n      startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);\r\n      startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);\r\n\r\n      endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);\r\n      endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    // TODO uv could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    const stroke = Color.Transparent;\r\n    const strokeThickness = 0;\r\n    const width = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = startTop.x;\r\n    vertexBuffer[this._vertexIndex++] = startTop.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = startBottom.x;\r\n    vertexBuffer[this._vertexIndex++] = startBottom.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = endTop.x;\r\n    vertexBuffer[this._vertexIndex++] = endTop.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = endBottom.x;\r\n    vertexBuffer[this._vertexIndex++] = endBottom.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n  }\r\n\r\n  drawRectangle(\r\n    pos: Vector,\r\n    width: number,\r\n    height: number,\r\n    color: Color,\r\n    stroke: Color = Color.Transparent,\r\n    strokeThickness: number = 0): void {\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._rectangleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const topLeft = transform.multiply(pos.add(vec(0, 0)));\r\n    const topRight = transform.multiply(pos.add(vec(width, 0)));\r\n    const bottomRight = transform.multiply(pos.add(vec(width, height)));\r\n    const bottomLeft = transform.multiply(pos.add(vec(0, height)));\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n\r\n      topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n      topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n\r\n      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n\r\n      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    // TODO uv could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._rectangleCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._rectangleCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._rectangleCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n\r\n}","export default \"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness;\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  // make (0, 0) the center the uv \\r\\n  vec2 uv = v_uv * 2.0 - 1.0;\\r\\n\\r\\n  vec4 color = v_color;\\r\\n  vec4 strokeColor = v_strokeColor;\\r\\n\\r\\n  // circle border is at radius 1.0 \\r\\n  // dist is > 0 when inside the circle \\r\\n  float d = length(uv);\\r\\n  float dist = 1.0 - length(uv);\\r\\n\\r\\n  // Fade based on fwidth\\r\\n  float fade = fwidth(dot(uv, uv));\\r\\n\\r\\n  // if dist is greater than 0 step to 1;\\r\\n  // when we cross this 0 threshold add a smooth fade\\r\\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\\r\\n\\r\\n  // if dist is greater than the stroke thickness step to 1\\r\\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\\r\\n\\r\\n  strokeColor.a *= fill * stroke;\\r\\n  strokeColor.rgb *= strokeColor.a;\\r\\n\\r\\n  color.a *= fill * (1.0 - stroke);\\r\\n  color.rgb *= color.a;\\r\\n\\r\\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\\r\\n  finalColor.rgb = finalColor.rgb * v_opacity;\\r\\n  finalColor.a = finalColor.a * v_opacity;\\r\\n  fragColor = finalColor;\\r\\n}\";","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\n\\r\\n// UV coordinate\\r\\nin vec2 a_uv;\\r\\nout vec2 v_uv;\\r\\n\\r\\n// Opacity \\r\\nin float a_opacity;\\r\\nout float v_opacity;\\r\\n\\r\\nin vec4 a_color;\\r\\nout vec4 v_color;\\r\\n\\r\\nin vec4 a_strokeColor;\\r\\nout vec4 v_strokeColor;\\r\\n\\r\\nin float a_strokeThickness;\\r\\nout float v_strokeThickness;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n\\r\\n   // Pass through UV coords\\r\\n   v_uv = a_uv;\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n   // Pass through the stroke color to the fragment shader\\r\\n   v_strokeColor = a_strokeColor;\\r\\n   // Pass through the stroke thickenss to the fragment shader\\r\\n   v_strokeThickness = a_strokeThickness;\\r\\n}\";","import { Color } from '../../../Color';\r\nimport { vec, Vector } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { ExcaliburGraphicsContextWebGL, pixelSnapEpsilon } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\n\r\nimport frag from './circle-renderer.frag.glsl';\r\nimport vert from './circle-renderer.vert.glsl';\r\n\r\nexport class CircleRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.circle';\r\n  public priority: number = 0;\r\n\r\n  private _maxCircles: number = 10922; // max(uint16) / 6 verts\r\n\r\n  private _shader: Shader;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n\r\n  private _circleCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      fragmentSource: frag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n\r\n    this._buffer = new VertexBuffer({\r\n      size: 14 * 4 * this._maxCircles,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_uv', 2],\r\n        ['a_opacity', 1],\r\n        ['a_color', 4],\r\n        ['a_strokeColor', 4],\r\n        ['a_strokeThickness', 1]\r\n      ]\r\n    });\r\n\r\n    this._quads = new QuadIndexBuffer(this._maxCircles, true);\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._circleCount >= this._maxCircles) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  draw(pos: Vector, radius: number, color: Color, stroke: Color = Color.Transparent, strokeThickness: number = 0): void {\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._circleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));\r\n    const topRight = transform.multiply(pos.add(vec(radius, -radius)));\r\n    const bottomRight = transform.multiply(pos.add(vec(radius, radius)));\r\n    const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);\r\n      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);\r\n\r\n      topRight.x = ~~(topRight.x + pixelSnapEpsilon);\r\n      topRight.y = ~~(topRight.y + pixelSnapEpsilon);\r\n\r\n      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);\r\n      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);\r\n\r\n      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);\r\n      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);\r\n    }\r\n\r\n    // TODO UV could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._circleCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._circleCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._circleCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._circleCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n\r\n}","import { Logger } from '..';\r\nexport class Pool<Type> {\r\n  public totalAllocations = 0;\r\n  public index = 0;\r\n  public objects: Type[] = [];\r\n  public disableWarnings = false;\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(\r\n    public builder: (...args: any[]) => Type,\r\n    public recycler: (instance: Type, ...args: any[]) => Type,\r\n    public maxObjects: number = 100\r\n  ) {}\r\n\r\n  preallocate() {\r\n    for (let i = 0; i < this.maxObjects; i++) {\r\n      this.objects[i] = this.builder();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use many instances out of the in the context and return all to the pool.\r\n   *\r\n   * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers\r\n   * @param context\r\n   */\r\n  using(context: (pool: Pool<Type>) => Type[] | void) {\r\n    const result = context(this);\r\n    if (result) {\r\n      return this.done(...result);\r\n    }\r\n    return this.done();\r\n  }\r\n\r\n  /**\r\n   * Use a single instance out of th pool and immediately return it to the pool\r\n   * @param context\r\n   */\r\n  borrow(context: (object: Type) => void) {\r\n    const object = this.get();\r\n    context(object);\r\n    this.index--;\r\n  }\r\n\r\n  /**\r\n   * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool\r\n   * @param args\r\n   */\r\n  get(...args: any[]): Type {\r\n    if (this.index === this.maxObjects) {\r\n      if (!this.disableWarnings) {\r\n        this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');\r\n      }\r\n      this.maxObjects = this.maxObjects * 2;\r\n    }\r\n\r\n    if (this.objects[this.index]) {\r\n      // Pool has an available object already constructed\r\n      return this.recycler(this.objects[this.index++], ...args);\r\n    } else {\r\n      // New allocation\r\n      this.totalAllocations++;\r\n      const object = (this.objects[this.index++] = this.builder(...args));\r\n      return object;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Signals we are done with the pool objects for now, Reclaims all objects in the pool.\r\n   *\r\n   * If a list of pooled objects is passed to done they are un-hooked from the pool and are free\r\n   * to be passed to consumers\r\n   * @param objects A list of object to separate from the pool\r\n   */\r\n  done(...objects: Type[]): Type[];\r\n  done(): void;\r\n  done(...objects: Type[]): Type[] | void {\r\n    // All objects in pool now considered \"free\"\r\n    this.index = 0;\r\n    for (const object of objects) {\r\n      const poolIndex = this.objects.indexOf(object);\r\n      // Build a new object to take the pool place\r\n      this.objects[poolIndex] = (this as any).builder(); // TODO problematic 0-arg only support\r\n      this.totalAllocations++;\r\n    }\r\n    return objects;\r\n  }\r\n}\r\n","import { AffineMatrix } from '../../Math/affine-matrix';\r\nimport { Color } from '../../Color';\r\nimport { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class DrawCall {\r\n  public z: number = 0;\r\n  public priority: number = 0;\r\n  public renderer: string;\r\n  public transform: AffineMatrix = AffineMatrix.identity();\r\n  public state: ExcaliburGraphicsContextState = {\r\n    z: 0,\r\n    opacity: 1,\r\n    tint: Color.White\r\n  };\r\n  public args: any[];\r\n}","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  RectGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\n\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { TransformStack } from './transform-stack';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { Logger } from '../../Util/Log';\r\nimport { DebugText } from './debug-text';\r\nimport { ScreenDimension } from '../../Screen';\r\nimport { RenderTarget } from './render-target';\r\nimport { PostProcessor } from '../PostProcessor/PostProcessor';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { TextureLoader } from './texture-loader';\r\nimport { RendererPlugin } from './renderer';\r\n\r\n// renderers\r\nimport { LineRenderer } from './line-renderer/line-renderer';\r\nimport { PointRenderer } from './point-renderer/point-renderer';\r\nimport { ScreenPassPainter } from './screen-pass-painter/screen-pass-painter';\r\nimport { ImageRenderer } from './image-renderer/image-renderer';\r\nimport { RectangleRenderer } from './rectangle-renderer/rectangle-renderer';\r\nimport { CircleRenderer } from './circle-renderer/circle-renderer';\r\nimport { Pool } from '../../Util/Pool';\r\nimport { DrawCall } from './draw-call';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport const pixelSnapEpsilon = 0.0001;\r\n\r\nclass ExcaliburGraphicsContextWebGLDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _webglCtx: ExcaliburGraphicsContextWebGL) {}\r\n\r\n  /**\r\n   * Draw a debugging rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number, rectOptions: RectGraphicsOptions = { color: Color.Black }): void {\r\n    this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging line to the context\r\n   * @param start\r\n   * @param end\r\n   * @param lineOptions\r\n   */\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._webglCtx.draw<LineRenderer>('ex.line', start, end, lineOptions.color);\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging point to the context\r\n   * @param point\r\n   * @param pointOptions\r\n   */\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._webglCtx.draw<PointRenderer>('ex.point', point, pointOptions.color, pointOptions.size);\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._webglCtx, text, pos);\r\n  }\r\n}\r\n\r\nexport interface WebGLGraphicsContextInfo {\r\n  transform: TransformStack;\r\n  state: StateStack;\r\n  ortho: Matrix;\r\n  context: ExcaliburGraphicsContextWebGL;\r\n}\r\n\r\nexport class ExcaliburGraphicsContextWebGL implements ExcaliburGraphicsContext {\r\n  private _logger = Logger.getInstance();\r\n  private _renderers: Map<string, RendererPlugin> = new Map<string, RendererPlugin>();\r\n  private _isDrawLifecycle = false;\r\n  public useDrawSorting = true;\r\n\r\n  private _drawCallPool = new Pool<DrawCall>(\r\n    () => new DrawCall(),\r\n    (instance) => {\r\n      instance.priority = 0;\r\n      instance.z = 0;\r\n      instance.renderer = undefined;\r\n      instance.args = undefined;\r\n      return instance;\r\n    }, 4000);\r\n  private _drawCalls: DrawCall[] = [];\r\n\r\n  // Main render target\r\n  private _renderTarget: RenderTarget;\r\n\r\n  // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process\r\n  private _postProcessTargets: RenderTarget[] = [];\r\n\r\n  private _screenRenderer: ScreenPassPainter;\r\n\r\n  private _postprocessors: PostProcessor[] = [];\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __gl: WebGL2RenderingContext;\r\n\r\n  private _transform = new TransformStack();\r\n  private _state = new StateStack();\r\n  private _ortho!: Matrix;\r\n\r\n  public snapToPixel: boolean = false;\r\n\r\n  public smoothing: boolean = false;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  public get z(): number {\r\n    return this._state.current.z;\r\n  }\r\n\r\n  public set z(value: number) {\r\n    this._state.current.z = value;\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public get tint(): Color {\r\n    return this._state.current.tint;\r\n  }\r\n\r\n  public set tint(color: Color) {\r\n    this._state.current.tint = color;\r\n  }\r\n\r\n  public get width() {\r\n    return this.__gl.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__gl.canvas.height;\r\n  }\r\n\r\n  public get ortho(): Matrix {\r\n    return this._ortho;\r\n  }\r\n\r\n  /**\r\n   * Checks the underlying webgl implementation if the requested internal resolution is supported\r\n   * @param dim\r\n   */\r\n  public checkIfResolutionSupported(dim: ScreenDimension): boolean {\r\n    // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo\r\n    let supported = true;\r\n    if (dim.width > 4096 || dim.height > 4096) {\r\n      supported = false;\r\n    }\r\n    return supported;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;\r\n    this.__gl = canvasElement.getContext('webgl2', {\r\n      antialias: smoothing ?? this.smoothing,\r\n      premultipliedAlpha: false,\r\n      alpha: enableTransparency ?? true,\r\n      depth: true,\r\n      powerPreference: 'high-performance'\r\n      // TODO Chromium fixed the bug where this didn't work now it breaks CI :(\r\n      // failIfMajorPerformanceCaveat: true\r\n    });\r\n    if (!this.__gl) {\r\n      throw Error('Failed to retrieve webgl context from browser');\r\n    }\r\n    ExcaliburWebGLContextAccessor.register(this.__gl);\r\n    TextureLoader.register(this.__gl);\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.useDrawSorting = useDrawSorting ?? this.useDrawSorting;\r\n    this._drawCallPool.disableWarnings = true;\r\n    this._drawCallPool.preallocate();\r\n    this._init();\r\n  }\r\n\r\n  private _init() {\r\n    const gl = this.__gl;\r\n    // Setup viewport and view matrix\r\n    this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n    // Clear background\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // Enable alpha blending\r\n    // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/\r\n    gl.enable(gl.BLEND);\r\n    gl.blendEquation(gl.FUNC_ADD);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\r\n    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n    // Setup builtin renderers\r\n    this.register(new ImageRenderer());\r\n    this.register(new RectangleRenderer());\r\n    this.register(new CircleRenderer());\r\n    this.register(new PointRenderer());\r\n    this.register(new LineRenderer());\r\n\r\n    this._screenRenderer = new ScreenPassPainter(gl);\r\n\r\n    this._renderTarget = new RenderTarget({\r\n      gl,\r\n      width: gl.canvas.width,\r\n      height: gl.canvas.height\r\n    });\r\n\r\n\r\n    this._postProcessTargets = [\r\n      new RenderTarget({\r\n        gl,\r\n        width: gl.canvas.width,\r\n        height: gl.canvas.height\r\n      }),\r\n      new RenderTarget({\r\n        gl,\r\n        width: gl.canvas.width,\r\n        height: gl.canvas.height\r\n      })\r\n    ];\r\n  }\r\n\r\n  public register<T extends RendererPlugin>(renderer: T) {\r\n    this._renderers.set(renderer.type, renderer);\r\n    renderer.initialize(this.__gl, this);\r\n  }\r\n\r\n  public get(rendererName: string): RendererPlugin {\r\n    return this._renderers.get(rendererName);\r\n  }\r\n\r\n  private _currentRenderer: RendererPlugin;\r\n\r\n  private _isCurrentRenderer(renderer: RendererPlugin): boolean {\r\n    if (!this._currentRenderer || this._currentRenderer === renderer) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public beginDrawLifecycle() {\r\n    this._isDrawLifecycle = true;\r\n  }\r\n\r\n  public endDrawLifecycle() {\r\n    this._isDrawLifecycle = false;\r\n  }\r\n\r\n  private _alreadyWarnedDrawLifecycle = false;\r\n\r\n  public draw<TRenderer extends RendererPlugin>(rendererName: TRenderer['type'], ...args: Parameters<TRenderer['draw']>) {\r\n    if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {\r\n      this._logger.warn(\r\n        `Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\\n` +\r\n        `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);\r\n      this._alreadyWarnedDrawLifecycle = true;\r\n    }\r\n\r\n    const renderer = this._renderers.get(rendererName);\r\n    if (renderer) {\r\n      if (this.useDrawSorting) {\r\n        const drawCall = this._drawCallPool.get();\r\n        drawCall.z = this._state.current.z;\r\n        drawCall.priority = renderer.priority;\r\n        drawCall.renderer = rendererName;\r\n        this.getTransform().clone(drawCall.transform);\r\n        drawCall.state.z = this._state.current.z;\r\n        drawCall.state.opacity = this._state.current.opacity;\r\n        drawCall.state.tint = this._state.current.tint;\r\n        drawCall.args = args;\r\n        this._drawCalls.push(drawCall);\r\n      } else {\r\n        // Set the current renderer if not defined\r\n        if (!this._currentRenderer) {\r\n          this._currentRenderer = renderer;\r\n        }\r\n\r\n        if (!this._isCurrentRenderer(renderer)) {\r\n          // switching graphics means we must flush the previous\r\n          this._currentRenderer.flush();\r\n        }\r\n\r\n        // If we are still using the same renderer we can add to the current batch\r\n        renderer.draw(...args);\r\n\r\n        this._currentRenderer = renderer;\r\n      }\r\n    } else {\r\n      throw Error(`No renderer with name ${rendererName} has been registered`);\r\n    }\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this._transform.current = AffineMatrix.identity();\r\n  }\r\n\r\n  public updateViewport(resolution: ScreenDimension): void {\r\n    const gl = this.__gl;\r\n    this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);\r\n\r\n    this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);\r\n    this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);\r\n    this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);\r\n  }\r\n\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    if (!image) {\r\n      Logger.getInstance().warn('Cannot draw a null or undefined image');\r\n      // tslint:disable-next-line: no-console\r\n      if (console.trace) {\r\n        // tslint:disable-next-line: no-console\r\n        console.trace();\r\n      }\r\n      return;\r\n    }\r\n    this.draw<ImageRenderer>('ex.image', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.draw<RectangleRenderer>('ex.rectangle', start, end, color, thickness);\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color, stroke?: Color, strokeThickness?: number) {\r\n    this.draw<RectangleRenderer>('ex.rectangle', pos, width, height, color, stroke, strokeThickness);\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color, stroke?: Color, thickness?: number) {\r\n    this.draw<CircleRenderer>('ex.circle', pos, radius, color, stroke, thickness);\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContextWebGLDebug(this);\r\n\r\n  public save(): void {\r\n    this._transform.save();\r\n    this._state.save();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._transform.restore();\r\n    this._state.restore();\r\n  }\r\n\r\n  public translate(x: number, y: number): void {\r\n    this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);\r\n  }\r\n\r\n  public rotate(angle: number): void {\r\n    this._transform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): void {\r\n    this._transform.scale(x, y);\r\n  }\r\n\r\n  public transform(matrix: AffineMatrix) {\r\n    this._transform.current = matrix;\r\n  }\r\n\r\n  public getTransform(): AffineMatrix {\r\n    return this._transform.current;\r\n  }\r\n\r\n  public multiply(m: AffineMatrix) {\r\n    this._transform.current.multiply(m, this._transform.current);\r\n  }\r\n\r\n  public addPostProcessor(postprocessor: PostProcessor) {\r\n    this._postprocessors.push(postprocessor);\r\n    postprocessor.initialize(this.__gl);\r\n  }\r\n\r\n  public removePostProcessor(postprocessor: PostProcessor) {\r\n    const index = this._postprocessors.indexOf(postprocessor);\r\n    if (index !== -1) {\r\n      this._postprocessors.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  public clearPostProcessors() {\r\n    this._postprocessors.length = 0;\r\n  }\r\n\r\n  clear() {\r\n    const gl = this.__gl;\r\n    this._renderTarget.use();\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    // Clear the context with the newly set color. This is\r\n    // the function call that actually does the drawing.\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n  }\r\n\r\n  /**\r\n   * Flushes all batched rendering to the screen\r\n   */\r\n  flush() {\r\n    const gl = this.__gl;\r\n\r\n    // render target captures all draws and redirects to the render target\r\n    this._renderTarget.use();\r\n\r\n    if (this.useDrawSorting) {\r\n      // sort draw calls\r\n      // Find the original order of the first instance of the draw call\r\n      const originalSort = new Map<string, number>();\r\n      for (const [name] of this._renderers) {\r\n        const firstIndex = this._drawCalls.findIndex(dc => dc.renderer === name);\r\n        originalSort.set(name, firstIndex);\r\n      }\r\n\r\n      this._drawCalls.sort((a, b) => {\r\n        const zIndex = a.z - b.z;\r\n        const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);\r\n        const priority = a.priority - b.priority;\r\n        if (zIndex === 0) { // sort by z first\r\n          if (priority === 0) { // sort by priority\r\n            return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order\r\n          }\r\n          return priority;\r\n        }\r\n        return zIndex;\r\n      });\r\n\r\n      const oldTransform = this._transform.current;\r\n      const oldState = this._state.current;\r\n\r\n      if (this._drawCalls.length) {\r\n        let currentRendererName = this._drawCalls[0].renderer;\r\n        let currentRenderer = this._renderers.get(currentRendererName);\r\n        for (let i = 0; i < this._drawCalls.length; i++) {\r\n          // hydrate the state for renderers\r\n          this._transform.current = this._drawCalls[i].transform;\r\n          this._state.current = this._drawCalls[i].state;\r\n\r\n          if (this._drawCalls[i].renderer !== currentRendererName) {\r\n            // switching graphics renderer means we must flush the previous\r\n            currentRenderer.flush();\r\n            currentRendererName = this._drawCalls[i].renderer;\r\n            currentRenderer = this._renderers.get(currentRendererName);\r\n          }\r\n\r\n          // If we are still using the same renderer we can add to the current batch\r\n          currentRenderer.draw(...this._drawCalls[i].args);\r\n        }\r\n        if (currentRenderer.hasPendingDraws()) {\r\n          currentRenderer.flush();\r\n        }\r\n      }\r\n\r\n      // reset state\r\n      this._transform.current = oldTransform;\r\n      this._state.current = oldState;\r\n\r\n      // reclaim draw calls\r\n      this._drawCallPool.done();\r\n      this._drawCalls.length = 0;\r\n    } else {\r\n      // This is the final flush at the moment to draw any leftover pending draw\r\n      for (const renderer of this._renderers.values()) {\r\n        if (renderer.hasPendingDraws()) {\r\n          renderer.flush();\r\n        }\r\n      }\r\n    }\r\n\r\n    this._renderTarget.disable();\r\n\r\n    // post process step\r\n    const source = this._renderTarget.toRenderSource();\r\n    source.use();\r\n\r\n    // flip flop render targets\r\n    for (let i = 0; i < this._postprocessors.length; i++) {\r\n      this._postProcessTargets[i % 2].use();\r\n      this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);\r\n      this._postProcessTargets[i % 2].toRenderSource().use();\r\n    }\r\n\r\n    // passing null switches rendering back to the canvas\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    this._screenRenderer.renderToScreen();\r\n  }\r\n}\r\n","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { GraphicsDiagnostics } from '../GraphicsDiagnostics';\r\nimport { DebugText } from './debug-text';\r\nimport { ScreenDimension } from '../../Screen';\r\nimport { PostProcessor } from '../PostProcessor/PostProcessor';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nconst pixelSnapEpsilon = 0.0001;\r\n\r\nclass ExcaliburGraphicsContext2DCanvasDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _ex: ExcaliburGraphicsContext2DCanvas) {}\r\n  /**\r\n   * Draw a debug rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.strokeStyle = 'red';\r\n    this._ex.__ctx.strokeRect(\r\n      this._ex.snapToPixel ? ~~(x + pixelSnapEpsilon) : x,\r\n      this._ex.snapToPixel ? ~~(y + pixelSnapEpsilon) : y,\r\n      this._ex.snapToPixel ? ~~(width + pixelSnapEpsilon) : width,\r\n      this._ex.snapToPixel ? ~~(height + pixelSnapEpsilon) : height\r\n    );\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.strokeStyle = lineOptions.color.toString();\r\n    this._ex.__ctx.moveTo(\r\n      this._ex.snapToPixel ? ~~(start.x + pixelSnapEpsilon) : start.x,\r\n      this._ex.snapToPixel ? ~~(start.y + pixelSnapEpsilon) : start.y\r\n    );\r\n    this._ex.__ctx.lineTo(\r\n      this._ex.snapToPixel ? ~~(end.x + pixelSnapEpsilon) : end.x,\r\n      this._ex.snapToPixel ? ~~(end.y + pixelSnapEpsilon) : end.y\r\n    );\r\n    this._ex.__ctx.lineWidth = 2;\r\n    this._ex.__ctx.stroke();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.fillStyle = pointOptions.color.toString();\r\n    this._ex.__ctx.arc(\r\n      this._ex.snapToPixel ? ~~(point.x + pixelSnapEpsilon) : point.x,\r\n      this._ex.snapToPixel ? ~~(point.y + pixelSnapEpsilon) : point.y,\r\n      pointOptions.size,\r\n      0,\r\n      Math.PI * 2\r\n    );\r\n    this._ex.__ctx.fill();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._ex, text, pos);\r\n  }\r\n}\r\n\r\nexport class ExcaliburGraphicsContext2DCanvas implements ExcaliburGraphicsContext {\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __ctx: CanvasRenderingContext2D;\r\n  public get width() {\r\n    return this.__ctx.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__ctx.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Unused in Canvas implementation\r\n   */\r\n  public readonly useDrawSorting: boolean = false;\r\n\r\n  /**\r\n   * Unused in Canvas implementation\r\n   */\r\n  public z: number = 0;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  private _state = new StateStack();\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public get tint(): Color {\r\n    return this._state.current.tint;\r\n  }\r\n\r\n  public set tint(color: Color) {\r\n    this._state.current.tint = color;\r\n  }\r\n\r\n  public snapToPixel: boolean = false;\r\n\r\n  public get smoothing(): boolean {\r\n    return this.__ctx.imageSmoothingEnabled;\r\n  }\r\n\r\n  public set smoothing(value: boolean) {\r\n    this.__ctx.imageSmoothingEnabled = value;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;\r\n    this.__ctx = canvasElement.getContext('2d', {\r\n      alpha: enableTransparency ?? true\r\n    });\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this.__ctx.resetTransform();\r\n  }\r\n\r\n  public updateViewport(_resolution: ScreenDimension): void {\r\n    // pass\r\n  }\r\n\r\n  /**\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate using the images width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate with a specific width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context specifying the source image coordinates (sx, sy, swidth, sheight)\r\n   * and to a specific destination on the context (dx, dy, dwidth, dheight)\r\n   */\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    this.__ctx.globalAlpha = this.opacity;\r\n    const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]\r\n      .filter((a) => a !== undefined)\r\n      .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));\r\n    this.__ctx.drawImage.apply(this.__ctx, args);\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n    GraphicsDiagnostics.DrawnImagesCount = 1;\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    this.__ctx.strokeStyle = color.toString();\r\n    this.__ctx.moveTo(\r\n      this.snapToPixel ? ~~ (start.x + pixelSnapEpsilon) : start.x,\r\n      this.snapToPixel ? ~~(start.y + pixelSnapEpsilon) : start.y\r\n    );\r\n    this.__ctx.lineTo(\r\n      this.snapToPixel ? ~~ (end.x + pixelSnapEpsilon) : end.x,\r\n      this.snapToPixel ? ~~(end.y + pixelSnapEpsilon) : end.y\r\n    );\r\n    this.__ctx.lineWidth = thickness;\r\n    this.__ctx.stroke();\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color) {\r\n    this.__ctx.save();\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.fillRect(\r\n      this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon) : pos.x,\r\n      this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon) : pos.y,\r\n      this.snapToPixel ? ~~(width + pixelSnapEpsilon) : width,\r\n      this.snapToPixel ? ~~(height + pixelSnapEpsilon) : height\r\n    );\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color, stroke?: Color, thickness?: number) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    if (stroke) {\r\n      this.__ctx.strokeStyle = stroke.toString();\r\n    }\r\n    if (thickness) {\r\n      this.__ctx.lineWidth = thickness;\r\n    }\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.arc(\r\n      this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon) : pos.x,\r\n      this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2\r\n    );\r\n    this.__ctx.fill();\r\n    if (stroke) {\r\n      this.__ctx.stroke();\r\n    }\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContext2DCanvasDebug(this);\r\n\r\n  /**\r\n   * Save the current state of the canvas to the stack (transforms and opacity)\r\n   */\r\n  save(): void {\r\n    this.__ctx.save();\r\n  }\r\n\r\n  /**\r\n   * Restore the state of the canvas from the stack\r\n   */\r\n  restore(): void {\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Translate the origin of the context by an x and y\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number): void {\r\n    this.__ctx.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);\r\n  }\r\n\r\n  /**\r\n   * Rotate the context about the current origin\r\n   */\r\n  rotate(angle: number): void {\r\n    this.__ctx.rotate(angle);\r\n  }\r\n\r\n  /**\r\n   * Scale the context by an x and y factor\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number): void {\r\n    this.__ctx.scale(x, y);\r\n  }\r\n\r\n  public getTransform(): AffineMatrix {\r\n    throw new Error('Not implemented');\r\n  }\r\n\r\n  public multiply(_m: AffineMatrix): void {\r\n    this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));\r\n  }\r\n\r\n  public addPostProcessor(_postprocessor: PostProcessor) {\r\n    // pass\r\n  }\r\n\r\n  public removePostProcessor(_postprocessor: PostProcessor) {\r\n    // pass\r\n  }\r\n\r\n  public clearPostProcessors() {\r\n    // pass\r\n  }\r\n\r\n  public beginDrawLifecycle() {\r\n    // pass\r\n  }\r\n\r\n  public endDrawLifecycle() {\r\n    // pass\r\n  }\r\n\r\n  clear(): void {\r\n    // Clear frame\r\n    this.__ctx.clearRect(0, 0, this.width, this.height);\r\n    this.__ctx.fillStyle = this.backgroundColor.toString();\r\n    this.__ctx.fillRect(0, 0, this.width, this.height);\r\n    GraphicsDiagnostics.clear();\r\n  }\r\n\r\n  /**\r\n   * Flushes the batched draw calls to the screen\r\n   */\r\n  flush(): void {\r\n    // pass\r\n  }\r\n}\r\n","import { vec, Vector } from './Math/vector';\r\nimport { Logger } from './Util/Log';\r\nimport { Camera } from './Camera';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { BoundingBox } from './Collision/Index';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { getPosition } from './Util/Util';\r\nimport { ExcaliburGraphicsContextWebGL } from './Graphics/Context/ExcaliburGraphicsContextWebGL';\r\nimport { ExcaliburGraphicsContext2DCanvas } from './Graphics/Context/ExcaliburGraphicsContext2DCanvas';\r\n\r\n/**\r\n * Enum representing the different display modes available to Excalibur.\r\n */\r\nexport enum DisplayMode {\r\n  /**\r\n   * Default, use a specified resolution for the game. Like 800x600 pixels for example.\r\n   */\r\n  Fixed = 'Fixed',\r\n\r\n  /**\r\n   * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.\r\n   * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n   * is guaranteed to be on screen.\r\n   */\r\n  FitContainerAndFill = 'FitContainerAndFill',\r\n\r\n  /**\r\n   * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.\r\n   * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n   * is guaranteed to be on screen.\r\n   */\r\n  FitScreenAndFill = 'FitScreenAndFill',\r\n\r\n  /**\r\n   * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n   * (letterbox) that would otherwise be present in [[FitContainer]].\r\n   *\r\n   * **warning** This will clip some drawable area from the user because of the zoom,\r\n   * use [[Screen.contentArea]] to know the safe to draw area.\r\n   */\r\n  FitContainerAndZoom = 'FitContainerAndZoom',\r\n\r\n  /**\r\n   * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n   * (letterbox) that would otherwise be present in [[FitScreen]].\r\n   *\r\n   * **warning** This will clip some drawable area from the user because of the zoom,\r\n   * use [[Screen.contentArea]] to know the safe to draw area.\r\n   */\r\n  FitScreenAndZoom = 'FitScreenAndZoom',\r\n\r\n  /**\r\n   * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.\r\n   * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.\r\n   *\r\n   * You may want to center your game here is an example\r\n   * ```html\r\n   * <!-- html -->\r\n   * <body>\r\n   * <main>\r\n   *   <canvas id=\"game\"></canvas>\r\n   * </main>\r\n   * </body>\r\n   * ```\r\n   *\r\n   * ```css\r\n   * // css\r\n   * main {\r\n   *   display: flex;\r\n   *   align-items: center;\r\n   *   justify-content: center;\r\n   *   height: 100%;\r\n   *   width: 100%;\r\n   * }\r\n   * ```\r\n   */\r\n  FitScreen = 'FitScreen',\r\n\r\n  /**\r\n   * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will\r\n   * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]\r\n   */\r\n  FillScreen = 'FillScreen',\r\n\r\n  /**\r\n   * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.\r\n   */\r\n  FitContainer = 'FitContainer',\r\n\r\n  /**\r\n   * Use the parent DOM container's css width/height for the game resolution dynamically\r\n   */\r\n  FillContainer = 'FillContainer'\r\n}\r\n\r\n/**\r\n * Convenience class for quick resolutions\r\n * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution\r\n */\r\nexport class Resolution {\r\n  /* istanbul ignore next */\r\n  public static get SVGA(): ScreenDimension {\r\n    return { width: 800, height: 600 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Standard(): ScreenDimension {\r\n    return { width: 1920, height: 1080 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Atari2600(): ScreenDimension {\r\n    return { width: 160, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoy(): ScreenDimension {\r\n    return { width: 160, height: 144 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoyAdvance(): ScreenDimension {\r\n    return { width: 240, height: 160 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NintendoDS(): ScreenDimension {\r\n    return { width: 256, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NES(): ScreenDimension {\r\n    return { width: 256, height: 224 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get SNES(): ScreenDimension {\r\n    return { width: 256, height: 244 };\r\n  }\r\n}\r\n\r\nexport interface ScreenDimension {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface ScreenOptions {\r\n  /**\r\n   * Canvas element to build a screen on\r\n   */\r\n  canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Graphics context for the screen\r\n   */\r\n  context: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Browser abstraction\r\n   */\r\n  browser: BrowserEvents;\r\n  /**\r\n   * Optionally set antialiasing, defaults to true. If set to true, images will be smoothed\r\n   */\r\n  antialiasing?: boolean;\r\n  /**\r\n   * Optionally override the pixel ratio to use for the screen, otherwise calculated automatically from the browser\r\n   */\r\n  pixelRatio?: number;\r\n  /**\r\n   * Optionally specify the actual pixel resolution in width/height pixels (also known as logical resolution), by default the\r\n   * resolution will be the same as the viewport. Resolution will be overridden by [[DisplayMode.FillContainer]] and\r\n   * [[DisplayMode.FillScreen]].\r\n   */\r\n  resolution?: ScreenDimension;\r\n  /**\r\n   * Visual viewport size in css pixel, if resolution is not specified it will be the same as the viewport\r\n   */\r\n  viewport: ScreenDimension;\r\n  /**\r\n   * Set the display mode of the screen, by default DisplayMode.Fixed.\r\n   */\r\n  displayMode?: DisplayMode;\r\n}\r\n\r\n/**\r\n * The Screen handles all aspects of interacting with the screen for Excalibur.\r\n */\r\nexport class Screen {\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n  private _canvas: HTMLCanvasElement;\r\n  private _antialiasing: boolean = true;\r\n  private _contentResolution: ScreenDimension;\r\n  private _browser: BrowserEvents;\r\n  private _camera: Camera;\r\n  private _resolution: ScreenDimension;\r\n  private _resolutionStack: ScreenDimension[] = [];\r\n  private _viewport: ScreenDimension;\r\n  private _viewportStack: ScreenDimension[] = [];\r\n  private _pixelRatioOverride: number | null = null;\r\n  private _displayMode: DisplayMode;\r\n  private _isFullScreen = false;\r\n  private _mediaQueryList: MediaQueryList;\r\n  private _isDisposed = false;\r\n  private _logger = Logger.getInstance();\r\n  private _resizeObserver: ResizeObserver;\r\n\r\n  constructor(options: ScreenOptions) {\r\n    this.viewport = options.viewport;\r\n    this.resolution = options.resolution ?? { ...this.viewport };\r\n    this._contentResolution = this.resolution;\r\n    this._displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    this._canvas = options.canvas;\r\n    this.graphicsContext = options.context;\r\n    this._antialiasing = options.antialiasing ?? this._antialiasing;\r\n    this._browser = options.browser;\r\n    this._pixelRatioOverride = options.pixelRatio;\r\n\r\n    this._applyDisplayMode();\r\n\r\n    this._listenForPixelRatio();\r\n\r\n    this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    this.applyResolutionAndViewport();\r\n  }\r\n\r\n  private _listenForPixelRatio() {\r\n    if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {\r\n      // Safari <=13.1 workaround, remove any existing handlers\r\n      this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n    }\r\n    this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\r\n\r\n    // Safari <=13.1 workaround\r\n    if (this._mediaQueryList.addEventListener) {\r\n      this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });\r\n    } else {\r\n      this._mediaQueryList.addListener(this._pixelRatioChangeHandler);\r\n    }\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (!this._isDisposed) {\r\n      // Clean up handlers\r\n      this._isDisposed = true;\r\n      this._browser.window.off('resize', this._resizeHandler);\r\n      if (this._resizeObserver) {\r\n        this._resizeObserver.disconnect();\r\n      }\r\n      this.parent.removeEventListener('resize', this._resizeHandler);\r\n      // Safari <=13.1 workaround\r\n      if (this._mediaQueryList.removeEventListener) {\r\n        this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);\r\n      } else {\r\n        this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n      }\r\n      this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    }\r\n  }\r\n\r\n  private _fullscreenChangeHandler = () => {\r\n    this._isFullScreen = !this._isFullScreen;\r\n    this._logger.debug('Fullscreen Change', this._isFullScreen);\r\n  };\r\n\r\n  private _pixelRatioChangeHandler = () => {\r\n    this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);\r\n    this._listenForPixelRatio();\r\n    this._devicePixelRatio = this._calculateDevicePixelRatio();\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _resizeHandler = () => {\r\n    const parent = this.parent;\r\n    this._logger.debug('View port resized');\r\n    this._setResolutionAndViewportByDisplayMode(parent);\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _calculateDevicePixelRatio() {\r\n    if (window.devicePixelRatio < 1) {\r\n      return 1;\r\n    }\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n\r\n    return devicePixelRatio;\r\n  }\r\n\r\n  // Asking the window.devicePixelRatio is expensive we do it once\r\n  private _devicePixelRatio = this._calculateDevicePixelRatio();\r\n\r\n  public get pixelRatio(): number {\r\n    if (this._pixelRatioOverride) {\r\n      return this._pixelRatioOverride;\r\n    }\r\n\r\n    return this._devicePixelRatio;\r\n  }\r\n\r\n  public get isHiDpi() {\r\n    return this.pixelRatio !== 1;\r\n  }\r\n\r\n  public get displayMode(): DisplayMode {\r\n    return this._displayMode;\r\n  }\r\n\r\n  public get canvas(): HTMLCanvasElement {\r\n    return this._canvas;\r\n  }\r\n\r\n  public get parent(): HTMLElement | Window {\r\n    switch (this.displayMode) {\r\n      case DisplayMode.FillContainer:\r\n      case DisplayMode.FitContainer:\r\n      case DisplayMode.FitContainerAndFill:\r\n      case DisplayMode.FitContainerAndZoom:\r\n        return this.canvas.parentElement || document.body;\r\n      default:\r\n        return window;\r\n    }\r\n  }\r\n\r\n  public get resolution(): ScreenDimension {\r\n    return this._resolution;\r\n  }\r\n\r\n  public set resolution(resolution: ScreenDimension) {\r\n    this._resolution = resolution;\r\n  }\r\n\r\n  public get viewport(): ScreenDimension {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n    return this._resolution;\r\n  }\r\n\r\n  public set viewport(viewport: ScreenDimension) {\r\n    this._viewport = viewport;\r\n  }\r\n\r\n  public get aspectRatio() {\r\n    return this._resolution.width / this._resolution.height;\r\n  }\r\n\r\n  public get scaledWidth() {\r\n    return this._resolution.width * this.pixelRatio;\r\n  }\r\n\r\n  public get scaledHeight() {\r\n    return this._resolution.height * this.pixelRatio;\r\n  }\r\n\r\n  public setCurrentCamera(camera: Camera) {\r\n    this._camera = camera;\r\n  }\r\n\r\n  public pushResolutionAndViewport() {\r\n    this._resolutionStack.push(this.resolution);\r\n    this._viewportStack.push(this.viewport);\r\n\r\n    this.resolution = { ...this.resolution };\r\n    this.viewport = { ...this.viewport };\r\n  }\r\n\r\n  public peekViewport(): ScreenDimension {\r\n    return this._viewportStack[this._viewportStack.length - 1];\r\n  }\r\n\r\n  public peekResolution(): ScreenDimension {\r\n    return this._resolutionStack[this._resolutionStack.length - 1];\r\n  }\r\n\r\n  public popResolutionAndViewport() {\r\n    this.resolution = this._resolutionStack.pop();\r\n    this.viewport = this._viewportStack.pop();\r\n  }\r\n\r\n  private _alreadyWarned = false;\r\n  public applyResolutionAndViewport() {\r\n    this._canvas.width = this.scaledWidth;\r\n    this._canvas.height = this.scaledHeight;\r\n\r\n    if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      const supported = this.graphicsContext.checkIfResolutionSupported({\r\n        width: this.scaledWidth,\r\n        height: this.scaledHeight\r\n      });\r\n      if (!supported && !this._alreadyWarned) {\r\n        this._alreadyWarned = true; // warn once\r\n        this._logger.warn(\r\n          `The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +\r\n          ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +\r\n          ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +\r\n          ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');\r\n      }\r\n    }\r\n\r\n    if (this._antialiasing) {\r\n      this._canvas.style.imageRendering = 'auto';\r\n    } else {\r\n      this._canvas.style.imageRendering = 'pixelated';\r\n      // Fall back to 'crisp-edges' if 'pixelated' is not supported\r\n      // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\r\n      if (this._canvas.style.imageRendering === '') {\r\n        this._canvas.style.imageRendering = 'crisp-edges';\r\n      }\r\n    }\r\n    this._canvas.style.width = this.viewport.width + 'px';\r\n    this._canvas.style.height = this.viewport.height + 'px';\r\n\r\n    // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset\r\n    this.graphicsContext.updateViewport(this.resolution);\r\n    this.graphicsContext.resetTransform();\r\n    this.graphicsContext.smoothing = this._antialiasing;\r\n    if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {\r\n      this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);\r\n    }\r\n  }\r\n\r\n  public get antialiasing() {\r\n    return this._antialiasing;\r\n  }\r\n\r\n  public set antialiasing(isSmooth: boolean) {\r\n    this._antialiasing = isSmooth;\r\n    this.graphicsContext.smoothing = this._antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Returns true if excalibur is fullscreen using the browser fullscreen api\r\n   */\r\n  public get isFullScreen() {\r\n    return this._isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.\r\n   * For example, wire this to a user click handler.\r\n   *\r\n   * Optionally specify a target element id to go fullscreen, by default the game canvas is used\r\n   * @param elementId\r\n   */\r\n  public goFullScreen(elementId?: string): Promise<void> {\r\n    if (elementId) {\r\n      const maybeElement = document.getElementById(elementId);\r\n      if (maybeElement) {\r\n        return maybeElement.requestFullscreen();\r\n      }\r\n    }\r\n    return this._canvas.requestFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Requests to exit fullscreen using the browser fullscreen api\r\n   */\r\n  public exitFullScreen(): Promise<void> {\r\n    return document.exitFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to\r\n   * Excalibur screen space.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public pageToScreenCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    if (!this._isFullScreen) {\r\n      newX -= getPosition(this._canvas).x;\r\n      newY -= getPosition(this._canvas).y;\r\n    }\r\n\r\n    // if fullscreen api on it centers with black bars\r\n    // we need to adjust the screen to world coordinates in this case\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;\r\n        newX = (newX / window.innerWidth) * this.viewport.width;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;\r\n        newY = (newY / window.innerHeight) * this.viewport.height;\r\n      }\r\n    }\r\n\r\n    newX = (newX / this.viewport.width) * this.resolution.width;\r\n    newY = (newY / this.viewport.height) * this.resolution.height;\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,\r\n   * this is where html elements might live if you want to position them relative to Excalibur.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public screenToPageCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    newX = (newX / this.resolution.width) * this.viewport.width;\r\n    newY = (newY / this.resolution.height) * this.viewport.height;\r\n\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = (newY / this.viewport.height) * screenHeight + screenMarginY;\r\n        newX = (newX / this.viewport.width) * window.innerWidth;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = (newX / this.viewport.width) * screenWidth + screenMarginX;\r\n        newY = (newY / this.viewport.height) * window.innerHeight;\r\n      }\r\n    }\r\n\r\n    if (!this._isFullScreen) {\r\n      newX += getPosition(this._canvas).x;\r\n      newY += getPosition(this._canvas).y;\r\n    }\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.\r\n   *\r\n   * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]\r\n   * and extends infinitely out relative from the [[Camera]].\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    // the only difference between screen & world is the camera transform\r\n    if (this._camera) {\r\n      return this._camera.inverse.multiply(point);\r\n    }\r\n    return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.\r\n   *\r\n   * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    if (this._camera) {\r\n      return this._camera.transform.multiply(point);\r\n    }\r\n    return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n  }\r\n\r\n  public pageToWorldCoordinates(point: Vector): Vector {\r\n    const screen = this.pageToScreenCoordinates(point);\r\n    return this.screenToWorldCoordinates(screen);\r\n  }\r\n\r\n  public worldToPageCoordinates(point: Vector): Vector {\r\n    const screen = this.worldToScreenCoordinates(point);\r\n    return this.screenToPageCoordinates(screen);\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   *\r\n   * World bounds are in world coordinates, useful for culling objects offscreen\r\n   */\r\n  public getWorldBounds(): BoundingBox {\r\n    const topLeft = this.screenToWorldCoordinates(Vector.Zero);\r\n    const right = topLeft.x + this.drawWidth;\r\n    const bottom = topLeft.y + this.drawHeight;\r\n\r\n    return new BoundingBox(topLeft.x, topLeft.y, right, bottom);\r\n  }\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.canvas.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.canvas.width / 2;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.canvas.height / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    if (this._camera) {\r\n      return this.resolution.width / this._camera.zoom;\r\n    }\r\n    return this.resolution.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.drawWidth / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    if (this._camera) {\r\n      return this.resolution.height / this._camera.zoom;\r\n    }\r\n    return this.resolution.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.drawHeight / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns screen center coordinates including zoom and device pixel ratio.\r\n   */\r\n  public get center(): Vector {\r\n    return vec(this.halfDrawWidth, this.halfDrawHeight);\r\n  }\r\n\r\n  /**\r\n   * Returns the content area in screen space where it is safe to place content\r\n   */\r\n  public get contentArea(): BoundingBox {\r\n    return this._contentArea;\r\n  }\r\n\r\n  private _computeFit() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (window.innerWidth / aspect < window.innerHeight) {\r\n      adjustedWidth = window.innerWidth;\r\n      adjustedHeight = window.innerWidth / aspect;\r\n    } else {\r\n      adjustedWidth = window.innerHeight * aspect;\r\n      adjustedHeight = window.innerHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n  }\r\n\r\n  private _contentArea: BoundingBox = new BoundingBox();\r\n  private _computeFitScreenAndFill() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n    this._computeFitAndFill(vw, vh);\r\n  }\r\n\r\n\r\n\r\n  private _computeFitContainerAndFill() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const parent = this.canvas.parentElement;\r\n    const vw = parent.clientWidth;\r\n    const vh = parent.clientHeight;\r\n    this._computeFitAndFill(vw, vh);\r\n  }\r\n\r\n  private _computeFitAndFill(vw: number, vh: number) {\r\n    this.viewport = {\r\n      width: vw,\r\n      height: vh\r\n    };\r\n    // if the current screen aspectRatio is less than the original aspectRatio\r\n    if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {\r\n      // compute new resolution to match the original aspect ratio\r\n      this.resolution = {\r\n        width:  vw * this._contentResolution.width / vw,\r\n        height: vw * this._contentResolution.width / vw * vh / vw\r\n      };\r\n      const clip = (this.resolution.height - this._contentResolution.height) / 2;\r\n      this._contentArea = new BoundingBox({\r\n        top: clip,\r\n        left: 0,\r\n        right: this._contentResolution.width,\r\n        bottom: this.resolution.height - clip\r\n      });\r\n    } else {\r\n      this.resolution = {\r\n        width: vh *  this._contentResolution.height / vh * vw / vh,\r\n        height: vh *  this._contentResolution.height / vh\r\n      };\r\n      const clip = (this.resolution.width - this._contentResolution.width) / 2;\r\n      this._contentArea = new BoundingBox({\r\n        top: 0,\r\n        left: clip,\r\n        right: this.resolution.width - clip,\r\n        bottom: this._contentResolution.height\r\n      });\r\n    }\r\n  }\r\n\r\n  private _computeFitScreenAndZoom() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    this.canvas.style.position = 'absolute';\r\n\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n\r\n    this._computeFitAndZoom(vw, vh);\r\n  }\r\n\r\n  private _computeFitContainerAndZoom() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    this.canvas.style.position = 'absolute';\r\n    const parent = this.canvas.parentElement;\r\n    parent.style.position = 'relative';\r\n    parent.style.overflow = 'hidden';\r\n\r\n    const vw = parent.clientWidth;\r\n    const vh = parent.clientHeight;\r\n\r\n    this._computeFitAndZoom(vw, vh);\r\n  }\r\n\r\n  private _computeFitAndZoom(vw: number, vh: number) {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (vw / aspect < vh) {\r\n      adjustedWidth = vw;\r\n      adjustedHeight = vw / aspect;\r\n    } else {\r\n      adjustedWidth = vh * aspect;\r\n      adjustedHeight = vh;\r\n    }\r\n\r\n    const scaleX = vw / adjustedWidth;\r\n    const scaleY = vh / adjustedHeight;\r\n\r\n    const maxScaleFactor = Math.max(scaleX, scaleY);\r\n\r\n    const zoomedWidth = adjustedWidth * maxScaleFactor;\r\n    const zoomedHeight = adjustedHeight * maxScaleFactor;\r\n\r\n    // Center zoomed dimension if bigger than the screen\r\n    if (zoomedWidth > vw) {\r\n      this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';\r\n    } else {\r\n      this.canvas.style.left = '';\r\n    }\r\n\r\n    if (zoomedHeight > vh) {\r\n      this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';\r\n    } else {\r\n      this.canvas.style.top = '';\r\n    }\r\n\r\n    this.viewport = {\r\n      width: zoomedWidth,\r\n      height: zoomedHeight\r\n    };\r\n\r\n    const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);\r\n    // return safe area\r\n    if (this.viewport.width > vw) {\r\n      const clip = (this.viewport.width - vw)/this.viewport.width * this.resolution.width;\r\n      bounds.top = 0;\r\n      bounds.left = clip / 2;\r\n      bounds.right = this.resolution.width - clip / 2;\r\n      bounds.bottom = this.resolution.height;\r\n    }\r\n\r\n    if (this.viewport.height > vh) {\r\n      const clip = (this.viewport.height - vh)/this.viewport.height * this.resolution.height;\r\n      bounds.top = clip / 2;\r\n      bounds.left = 0;\r\n      bounds.bottom = this.resolution.height - clip / 2;\r\n      bounds.right = this.resolution.width;\r\n    }\r\n    this._contentArea = bounds;\r\n  }\r\n\r\n  private _computeFitContainer() {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    const parent = this.canvas.parentElement;\r\n    if (parent.clientWidth / aspect < parent.clientHeight) {\r\n      adjustedWidth = parent.clientWidth;\r\n      adjustedHeight = parent.clientWidth / aspect;\r\n    } else {\r\n      adjustedWidth = parent.clientHeight * aspect;\r\n      adjustedHeight = parent.clientHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n  }\r\n\r\n  private _applyDisplayMode() {\r\n    this._setResolutionAndViewportByDisplayMode(this.parent);\r\n\r\n    // watch resizing\r\n    if (this.parent instanceof Window) {\r\n      this._browser.window.on('resize', this._resizeHandler);\r\n    } else {\r\n      this._resizeObserver = new ResizeObserver(() => {\r\n        this._resizeHandler();\r\n      });\r\n      this._resizeObserver.observe(this.parent);\r\n    }\r\n    this.parent.addEventListener('resize', this._resizeHandler);\r\n  }\r\n\r\n  /**\r\n   * Sets the resolution and viewport based on the selected display mode.\r\n   */\r\n  private _setResolutionAndViewportByDisplayMode(parent: HTMLElement | Window) {\r\n    if (this.displayMode === DisplayMode.FillContainer) {\r\n      this.resolution = {\r\n        width: (<HTMLElement> parent).clientWidth,\r\n        height: (<HTMLElement> parent).clientHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FillScreen) {\r\n      document.body.style.margin = '0px';\r\n      document.body.style.overflow = 'hidden';\r\n      this.resolution = {\r\n        width: (<Window> parent).innerWidth,\r\n        height: (<Window> parent).innerHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreen) {\r\n      this._computeFit();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainer) {\r\n      this._computeFitContainer();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreenAndFill) {\r\n      this._computeFitScreenAndFill();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainerAndFill){\r\n      this._computeFitContainerAndFill();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreenAndZoom) {\r\n      this._computeFitScreenAndZoom();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainerAndZoom){\r\n      this._computeFitContainerAndZoom();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Internal class used to build instances of AudioContext\r\n */\r\n/* istanbul ignore next */\r\nexport class AudioContextFactory {\r\n  private static _INSTANCE: AudioContext = null;\r\n\r\n  public static create(): AudioContext {\r\n    if (!this._INSTANCE) {\r\n      if ((<any>window).AudioContext || (<any>window).webkitAudioContext) {\r\n        this._INSTANCE = new AudioContext();\r\n      }\r\n    }\r\n\r\n    return this._INSTANCE;\r\n  }\r\n}\r\n","import { AudioContextFactory } from '../Resources/Sound/AudioContext';\r\nimport { Logger } from './Log';\r\n\r\nexport interface LegacyWebAudioSource {\r\n  playbackState: string;\r\n  PLAYING_STATE: 'playing';\r\n  FINISHED_STATE: 'finished';\r\n}\r\n\r\n/**\r\n * Patch for detecting legacy web audio in browsers\r\n * @internal\r\n * @param source\r\n */\r\nfunction isLegacyWebAudioSource(source: any): source is LegacyWebAudioSource {\r\n  return !!source.playbackState;\r\n}\r\n\r\nexport class WebAudio {\r\n  private static _UNLOCKED: boolean = false;\r\n\r\n  /**\r\n   * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n   * right after a user interaction event.\r\n   * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n   */\r\n  static unlock(): Promise<boolean> {\r\n    const promise = new Promise<boolean>((resolve, reject) => {\r\n      if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {\r\n        return resolve(true);\r\n      }\r\n      const unlockTimeoutTimer = setTimeout(() => {\r\n        Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');\r\n        resolve(false);\r\n      }, 200);\r\n\r\n      const audioContext = AudioContextFactory.create();\r\n      audioContext.resume().then(\r\n        () => {\r\n          // create empty buffer and play it\r\n          const buffer = audioContext.createBuffer(1, 1, 22050);\r\n          const source = audioContext.createBufferSource();\r\n          let ended = false;\r\n\r\n          source.buffer = buffer;\r\n          source.connect(audioContext.destination);\r\n          source.onended = () => (ended = true);\r\n\r\n          source.start(0);\r\n\r\n          // by checking the play state after some time, we know if we're really unlocked\r\n          setTimeout(() => {\r\n            if (isLegacyWebAudioSource(source)) {\r\n              if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            } else {\r\n              if (audioContext.currentTime > 0 || ended) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            }\r\n          }, 0);\r\n\r\n          clearTimeout(unlockTimeoutTimer);\r\n          resolve(true);\r\n        },\r\n        () => {\r\n          reject();\r\n        }\r\n      );\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  static isUnlocked() {\r\n    return this._UNLOCKED;\r\n  }\r\n}\r\n","import { EventDispatcher } from './EventDispatcher';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\n/**\r\n * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n * and extending abilities for vanilla Javascript projects\r\n */\r\nexport class Class implements Eventable {\r\n  /**\r\n   * Direct access to the game object event dispatcher.\r\n   */\r\n  public eventDispatcher: EventDispatcher;\r\n\r\n  constructor() {\r\n    this.eventDispatcher = new EventDispatcher();\r\n  }\r\n\r\n  /**\r\n   * Alias for `addEventListener`. You can listen for a variety of\r\n   * events off of the engine; see the events section below for a complete list.\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public on(eventName: string, handler: (event: any) => void) {\r\n    this.eventDispatcher.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Alias for `removeEventListener`. If only the eventName is specified\r\n   * it will remove all handlers registered for that specific event. If the eventName\r\n   * and the handler instance are specified only that handler will be removed.\r\n   *\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public off(eventName: string, handler?: (event: any) => void) {\r\n    this.eventDispatcher.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Emits a new event\r\n   * @param eventName   Name of the event to emit\r\n   * @param eventObject Data associated with this event\r\n   */\r\n  public emit(eventName: string, eventObject: any) {\r\n    this.eventDispatcher.emit(eventName, eventObject);\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: any) => void) {\r\n    this.eventDispatcher.once(eventName, handler);\r\n  }\r\n}\r\n","import { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\n\r\n/**\r\n * A canvas linecap style. \"butt\" is the default flush style, \"round\" is a semi-circle cap with a radius half the width of\r\n * the line, and \"square\" is a rectangle that is an equal width and half height cap.\r\n */\r\nexport type LineCapStyle = 'butt' | 'round' | 'square';\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw a line on canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param color The color of the line\r\n * @param x1 The start x coordinate\r\n * @param y1 The start y coordinate\r\n * @param x2 The ending x coordinate\r\n * @param y2 The ending y coordinate\r\n * @param thickness The line thickness\r\n * @param cap The [[LineCapStyle]] (butt, round, or square)\r\n */\r\nexport function line(\r\n  ctx: CanvasRenderingContext2D,\r\n  color: Color = Color.Red,\r\n  x1: number,\r\n  y1: number,\r\n  x2: number,\r\n  y2: number,\r\n  thickness: number = 1,\r\n  cap: LineCapStyle = 'butt'\r\n) {\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.lineWidth = thickness;\r\n  ctx.lineCap = cap;\r\n  ctx.strokeStyle = color.toString();\r\n  ctx.moveTo(x1, y1);\r\n  ctx.lineTo(x2, y2);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw the vector as a point onto the canvas.\r\n */\r\nexport function point(ctx: CanvasRenderingContext2D, color: Color = Color.Red, point: Vector): void {\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = color.toString();\r\n  ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Draw the vector as a line onto the canvas starting a origin point.\r\n */\r\n/* istanbul ignore next */\r\n/**\r\n *\r\n */\r\nexport function vector(ctx: CanvasRenderingContext2D, color: Color, origin: Vector, vector: Vector, scale: number = 1.0): void {\r\n  const c = color ? color.toString() : 'blue';\r\n  const v = vector.scale(scale);\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = c;\r\n  ctx.moveTo(origin.x, origin.y);\r\n  ctx.lineTo(origin.x + v.x, origin.y + v.y);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Represents border radius values\r\n */\r\nexport interface BorderRadius {\r\n  /**\r\n   * Top-left\r\n   */\r\n  tl: number;\r\n  /**\r\n   * Top-right\r\n   */\r\n  tr: number;\r\n  /**\r\n   * Bottom-right\r\n   */\r\n  br: number;\r\n  /**\r\n   * Bottom-left\r\n   */\r\n  bl: number;\r\n}\r\n\r\n/**\r\n * Draw a round rectangle on a canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param x The top-left x coordinate\r\n * @param y The top-left y coordinate\r\n * @param width The width of the rectangle\r\n * @param height The height of the rectangle\r\n * @param radius The border radius of the rectangle\r\n * @param stroke The [[Color]] to stroke rectangle with\r\n * @param fill The [[Color]] to fill rectangle with\r\n */\r\nexport function roundRect(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n  radius: number | BorderRadius = 5,\r\n  stroke: Color = Color.White,\r\n  fill: Color = null\r\n) {\r\n  let br: BorderRadius;\r\n\r\n  if (typeof radius === 'number') {\r\n    br = { tl: radius, tr: radius, br: radius, bl: radius };\r\n  } else {\r\n    const defaultRadius: BorderRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n\r\n    for (const prop in defaultRadius) {\r\n      if (defaultRadius.hasOwnProperty(prop)) {\r\n        const side = <keyof BorderRadius>prop;\r\n        br[side] = radius[side] || defaultRadius[side];\r\n      }\r\n    }\r\n  }\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(x + br.tl, y);\r\n  ctx.lineTo(x + width - br.tr, y);\r\n  ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\r\n  ctx.lineTo(x + width, y + height - br.br);\r\n  ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\r\n  ctx.lineTo(x + br.bl, y + height);\r\n  ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\r\n  ctx.lineTo(x, y + br.tl);\r\n  ctx.quadraticCurveTo(x, y, x + br.tl, y);\r\n  ctx.closePath();\r\n\r\n  if (fill) {\r\n    ctx.fillStyle = fill.toString();\r\n    ctx.fill();\r\n  }\r\n\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke.toString();\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function circle(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  stroke: Color = Color.White,\r\n  fill: Color = null\r\n) {\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n  ctx.closePath();\r\n\r\n  if (fill) {\r\n    ctx.fillStyle = fill.toString();\r\n    ctx.fill();\r\n  }\r\n\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke.toString();\r\n    ctx.stroke();\r\n  }\r\n}\r\n","export default \"data:image/png;base64,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\"","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { watch } from '../Util/Watch';\r\nimport { TextureLoader } from './Context/texture-loader';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\n\r\nexport interface RasterOptions {\r\n  /**\r\n   * Optionally specify a quality number, which is how much to scale the internal Raster. Default is 1.\r\n   *\r\n   * For example if the quality is set to 2, it doubles the internal raster bitmap in memory.\r\n   *\r\n   * Adjusting this value can be useful if you are working with small rasters.\r\n   */\r\n  quality?: number;\r\n  /**\r\n   * Optionally specify \"smoothing\" if you want antialiasing to apply to the raster's bitmap context, by default `false`\r\n   */\r\n  smoothing?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the color of the raster's bitmap context, by default [[Color.Black]]\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Optionally specify the stroke color of the raster's bitmap context, by default undefined\r\n   */\r\n  strokeColor?: Color;\r\n\r\n  /**\r\n   * Optionally specify the line width of the raster's bitmap, by default 1 pixel\r\n   */\r\n  lineWidth?: number;\r\n\r\n  /**\r\n   * Optionally specify the line dash of the raster's bitmap, by default `[]` which means none\r\n   */\r\n  lineDash?: number[];\r\n\r\n  /**\r\n   * Optionally specify the line end style, default is \"butt\".\r\n   */\r\n  lineCap?: 'butt' | 'round' | 'square';\r\n\r\n  /**\r\n   * Optionally specify the padding to apply to the bitmap\r\n   */\r\n  padding?: number;\r\n\r\n  /**\r\n   * Optionally specify what image filtering mode should be used, [[ImageFiltering.Pixel]] for pixel art,\r\n   * [[ImageFiltering.Blended]] for hi-res art\r\n   *\r\n   * By default unset, rasters defer to the engine antialiasing setting\r\n   */\r\n  filtering?: ImageFiltering;\r\n}\r\n\r\n/**\r\n * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the\r\n * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.\r\n *\r\n * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.\r\n */\r\nexport abstract class Raster extends Graphic {\r\n  public filtering: ImageFiltering = null;\r\n  public lineCap: 'butt' | 'round' | 'square' = 'butt';\r\n  public quality: number = 1;\r\n\r\n  public _bitmap: HTMLCanvasElement;\r\n  protected _ctx: CanvasRenderingContext2D;\r\n  private _dirty: boolean = true;\r\n\r\n  constructor(options?: GraphicOptions & RasterOptions) {\r\n    super(options);\r\n    if (options) {\r\n      this.quality = options.quality ?? this.quality;\r\n      this.color = options.color ?? Color.Black;\r\n      this.strokeColor = options?.strokeColor;\r\n      this.smoothing = options.smoothing ?? this.smoothing;\r\n      this.lineWidth = options.lineWidth ?? this.lineWidth;\r\n      this.lineDash = options.lineDash ?? this.lineDash;\r\n      this.lineCap = options.lineCap ?? this.lineCap;\r\n      this.padding = options.padding ?? this.padding;\r\n      this.filtering = options.filtering ?? this.filtering;\r\n    }\r\n    this._bitmap = document.createElement('canvas');\r\n    // get the default canvas width/height as a fallback\r\n    const bitmapWidth = options?.width ?? this._bitmap.width;\r\n    const bitmapHeight = options?.height ?? this._bitmap.height;\r\n    this.width = bitmapWidth;\r\n    this.height = bitmapHeight;\r\n    const maybeCtx = this._bitmap.getContext('2d');\r\n    if (!maybeCtx) {\r\n      /* istanbul ignore next */\r\n      throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');\r\n    } else {\r\n      this._ctx = maybeCtx;\r\n    }\r\n  }\r\n\r\n  public cloneRasterOptions(): RasterOptions {\r\n    return {\r\n      color: this.color ? this.color.clone() : null,\r\n      strokeColor: this.strokeColor ? this.strokeColor.clone() : null,\r\n      smoothing: this.smoothing,\r\n      lineWidth: this.lineWidth,\r\n      lineDash: this.lineDash,\r\n      lineCap: this.lineCap,\r\n      quality: this.quality,\r\n      padding: this.padding\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized\r\n   */\r\n  public get dirty() {\r\n    return this._dirty;\r\n  }\r\n\r\n  /**\r\n   * Flags the graphic as dirty, meaning it must be re-rasterized before draw.\r\n   * This should be called any time the graphics state changes such that it affects the outputted drawing\r\n   */\r\n  public flagDirty() {\r\n    this._dirty = true;\r\n  }\r\n\r\n  private _originalWidth: number;\r\n  /**\r\n   * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   *\r\n   * Any `padding`s or `quality` set will be factored into the width\r\n   */\r\n  public get width() {\r\n    return Math.abs(this._getTotalWidth() * this.scale.x);\r\n  }\r\n  public set width(value: number) {\r\n    value /= Math.abs(this.scale.x);\r\n    this._bitmap.width = value;\r\n    this._originalWidth = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _originalHeight: number;\r\n  /**\r\n   * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   *\r\n   * Any `padding` or `quality` set will be factored into the height\r\n   */\r\n  public get height() {\r\n    return Math.abs(this._getTotalHeight() * this.scale.y);\r\n  }\r\n\r\n  public set height(value: number) {\r\n    value /= Math.abs(this.scale.y);\r\n    this._bitmap.height = value;\r\n    this._originalHeight = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _getTotalWidth() {\r\n    return ((this._originalWidth ?? this._bitmap.width) + this.padding * 2) * 1;\r\n  }\r\n\r\n  private _getTotalHeight() {\r\n    return ((this._originalHeight ?? this._bitmap.height) + this.padding * 2) * 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the local bounds of the Raster including the padding\r\n   */\r\n  public get localBounds() {\r\n    return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);\r\n  }\r\n\r\n  private _smoothing: boolean = false;\r\n  /**\r\n   * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get smoothing() {\r\n    return this._smoothing;\r\n  }\r\n  public set smoothing(value: boolean) {\r\n    this._smoothing = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _color: Color = watch(Color.Black, () => this.flagDirty());\r\n  /**\r\n   * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get color() {\r\n    return this._color;\r\n  }\r\n  public set color(value) {\r\n    this.flagDirty();\r\n    this._color = watch(value, () => this.flagDirty());\r\n  }\r\n\r\n  private _strokeColor: Color;\r\n  /**\r\n   * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get strokeColor() {\r\n    return this._strokeColor;\r\n  }\r\n  public set strokeColor(value) {\r\n    this.flagDirty();\r\n    this._strokeColor = watch(value, () => this.flagDirty());\r\n  }\r\n\r\n  private _lineWidth: number = 1;\r\n  /**\r\n   * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get lineWidth() {\r\n    return this._lineWidth;\r\n  }\r\n  public set lineWidth(value) {\r\n    this._lineWidth = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _lineDash: number[] = [];\r\n  public get lineDash() {\r\n    return this._lineDash;\r\n  }\r\n\r\n  public set lineDash(value) {\r\n    this._lineDash = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _padding: number = 0;\r\n  public get padding() {\r\n    return this._padding;\r\n  }\r\n\r\n  public set padding(value: number) {\r\n    this._padding = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  /**\r\n   * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if\r\n   * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call\r\n   */\r\n  public rasterize(): void {\r\n    this._dirty = false;\r\n    this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());\r\n    this._ctx.save();\r\n    this._applyRasterProperties(this._ctx);\r\n    this.execute(this._ctx);\r\n    this._ctx.restore();\r\n    // The webgl texture needs to be updated if it exists after a raster cycle\r\n    TextureLoader.load(this._bitmap, this.filtering, true);\r\n  }\r\n\r\n  protected _applyRasterProperties(ctx: CanvasRenderingContext2D) {\r\n    this._bitmap.width = this._getTotalWidth() * this.quality;\r\n    this._bitmap.height = this._getTotalHeight() * this.quality;\r\n    ctx.scale(this.quality, this.quality);\r\n    ctx.translate(this.padding, this.padding);\r\n    ctx.imageSmoothingEnabled = this.smoothing;\r\n    ctx.lineWidth = this.lineWidth;\r\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\r\n    ctx.lineCap = this.lineCap;\r\n    ctx.strokeStyle = this.strokeColor?.toString();\r\n    ctx.fillStyle = this.color?.toString();\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this._dirty) {\r\n      this.rasterize();\r\n    }\r\n    ex.scale(1 / this.quality, 1 / this.quality);\r\n    ex.drawImage(this._bitmap, x, y);\r\n  }\r\n\r\n  /**\r\n   * Executes drawing implementation of the graphic, this is where the specific drawing code for the graphic\r\n   * should be implemented. Once `rasterize()` the graphic can be drawn to the [[ExcaliburGraphicsContext]] via `draw(...)`\r\n   * @param ctx Canvas to draw the graphic to\r\n   */\r\n  abstract execute(ctx: CanvasRenderingContext2D): void;\r\n}\r\n","import { GraphicOptions } from './Graphic';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CanvasOptions {\r\n  draw?: (ctx: CanvasRenderingContext2D) => void;\r\n  cache?: boolean;\r\n}\r\n\r\n/**\r\n * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].\r\n *\r\n * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed\r\n * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.\r\n *\r\n * **Low performance API**\r\n */\r\nexport class Canvas extends Raster {\r\n  /**\r\n   * Return the 2D graphics context of this canvas\r\n   */\r\n  public get ctx() {\r\n    return this._ctx;\r\n  }\r\n\r\n  constructor(private _options: GraphicOptions & RasterOptions & CanvasOptions) {\r\n    super(_options);\r\n  }\r\n\r\n  public clone(): Canvas {\r\n    return new Canvas({\r\n      ...this._options,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this._options?.draw) {\r\n      this._options?.draw(ctx);\r\n    }\r\n    if (!this._options.cache) {\r\n      this.flagDirty();\r\n    }\r\n  }\r\n}\r\n","import { Audio } from './Audio';\r\n\r\nexport type ExResponseType = '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text';\r\n\r\nexport interface ExResponseTypesLookup {\r\n  [name: string]: ExResponseType;\r\n}\r\n\r\nexport class ExResponse {\r\n  public static type: ExResponseTypesLookup = {\r\n    any: '',\r\n    blob: 'blob',\r\n    json: 'json',\r\n    text: 'text',\r\n    document: 'document',\r\n    arraybuffer: 'arraybuffer'\r\n  };\r\n}\r\n\r\n/**\r\n * Represents an audio implementation like [[WebAudioInstance]]\r\n */\r\nexport interface AudioImplementation {\r\n  /**\r\n   * XHR response type\r\n   */\r\n  responseType: ExResponseType;\r\n\r\n  /**\r\n   * Processes raw data and transforms into sound data\r\n   */\r\n  processData(data: Blob | ArrayBuffer): Promise<string | AudioBuffer>;\r\n\r\n  /**\r\n   * Factory method that returns an instance of a played audio track\r\n   */\r\n  createInstance(data: string | AudioBuffer): Audio;\r\n}\r\n","\r\nexport interface State {\r\n  name?: string;\r\n  transitions: string[];\r\n  onEnter?: (context: {from: string, eventData?: any, data: any}) => boolean | void;\r\n  onState?: () => any;\r\n  onExit?: (context: {to: string, data: any}) => boolean | void;\r\n  onUpdate?: (data: any, elapsedMs: number) => any;\r\n}\r\n\r\nexport interface StateMachineDescription {\r\n  start: string,\r\n  states: { [name: string]: State }\r\n}\r\n\r\nexport type PossibleStates<TMachine> = TMachine extends StateMachineDescription ? Extract<keyof TMachine['states'], string> : never;\r\n\r\nexport interface StateMachineState {\r\n  data: any;\r\n  currentState: string;\r\n}\r\n\r\nexport class StateMachine<TPossibleStates extends string, TData> {\r\n  public startState: State;\r\n  private _currentState: State;\r\n  public get currentState(): State {\r\n    return this._currentState;\r\n  }\r\n  public set currentState(state: State) {\r\n    this._currentState = state;\r\n  }\r\n  public states = new Map<string, State>();\r\n  public data: TData;\r\n\r\n  static create<TMachine extends StateMachineDescription, TData>(\r\n    machineDescription: TMachine, data?: TData): StateMachine<PossibleStates<TMachine>, TData> {\r\n    const machine = new StateMachine<PossibleStates<TMachine>, TData>();\r\n    machine.data = data;\r\n    for (const stateName in machineDescription.states) {\r\n      machine.states.set(stateName as PossibleStates<TMachine>, {\r\n        name: stateName,\r\n        ...machineDescription.states[stateName]\r\n      });\r\n    }\r\n\r\n    // validate transitions are states\r\n    for (const state of machine.states.values()) {\r\n      for (const transitionState of state.transitions) {\r\n        if (transitionState === '*') {\r\n          continue;\r\n        }\r\n        if (!machine.states.has(transitionState)) {\r\n          throw Error(\r\n            `Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`\r\n          );\r\n        }\r\n      }\r\n    }\r\n    machine.currentState = machine.startState = machine.states.get(machineDescription.start);\r\n    return machine;\r\n  }\r\n\r\n  in(state: TPossibleStates): boolean {\r\n    return this.currentState.name === state;\r\n  }\r\n\r\n  go(stateName: TPossibleStates, eventData?: any): boolean {\r\n    if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes('*')) {\r\n      const potentialNewState = this.states.get(stateName);\r\n      if (this.currentState.onExit) {\r\n        const canExit = this.currentState?.onExit({to: potentialNewState.name, data: this.data});\r\n        if (canExit === false) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (potentialNewState?.onEnter) {\r\n        const canEnter = potentialNewState?.onEnter({from: this.currentState.name, eventData, data: this.data});\r\n        if (canEnter === false) {\r\n          return false;\r\n        }\r\n      }\r\n      // console.log(`${this.currentState.name} => ${potentialNewState.name} (${eventData})`);\r\n      this.currentState = potentialNewState;\r\n      if (this.currentState?.onState) {\r\n        this.currentState.onState();\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  update(elapsedMs: number) {\r\n    if (this.currentState.onUpdate) {\r\n      this.currentState.onUpdate(this.data, elapsedMs);\r\n    }\r\n  }\r\n\r\n  save(saveKey: string) {\r\n    localStorage.setItem(saveKey, JSON.stringify({\r\n      currentState: this.currentState.name,\r\n      data: this.data\r\n    }));\r\n  }\r\n\r\n  restore(saveKey: string) {\r\n    const state: StateMachineState = JSON.parse(localStorage.getItem(saveKey));\r\n    this.currentState = this.states.get(state.currentState);\r\n    this.data = state.data;\r\n  }\r\n}\r\n\r\n","import { StateMachine } from '../../Util/StateMachine';\r\nimport { Audio } from '../../Interfaces/Audio';\r\nimport { clamp } from '../../Math/util';\r\nimport { AudioContextFactory } from './AudioContext';\r\n\r\ninterface SoundState {\r\n  startedAt: number;\r\n  pausedAt: number;\r\n}\r\n\r\n/**\r\n * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n */\r\nexport class WebAudioInstance implements Audio {\r\n  private _instance: AudioBufferSourceNode;\r\n  private _audioContext: AudioContext = AudioContextFactory.create();\r\n  private _volumeNode = this._audioContext.createGain();\r\n  private _playingResolve: (value: boolean) => void;\r\n  private _playingPromise = new Promise<boolean>((resolve) => {\r\n    this._playingResolve = resolve;\r\n  });\r\n  private _stateMachine = StateMachine.create({\r\n    start: 'STOPPED',\r\n    states: {\r\n      PLAYING: {\r\n        onEnter: ({data}: {from: string, data: SoundState}) => {\r\n\r\n          // Buffer nodes are single use\r\n          this._createNewBufferSource();\r\n          this._handleEnd();\r\n          this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);\r\n          data.startedAt = (this._audioContext.currentTime - data.pausedAt);\r\n          data.pausedAt = 0;\r\n        },\r\n        onState: () => this._playStarted(),\r\n        onExit: ({to}) => {\r\n          // If you've exited early only resolve if explicitly STOPPED\r\n          if (to === 'STOPPED') {\r\n            this._playingResolve(true);\r\n          }\r\n          // Whenever you're not playing... you stop!\r\n          this._instance.onended = null; // disconnect the wired on-end handler\r\n          this._instance.disconnect();\r\n          this._instance.stop(0);\r\n          this._instance = null;\r\n        },\r\n        transitions: ['STOPPED', 'PAUSED', 'SEEK']\r\n      },\r\n      SEEK: {\r\n        onEnter: ({ eventData: position, data }: {eventData?: number, data: SoundState}) => {\r\n          data.pausedAt = (position ?? 0) / this._playbackRate;\r\n          data.startedAt = 0;\r\n        },\r\n        transitions: ['*']\r\n      },\r\n      STOPPED: {\r\n        onEnter: ({data}: {from: string, data: SoundState}) => {\r\n          data.pausedAt = 0;\r\n          data.startedAt = 0;\r\n          this._playingResolve(true);\r\n        },\r\n        transitions: ['PLAYING', 'PAUSED', 'SEEK']\r\n      },\r\n      PAUSED: {\r\n        onEnter: ({data}: {data: SoundState}) => {\r\n          // Playback rate will be a scale factor of how fast/slow the audio is being played\r\n          // default is 1.0\r\n          // we need to invert it to get the time scale\r\n          data.pausedAt = (this._audioContext.currentTime - data.startedAt);\r\n        },\r\n        transitions: ['PLAYING', 'STOPPED', 'SEEK']\r\n      }\r\n    }\r\n  }, {\r\n    startedAt: 0,\r\n    pausedAt: 0\r\n  } as SoundState);\r\n\r\n  private _createNewBufferSource() {\r\n    this._instance = this._audioContext.createBufferSource();\r\n    this._instance.buffer = this._src;\r\n    this._instance.loop = this.loop;\r\n    this._instance.playbackRate.value = this._playbackRate;\r\n    this._instance.connect(this._volumeNode);\r\n    this._volumeNode.connect(this._audioContext.destination);\r\n  }\r\n\r\n  private _handleEnd() {\r\n    if (!this.loop) {\r\n      this._instance.onended = () => {\r\n        this._playingResolve(true);\r\n      };\r\n    }\r\n  }\r\n\r\n  private _volume = 1;\r\n  private _loop = false;\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  private _playStarted: () => any = () => {};\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    if (this._instance) {\r\n      this._instance.loop = value;\r\n      if (!this.loop) {\r\n        this._instance.onended = () => {\r\n          this._playingResolve(true);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    value = clamp(value, 0, 1.0);\r\n\r\n    this._volume = value;\r\n\r\n    if (this._stateMachine.in('PLAYING') && this._volumeNode.gain.setTargetAtTime) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime\r\n      // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.\r\n      // This exponential ramp provides a more pleasant transition in gain\r\n      this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);\r\n    } else {\r\n      this._volumeNode.gain.value = value;\r\n    }\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  private _duration: number | undefined;\r\n  /**\r\n   * Returns the set duration to play, otherwise returns the total duration if unset\r\n   */\r\n  public get duration() {\r\n    return this._duration ?? this.getTotalPlaybackDuration();\r\n  }\r\n\r\n  /**\r\n   * Set the duration that this audio should play.\r\n   *\r\n   * Note: if you seek to a specific point the duration will start from that point, for example\r\n   *\r\n   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n   */\r\n  public set duration(duration: number) {\r\n    this._duration = duration;\r\n  }\r\n\r\n  constructor(private _src: AudioBuffer) {\r\n    this._createNewBufferSource();\r\n  }\r\n\r\n  public isPlaying() {\r\n    return this._stateMachine.in('PLAYING');\r\n  }\r\n\r\n  public isPaused() {\r\n    return this._stateMachine.in('PAUSED') || this._stateMachine.in('SEEK');\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  public play(playStarted: () => any = () => {}) {\r\n    this._playStarted = playStarted;\r\n    this._stateMachine.go('PLAYING');\r\n    return this._playingPromise;\r\n  }\r\n\r\n  public pause() {\r\n    this._stateMachine.go('PAUSED');\r\n  }\r\n\r\n  public stop() {\r\n    this._stateMachine.go('STOPPED');\r\n  }\r\n\r\n  public seek(position: number) {\r\n    this._stateMachine.go('PAUSED');\r\n    this._stateMachine.go('SEEK', position);\r\n  }\r\n\r\n  public getTotalPlaybackDuration() {\r\n    return this._src.duration;\r\n  }\r\n\r\n  public getPlaybackPosition() {\r\n    const {pausedAt, startedAt} =  this._stateMachine.data;\r\n    if (pausedAt) {\r\n      return pausedAt * this._playbackRate;\r\n    }\r\n    if (startedAt) {\r\n      return (this._audioContext.currentTime - startedAt) * this._playbackRate;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private _playbackRate = 1.0;\r\n  public set playbackRate(playbackRate: number) {\r\n    this._instance.playbackRate.value = this._playbackRate = playbackRate;\r\n  }\r\n\r\n  public get playbackRate() {\r\n    return this._instance.playbackRate.value;\r\n  }\r\n}\r\n","import { GameEvent } from '../Events';\r\nimport { Sound } from '../Resources/Sound/Sound';\r\nimport { Actor } from '../Actor';\r\nimport { WebAudioInstance } from '../Resources/Sound/WebAudioInstance';\r\n\r\nexport class MediaEvent extends GameEvent<Sound> {\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public set bubbles(_value: boolean) {\r\n    // stubbed\r\n  }\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public get bubbles(): boolean {\r\n    return false;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected get _path(): Actor[] {\r\n    return null;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected set _path(_val: Actor[]) {\r\n    // stubbed\r\n  }\r\n\r\n  constructor(public target: Sound, protected _name: string = 'MediaEvent') {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Action, that calls when event happens\r\n   */\r\n  public action(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Propagate event further through event path\r\n   */\r\n  public propagate(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n\r\n  public layPath(_actor: Actor): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n}\r\n\r\nexport class NativeSoundEvent extends MediaEvent {\r\n  constructor(target: Sound, public track?: WebAudioInstance) {\r\n    super(target, 'NativeSoundEvent');\r\n  }\r\n}\r\n\r\nexport class NativeSoundProcessedEvent extends MediaEvent {\r\n  public data: string | AudioBuffer;\r\n\r\n  constructor(target: Sound, private _processedData: string | AudioBuffer) {\r\n    super(target, 'NativeSoundProcessedEvent');\r\n\r\n    this.data = this._processedData;\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n\r\n/**\r\n * Whether or not the browser can play this file as HTML5 Audio\r\n */\r\nexport function canPlayFile(file: string): boolean {\r\n  try {\r\n    const a = new Audio();\r\n    const filetype = /.*\\.([A-Za-z0-9]+)$/;\r\n    const type = file.match(filetype)[1];\r\n    if (a.canPlayType('audio/' + type)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  } catch (e) {\r\n    Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);\r\n    return false;\r\n  }\r\n}\r\n","import { ExResponse } from '../../Interfaces/AudioImplementation';\r\nimport { Audio } from '../../Interfaces/Audio';\r\nimport { Engine } from '../../Engine';\r\nimport { Resource } from '../Resource';\r\nimport { WebAudioInstance } from './WebAudioInstance';\r\nimport { AudioContextFactory } from './AudioContext';\r\nimport { NativeSoundEvent, NativeSoundProcessedEvent } from '../../Events/MediaEvents';\r\nimport { canPlayFile } from '../../Util/Sound';\r\nimport { Loadable } from '../../Interfaces/Index';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Class } from '../../Class';\r\n\r\n/**\r\n * The [[Sound]] object allows games built in Excalibur to load audio\r\n * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]\r\n * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n */\r\nexport class Sound extends Class implements Audio, Loadable<AudioBuffer> {\r\n  public logger: Logger = Logger.getInstance();\r\n  public data: AudioBuffer;\r\n  private _resource: Resource<ArrayBuffer>;\r\n  /**\r\n   * Indicates whether the clip should loop when complete\r\n   * @param value  Set the looping flag\r\n   */\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.loop = this._loop;\r\n    }\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    this._volume = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.volume = this._volume;\r\n    }\r\n\r\n    this.emit('volumechange', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  private _duration: number | undefined;\r\n  /**\r\n   * Get the duration that this audio should play. If unset the total natural playback duration will be used.\r\n   */\r\n  public get duration(): number | undefined {\r\n    return this._duration;\r\n  }\r\n  /**\r\n   * Set the duration that this audio should play. If unset the total natural playback duration will be used.\r\n   *\r\n   * Note: if you seek to a specific point the duration will start from that point, for example\r\n   *\r\n   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.\r\n   */\r\n  public set duration(duration: number | undefined){\r\n    this._duration = duration;\r\n  }\r\n\r\n  /**\r\n   * Return array of Current AudioInstances playing or being paused\r\n   */\r\n  public get instances(): Audio[] {\r\n    return this._tracks;\r\n  }\r\n\r\n  public get path() {\r\n    return this._resource.path;\r\n  }\r\n\r\n  public set path(val: string) {\r\n    this._resource.path = val;\r\n  }\r\n\r\n  private _loop = false;\r\n  private _volume = 1;\r\n  private _isStopped = false;\r\n  // private _isPaused = false;\r\n  private _tracks: Audio[] = [];\r\n  private _engine: Engine;\r\n  private _wasPlayingOnHidden: boolean = false;\r\n  private _playbackRate = 1.0;\r\n  private _audioContext = AudioContextFactory.create();\r\n\r\n  /**\r\n   * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n   */\r\n  constructor(...paths: string[]) {\r\n    super();\r\n    this._resource = new Resource('', ExResponse.type.arraybuffer);\r\n    /**\r\n     * Chrome : MP3, WAV, Ogg\r\n     * Firefox : WAV, Ogg,\r\n     * IE : MP3, WAV coming soon\r\n     * Safari MP3, WAV, Ogg\r\n     */\r\n    for (const path of paths) {\r\n      if (canPlayFile(path)) {\r\n        this.path = path;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!this.path) {\r\n      this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));\r\n      this.logger.warn('Attempting to use', paths[0]);\r\n      this.path = paths[0]; // select the first specified\r\n    }\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  public async load(): Promise<AudioBuffer> {\r\n    if (this.data) {\r\n      return this.data;\r\n    }\r\n    const arraybuffer = await this._resource.load();\r\n    const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));\r\n    this._duration = this._duration ?? audiobuffer?.duration ?? undefined;\r\n    this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));\r\n    return this.data = audiobuffer;\r\n  }\r\n\r\n  public async decodeAudio(data: ArrayBuffer): Promise<AudioBuffer> {\r\n    try {\r\n      return await this._audioContext.decodeAudioData(data.slice(0));\r\n    } catch (e) {\r\n      this.logger.error(\r\n        'Unable to decode ' +\r\n          ' this browser may not fully support this format, or the file may be corrupt, ' +\r\n          'if this is an mp3 try removing id3 tags and album art from the file.'\r\n      );\r\n      return await Promise.reject();\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    if (engine) {\r\n      this._engine = engine;\r\n\r\n      this._engine.on('hidden', () => {\r\n        if (engine.pauseAudioWhenHidden && this.isPlaying()) {\r\n          this._wasPlayingOnHidden = true;\r\n          this.pause();\r\n        }\r\n      });\r\n\r\n      this._engine.on('visible', () => {\r\n        if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {\r\n          this.play();\r\n          this._wasPlayingOnHidden = false;\r\n        }\r\n      });\r\n\r\n      this._engine.on('start', () => {\r\n        this._isStopped = false;\r\n      });\r\n\r\n      this._engine.on('stop', () => {\r\n        this.stop();\r\n        this._isStopped = true;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns how many instances of the sound are currently playing\r\n   */\r\n  public instanceCount(): number {\r\n    return this._tracks.length;\r\n  }\r\n\r\n  /**\r\n   * Whether or not the sound is playing right now\r\n   */\r\n  public isPlaying(): boolean {\r\n    return this._tracks.some((t) => t.isPlaying());\r\n  }\r\n\r\n  public isPaused(): boolean {\r\n    return this._tracks.some(t => t.isPaused());\r\n  }\r\n\r\n  /**\r\n   * Play the sound, returns a promise that resolves when the sound is done playing\r\n   * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n   */\r\n  public play(volume?: number): Promise<boolean> {\r\n    if (!this.isLoaded()) {\r\n      this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');\r\n\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    if (this._isStopped) {\r\n      this.logger.warn('Cannot start playing. Engine is in a stopped state.');\r\n      return Promise.resolve(false);\r\n    }\r\n\r\n    this.volume = volume || this.volume;\r\n\r\n    if (this.isPaused()) {\r\n      return this._resumePlayback();\r\n    } else {\r\n      return this._startPlayback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the sound, and do not rewind\r\n   */\r\n  public pause() {\r\n    if (!this.isPlaying()) {\r\n      return;\r\n    }\r\n\r\n    for (const track of this._tracks) {\r\n      track.pause();\r\n    }\r\n\r\n    this.emit('pause', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Paused all instances of sound', this.path);\r\n  }\r\n\r\n  /**\r\n   * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.\r\n   */\r\n  public stop() {\r\n    for (const track of this._tracks) {\r\n      track.stop();\r\n    }\r\n\r\n    this.emit('stop', new NativeSoundEvent(this));\r\n\r\n    this._tracks.length = 0;\r\n    this.logger.debug('Stopped all instances of sound', this.path);\r\n  }\r\n\r\n  public get playbackRate(): number {\r\n    return this._playbackRate;\r\n  }\r\n\r\n  public set playbackRate(playbackRate: number) {\r\n    this._playbackRate = playbackRate;\r\n    this._tracks.forEach(t => {\r\n      t.playbackRate = this._playbackRate;\r\n    });\r\n  }\r\n\r\n  public seek(position: number, trackId = 0) {\r\n    if (this._tracks.length === 0) {\r\n      this._getTrackInstance(this.data);\r\n    }\r\n\r\n    this._tracks[trackId].seek(position);\r\n  }\r\n\r\n  public getTotalPlaybackDuration() {\r\n    return this.data.duration;\r\n  }\r\n\r\n  /**\r\n   * Return the current playback time of the playing track in seconds from the start.\r\n   *\r\n   * Optionally specify the track to query if multiple are playing at once.\r\n   * @param trackId\r\n   */\r\n  public getPlaybackPosition(trackId = 0) {\r\n    if (this._tracks.length) {\r\n      return this._tracks[trackId].getPlaybackPosition();\r\n    }\r\n    return 0;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get Id of provided AudioInstance in current trackList\r\n   * @param track [[Audio]] which Id is to be given\r\n   */\r\n  public getTrackId(track: Audio): number {\r\n    return this._tracks.indexOf(track);\r\n  }\r\n\r\n  private async _resumePlayback(): Promise<boolean> {\r\n    if (this.isPaused) {\r\n      const resumed: Promise<boolean>[] = [];\r\n      // ensure we resume *current* tracks (if paused)\r\n      for (const track of this._tracks) {\r\n        resumed.push(track.play().then(() => {\r\n          this.emit('playbackend', new NativeSoundEvent(this, track as WebAudioInstance));\r\n          this._tracks.splice(this.getTrackId(track), 1);\r\n          return true;\r\n        }));\r\n      }\r\n\r\n      this.emit('resume', new NativeSoundEvent(this));\r\n\r\n      this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);\r\n      // resolve when resumed tracks are done\r\n      await Promise.all(resumed);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Starts playback, returns a promise that resolves when playback is complete\r\n   */\r\n  private async _startPlayback(): Promise<boolean> {\r\n    const track = await this._getTrackInstance(this.data);\r\n\r\n    const complete = await track.play(() => {\r\n      this.emit('playbackstart', new NativeSoundEvent(this, track));\r\n      this.logger.debug('Playing new instance for sound', this.path);\r\n    });\r\n\r\n    // when done, remove track\r\n    this.emit('playbackend', new NativeSoundEvent(this, track));\r\n    this._tracks.splice(this.getTrackId(track), 1);\r\n\r\n    return complete;\r\n  }\r\n\r\n  private _getTrackInstance(data: AudioBuffer): WebAudioInstance {\r\n    const newTrack = new WebAudioInstance(data);\r\n\r\n    newTrack.loop = this.loop;\r\n    newTrack.volume = this.volume;\r\n    newTrack.duration = this.duration;\r\n    newTrack.playbackRate = this._playbackRate;\r\n\r\n    this._tracks.push(newTrack);\r\n\r\n    return newTrack;\r\n  }\r\n}\r\n","import { Color } from './Color';\r\nimport { WebAudio } from './Util/WebAudio';\r\nimport { Engine } from './Engine';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Class } from './Class';\r\nimport * as DrawUtil from './Util/DrawUtil';\r\n\r\nimport logoImg from './Loader.logo.png';\r\nimport loaderCss from './Loader.css';\r\nimport { Canvas } from './Graphics/Canvas';\r\nimport { Vector } from './Math/vector';\r\nimport { delay } from './Util/Util';\r\nimport { ImageFiltering } from './Graphics/Filtering';\r\nimport { clamp } from './Math/util';\r\nimport { Sound } from './Resources/Sound/Sound';\r\nimport { Future } from './Util/Future';\r\n\r\n/**\r\n * Pre-loading assets\r\n *\r\n * The loader provides a mechanism to preload multiple resources at\r\n * one time. The loader must be passed to the engine in order to\r\n * trigger the loading progress bar.\r\n *\r\n * The [[Loader]] itself implements [[Loadable]] so you can load loaders.\r\n *\r\n * ## Example: Pre-loading resources for a game\r\n *\r\n * ```js\r\n * // create a loader\r\n * var loader = new ex.Loader();\r\n *\r\n * // create a resource dictionary (best practice is to keep a separate file)\r\n * var resources = {\r\n *   TextureGround: new ex.Texture(\"/images/textures/ground.png\"),\r\n *   SoundDeath: new ex.Sound(\"/sound/death.wav\", \"/sound/death.mp3\")\r\n * };\r\n *\r\n * // loop through dictionary and add to loader\r\n * for (var loadable in resources) {\r\n *   if (resources.hasOwnProperty(loadable)) {\r\n *     loader.addResource(resources[loadable]);\r\n *   }\r\n * }\r\n *\r\n * // start game\r\n * game.start(loader).then(function () {\r\n *   console.log(\"Game started!\");\r\n * });\r\n * ```\r\n *\r\n * ## Customize the Loader\r\n *\r\n * The loader can be customized to show different, text, logo, background color, and button.\r\n *\r\n * ```typescript\r\n * const loader = new ex.Loader([playerTexture]);\r\n *\r\n * // The loaders button text can simply modified using this\r\n * loader.playButtonText = 'Start the best game ever';\r\n *\r\n * // The logo can be changed by inserting a base64 image string here\r\n *\r\n * loader.logo = 'data:image/png;base64,iVBORw...';\r\n * loader.logoWidth = 15;\r\n * loader.logoHeight = 14;\r\n *\r\n * // The background color can be changed like so by supplying a valid CSS color string\r\n *\r\n * loader.backgroundColor = 'red'\r\n * loader.backgroundColor = '#176BAA'\r\n *\r\n * // To build a completely new button\r\n * loader.startButtonFactory = () => {\r\n *     let myButton = document.createElement('button');\r\n *     myButton.textContent = 'The best button';\r\n *     return myButton;\r\n * };\r\n *\r\n * engine.start(loader).then(() => {});\r\n * ```\r\n */\r\nexport class Loader extends Class implements Loadable<Loadable<any>[]> {\r\n  public canvas: Canvas = new Canvas({\r\n    filtering: ImageFiltering.Blended,\r\n    smoothing: true,\r\n    cache: true,\r\n    draw: this.draw.bind(this)\r\n  });\r\n  private _resourceList: Loadable<any>[] = [];\r\n  private _index = 0;\r\n\r\n  private _playButtonShown: boolean = false;\r\n  private _resourceCount: number = 0;\r\n  private _numLoaded: number = 0;\r\n  private _progressCounts: { [key: string]: number } = {};\r\n  private _totalCounts: { [key: string]: number } = {};\r\n  private _engine: Engine;\r\n\r\n  // logo drawing stuff\r\n\r\n  // base64 string encoding of the excalibur logo (logo-white.png)\r\n  public logo = logoImg;\r\n  public logoWidth = 468;\r\n  public logoHeight = 118;\r\n  /**\r\n   * Positions the top left corner of the logo image\r\n   * If not set, the loader automatically positions the logo\r\n   */\r\n  public logoPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the play button.\r\n   * If not set, the loader automatically positions the play button\r\n   */\r\n  public playButtonPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the loading bar\r\n   * If not set, the loader automatically positions the loading bar\r\n   */\r\n  public loadingBarPosition: Vector | null;\r\n\r\n  /**\r\n   * Gets or sets the color of the loading bar, default is [[Color.White]]\r\n   */\r\n  public loadingBarColor: Color = Color.White;\r\n\r\n  /**\r\n   * Gets or sets the background color of the loader as a hex string\r\n   */\r\n  public backgroundColor: string = '#176BAA';\r\n\r\n  protected _imageElement: HTMLImageElement;\r\n  protected get _image() {\r\n    if (!this._imageElement) {\r\n      this._imageElement = new Image();\r\n      this._imageElement.src = this.logo;\r\n    }\r\n\r\n    return this._imageElement;\r\n  }\r\n\r\n  public suppressPlayButton: boolean = false;\r\n  public get playButtonRootElement(): HTMLElement | null {\r\n    return this._playButtonRootElement;\r\n  }\r\n  public get playButtonElement(): HTMLButtonElement | null {\r\n    return this._playButtonElement;\r\n  }\r\n  protected _playButtonRootElement: HTMLElement;\r\n  protected _playButtonElement: HTMLButtonElement;\r\n  protected _styleBlock: HTMLStyleElement;\r\n  /** Loads the css from Loader.css */\r\n  protected _playButtonStyles: string = loaderCss.toString();\r\n  protected get _playButton() {\r\n    const existingRoot = document.getElementById('excalibur-play-root');\r\n    if (existingRoot) {\r\n      this._playButtonRootElement = existingRoot;\r\n    }\r\n    if (!this._playButtonRootElement) {\r\n      this._playButtonRootElement = document.createElement('div');\r\n      this._playButtonRootElement.id = 'excalibur-play-root';\r\n      this._playButtonRootElement.style.position = 'absolute';\r\n      document.body.appendChild(this._playButtonRootElement);\r\n    }\r\n    if (!this._styleBlock) {\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._playButtonStyles;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n    if (!this._playButtonElement) {\r\n      this._playButtonElement = this.startButtonFactory();\r\n      this._playButtonRootElement.appendChild(this._playButtonElement);\r\n    }\r\n    return this._playButtonElement;\r\n  }\r\n\r\n  /**\r\n   * Get/set play button text\r\n   */\r\n  public playButtonText: string = 'Play game';\r\n\r\n  /**\r\n   * Return a html button element for excalibur to use as a play button\r\n   */\r\n  public startButtonFactory = () => {\r\n    let buttonElement: HTMLButtonElement = document.getElementById('excalibur-play') as HTMLButtonElement;\r\n    if (!buttonElement) {\r\n      buttonElement = document.createElement('button');\r\n    }\r\n\r\n    buttonElement.id = 'excalibur-play';\r\n    buttonElement.textContent = this.playButtonText;\r\n    buttonElement.style.display = 'none';\r\n    return buttonElement;\r\n  };\r\n\r\n  /**\r\n   * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n   */\r\n  constructor(loadables?: Loadable<any>[]) {\r\n    super();\r\n\r\n    if (loadables) {\r\n      this.addResources(loadables);\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    this._engine = engine;\r\n    this.canvas.width = this._engine.canvas.width;\r\n    this.canvas.height = this._engine.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Add a resource to the loader to load\r\n   * @param loadable  Resource to add\r\n   */\r\n  public addResource(loadable: Loadable<any>) {\r\n    const key = this._index++;\r\n    this._resourceList.push(loadable);\r\n    this._progressCounts[key] = 0;\r\n    this._totalCounts[key] = 1;\r\n    this._resourceCount++;\r\n  }\r\n\r\n  /**\r\n   * Add a list of resources to the loader to load\r\n   * @param loadables  The list of resources to load\r\n   */\r\n  public addResources(loadables: Loadable<any>[]) {\r\n    let i = 0;\r\n    const len = loadables.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this.addResource(loadables[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the loader has completely loaded all resources\r\n   */\r\n  public isLoaded() {\r\n    return this._numLoaded === this._resourceCount;\r\n  }\r\n\r\n  /**\r\n   * Shows the play button and returns a promise that resolves when clicked\r\n   */\r\n  public async showPlayButton(): Promise<void> {\r\n    if (this.suppressPlayButton) {\r\n      this.hidePlayButton();\r\n      // Delay is to give the logo a chance to show, otherwise don't delay\r\n      await delay(500, this._engine?.clock);\r\n    } else {\r\n      const resizeHandler = () => {\r\n        this._positionPlayButton();\r\n      };\r\n      if (this._engine?.browser) {\r\n        this._engine.browser.window.on('resize', resizeHandler);\r\n      }\r\n      this._playButtonShown = true;\r\n      this._playButton.style.display = 'block';\r\n      document.body.addEventListener('keyup', (evt: KeyboardEvent) => {\r\n        if (evt.key === 'Enter') {\r\n          this._playButton.click();\r\n        }\r\n      });\r\n      this._positionPlayButton();\r\n      const playButtonClicked = new Promise<void>((resolve) => {\r\n        const startButtonHandler = (e: Event) => {\r\n          // We want to stop propagation to keep bubbling to the engine pointer handlers\r\n          e.stopPropagation();\r\n          // Hide Button after click\r\n          this.hidePlayButton();\r\n          if (this._engine?.browser) {\r\n            this._engine.browser.window.off('resize', resizeHandler);\r\n          }\r\n          resolve();\r\n        };\r\n        this._playButton.addEventListener('click', startButtonHandler);\r\n        this._playButton.addEventListener('touchend', startButtonHandler);\r\n        this._playButton.addEventListener('pointerup', startButtonHandler);\r\n      });\r\n\r\n      return await playButtonClicked;\r\n    }\r\n  }\r\n\r\n  public hidePlayButton() {\r\n    this._playButtonShown = false;\r\n    this._playButton.style.display = 'none';\r\n  }\r\n\r\n  /**\r\n   * Clean up generated elements for the loader\r\n   */\r\n  public dispose() {\r\n    if (this._playButtonRootElement.parentElement) {\r\n      this._playButtonRootElement.removeChild(this._playButtonElement);\r\n      document.body.removeChild(this._playButtonRootElement);\r\n      document.head.removeChild(this._styleBlock);\r\n      this._playButtonRootElement = null;\r\n      this._playButtonElement = null;\r\n      this._styleBlock = null;\r\n    }\r\n  }\r\n\r\n  update(_engine: Engine, _delta: number): void {\r\n    // override me\r\n  }\r\n\r\n  data: Loadable<any>[];\r\n\r\n  private _loadingFuture = new Future<void>();\r\n  public areResourcesLoaded() {\r\n    return this._loadingFuture.promise;\r\n  }\r\n\r\n  /**\r\n   * Begin loading all of the supplied resources, returning a promise\r\n   * that resolves when loading of all is complete AND the user has clicked the \"Play button\"\r\n   */\r\n  public async load(): Promise<Loadable<any>[]> {\r\n    await this._image?.decode(); // decode logo if it exists\r\n    this.canvas.flagDirty();\r\n\r\n    await Promise.all(\r\n      this._resourceList.map(async (r) => {\r\n        await r.load().finally(() => {\r\n          // capture progress\r\n          this._numLoaded++;\r\n          this.canvas.flagDirty();\r\n        });\r\n      })\r\n    );\r\n    // Wire all sound to the engine\r\n    for (const resource of this._resourceList) {\r\n      if (resource instanceof Sound) {\r\n        resource.wireEngine(this._engine);\r\n      }\r\n    }\r\n\r\n    this._loadingFuture.resolve();\r\n\r\n    // short delay in showing the button for aesthetics\r\n    await delay(200, this._engine?.clock);\r\n    this.canvas.flagDirty();\r\n\r\n    await this.showPlayButton();\r\n    // Unlock browser AudioContext in after user gesture\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/262\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/1031\r\n    await WebAudio.unlock();\r\n\r\n    return (this.data = this._resourceList);\r\n  }\r\n\r\n  public markResourceComplete(): void {\r\n    this._numLoaded++;\r\n  }\r\n\r\n  /**\r\n   * Returns the progress of the loader as a number between [0, 1] inclusive.\r\n   */\r\n  public get progress(): number {\r\n    return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;\r\n  }\r\n\r\n  private _positionPlayButton() {\r\n    if (this._engine) {\r\n      const screenHeight = this._engine.screen.viewport.height;\r\n      const screenWidth = this._engine.screen.viewport.width;\r\n      if (this._playButtonRootElement) {\r\n        const left = this._engine.canvas.offsetLeft;\r\n        const top = this._engine.canvas.offsetTop;\r\n        const buttonWidth = this._playButton.clientWidth;\r\n        const buttonHeight = this._playButton.clientHeight;\r\n        if (this.playButtonPosition) {\r\n          this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;\r\n          this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;\r\n        } else {\r\n          this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;\r\n          this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loader draw function. Draws the default Excalibur loading screen.\r\n   * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n   * to customize the drawing, or just override entire method.\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D) {\r\n    const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;\r\n    const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;\r\n\r\n    this._positionPlayButton();\r\n\r\n    ctx.fillStyle = this.backgroundColor;\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    let logoY = canvasHeight / 2;\r\n    const width = Math.min(this.logoWidth, canvasWidth * 0.75);\r\n    let logoX = canvasWidth / 2 - width / 2;\r\n\r\n    if (this.logoPosition) {\r\n      logoX = this.logoPosition.x;\r\n      logoY = this.logoPosition.y;\r\n    }\r\n\r\n    const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\r\n    const oldAntialias = this._engine.getAntialiasing();\r\n    this._engine.setAntialiasing(true);\r\n    if (!this.logoPosition) {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);\r\n    } else {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);\r\n    }\r\n\r\n    // loading box\r\n    if (!this.suppressPlayButton && this._playButtonShown) {\r\n      this._engine.setAntialiasing(oldAntialias);\r\n      return;\r\n    }\r\n\r\n    let loadingX = logoX;\r\n    let loadingY = logoY;\r\n    if (this.loadingBarPosition) {\r\n      loadingX = this.loadingBarPosition.x;\r\n      loadingY = this.loadingBarPosition.y;\r\n    }\r\n\r\n    ctx.lineWidth = 2;\r\n    DrawUtil.roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);\r\n    const progress = width * this.progress;\r\n    const margin = 5;\r\n    const progressWidth = progress - margin * 2;\r\n    const height = 20 - margin * 2;\r\n    DrawUtil.roundRect(\r\n      ctx,\r\n      loadingX + margin,\r\n      loadingY + margin,\r\n      progressWidth > 10 ? progressWidth : 10,\r\n      height,\r\n      5,\r\n      null,\r\n      this.loadingBarColor\r\n    );\r\n    this._engine.setAntialiasing(oldAntialias);\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n/**\r\n * This is the list of features that will be used to log the supported\r\n * features to the console when Detector.logBrowserFeatures() is called.\r\n */\r\n\r\nconst REPORTED_FEATURES: { [key: string]: string } = {\r\n  webgl: 'WebGL',\r\n  webaudio: 'WebAudio',\r\n  gamepadapi: 'Gamepad API'\r\n};\r\n\r\n/**\r\n * Interface for detected browser features matrix\r\n */\r\nexport interface DetectedFeatures {\r\n  readonly canvas: boolean;\r\n  readonly arraybuffer: boolean;\r\n  readonly dataurl: boolean;\r\n  readonly objecturl: boolean;\r\n  readonly rgba: boolean;\r\n  readonly webaudio: boolean;\r\n  readonly webgl: boolean;\r\n  readonly gamepadapi: boolean;\r\n}\r\n\r\ninterface CriticalTests {\r\n  canvasSupport(): boolean;\r\n  arrayBufferSupport(): boolean;\r\n  dataUrlSupport(): boolean;\r\n  objectUrlSupport(): boolean;\r\n  rgbaSupport(): boolean;\r\n}\r\n\r\ninterface WarningTests {\r\n  webAudioSupport(): boolean;\r\n  webglSupport(): boolean;\r\n}\r\n\r\n/**\r\n * Excalibur internal feature detection helper class\r\n */\r\nexport class Detector {\r\n  private _features: DetectedFeatures = null;\r\n\r\n  public failedTests: string[] = [];\r\n\r\n  public constructor() {\r\n    this._features = this._loadBrowserFeatures();\r\n  }\r\n\r\n  /**\r\n   * Returns a map of currently supported browser features. This method\r\n   * treats the features as a singleton and will only calculate feature\r\n   * support if it has not previously been done.\r\n   */\r\n  public getBrowserFeatures(): DetectedFeatures {\r\n    if (this._features === null) {\r\n      this._features = this._loadBrowserFeatures();\r\n    }\r\n    return this._features;\r\n  }\r\n\r\n  /**\r\n   * Report on non-critical browser support for debugging purposes.\r\n   * Use native browser console colors for visibility.\r\n   */\r\n  public logBrowserFeatures(): void {\r\n    let msg = '%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n';\r\n    const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];\r\n\r\n    const supported: any = this.getBrowserFeatures();\r\n    for (const feature of Object.keys(REPORTED_FEATURES)) {\r\n      if (supported[feature]) {\r\n        msg += '(%c\\u2713%c)'; // (✓)\r\n        args.push('font-weight: bold; color: green');\r\n        args.push('font-weight: normal; color: inherit');\r\n      } else {\r\n        msg += '(%c\\u2717%c)'; // (✗)\r\n        args.push('font-weight: bold; color: red');\r\n        args.push('font-weight: normal; color: inherit');\r\n      }\r\n\r\n      msg += ' ' + REPORTED_FEATURES[feature] + '\\n';\r\n    }\r\n\r\n    args.unshift(msg);\r\n    // eslint-disable-next-line no-console\r\n    console.log.apply(console, args);\r\n  }\r\n\r\n  /**\r\n   * Executes several IIFE's to get a constant reference to supported\r\n   * features within the current execution context.\r\n   */\r\n  private _loadBrowserFeatures(): DetectedFeatures {\r\n    return {\r\n      // IIFE to check canvas support\r\n      canvas: (() => {\r\n        return this._criticalTests.canvasSupport();\r\n      })(),\r\n\r\n      // IIFE to check arraybuffer support\r\n      arraybuffer: (() => {\r\n        return this._criticalTests.arrayBufferSupport();\r\n      })(),\r\n\r\n      // IIFE to check dataurl support\r\n      dataurl: (() => {\r\n        return this._criticalTests.dataUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check objecturl support\r\n      objecturl: (() => {\r\n        return this._criticalTests.objectUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check rgba support\r\n      rgba: (() => {\r\n        return this._criticalTests.rgbaSupport();\r\n      })(),\r\n\r\n      // IIFE to check webaudio support\r\n      webaudio: (() => {\r\n        return this._warningTest.webAudioSupport();\r\n      })(),\r\n\r\n      // IIFE to check webgl support\r\n      webgl: (() => {\r\n        return this._warningTest.webglSupport();\r\n      })(),\r\n\r\n      // IIFE to check gamepadapi support\r\n      gamepadapi: (() => {\r\n        return !!(<any>navigator).getGamepads;\r\n      })()\r\n    };\r\n  }\r\n\r\n  // critical browser features required for ex to run\r\n  private _criticalTests: CriticalTests = {\r\n    // Test canvas/2d context support\r\n    canvasSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('2d'));\r\n    },\r\n\r\n    // Test array buffer support ex uses for downloading binary data\r\n    arrayBufferSupport: function() {\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('GET', '/');\r\n      try {\r\n        xhr.responseType = 'arraybuffer';\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n      return xhr.responseType === 'arraybuffer';\r\n    },\r\n\r\n    // Test data urls ex uses for sprites\r\n    dataUrlSupport: function() {\r\n      const canvas = document.createElement('canvas');\r\n      return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;\r\n    },\r\n\r\n    // Test object url support for loading\r\n    objectUrlSupport: function() {\r\n      return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;\r\n    },\r\n\r\n    // RGBA support for colors\r\n    rgbaSupport: function() {\r\n      const style = document.createElement('a').style;\r\n      style.cssText = 'background-color:rgba(150,255,150,.5)';\r\n      return ('' + style.backgroundColor).indexOf('rgba') > -1;\r\n    }\r\n  };\r\n\r\n  // warnings excalibur performance will be degraded\r\n  private _warningTest: WarningTests = {\r\n    webAudioSupport: function() {\r\n      return !!(\r\n        (<any>window).AudioContext ||\r\n        (<any>window).webkitAudioContext ||\r\n        (<any>window).mozAudioContext ||\r\n        (<any>window).msAudioContext ||\r\n        (<any>window).oAudioContext\r\n      );\r\n    },\r\n    webglSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('webgl'));\r\n    }\r\n  };\r\n\r\n  public test(): boolean {\r\n    // Critical test will for ex not to run\r\n    let failedCritical = false;\r\n    for (const test in this._criticalTests) {\r\n      if (!this._criticalTests[<keyof CriticalTests>test].call(this)) {\r\n        this.failedTests.push(test);\r\n        Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);\r\n        failedCritical = true;\r\n      }\r\n    }\r\n    if (failedCritical) {\r\n      return false;\r\n    }\r\n\r\n    // Warning tests do not for ex to return false to compatibility\r\n    for (const warning in this._warningTest) {\r\n      if (!this._warningTest[<keyof WarningTests>warning]()) {\r\n        Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the types of collisions bodies can participate in\r\n */\r\nexport enum CollisionType {\r\n  /**\r\n   * Bodies with the `PreventCollision` setting do not participate in any\r\n   * collisions and do not raise collision events.\r\n   */\r\n  PreventCollision = 'PreventCollision',\r\n  /**\r\n   * Bodies with the `Passive` setting only raise collision events, but are not\r\n   * influenced or moved by other bodies and do not influence or move other bodies.\r\n   * This is useful for use in trigger type behavior.\r\n   */\r\n  Passive = 'Passive',\r\n  /**\r\n   * Bodies with the `Active` setting raise collision events and participate\r\n   * in collisions with other bodies and will be push or moved by bodies sharing\r\n   * the `Active` or `Fixed` setting.\r\n   */\r\n  Active = 'Active',\r\n  /**\r\n   * Bodies with the `Fixed` setting raise collision events and participate in\r\n   * collisions with other bodies. Actors with the `Fixed` setting will not be\r\n   * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed\r\n   * bodies as \"immovable/unstoppable\" objects. If two `Fixed` bodies meet they will\r\n   * not be pushed or moved by each other, they will not interact except to throw\r\n   * collision events.\r\n   */\r\n  Fixed = 'Fixed'\r\n}\r\n","import { Flags } from '../Flags';\r\nimport { Logger } from './Log';\r\n\r\n/**\r\n * Obsolete decorator options\r\n */\r\nexport interface ObsoleteOptions {\r\n  // Optionally specify a custom message\r\n  message?: string;\r\n  // Optionally indicate that an alternate method to the obsolete one exists\r\n  alternateMethod?: string;\r\n  // Optional show stack trace, by default off\r\n  showStackTrace?: boolean;\r\n}\r\n\r\nexport const maxMessages = 5;\r\nconst obsoleteMessage: { [messageCount: string]: number } = {};\r\nexport const resetObsoleteCounter = () => {\r\n  for (const message in obsoleteMessage) {\r\n    obsoleteMessage[message] = 0;\r\n  }\r\n};\r\n\r\nconst logMessage = (message: string, options: ObsoleteOptions) => {\r\n  const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');\r\n  if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {\r\n    Logger.getInstance().warn(message);\r\n\r\n    // tslint:disable-next-line: no-console\r\n    if (console.trace && options.showStackTrace) {\r\n      // tslint:disable-next-line: no-console\r\n      console.trace();\r\n    }\r\n  }\r\n  obsoleteMessage[message]++;\r\n};\r\n\r\n/**\r\n * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n */\r\nexport function obsolete(options?: ObsoleteOptions): any {\r\n  options = {\r\n    message: 'This feature will be removed in future versions of Excalibur.',\r\n    alternateMethod: null,\r\n    showStackTrace: false,\r\n    ...options\r\n  };\r\n\r\n  return function (target: any, property: string, descriptor: PropertyDescriptor): any {\r\n    if (\r\n      descriptor &&\r\n      !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\r\n    ) {\r\n      throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');\r\n    }\r\n    const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;\r\n\r\n    const message =\r\n      `${methodSignature} is marked obsolete: ${options.message}` +\r\n      (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');\r\n\r\n    if (!obsoleteMessage[message]) {\r\n      obsoleteMessage[message] = 0;\r\n    }\r\n\r\n    // If descriptor is null it is a class\r\n    const method = descriptor ? { ...descriptor } : target;\r\n    if (!descriptor) {\r\n      // with es2015 classes we need to change our decoration tactic\r\n      class DecoratedClass extends method {\r\n        constructor(...args: any) {\r\n          logMessage(message, options);\r\n          super(...args);\r\n        }\r\n      }\r\n      return DecoratedClass;\r\n    }\r\n\r\n    if (descriptor && descriptor.value) {\r\n      method.value = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.value.apply(this, arguments);\r\n      };\r\n      return method;\r\n    }\r\n\r\n    if (descriptor && descriptor.get) {\r\n      method.get = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.get.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    if (descriptor && descriptor.set) {\r\n      method.set = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.set.apply(this, arguments);\r\n      };\r\n    }\r\n    return method;\r\n  };\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n\r\n/**\r\n * Possible collision resolution strategies\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things\r\n * like platformers or top down games.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */\r\nexport enum CollisionResolutionStrategy {\r\n  Arcade = 'arcade',\r\n  Realistic = 'realistic'\r\n}\r\n\r\n/**\r\n * Possible broadphase collision pair identification strategies\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */\r\nexport enum BroadphaseStrategy {\r\n  DynamicAABBTree\r\n}\r\n\r\n/**\r\n * Possible numerical integrators for position and velocity\r\n */\r\nexport enum Integrator {\r\n  Euler\r\n}\r\n\r\n/**\r\n * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n */\r\n/* istanbul ignore next */\r\nexport class Physics {\r\n  /**\r\n   * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.\r\n   * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.\r\n   *\r\n   * This is a great way to globally simulate effects like gravity.\r\n   */\r\n  public static acc = new Vector(0, 0);\r\n  public static get gravity() {\r\n    return Physics.acc;\r\n  }\r\n  public static set gravity(v: Vector) {\r\n    Physics.acc = v;\r\n  }\r\n\r\n  /**\r\n   * Globally switches all Excalibur physics behavior on or off.\r\n   */\r\n  public static enabled = true;\r\n\r\n  /**\r\n   * Gets or sets the broadphase pair identification strategy.\r\n   *\r\n   * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n   * potential collision pairs which is O(nlog(n)) faster.\r\n   */\r\n  public static broadphaseStrategy: BroadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\r\n\r\n  /**\r\n   * Gets or sets the global collision resolution strategy (narrowphase).\r\n   *\r\n   * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.\r\n   *\r\n   * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static collisionResolutionStrategy: CollisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  /**\r\n   * The default mass to use if none is specified\r\n   */\r\n  public static defaultMass: number = 10;\r\n  /**\r\n   * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n   */\r\n  public static integrator: Integrator = Integrator.Euler;\r\n\r\n  /**\r\n   * Configures Excalibur to use \"arcade\" physics. Arcade physics which performs simple axis aligned arcade style physics.\r\n   */\r\n  public static useArcadePhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  }\r\n\r\n  /**\r\n   * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static useRealisticPhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;\r\n  }\r\n\r\n  /**\r\n   * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);\r\n   */\r\n  public static dynamicTreeVelocityMultiplier = 2;\r\n\r\n  @obsolete({\r\n    message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',\r\n    alternateMethod: 'dynamicTreeVelocityMultiplier'\r\n  })\r\n  public static get dynamicTreeVelocityMultiplyer() {\r\n    return Physics.dynamicTreeVelocityMultiplier;\r\n  }\r\n\r\n  public static set dynamicTreeVelocityMultiplyer(value: number) {\r\n    Physics.dynamicTreeVelocityMultiplier = value;\r\n  }\r\n\r\n  /**\r\n   * Pad RigidBody BoundingBox by a constant amount\r\n   */\r\n  public static boundsPadding = 5;\r\n\r\n  /**\r\n   * Number of position iterations (overlap) to run in the solver\r\n   */\r\n  public static positionIterations = 3;\r\n\r\n  /**\r\n   * Number of velocity iteration (response) to run in the solver\r\n   */\r\n  public static velocityIterations = 8;\r\n\r\n  /**\r\n   * Amount of overlap to tolerate in pixels\r\n   */\r\n  public static slop = 1;\r\n\r\n  /**\r\n   * Amount of positional overlap correction to apply each position iteration of the solver\r\n   * O - meaning no correction, 1 - meaning correct all overlap\r\n   */\r\n  public static steeringFactor = 0.2;\r\n\r\n  /**\r\n   * Warm start set to true re-uses impulses from previous frames back in the solver\r\n   */\r\n  public static warmStart = true;\r\n\r\n  /**\r\n   * By default bodies do not sleep\r\n   */\r\n  public static bodiesCanSleepByDefault = false;\r\n\r\n  /**\r\n   * Surface epsilon is used to help deal with surface penetration\r\n   */\r\n  public static surfaceEpsilon = 0.1;\r\n\r\n  public static sleepEpsilon = 0.07;\r\n\r\n  public static wakeThreshold = Physics.sleepEpsilon * 3;\r\n\r\n  public static sleepBias = 0.9;\r\n\r\n  /**\r\n   * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n   * bodies from tunneling through one another.\r\n   */\r\n  public static checkForFastBodies = true;\r\n\r\n  /**\r\n   * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n   * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n   * Excalibur will always perform the fast body raycast regardless of speed.\r\n   */\r\n  public static disableMinimumSpeedForFastBody = false;\r\n}\r\n","/**\r\n * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]\r\n */\r\nexport enum CoordPlane {\r\n  /**\r\n   * The world coordinate plane (default) represents world space, any entities drawn with world\r\n   * space move when the camera moves.\r\n   */\r\n  World = 'world',\r\n  /**\r\n   * The screen coordinate plane represents screen space, entities drawn in screen space are pinned\r\n   * to screen coordinates ignoring the camera.\r\n   */\r\n  Screen = 'screen'\r\n}","import { Vector } from './vector';\r\n\r\nexport interface VectorViewOptions {\r\n  getX: () => number;\r\n  getY: () => number;\r\n  setX: (x: number) => void;\r\n  setY: (y: number) => void;\r\n}\r\nexport class VectorView extends Vector {\r\n  private _getX: () => number;\r\n  private _getY: () => number;\r\n  private _setX: (x: number) => void;\r\n  private _setY: (y: number) => void;\r\n  constructor(options: VectorViewOptions) {\r\n    super(0, 0);\r\n    this._getX = options.getX;\r\n    this._getY = options.getY;\r\n    this._setX = options.setX;\r\n    this._setY = options.setY;\r\n  }\r\n  public get x() {\r\n    return (this._x = this._getX());\r\n  }\r\n\r\n  public set x(val) {\r\n    this._setX(val);\r\n    this._x = val;\r\n  }\r\n\r\n  public get y() {\r\n    return (this._y = this._getY());\r\n  }\r\n  public set y(val) {\r\n    this._setY(val);\r\n    this._y = val;\r\n  }\r\n}\r\n","import { Vector } from './vector';\r\n\r\n/**\r\n * Wraps a vector and watches for changes in the x/y, modifies the original vector.\r\n */\r\nexport class WatchVector extends Vector {\r\n  constructor(public original: Vector, public change: (x: number, y: number) => any) {\r\n    super(original.x, original.y);\r\n  }\r\n  public get x() {\r\n    return this._x = this.original.x;\r\n  }\r\n\r\n  public set x(newX: number) {\r\n    this.change(newX, this._y);\r\n    this._x = this.original.x = newX;\r\n  }\r\n\r\n  public get y() {\r\n    return this._y = this.original.y;\r\n  }\r\n\r\n  public set y(newY: number) {\r\n    this.change(this._x, newY);\r\n    this._y = this.original.y = newY;\r\n  }\r\n}","import { AffineMatrix } from './affine-matrix';\r\nimport { canonicalizeAngle } from './util';\r\nimport { vec, Vector } from './vector';\r\nimport { VectorView } from './vector-view';\r\nimport { WatchVector } from './watch-vector';\r\n\r\nexport class Transform {\r\n  private _parent: Transform | null = null;\r\n  get parent() {\r\n    return this._parent;\r\n  }\r\n  set parent(transform: Transform) {\r\n    if (this._parent) {\r\n      const index = this._parent._children.indexOf(this);\r\n      if (index > -1) {\r\n        this._parent._children.splice(index, 1);\r\n      }\r\n    }\r\n    this._parent = transform;\r\n    if (this._parent) {\r\n      this._parent._children.push(this);\r\n    }\r\n    this.flagDirty();\r\n  }\r\n  get children(): readonly Transform[] {\r\n    return this._children;\r\n  }\r\n  private _children: Transform[] = [];\r\n\r\n  private _pos: Vector = vec(0, 0);\r\n  set pos(v: Vector) {\r\n    if (!v.equals(this._pos)) {\r\n      this._pos.x = v.x;\r\n      this._pos.y = v.y;\r\n      this.flagDirty();\r\n    }\r\n  }\r\n  get pos() {\r\n    return new WatchVector(this._pos, (x, y) => {\r\n      if (x !== this._pos.x || y !== this._pos.y) {\r\n        this.flagDirty();\r\n      }\r\n    });\r\n  }\r\n\r\n  set globalPos(v: Vector) {\r\n    let localPos = v.clone();\r\n    if (this.parent) {\r\n      localPos = this.parent.inverse.multiply(v);\r\n    }\r\n    if (!localPos.equals(this._pos)) {\r\n      this._pos = localPos;\r\n      this.flagDirty();\r\n    }\r\n  }\r\n  get globalPos() {\r\n    return new VectorView({\r\n      getX: () => this.matrix.data[4],\r\n      getY: () => this.matrix.data[5],\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const { x: newX } = this.parent.inverse.multiply(vec(x, this.pos.y));\r\n          this.pos.x = newX;\r\n        } else {\r\n          this.pos.x = x;\r\n        }\r\n        if (x !== this.matrix.data[4]) {\r\n          this.flagDirty();\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y));\r\n          this.pos.y = newY;\r\n        } else {\r\n          this.pos.y = y;\r\n        }\r\n        if (y !== this.matrix.data[5]) {\r\n          this.flagDirty();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private _rotation: number = 0;\r\n  set rotation(rotation: number) {\r\n    const canonRotation = canonicalizeAngle(rotation);\r\n    if (canonRotation !== this._rotation) {\r\n      this.flagDirty();\r\n    }\r\n    this._rotation = canonRotation;\r\n  }\r\n  get rotation() {\r\n    return this._rotation;\r\n  }\r\n\r\n  set globalRotation(rotation: number) {\r\n    let inverseRotation = 0;\r\n    if (this.parent) {\r\n      inverseRotation = this.parent.globalRotation;\r\n    }\r\n    const canonRotation = canonicalizeAngle(rotation + inverseRotation);\r\n    if (canonRotation !== this._rotation) {\r\n      this.flagDirty();\r\n    }\r\n    this._rotation = canonRotation;\r\n  }\r\n\r\n  get globalRotation() {\r\n    if (this.parent) {\r\n      return this.matrix.getRotation();\r\n    }\r\n    return this.rotation;\r\n  }\r\n\r\n  private _scale: Vector = vec(1, 1);\r\n  set scale(v: Vector) {\r\n    if (!v.equals(this._scale)) {\r\n      this._scale.x = v.x;\r\n      this._scale.y = v.y;\r\n      this.flagDirty();\r\n    }\r\n  }\r\n  get scale() {\r\n    return new WatchVector(this._scale, (x, y) => {\r\n      if (x !== this._scale.x || y !== this._scale.y) {\r\n        this.flagDirty();\r\n      }\r\n    });\r\n  }\r\n\r\n  set globalScale(v: Vector) {\r\n    let inverseScale = vec(1, 1);\r\n    if (this.parent) {\r\n      inverseScale = this.parent.globalScale;\r\n    }\r\n    this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));\r\n  }\r\n\r\n  get globalScale() {\r\n    return new VectorView({\r\n      getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,\r\n      getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const globalScaleX = this.parent.globalScale.x;\r\n          this.scale.x = x / globalScaleX;\r\n        } else {\r\n          this.scale.x = x;\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const globalScaleY = this.parent.globalScale.y;\r\n          this.scale.y = y / globalScaleY;\r\n        } else {\r\n          this.scale.y = y;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private _isDirty = false;\r\n  private _isInverseDirty = false;\r\n  private _matrix = AffineMatrix.identity();\r\n  private _inverse = AffineMatrix.identity();\r\n\r\n  public get matrix() {\r\n    if (this._isDirty) {\r\n      if (this.parent === null) {\r\n        this._matrix = this._calculateMatrix();\r\n      } else {\r\n        this._matrix = this.parent.matrix.multiply(this._calculateMatrix());\r\n      }\r\n      this._isDirty = false;\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  public get inverse() {\r\n    if (this._isInverseDirty) {\r\n      this._inverse = this.matrix.inverse();\r\n      this._isInverseDirty = false;\r\n    }\r\n    return this._inverse;\r\n  }\r\n\r\n  private _calculateMatrix(): AffineMatrix {\r\n    const matrix = AffineMatrix.identity()\r\n      .translate(this.pos.x, this.pos.y)\r\n      .rotate(this.rotation)\r\n      .scale(this.scale.x, this.scale.y);\r\n    return matrix;\r\n  }\r\n\r\n\r\n  public flagDirty() {\r\n    this._isDirty = true;\r\n    this._isInverseDirty = true;\r\n    for (let i = 0; i < this._children.length; i ++) {\r\n      this._children[i].flagDirty();\r\n    }\r\n  }\r\n\r\n  public apply(point: Vector): Vector {\r\n    return this.matrix.multiply(point);\r\n  }\r\n\r\n  public applyInverse(point: Vector): Vector {\r\n    return this.inverse.multiply(point);\r\n  }\r\n\r\n  public setTransform(pos: Vector, rotation: number, scale: Vector) {\r\n    this._pos.x = pos.x;\r\n    this._pos.y = pos.y;\r\n    this._rotation = canonicalizeAngle(rotation);\r\n    this._scale.x = scale.x;\r\n    this._scale.y = scale.y;\r\n    this.flagDirty();\r\n  }\r\n\r\n  public clone(dest?: Transform) {\r\n    const target = dest ?? new Transform();\r\n    this._pos.clone(target._pos);\r\n    target._rotation = this._rotation;\r\n    this._scale.clone(target._scale);\r\n    target.flagDirty();\r\n  }\r\n}","import { Entity } from './Entity';\r\n\r\n/**\r\n * Component Contructor Types\r\n */\r\nexport declare type ComponentCtor<T extends Component = Component> = new (...args:any[]) => T;\r\n\r\n/**\r\n * Type guard to check if a component implements clone\r\n * @param x\r\n */\r\nfunction hasClone(x: any): x is { clone(): any } {\r\n  return !!x?.clone;\r\n}\r\n\r\nexport type ComponentType<ComponentToParse> = ComponentToParse extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * Plucks the string type out of a component type\r\n */\r\nexport type ComponentStringType<T> = T extends Component<infer R> ? R : string;\r\n\r\n/**\r\n * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses\r\n *\r\n * Implementations of Component must have a zero-arg constructor to support dependencies\r\n *\r\n * ```typescript\r\n * class MyComponent extends ex.Component<'my'> {\r\n *   public readonly type = 'my';\r\n *   // zero arg support required if you want to use component dependencies\r\n *   constructor(public optionalPos?: ex.Vector) {}\r\n * }\r\n * ```\r\n */\r\nexport abstract class Component<TypeName extends string = string> {\r\n  /**\r\n   * Optionally list any component types this component depends on\r\n   * If the owner entity does not have these components, new components will be added to the entity\r\n   *\r\n   * Only components with zero-arg constructors are supported as automatic component dependencies\r\n   */\r\n  readonly dependencies?: ComponentCtor[];\r\n\r\n  // todo implement optional\r\n  readonly optional?: ComponentCtor[];\r\n\r\n  /**\r\n   * Type of this component, must be a unique type among component types in you game.\r\n   */\r\n  abstract readonly type: TypeName;\r\n\r\n  /**\r\n   * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]\r\n   */\r\n  owner?: Entity = null;\r\n\r\n  /**\r\n   * Clones any properties on this component, if that property value has a `clone()` method it will be called\r\n   */\r\n  clone(): this {\r\n    const newComponent = new (this.constructor as any)();\r\n    for (const prop in this) {\r\n      if (this.hasOwnProperty(prop)) {\r\n        const val = this[prop];\r\n        if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {\r\n          newComponent[prop] = val.clone();\r\n        } else {\r\n          newComponent[prop] = val;\r\n        }\r\n      }\r\n    }\r\n    return newComponent;\r\n  }\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onAdd?(owner: Entity): void;\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onRemove?(previousOwner: Entity): void;\r\n}\r\n\r\n/**\r\n * Tag components are a way of tagging a component with label and a simple value\r\n *\r\n * For example:\r\n *\r\n * ```typescript\r\n * const isOffscreen = new TagComponent('offscreen');\r\n * entity.addComponent(isOffscreen);\r\n * entity.tags.includes\r\n * ```\r\n */\r\nexport class TagComponent<TypeName extends string, MaybeValueType extends string | symbol | number | boolean = never> extends Component<\r\nTypeName\r\n> {\r\n  constructor(public readonly type: TypeName, public readonly value?: MaybeValueType) {\r\n    super();\r\n  }\r\n}\r\n","/**\r\n * Defines a generic message that can contain any data\r\n * @template T is the typescript Type of the data\r\n */\r\nexport interface Message<T> {\r\n  type: string;\r\n  data: T;\r\n}\r\n\r\n/**\r\n * Defines an interface for an observer to receive a message via a notify() method\r\n */\r\nexport interface Observer<T> {\r\n  notify(message: T): void;\r\n}\r\n\r\n/**\r\n * Defines an interface for something that might be an observer if a notify() is present\r\n */\r\nexport type MaybeObserver<T> = Partial<Observer<T>>;\r\n\r\n/**\r\n * Simple Observable implementation\r\n * @template T is the typescript Type that defines the data being observed\r\n */\r\nexport class Observable<T> {\r\n  public observers: Observer<T>[] = [];\r\n  public subscriptions: ((val: T) => any)[] = [];\r\n\r\n  /**\r\n   * Register an observer to listen to this observable\r\n   * @param observer\r\n   */\r\n  register(observer: Observer<T>) {\r\n    this.observers.push(observer);\r\n  }\r\n\r\n  /**\r\n   * Register a callback to listen to this observable\r\n   * @param func\r\n   */\r\n  subscribe(func: (val: T) => any) {\r\n    this.subscriptions.push(func);\r\n  }\r\n\r\n  /**\r\n   * Remove an observer from the observable\r\n   * @param observer\r\n   */\r\n  unregister(observer: Observer<T>) {\r\n    const i = this.observers.indexOf(observer);\r\n    if (i !== -1) {\r\n      this.observers.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback that is listening to this observable\r\n   * @param func\r\n   */\r\n  unsubscribe(func: (val: T) => any) {\r\n    const i = this.subscriptions.indexOf(func);\r\n    if (i !== -1) {\r\n      this.subscriptions.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcasts a message to all observers and callbacks\r\n   * @param message\r\n   */\r\n  notifyAll(message: T) {\r\n    const observersLength = this.observers.length;\r\n    for (let i = 0; i < observersLength; i++) {\r\n      this.observers[i].notify(message);\r\n    }\r\n    const subscriptionsLength = this.subscriptions.length;\r\n    for (let i = 0; i < subscriptionsLength; i++) {\r\n      this.subscriptions[i](message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all observers and callbacks\r\n   */\r\n  clear() {\r\n    this.observers.length = 0;\r\n    this.subscriptions.length = 0;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { CoordPlane } from '../../Math/coord-plane';\r\nimport { Transform } from '../../Math/transform';\r\nimport { Component } from '../Component';\r\nimport { Entity } from '../Entity';\r\nimport { Observable } from '../../Util/Observable';\r\n\r\n\r\nexport class TransformComponent extends Component<'ex.transform'> {\r\n  public readonly type = 'ex.transform';\r\n\r\n  private _transform = new Transform();\r\n  public get() {\r\n    return this._transform;\r\n  }\r\n\r\n  private _addChildTransform = (child: Entity) => {\r\n    const childTxComponent = child.get(TransformComponent);\r\n    if (childTxComponent) {\r\n      childTxComponent._transform.parent = this._transform;\r\n    }\r\n  };\r\n  onAdd(owner: Entity): void {\r\n    for (const child of owner.children) {\r\n      this._addChildTransform(child);\r\n    }\r\n    owner.childrenAdded$.subscribe(child => this._addChildTransform(child));\r\n    owner.childrenRemoved$.subscribe(child => {\r\n      const childTxComponent = child.get(TransformComponent);\r\n      if (childTxComponent) {\r\n        childTxComponent._transform.parent = null;\r\n      }\r\n    });\r\n  }\r\n  onRemove(_previousOwner: Entity): void {\r\n    this._transform.parent = null;\r\n  }\r\n\r\n  /**\r\n   * Observable that emits when the z index changes on this component\r\n   */\r\n  public zIndexChanged$ = new Observable<number>();\r\n  private _z = 0;\r\n\r\n  /**\r\n   * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n   * For example z=99 would be drawn on top of z=0.\r\n   */\r\n  public get z(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    const oldz = this._z;\r\n    this._z = val;\r\n    if (oldz !== val) {\r\n      this.zIndexChanged$.notifyAll(val);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The [[CoordPlane|coordinate plane|]] for this transform for the entity.\r\n   */\r\n  public coordPlane = CoordPlane.World;\r\n\r\n  get pos() {\r\n    return this._transform.pos;\r\n  }\r\n  set pos(v: Vector) {\r\n    this._transform.pos = v;\r\n  }\r\n\r\n  get globalPos() {\r\n    return this._transform.globalPos;\r\n  }\r\n  set globalPos(v: Vector) {\r\n    this._transform.globalPos = v;\r\n  }\r\n\r\n  get rotation() {\r\n    return this._transform.rotation;\r\n  }\r\n  set rotation(rotation) {\r\n    this._transform.rotation = rotation;\r\n  }\r\n\r\n  get globalRotation() {\r\n    return this._transform.globalRotation;\r\n  }\r\n  set globalRotation(rotation) {\r\n    this._transform.globalRotation = rotation;\r\n  }\r\n\r\n  get scale() {\r\n    return this._transform.scale;\r\n  }\r\n  set scale(v: Vector) {\r\n    this._transform.scale = v;\r\n  }\r\n\r\n  get globalScale() {\r\n    return this._transform.globalScale;\r\n  }\r\n  set globalScale(v: Vector) {\r\n    this._transform.globalScale = v;\r\n  }\r\n\r\n  applyInverse(v: Vector) {\r\n    return this._transform.applyInverse(v);\r\n  }\r\n\r\n  apply(v: Vector) {\r\n    return this._transform.apply(v);\r\n  }\r\n}","import { Vector } from '../../Math/vector';\r\nimport { Component } from '../Component';\r\n\r\nexport interface Motion {\r\n  /**\r\n   * The velocity of an entity in pixels per second\r\n   */\r\n  vel: Vector;\r\n\r\n  /**\r\n   * The acceleration of entity in pixels per second^2\r\n   */\r\n  acc: Vector;\r\n\r\n  /**\r\n   * The scale rate of change in scale units per second\r\n   */\r\n  scaleFactor: Vector;\r\n\r\n  /**\r\n   * The angular velocity which is how quickly the entity is rotating in radians per second\r\n   */\r\n  angularVelocity: number;\r\n\r\n  /**\r\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n   */\r\n  torque: number;\r\n\r\n  /**\r\n   * Inertia can be thought of as the resistance to motion\r\n   */\r\n  inertia: number;\r\n}\r\n\r\nexport class MotionComponent extends Component<'ex.motion'> {\r\n  public readonly type = 'ex.motion';\r\n\r\n  /**\r\n   * The velocity of an entity in pixels per second\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The acceleration of entity in pixels per second^2\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The scale rate of change in scale units per second\r\n   */\r\n  public scaleFactor: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The angular velocity which is how quickly the entity is rotating in radians per second\r\n   */\r\n  public angularVelocity = 0;\r\n\r\n  /**\r\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n   */\r\n  public torque: number = 0;\r\n\r\n  /**\r\n   * Inertia can be thought of as the resistance to motion\r\n   */\r\n  public inertia: number = 1;\r\n}\r\n","/**\r\n * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s\r\n *\r\n * For example:\r\n *\r\n * Players have collision group \"player\"\r\n *\r\n * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)\r\n *\r\n * Enemies have collision group \"enemy\"\r\n *\r\n * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)\r\n *\r\n * Blocks have collision group \"ground\"\r\n *\r\n * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)\r\n *\r\n * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide\r\n * with players and blocks.\r\n *\r\n * This is done with bitmasking, see the following pseudo-code\r\n *\r\n * PlayerGroup = `0b001`\r\n * PlayerGroupMask = `0b110`\r\n *\r\n * EnemyGroup = `0b010`\r\n * EnemyGroupMask = `0b101`\r\n *\r\n * BlockGroup = `0b100`\r\n * BlockGroupMask = `0b011`\r\n *\r\n * Should Players collide? No because the bitwise mask evaluates to 0\r\n * `(player1.group & player2.mask) === 0`\r\n * `(0b001 & 0b110) === 0`\r\n *\r\n * Should Players and Enemies collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & enemy1.mask) === 1`\r\n * `(0b001 & 0b101) === 1`\r\n *\r\n * Should Players and Blocks collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & blocks1.mask) === 1`\r\n * `(0b001 & 0b011) === 1`\r\n */\r\nexport class CollisionGroup {\r\n  /**\r\n   * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,\r\n   * it is the default collision group on colliders.\r\n   */\r\n  public static All = new CollisionGroup('Collide with all groups', -1, -1);\r\n\r\n  private _name: string;\r\n  private _category: number;\r\n  private _mask: number;\r\n\r\n  /**\r\n   * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups\r\n   *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.\r\n   * @param name Name of the collision group\r\n   * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`\r\n   * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`\r\n   */\r\n  constructor(name: string, category: number, mask: number) {\r\n    this._name = name;\r\n    this._category = category;\r\n    this._mask = mask;\r\n  }\r\n\r\n  /**\r\n   * Get the name of the collision group\r\n   */\r\n  public get name() {\r\n    return this._name;\r\n  }\r\n\r\n  /**\r\n   * Get the category of the collision group, a 32 bit number which should be a unique power of 2\r\n   */\r\n  public get category() {\r\n    return this._category;\r\n  }\r\n\r\n  /**\r\n   * Get the mask for this collision group\r\n   */\r\n  public get mask() {\r\n    return this._mask;\r\n  }\r\n\r\n  /**\r\n   * Evaluates whether 2 collision groups can collide\r\n   * @param other  CollisionGroup\r\n   */\r\n  public canCollide(other: CollisionGroup): boolean {\r\n    return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Inverts the collision group. For example, if before the group specified \"players\",\r\n   * inverting would specify all groups except players\r\n   * @returns CollisionGroup\r\n   */\r\n  public invert(): CollisionGroup {\r\n    return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);\r\n  }\r\n\r\n  /**\r\n   * Combine collision groups with each other. The new group includes all of the previous groups.\r\n   *\r\n   * @param collisionGroups\r\n   */\r\n  public static combine(collisionGroups: CollisionGroup[]) {\r\n    const combinedName = collisionGroups.map((c) => c.name).join('+');\r\n    const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);\r\n    const combinedMask = ~combinedCategory;\r\n\r\n    return new CollisionGroup(combinedName, combinedCategory, combinedMask);\r\n  }\r\n\r\n  /**\r\n   * Creates a collision group that collides with the listed groups\r\n   * @param collisionGroups\r\n   */\r\n  public static collidesWith(collisionGroups: CollisionGroup[]) {\r\n    return CollisionGroup.combine(collisionGroups).invert();\r\n  }\r\n}\r\n","import { CollisionContact } from './CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Id } from '../../Id';\r\nimport { Collider } from '../Colliders/Collider';\r\n\r\n/**\r\n * Models a potential collision between 2 colliders\r\n */\r\nexport class Pair {\r\n  public id: string = null;\r\n  constructor(public colliderA: Collider, public colliderB: Collider) {\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a it is allowed for 2 colliders in a Pair to collide\r\n   * @param colliderA\r\n   * @param colliderB\r\n   */\r\n  public static canCollide(colliderA: Collider, colliderB: Collider) {\r\n    const bodyA = colliderA?.owner?.get(BodyComponent);\r\n    const bodyB = colliderB?.owner?.get(BodyComponent);\r\n\r\n    // Prevent self collision\r\n    if (colliderA.id === colliderB.id) {\r\n      return false;\r\n    }\r\n\r\n    // Colliders with the same owner do not collide (composite colliders)\r\n    if (colliderA.owner &&\r\n        colliderB.owner &&\r\n        colliderA.owner.id === colliderB.owner.id) {\r\n      return false;\r\n    }\r\n\r\n    // if the pair has a member with zero dimension don't collide\r\n    if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {\r\n      return false;\r\n    }\r\n\r\n    // Body's needed for collision in the current state\r\n    // TODO can we collide without a body?\r\n    if (!bodyA || !bodyB) {\r\n      return false;\r\n    }\r\n\r\n    // If both are in the same collision group short circuit\r\n    if (!bodyA.group.canCollide(bodyB.group)) {\r\n      return false;\r\n    }\r\n\r\n    // if both are fixed short circuit\r\n    if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {\r\n      return false;\r\n    }\r\n\r\n    // if the either is prevent collision short circuit\r\n    if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {\r\n      return false;\r\n    }\r\n\r\n    // if either is dead short circuit\r\n    if (!bodyA.active || !bodyB.active) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not it is possible for the pairs to collide\r\n   */\r\n  public get canCollide(): boolean {\r\n    const colliderA = this.colliderA;\r\n    const colliderB = this.colliderB;\r\n    return Pair.canCollide(colliderA, colliderB);\r\n  }\r\n\r\n  /**\r\n   * Runs the collision intersection logic on the members of this pair\r\n   */\r\n  public collide(): CollisionContact[] {\r\n    return this.colliderA.collide(this.colliderB);\r\n  }\r\n\r\n  /**\r\n   * Check if the collider is part of the pair\r\n   * @param collider\r\n   */\r\n  public hasCollider(collider: Collider) {\r\n    return collider === this.colliderA || collider === this.colliderB;\r\n  }\r\n\r\n  /**\r\n   * Calculates the unique pair hash id for this collision pair (owning id)\r\n   */\r\n  public static calculatePairHash(idA: Id<'collider'>, idB: Id<'collider'>): string {\r\n    if (idA.value < idB.value) {\r\n      return `#${idA.value}+${idB.value}`;\r\n    } else {\r\n      return `#${idB.value}+${idA.value}`;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * A 1 dimensional projection on an axis, used to test overlaps\r\n */\r\n\r\nexport class Projection {\r\n  constructor(public min: number, public max: number) {}\r\n  public overlaps(projection: Projection): boolean {\r\n    return this.max > projection.min && projection.max > this.min;\r\n  }\r\n\r\n  public getOverlap(projection: Projection): number {\r\n    if (this.overlaps(projection)) {\r\n      if (this.max > projection.max) {\r\n        return projection.max - this.min;\r\n      } else {\r\n        return this.max - projection.min;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n","import { Physics } from '../Physics';\r\nimport { BoundingBox } from '../BoundingBox';\r\n\r\nimport { Ray } from '../../Math/ray';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Id } from '../../Id';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Color, ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Dynamic Tree Node used for tracking bounds within the tree\r\n */\r\nexport class TreeNode<T> {\r\n  public left: TreeNode<T>;\r\n  public right: TreeNode<T>;\r\n  public bounds: BoundingBox;\r\n  public height: number;\r\n  public data: T;\r\n  constructor(public parent?: TreeNode<T>) {\r\n    this.parent = parent || null;\r\n    this.data = null;\r\n    this.bounds = new BoundingBox();\r\n    this.left = null;\r\n    this.right = null;\r\n    this.height = 0;\r\n  }\r\n\r\n  public isLeaf(): boolean {\r\n    return !this.left && !this.right;\r\n  }\r\n}\r\n\r\nexport interface ColliderProxy<T> {\r\n  id: Id<'collider'>;\r\n  owner: T;\r\n  bounds: BoundingBox;\r\n}\r\n\r\n/**\r\n * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for\r\n * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n *\r\n * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n */\r\nexport class DynamicTree<T extends ColliderProxy<Entity>> {\r\n  public root: TreeNode<T>;\r\n  public nodes: { [key: number]: TreeNode<T> };\r\n  constructor(public worldBounds: BoundingBox = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {\r\n    this.root = null;\r\n    this.nodes = {};\r\n  }\r\n\r\n  /**\r\n   * Inserts a node into the dynamic tree\r\n   */\r\n  private _insert(leaf: TreeNode<T>): void {\r\n    // If there are no nodes in the tree, make this the root leaf\r\n    if (this.root === null) {\r\n      this.root = leaf;\r\n      this.root.parent = null;\r\n      return;\r\n    }\r\n\r\n    // Search the tree for a node that is not a leaf and find the best place to insert\r\n    const leafAABB = leaf.bounds;\r\n    let currentRoot = this.root;\r\n    while (!currentRoot.isLeaf()) {\r\n      const left = currentRoot.left;\r\n      const right = currentRoot.right;\r\n\r\n      const area = currentRoot.bounds.getPerimeter();\r\n      const combinedAABB = currentRoot.bounds.combine(leafAABB);\r\n      const combinedArea = combinedAABB.getPerimeter();\r\n\r\n      // Calculate cost heuristic for creating a new parent and leaf\r\n      const cost = 2 * combinedArea;\r\n\r\n      // Minimum cost of pushing the leaf down the tree\r\n      const inheritanceCost = 2 * (combinedArea - area);\r\n\r\n      // Cost of descending\r\n      let leftCost = 0;\r\n      const leftCombined = leafAABB.combine(left.bounds);\r\n      let newArea;\r\n      let oldArea;\r\n      if (left.isLeaf()) {\r\n        leftCost = leftCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = left.bounds.getPerimeter();\r\n        newArea = leftCombined.getPerimeter();\r\n        leftCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      let rightCost = 0;\r\n      const rightCombined = leafAABB.combine(right.bounds);\r\n      if (right.isLeaf()) {\r\n        rightCost = rightCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = right.bounds.getPerimeter();\r\n        newArea = rightCombined.getPerimeter();\r\n        rightCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      // cost is acceptable\r\n      if (cost < leftCost && cost < rightCost) {\r\n        break;\r\n      }\r\n\r\n      // Descend to the depths\r\n      if (leftCost < rightCost) {\r\n        currentRoot = left;\r\n      } else {\r\n        currentRoot = right;\r\n      }\r\n    }\r\n\r\n    // Create the new parent node and insert into the tree\r\n    const oldParent = currentRoot.parent;\r\n    const newParent = new TreeNode(oldParent);\r\n    newParent.bounds = leafAABB.combine(currentRoot.bounds);\r\n    newParent.height = currentRoot.height + 1;\r\n\r\n    if (oldParent !== null) {\r\n      // The sibling node was not the root\r\n      if (oldParent.left === currentRoot) {\r\n        oldParent.left = newParent;\r\n      } else {\r\n        oldParent.right = newParent;\r\n      }\r\n\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n    } else {\r\n      // The sibling node was the root\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n      this.root = newParent;\r\n    }\r\n\r\n    // Walk up the tree fixing heights and AABBs\r\n    let currentNode = leaf.parent;\r\n    while (currentNode) {\r\n      currentNode = this._balance(currentNode);\r\n\r\n      if (!currentNode.left) {\r\n        throw new Error('Parent of current leaf cannot have a null left child' + currentNode);\r\n      }\r\n      if (!currentNode.right) {\r\n        throw new Error('Parent of current leaf cannot have a null right child' + currentNode);\r\n      }\r\n\r\n      currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n      currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n\r\n      currentNode = currentNode.parent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a node from the dynamic tree\r\n   */\r\n  private _remove(leaf: TreeNode<T>) {\r\n    if (leaf === this.root) {\r\n      this.root = null;\r\n      return;\r\n    }\r\n\r\n    const parent = leaf.parent;\r\n    const grandParent = parent.parent;\r\n    let sibling: TreeNode<T>;\r\n    if (parent.left === leaf) {\r\n      sibling = parent.right;\r\n    } else {\r\n      sibling = parent.left;\r\n    }\r\n\r\n    if (grandParent) {\r\n      if (grandParent.left === parent) {\r\n        grandParent.left = sibling;\r\n      } else {\r\n        grandParent.right = sibling;\r\n      }\r\n      sibling.parent = grandParent;\r\n\r\n      let currentNode = grandParent;\r\n      while (currentNode) {\r\n        currentNode = this._balance(currentNode);\r\n        currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n        currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n\r\n        currentNode = currentNode.parent;\r\n      }\r\n    } else {\r\n      this.root = sibling;\r\n      sibling.parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tracks a body in the dynamic tree\r\n   */\r\n  public trackCollider(collider: T) {\r\n    const node = new TreeNode<T>();\r\n    node.data = collider;\r\n    node.bounds = collider.bounds;\r\n    node.bounds.left -= 2;\r\n    node.bounds.top -= 2;\r\n    node.bounds.right += 2;\r\n    node.bounds.bottom += 2;\r\n    this.nodes[collider.id.value] = node;\r\n    this._insert(node);\r\n  }\r\n\r\n  /**\r\n   * Updates the dynamic tree given the current bounds of each body being tracked\r\n   */\r\n  public updateCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return false;\r\n    }\r\n    const b = collider.bounds;\r\n\r\n    // if the body is outside the world no longer update it\r\n    if (!this.worldBounds.contains(b)) {\r\n      Logger.getInstance().warn(\r\n        'Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics'\r\n      );\r\n      this.untrackCollider(collider);\r\n      return false;\r\n    }\r\n\r\n    if (node.bounds.contains(b)) {\r\n      return false;\r\n    }\r\n\r\n    this._remove(node);\r\n    b.left -= Physics.boundsPadding;\r\n    b.top -= Physics.boundsPadding;\r\n    b.right += Physics.boundsPadding;\r\n    b.bottom += Physics.boundsPadding;\r\n\r\n    // THIS IS CAUSING UNECESSARY CHECKS\r\n    if (collider.owner) {\r\n      const body = collider.owner?.get(BodyComponent);\r\n      if (body) {\r\n        const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n        const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n\r\n        if (multdx < 0) {\r\n          b.left += multdx;\r\n        } else {\r\n          b.right += multdx;\r\n        }\r\n\r\n        if (multdy < 0) {\r\n          b.top += multdy;\r\n        } else {\r\n          b.bottom += multdy;\r\n        }\r\n      }\r\n    }\r\n\r\n    node.bounds = b;\r\n    this._insert(node);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Untracks a body from the dynamic tree\r\n   */\r\n  public untrackCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return;\r\n    }\r\n    this._remove(node);\r\n    this.nodes[collider.id.value] = null;\r\n    delete this.nodes[collider.id.value];\r\n  }\r\n\r\n  /**\r\n   * Balances the tree about a node\r\n   */\r\n  private _balance(node: TreeNode<T>) {\r\n    if (node === null) {\r\n      throw new Error('Cannot balance at null node');\r\n    }\r\n\r\n    if (node.isLeaf() || node.height < 2) {\r\n      return node;\r\n    }\r\n\r\n    const left = node.left;\r\n    const right = node.right;\r\n\r\n    const a = node;\r\n    const b = left;\r\n    const c = right;\r\n    const d = left.left;\r\n    const e = left.right;\r\n    const f = right.left;\r\n    const g = right.right;\r\n\r\n    const balance = c.height - b.height;\r\n    // Rotate c node up\r\n    if (balance > 1) {\r\n      // Swap the right node with it's parent\r\n      c.left = a;\r\n      c.parent = a.parent;\r\n      a.parent = c;\r\n\r\n      // The original node's old parent should point to the right node\r\n      // this is mega confusing\r\n      if (c.parent) {\r\n        if (c.parent.left === a) {\r\n          c.parent.left = c;\r\n        } else {\r\n          c.parent.right = c;\r\n        }\r\n      } else {\r\n        this.root = c;\r\n      }\r\n\r\n      // Rotate\r\n      if (f.height > g.height) {\r\n        c.right = f;\r\n        a.right = g;\r\n        g.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(g.bounds);\r\n        c.bounds = a.bounds.combine(f.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, g.height);\r\n        c.height = 1 + Math.max(a.height, f.height);\r\n      } else {\r\n        c.right = g;\r\n        a.right = f;\r\n        f.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(f.bounds);\r\n        c.bounds = a.bounds.combine(g.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, f.height);\r\n        c.height = 1 + Math.max(a.height, g.height);\r\n      }\r\n\r\n      return c;\r\n    }\r\n    // Rotate left node up\r\n    if (balance < -1) {\r\n      // swap\r\n      b.left = a;\r\n      b.parent = a.parent;\r\n      a.parent = b;\r\n\r\n      // node's old parent should point to b\r\n      if (b.parent) {\r\n        if (b.parent.left === a) {\r\n          b.parent.left = b;\r\n        } else {\r\n          if (b.parent.right !== a) {\r\n            throw 'Error rotating Dynamic Tree';\r\n          }\r\n          b.parent.right = b;\r\n        }\r\n      } else {\r\n        this.root = b;\r\n      }\r\n\r\n      // rotate\r\n      if (d.height > e.height) {\r\n        b.right = d;\r\n        a.left = e;\r\n        e.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(e.bounds);\r\n        b.bounds = a.bounds.combine(d.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, e.height);\r\n        b.height = 1 + Math.max(a.height, d.height);\r\n      } else {\r\n        b.right = e;\r\n        a.left = d;\r\n        d.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(d.bounds);\r\n        b.bounds = a.bounds.combine(e.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, d.height);\r\n        b.height = 1 + Math.max(a.height, e.height);\r\n      }\r\n      return b;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n   */\r\n  public getHeight(): number {\r\n    if (this.root === null) {\r\n      return 0;\r\n    }\r\n    return this.root.height;\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n   *\r\n   * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n   * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n   * the tree until all possible colliders have been returned.\r\n   */\r\n  public query(collider: T, callback: (other: T) => boolean): void {\r\n    const bounds = collider.bounds;\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.overlaps(bounds)) {\r\n        if (currentNode.isLeaf() && currentNode.data !== collider) {\r\n          if (callback.call(collider, currentNode.data)) {\r\n            return true;\r\n          }\r\n        } else {\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n   * long ray to test the tree specified by `max`.\r\n   *\r\n   * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this\r\n   * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n   * the tree until all possible bodies that would intersect with the ray have been returned.\r\n   */\r\n  public rayCastQuery(ray: Ray, max: number = Infinity, callback: (other: T) => boolean): void {\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.rayCast(ray, max)) {\r\n        if (currentNode.isLeaf()) {\r\n          if (callback.call(ray, currentNode.data)) {\r\n            // ray hit a leaf! return the body\r\n            return true;\r\n          }\r\n        } else {\r\n          // ray hit but not at a leaf, recurse deeper\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false; // ray missed\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  public getNodes(): TreeNode<T>[] {\r\n    const helper = (currentNode: TreeNode<T>): TreeNode<T>[] => {\r\n      if (currentNode) {\r\n        return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    return helper(this.root);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    // draw all the nodes in the Dynamic Tree\r\n    const helper = (currentNode: TreeNode<T>) => {\r\n      if (currentNode) {\r\n        if (currentNode.isLeaf()) {\r\n          currentNode.bounds.draw(ex, Color.Green);\r\n        } else {\r\n          currentNode.bounds.draw(ex, Color.White);\r\n        }\r\n\r\n        if (currentNode.left) {\r\n          helper(currentNode.left);\r\n        }\r\n        if (currentNode.right) {\r\n          helper(currentNode.right);\r\n        }\r\n      }\r\n    };\r\n\r\n    helper(this.root);\r\n  }\r\n}\r\n","import { LineSegment } from './line-segment';\r\nimport { Vector } from './vector';\r\n\r\n/**\r\n * A 2D ray that can be cast into the scene to do collision detection\r\n */\r\n\r\nexport class Ray {\r\n  public pos: Vector;\r\n  public dir: Vector;\r\n\r\n  /**\r\n   * @param pos The starting position for the ray\r\n   * @param dir The vector indicating the direction of the ray\r\n   */\r\n  constructor(pos: Vector, dir: Vector) {\r\n    this.pos = pos;\r\n    this.dir = dir.normalize();\r\n  }\r\n\r\n  /**\r\n   * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\r\n   * This number indicates the mathematical intersection time.\r\n   * @param line  The line to test\r\n   */\r\n  public intersect(line: LineSegment): number {\r\n    const numerator = line.begin.sub(this.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {\r\n      return -1;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = this.dir.cross(line.getSlope());\r\n    if (divisor === 0) {\r\n      return -1;\r\n    }\r\n\r\n    const t = numerator.cross(line.getSlope()) / divisor;\r\n\r\n    if (t >= 0) {\r\n      const u = numerator.cross(this.dir) / divisor / line.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return t;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  public intersectPoint(line: LineSegment): Vector {\r\n    const time = this.intersect(line);\r\n    if (time < 0) {\r\n      return null;\r\n    }\r\n    return this.getPoint(time);\r\n  }\r\n\r\n  /**\r\n   * Returns the point of intersection given the intersection time\r\n   */\r\n  public getPoint(time: number): Vector {\r\n    return this.pos.add(this.dir.scale(time));\r\n  }\r\n}\r\n","import { Physics } from '../Physics';\r\nimport { CollisionProcessor } from './CollisionProcessor';\r\nimport { DynamicTree } from './DynamicTree';\r\nimport { Pair } from './Pair';\r\n\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { FrameStats } from '../../Debug';\r\nimport { Logger } from '../../Util/Log';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CompositeCollider } from '../Colliders/CompositeCollider';\r\nimport { ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Responsible for performing the collision broadphase (locating potential collisions) and\r\n * the narrowphase (actual collision contacts)\r\n */\r\nexport class DynamicTreeCollisionProcessor implements CollisionProcessor {\r\n  private _dynamicCollisionTree = new DynamicTree<Collider>();\r\n  private _pairs = new Set<string>();\r\n\r\n  private _collisionPairCache: Pair[] = [];\r\n  private _colliders: Collider[] = [];\r\n\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Tracks a physics body for collisions\r\n   */\r\n  public track(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot track null collider');\r\n      return;\r\n    }\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        c.owner = target.owner;\r\n        this._colliders.push(c);\r\n        this._dynamicCollisionTree.trackCollider(c);\r\n      }\r\n    } else {\r\n      this._colliders.push(target);\r\n      this._dynamicCollisionTree.trackCollider(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Untracks a physics body\r\n   */\r\n  public untrack(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot untrack a null collider');\r\n      return;\r\n    }\r\n\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        const index = this._colliders.indexOf(c);\r\n        if (index !== -1) {\r\n          this._colliders.splice(index, 1);\r\n        }\r\n        this._dynamicCollisionTree.untrackCollider(c);\r\n      }\r\n    } else {\r\n      const index = this._colliders.indexOf(target);\r\n      if (index !== -1) {\r\n        this._colliders.splice(index, 1);\r\n      }\r\n      this._dynamicCollisionTree.untrackCollider(target);\r\n    }\r\n  }\r\n\r\n  private _pairExists(colliderA: Collider, colliderB: Collider) {\r\n    // if the collision pair has been calculated already short circuit\r\n    const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    return this._pairs.has(hash);\r\n  }\r\n\r\n  /**\r\n   * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy\r\n   */\r\n  public broadphase(targets: Collider[], delta: number, stats?: FrameStats): Pair[] {\r\n    const seconds = delta / 1000;\r\n\r\n    // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n    const potentialColliders = targets.filter((other) => {\r\n      const body = other.owner?.get(BodyComponent);\r\n      return other.owner?.active && body.collisionType !== CollisionType.PreventCollision;\r\n    });\r\n\r\n    // clear old list of collision pairs\r\n    this._collisionPairCache = [];\r\n    this._pairs.clear();\r\n\r\n    // check for normal collision pairs\r\n    let collider: Collider;\r\n    for (let j = 0, l = potentialColliders.length; j < l; j++) {\r\n      collider = potentialColliders[j];\r\n      // Query the collision tree for potential colliders\r\n      this._dynamicCollisionTree.query(collider, (other: Collider) => {\r\n        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n          const pair = new Pair(collider, other);\r\n          this._pairs.add(pair.id);\r\n          this._collisionPairCache.push(pair);\r\n        }\r\n        // Always return false, to query whole tree. Returning true in the query method stops searching\r\n        return false;\r\n      });\r\n    }\r\n    if (stats) {\r\n      stats.physics.pairs = this._collisionPairCache.length;\r\n    }\r\n\r\n    // Check dynamic tree for fast moving objects\r\n    // Fast moving objects are those moving at least there smallest bound per frame\r\n    if (Physics.checkForFastBodies) {\r\n      for (const collider of potentialColliders) {\r\n        const body = collider.owner.get(BodyComponent);\r\n        // Skip non-active objects. Does not make sense on other collision types\r\n        if (body.collisionType !== CollisionType.Active) {\r\n          continue;\r\n        }\r\n\r\n        // Maximum travel distance next frame\r\n        const updateDistance =\r\n          body.vel.size * seconds + // velocity term\r\n          body.acc.size * 0.5 * seconds * seconds; // acc term\r\n\r\n        // Find the minimum dimension\r\n        const minDimension = Math.min(collider.bounds.height, collider.bounds.width);\r\n        if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {\r\n          if (stats) {\r\n            stats.physics.fastBodies++;\r\n          }\r\n\r\n          // start with the oldPos because the integration for actors has already happened\r\n          // objects resting on a surface may be slightly penetrating in the current position\r\n          const updateVec = body.globalPos.sub(body.oldPos);\r\n          const centerPoint = collider.center;\r\n          const furthestPoint = collider.getFurthestPoint(body.vel);\r\n          const origin: Vector = furthestPoint.sub(updateVec);\r\n\r\n          const ray: Ray = new Ray(origin, body.vel);\r\n\r\n          // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface\r\n          ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));\r\n          let minCollider: Collider;\r\n          let minTranslate: Vector = new Vector(Infinity, Infinity);\r\n          this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other: Collider) => {\r\n            if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n              const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);\r\n              if (hitPoint) {\r\n                const translate = hitPoint.sub(origin);\r\n                if (translate.size < minTranslate.size) {\r\n                  minTranslate = translate;\r\n                  minCollider = other;\r\n                }\r\n              }\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (minCollider && Vector.isValid(minTranslate)) {\r\n            const pair = new Pair(collider, minCollider);\r\n            if (!this._pairs.has(pair.id)) {\r\n              this._pairs.add(pair.id);\r\n              this._collisionPairCache.push(pair);\r\n            }\r\n            // move the fast moving object to the other body\r\n            // need to push into the surface by ex.Physics.surfaceEpsilon\r\n            const shift = centerPoint.sub(furthestPoint);\r\n            body.globalPos = origin\r\n              .add(shift)\r\n              .add(minTranslate)\r\n              .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact\r\n            collider.update(body.transform.get());\r\n\r\n            if (stats) {\r\n              stats.physics.fastBodyCollisions++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // return cache\r\n    return this._collisionPairCache;\r\n  }\r\n\r\n  /**\r\n   * Applies narrow phase on collision pairs to find actual area intersections\r\n   * Adds actual colliding pairs to stats' Frame data\r\n   */\r\n  public narrowphase(pairs: Pair[], stats?: FrameStats): CollisionContact[] {\r\n    let contacts: CollisionContact[] = [];\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const newContacts = pairs[i].collide();\r\n      contacts = contacts.concat(newContacts);\r\n      if (stats && newContacts.length > 0) {\r\n        for (const c of newContacts) {\r\n          stats.physics.contacts.set(c.id, c);\r\n        }\r\n      }\r\n    }\r\n    if (stats) {\r\n      stats.physics.collisions += contacts.length;\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  /**\r\n   * Update the dynamic tree positions\r\n   */\r\n  public update(targets: Collider[]): number {\r\n    let updated = 0;\r\n    const len = targets.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (this._dynamicCollisionTree.updateCollider(targets[i])) {\r\n        updated++;\r\n      }\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    this._dynamicCollisionTree.debug(ex);\r\n  }\r\n}\r\n","import { Color } from '../../Color';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Clonable } from '../../Interfaces/Clonable';\r\nimport { Entity } from '../../EntityComponentSystem';\r\nimport { createId, Id } from '../../Id';\r\nimport { EventDispatcher } from '../../EventDispatcher';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Transform } from '../../Math/transform';\r\n\r\n/**\r\n * A collision collider specifies the geometry that can detect when other collision colliders intersect\r\n * for the purposes of colliding 2 objects in excalibur.\r\n */\r\nexport abstract class Collider implements Clonable<Collider> {\r\n  private static _ID = 0;\r\n  public readonly id: Id<'collider'> = createId('collider', Collider._ID++);\r\n  /**\r\n   * Excalibur uses this to signal to the [[CollisionSystem]] this is part of a composite collider\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  public __compositeColliderId: Id<'collider'> | null = null;\r\n  public events: EventDispatcher<Collider> = new EventDispatcher<Collider>();\r\n\r\n  /**\r\n   * Returns a boolean indicating whether this body collided with\r\n   * or was in stationary contact with\r\n   * the body of the other [[Collider]]\r\n   */\r\n  public touching(other: Collider): boolean {\r\n    const contact = this.collide(other);\r\n\r\n    if (contact) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public owner: Entity;\r\n\r\n  /**\r\n   * Pixel offset of the collision collider relative to the collider, by default (0, 0) meaning the collider is positioned\r\n   * on top of the collider.\r\n   */\r\n  offset: Vector;\r\n\r\n  /**\r\n   * Position of the collision collider in world coordinates\r\n   */\r\n  abstract get worldPos(): Vector;\r\n\r\n  /**\r\n   * The center point of the collision collider, for example if the collider is a circle it would be the center.\r\n   */\r\n  abstract get center(): Vector;\r\n\r\n  /**\r\n   * Return the axis-aligned bounding box of the collision collider in world coordinates\r\n   */\r\n  abstract get bounds(): BoundingBox;\r\n\r\n  /**\r\n   * Return the axis-aligned bounding box of the collision collider in local coordinates\r\n   */\r\n  abstract get localBounds(): BoundingBox;\r\n\r\n  /**\r\n   * Return the axes of this particular collider\r\n   */\r\n  abstract get axes(): Vector[];\r\n  /**\r\n   * Find the furthest point on the convex hull of this particular collider in a certain direction.\r\n   */\r\n  abstract getFurthestPoint(direction: Vector): Vector;\r\n\r\n  abstract getInertia(mass: number): number;\r\n\r\n  // All new CollisionShape need to do the following\r\n  // Create a new collision function in the CollisionJumpTable against all the primitives\r\n  // Currently there are 3 primitive collision collider 3! = 6 jump functions\r\n  abstract collide(collider: Collider): CollisionContact[];\r\n\r\n  /**\r\n   * Returns the closest line between the surfaces this collider and another\r\n   * @param collider\r\n   */\r\n  abstract getClosestLineBetween(collider: Collider): LineSegment;\r\n\r\n  /**\r\n   * Return wether the collider contains a point inclusive to it's border\r\n   */\r\n  abstract contains(point: Vector): boolean;\r\n\r\n  /**\r\n   * Return the point on the border of the collision collider that intersects with a ray (if any).\r\n   */\r\n  abstract rayCast(ray: Ray, max?: number): Vector;\r\n\r\n  /**\r\n   * Create a projection of this collider along an axis. Think of this as casting a \"shadow\" along an axis\r\n   */\r\n  abstract project(axis: Vector): Projection;\r\n\r\n  /**\r\n   * Updates collider world space geometry\r\n   */\r\n  abstract update(transform: Transform): void;\r\n\r\n\r\n  abstract debug(ex: ExcaliburGraphicsContext, color: Color): void;\r\n\r\n  abstract clone(): Collider;\r\n}\r\n","import { Util } from '../..';\r\nimport { Pair } from '../Detection/Pair';\r\nimport { Color } from '../../Color';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Projection } from '../../Math/projection';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Vector } from '../../Math/vector';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { DynamicTree } from '../Detection/DynamicTree';\r\nimport { DynamicTreeCollisionProcessor } from '../Detection/DynamicTreeCollisionProcessor';\r\nimport { Collider } from './Collider';\r\nimport { Transform } from '../../Math/transform';\r\n\r\nexport class CompositeCollider extends Collider {\r\n  private _transform: Transform;\r\n  private _collisionProcessor = new DynamicTreeCollisionProcessor();\r\n  private _dynamicAABBTree = new DynamicTree();\r\n  private _colliders: Collider[] = [];\r\n\r\n  constructor(colliders: Collider[]) {\r\n    super();\r\n    for (const c of colliders) {\r\n      this.addCollider(c);\r\n    }\r\n  }\r\n\r\n  clearColliders() {\r\n    this._colliders = [];\r\n  }\r\n\r\n  addCollider(collider: Collider) {\r\n    this.events.wire(collider.events);\r\n    collider.__compositeColliderId = this.id;\r\n    this._colliders.push(collider);\r\n    this._collisionProcessor.track(collider);\r\n    this._dynamicAABBTree.trackCollider(collider);\r\n  }\r\n\r\n  removeCollider(collider: Collider) {\r\n    this.events.unwire(collider.events);\r\n    collider.__compositeColliderId = null;\r\n    Util.removeItemFromArray(collider, this._colliders);\r\n    this._collisionProcessor.untrack(collider);\r\n    this._dynamicAABBTree.untrackCollider(collider);\r\n  }\r\n\r\n  getColliders(): Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    // TODO transform component world pos\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get center(): Vector {\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get bounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce(\r\n      (acc, collider) => acc.combine(collider.bounds),\r\n      colliders[0]?.bounds ?? new BoundingBox().translate(this.worldPos)\r\n    );\r\n\r\n    return results;\r\n  }\r\n\r\n  get localBounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), colliders[0]?.localBounds ?? new BoundingBox());\r\n\r\n    return results;\r\n  }\r\n\r\n  get axes(): Vector[] {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    let axes: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      axes = axes.concat(collider.axes);\r\n    }\r\n    return axes;\r\n  }\r\n\r\n  getFurthestPoint(direction: Vector): Vector {\r\n    const colliders = this.getColliders();\r\n    const furthestPoints: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      furthestPoints.push(collider.getFurthestPoint(direction));\r\n    }\r\n    // Pick best point from all colliders\r\n    let bestPoint = furthestPoints[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (const point of furthestPoints) {\r\n      const distance = point.dot(direction);\r\n      if (distance > maxDistance) {\r\n        bestPoint = point;\r\n        maxDistance = distance;\r\n      }\r\n    }\r\n    return bestPoint;\r\n  }\r\n\r\n  getInertia(mass: number): number {\r\n    const colliders = this.getColliders();\r\n    let totalInertia = 0;\r\n    for (const collider of colliders) {\r\n      totalInertia += collider.getInertia(mass);\r\n    }\r\n    return totalInertia;\r\n  }\r\n\r\n  collide(other: Collider): CollisionContact[] {\r\n    let otherColliders = [other];\r\n    if (other instanceof CompositeCollider) {\r\n      otherColliders = other.getColliders();\r\n    }\r\n\r\n    const pairs: Pair[] = [];\r\n    for (const c of otherColliders) {\r\n      this._dynamicAABBTree.query(c, (potentialCollider: Collider) => {\r\n        pairs.push(new Pair(c, potentialCollider));\r\n        return false;\r\n      });\r\n    }\r\n\r\n    let contacts: CollisionContact[] = [];\r\n    for (const p of pairs) {\r\n      contacts = contacts.concat(p.collide());\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  getClosestLineBetween(other: Collider): LineSegment {\r\n    const colliders = this.getColliders();\r\n    const lines: LineSegment[] = [];\r\n    if (other instanceof CompositeCollider) {\r\n      const otherColliders = other.getColliders();\r\n      for (const colliderA of colliders) {\r\n        for (const colliderB of otherColliders) {\r\n          const maybeLine = colliderA.getClosestLineBetween(colliderB);\r\n          if (maybeLine) {\r\n            lines.push(maybeLine);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      for (const collider of colliders) {\r\n        const maybeLine = other.getClosestLineBetween(collider);\r\n        if (maybeLine) {\r\n          lines.push(maybeLine);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lines.length) {\r\n      let minLength = lines[0].getLength();\r\n      let minLine = lines[0];\r\n      for (const line of lines) {\r\n        const length = line.getLength();\r\n        if (length < minLength) {\r\n          minLength = length;\r\n          minLine = line;\r\n        }\r\n      }\r\n      return minLine;\r\n    }\r\n    return null;\r\n  }\r\n  contains(point: Vector): boolean {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      if (collider.contains(point)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  rayCast(ray: Ray, max?: number): Vector {\r\n    const colliders = this.getColliders();\r\n    const points: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      const vec = collider.rayCast(ray, max);\r\n      if (vec) {\r\n        points.push(vec);\r\n      }\r\n    }\r\n    if (points.length) {\r\n      let minPoint = points[0];\r\n      let minDistance = minPoint.dot(ray.dir);\r\n      for (const point of points) {\r\n        const distance = ray.dir.dot(point);\r\n        if (distance < minDistance) {\r\n          minPoint = point;\r\n          minDistance = distance;\r\n        }\r\n      }\r\n      return minPoint;\r\n    }\r\n    return null;\r\n  }\r\n  project(axis: Vector): Projection {\r\n    const colliders = this.getColliders();\r\n    const projs: Projection[] = [];\r\n    for (const collider of colliders) {\r\n      const proj = collider.project(axis);\r\n      if (proj) {\r\n        projs.push(proj);\r\n      }\r\n    }\r\n    // Merge all proj's on the same axis\r\n    if (projs.length) {\r\n      const newProjection = new Projection(projs[0].min, projs[0].max);\r\n      for (const proj of projs) {\r\n        newProjection.min = Math.min(proj.min, newProjection.min);\r\n        newProjection.max = Math.max(proj.max, newProjection.max);\r\n      }\r\n      return newProjection;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  update(transform: Transform): void {\r\n    if (transform) {\r\n      const colliders = this.getColliders();\r\n      for (const collider of colliders) {\r\n        collider.owner = this.owner;\r\n        collider.update(transform);\r\n      }\r\n    }\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      collider.debug(ex, color);\r\n    }\r\n  }\r\n\r\n  clone(): Collider {\r\n    return new CompositeCollider(this._colliders.map((c) => c.clone()));\r\n  }\r\n}\r\n","import { Vector } from './vector';\r\n\r\n/**\r\n * A 2D line segment\r\n */\r\n\r\nexport class LineSegment {\r\n\r\n  /**\r\n   * @param begin  The starting point of the line segment\r\n   * @param end  The ending point of the line segment\r\n   */\r\n  constructor(public readonly begin: Vector, public readonly end: Vector) {}\r\n\r\n  /**\r\n   * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\r\n   */\r\n  public get slope() {\r\n    return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\r\n  }\r\n\r\n  /**\r\n   * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\r\n   */\r\n  public get intercept() {\r\n    return this.begin.y - this.slope * this.begin.x;\r\n  }\r\n\r\n  private _normal: Vector;\r\n  /**\r\n   * Gets the normal of the line\r\n   */\r\n  public normal(): Vector {\r\n    if (this._normal) {\r\n      return this._normal;\r\n    }\r\n    return this._normal = this.end.sub(this.begin).normal();\r\n  }\r\n\r\n  private _dir: Vector;\r\n  public dir(): Vector {\r\n    if (this._dir) {\r\n      return this._dir;\r\n    }\r\n    return this._dir = this.end.sub(this.begin);\r\n  }\r\n\r\n  public getPoints(): Vector[] {\r\n    return [this.begin, this.end];\r\n  }\r\n\r\n  private _slope: Vector;\r\n  /**\r\n   * Returns the slope of the line in the form of a vector of length 1\r\n   */\r\n  public getSlope(): Vector {\r\n    if (this._slope) {\r\n      return this._slope;\r\n    }\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    const distance = begin.distance(end);\r\n    return this._slope = end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the edge of the line as vector, the length of the vector is the length of the edge\r\n   */\r\n  public getEdge(): Vector {\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    return end.sub(begin);\r\n  }\r\n\r\n  private _length: number;\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    if (this._length) {\r\n      return this._length;\r\n    }\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    const distance = begin.distance(end);\r\n    return this._length = distance;\r\n  }\r\n\r\n  /**\r\n   * Returns the midpoint of the edge\r\n   */\r\n  public get midpoint(): Vector {\r\n    return this.begin.add(this.end).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Flips the direction of the line segment\r\n   */\r\n  public flip(): LineSegment {\r\n    return new LineSegment(this.end, this.begin);\r\n  }\r\n\r\n  /**\r\n   * Tests if a given point is below the line, points in the normal direction above the line are considered above.\r\n   * @param point\r\n   */\r\n  public below(point: Vector): boolean {\r\n    const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);\r\n    return above2 >= 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the clip point\r\n   * @param sideVector Vector that traces the line\r\n   * @param length Length to clip along side\r\n   */\r\n  public clip(sideVector: Vector, length: number): LineSegment {\r\n    let dir = sideVector;\r\n    dir = dir.normalize();\r\n\r\n    const near = dir.dot(this.begin) - length;\r\n    const far = dir.dot(this.end) - length;\r\n\r\n    const results = [];\r\n    if (near <= 0) {\r\n      results.push(this.begin);\r\n    }\r\n    if (far <= 0) {\r\n      results.push(this.end);\r\n    }\r\n\r\n    if (near * far < 0) {\r\n      const clipTime = near / (near - far);\r\n      results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));\r\n    }\r\n    if (results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    return new LineSegment(results[0], results[1]);\r\n  }\r\n\r\n  /**\r\n   * Find the perpendicular distance from the line to a point\r\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n   * @param point\r\n   */\r\n  public distanceToPoint(point: Vector, signed: boolean = false) {\r\n    const x0 = point.x;\r\n    const y0 = point.y;\r\n\r\n    const l = this.getLength();\r\n\r\n    const dy = this.end.y - this.begin.y;\r\n    const dx = this.end.x - this.begin.x;\r\n    const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\r\n    return signed ? distance : Math.abs(distance);\r\n  }\r\n\r\n  /**\r\n   * Find the perpendicular line from the line to a point\r\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n   * (a - p) - ((a - p) * n)n\r\n   * a is a point on the line\r\n   * p is the arbitrary point above the line\r\n   * n is a unit vector in direction of the line\r\n   * @param point\r\n   */\r\n  public findVectorToPoint(point: Vector): Vector {\r\n    const aMinusP = this.begin.sub(point);\r\n    const n = this.getSlope();\r\n\r\n    return aMinusP.sub(n.scale(aMinusP.dot(n)));\r\n  }\r\n\r\n  /**\r\n   * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\r\n   * a new point with the calculated Y value and vice-versa.\r\n   *\r\n   * @param x The known X value of the target point\r\n   * @param y The known Y value of the target point\r\n   * @returns A new point with the other calculated axis value\r\n   */\r\n  public findPoint(x: number = null, y: number = null): Vector {\r\n    const m = this.slope;\r\n    const b = this.intercept;\r\n\r\n    if (x !== null) {\r\n      return new Vector(x, m * x + b);\r\n    } else if (y !== null) {\r\n      return new Vector((y - b) / m, y);\r\n    } else {\r\n      throw new Error('You must provide an X or a Y value');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given point lies on this line. This method is precise by default\r\n   * meaning the point must lie exactly on the line. Adjust threshold to\r\n   * loosen the strictness of the check for floating-point calculations.\r\n   */\r\n  public hasPoint(x: number, y: number, threshold?: number): boolean;\r\n\r\n  /**\r\n   * Whether or not the given point lies on this line. This method is precise by default\r\n   * meaning the point must lie exactly on the line. Adjust threshold to\r\n   * loosen the strictness of the check for floating-point calculations.\r\n   */\r\n  public hasPoint(v: Vector, threshold?: number): boolean;\r\n\r\n  /**\r\n   * @see http://stackoverflow.com/a/11908158/109458\r\n   */\r\n  public hasPoint(): boolean {\r\n    let currPoint: Vector;\r\n    let threshold = 0;\r\n\r\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\r\n      currPoint = new Vector(arguments[0], arguments[1]);\r\n      threshold = arguments[2] || 0;\r\n    } else if (arguments[0] instanceof Vector) {\r\n      currPoint = arguments[0];\r\n      threshold = arguments[1] || 0;\r\n    } else {\r\n      throw 'Could not determine the arguments for Vector.hasPoint';\r\n    }\r\n\r\n    const dxc = currPoint.x - this.begin.x;\r\n    const dyc = currPoint.y - this.begin.y;\r\n\r\n    const dx1 = this.end.x - this.begin.x;\r\n    const dy1 = this.end.y - this.begin.y;\r\n\r\n    const cross = dxc * dy1 - dyc * dx1;\r\n\r\n    // check whether point lines on the line\r\n    if (Math.abs(cross) > threshold) {\r\n      return false;\r\n    }\r\n\r\n    // check whether point lies in-between start and end\r\n    if (Math.abs(dx1) >= Math.abs(dy1)) {\r\n      return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\r\n    } else {\r\n      return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\r\n    }\r\n  }\r\n}\r\n","import { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\n\r\n/**\r\n * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment\r\n * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n * @param p0 Point where L1 begins\r\n * @param u Direction and length of L1\r\n * @param q0 Point were L2 begins\r\n * @param v Direction and length of L2\r\n */\r\nexport function ClosestLine(p0: Vector, u: Vector, q0: Vector, v: Vector) {\r\n  // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html\r\n\r\n  // w(s, t) = P(s) - Q(t)\r\n  // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest\r\n  //\r\n  // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.\r\n  // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0\r\n  //\r\n  // The closest point between 2 lines then satisfies this pair of equations\r\n  // 1: u * wClosest = 0\r\n  // 2: v * wClosest = 0\r\n  //\r\n  // Substituting wClosest into the equations we get\r\n  //\r\n  // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0\r\n  // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0\r\n\r\n  // simplify w0\r\n  const w0 = p0.sub(q0);\r\n\r\n  // simplify (u * u);\r\n  const a = u.dot(u);\r\n  // simplify (u * v);\r\n  const b = u.dot(v);\r\n  // simplify (v * v)\r\n  const c = v.dot(v);\r\n  // simplify (u * w0)\r\n  const d = u.dot(w0);\r\n  // simplify (v * w0)\r\n  const e = v.dot(w0);\r\n\r\n  // denominator ac - b^2\r\n  const denom = a * c - b * b;\r\n  let sDenom = denom;\r\n  let tDenom = denom;\r\n  // if denom is 0 they are parallel, use any point from either as the start in this case p0\r\n  if (denom === 0 || denom <= 0.01) {\r\n    const tClosestParallel = d / b;\r\n    return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));\r\n  }\r\n\r\n  // Solve for sClosest for infinite line\r\n  let sClosest = b * e - c * d; // / denom;\r\n\r\n  // Solve for tClosest for infinite line\r\n  let tClosest = a * e - b * d; // / denom;\r\n\r\n  // Solve for segments candidate edges, if sClosest and tClosest are outside their segments\r\n  if (sClosest < 0) {\r\n    sClosest = 0;\r\n    tClosest = e;\r\n    tDenom = c;\r\n  } else if (sClosest > sDenom) {\r\n    sClosest = sDenom;\r\n    tClosest = e + b;\r\n    tDenom = c;\r\n  }\r\n\r\n  if (tClosest < 0) {\r\n    tClosest = 0;\r\n    if (-d < 0) {\r\n      sClosest = 0;\r\n    } else if (-d > a) {\r\n      sClosest = sDenom;\r\n    } else {\r\n      sClosest = -d;\r\n      sDenom = a;\r\n    }\r\n  } else if (tClosest > tDenom) {\r\n    tClosest = tDenom;\r\n    if (-d + b < 0) {\r\n      sClosest = 0;\r\n    } else if (-d + b > a) {\r\n      sClosest = sDenom;\r\n    } else {\r\n      sClosest = -d + b;\r\n      sDenom = a;\r\n    }\r\n  }\r\n  sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;\r\n  tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;\r\n\r\n  return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));\r\n}\r\n\r\nexport const ClosestLineJumpTable = {\r\n  PolygonPolygonClosestLine(polygonA: PolygonCollider, polygonB: PolygonCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = polygonB.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygonA.worldPos);\r\n    const thisDirection = otherDirection.negate();\r\n\r\n    const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);\r\n    const rayTowardsThis = new Ray(otherWorldPos, thisDirection);\r\n\r\n    const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n    const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));\r\n\r\n    const thisFace = polygonA.getClosestFace(thisPoint);\r\n    const otherFace = polygonB.getClosestFace(otherPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const q0 = otherFace.face.begin;\r\n    const v = otherFace.face.getEdge();\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  },\r\n\r\n  PolygonEdgeClosestLine(polygon: PolygonCollider, edge: EdgeCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = edge.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);\r\n\r\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n\r\n    const thisFace = polygon.getClosestFace(thisPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const edgeLine = edge.asLine();\r\n    const edgeStart = edgeLine.begin;\r\n    const edgeVector = edgeLine.getEdge();\r\n    const q0 = edgeStart;\r\n    const v = edgeVector;\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  },\r\n\r\n  PolygonCircleClosestLine(polygon: PolygonCollider, circle: CircleCollider) {\r\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = circle.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());\r\n\r\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n\r\n    const thisFace = polygon.getClosestFace(thisPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // Time of minimum distance\r\n    let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n\r\n    // If time of minimum is past the edge clamp\r\n    if (t > 1) {\r\n      t = 1;\r\n    } else if (t < 0) {\r\n      t = 0;\r\n    }\r\n\r\n    // Minimum distance\r\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;\r\n\r\n    const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);\r\n    const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);\r\n    return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));\r\n  },\r\n\r\n  CircleCircleClosestLine(circleA: CircleCollider, circleB: CircleCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = circleB.worldPos;\r\n    const otherDirection = otherWorldPos.sub(circleA.worldPos);\r\n\r\n    const thisWorldPos = circleA.worldPos;\r\n    const thisDirection = thisWorldPos.sub(circleB.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);\r\n    const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);\r\n\r\n    const thisPoint = circleA.rayCast(rayTowardsOther);\r\n    const otherPoint = circleB.rayCast(rayTowardsThis);\r\n\r\n    return new LineSegment(thisPoint, otherPoint);\r\n  },\r\n\r\n  CircleEdgeClosestLine(circle: CircleCollider, edge: EdgeCollider) {\r\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n    const circleWorlPos = circle.worldPos;\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const edgeLine = edge.asLine();\r\n    const edgeStart = edgeLine.begin;\r\n    const edgeVector = edgeLine.getEdge();\r\n    const p0 = edgeStart;\r\n    const u = edgeVector;\r\n\r\n    // Time of minimum distance\r\n    let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n\r\n    // If time of minimum is past the edge clamp to edge\r\n    if (t > 1) {\r\n      t = 1;\r\n    } else if (t < 0) {\r\n      t = 0;\r\n    }\r\n\r\n    // Minimum distance\r\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;\r\n\r\n    const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);\r\n    const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);\r\n    return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));\r\n  },\r\n\r\n  EdgeEdgeClosestLine(edgeA: EdgeCollider, edgeB: EdgeCollider) {\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const edgeLineA = edgeA.asLine();\r\n    const edgeStartA = edgeLineA.begin;\r\n    const edgeVectorA = edgeLineA.getEdge();\r\n    const p0 = edgeStartA;\r\n    const u = edgeVectorA;\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const edgeLineB = edgeB.asLine();\r\n    const edgeStartB = edgeLineB.begin;\r\n    const edgeVectorB = edgeLineB.getEdge();\r\n    const q0 = edgeStartB;\r\n    const v = edgeVectorB;\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\n\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Transform } from '../../Math/transform';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport interface CircleColliderOptions {\r\n  /**\r\n   * Optional pixel offset to shift the circle relative to the collider, by default (0, 0).\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Required radius of the circle\r\n   */\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * This is a circle collider for the excalibur rigid body physics simulation\r\n */\r\nexport class CircleCollider extends Collider {\r\n  /**\r\n   * Position of the circle relative to the collider, by default (0, 0).\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  private _globalMatrix: AffineMatrix = AffineMatrix.identity();\r\n\r\n  public get worldPos(): Vector {\r\n    return this._globalMatrix.getPosition();\r\n  }\r\n\r\n  private _naturalRadius: number;\r\n  /**\r\n   * Get the radius of the circle\r\n   */\r\n  public get radius(): number {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n    return this._naturalRadius * Math.min(scale.x, scale.y);\r\n  }\r\n\r\n  /**\r\n   * Set the radius of the circle\r\n   */\r\n  public set radius(val: number) {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n    this._naturalRadius = val / Math.min(scale.x, scale.y);\r\n  }\r\n\r\n  private _transform: Transform;\r\n\r\n  constructor(options: CircleColliderOptions) {\r\n    super();\r\n    this.offset = options.offset || Vector.Zero;\r\n    this.radius = options.radius || 0;\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this shape, not associated with any collider\r\n   */\r\n  public clone(): CircleCollider {\r\n    return new CircleCollider({\r\n      offset: this.offset.clone(),\r\n      radius: this.radius\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this._globalMatrix.getPosition();\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    const pos = this._transform?.pos ?? this.offset;\r\n    const distance = pos.distance(point);\r\n    if (distance <= this.radius) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Casts a ray at the Circle collider and returns the nearest point of collision\r\n   * @param ray\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n    const c = this.center;\r\n    const dir = ray.dir;\r\n    const orig = ray.pos;\r\n\r\n    const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));\r\n\r\n    if (discriminant < 0) {\r\n      // no intersection\r\n      return null;\r\n    } else {\r\n      let toi = 0;\r\n      if (discriminant === 0) {\r\n        toi = -dir.dot(orig.sub(c));\r\n        if (toi > 0 && toi < max) {\r\n          return ray.getPoint(toi);\r\n        }\r\n        return null;\r\n      } else {\r\n        const toi1 = -dir.dot(orig.sub(c)) + discriminant;\r\n        const toi2 = -dir.dot(orig.sub(c)) - discriminant;\r\n\r\n        const positiveToi: number[] = [];\r\n        if (toi1 >= 0) {\r\n          positiveToi.push(toi1);\r\n        }\r\n\r\n        if (toi2 >= 0) {\r\n          positiveToi.push(toi2);\r\n        }\r\n\r\n        const mintoi = Math.min(...positiveToi);\r\n        if (mintoi <= max) {\r\n          return ray.getPoint(mintoi);\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  public getClosestLineBetween(shape: Collider): LineSegment {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleCircle(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    return this.center.add(direction.normalize().scale(this.radius));\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the shape in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const dir = direction.normalize();\r\n    return dir.scale(this.radius);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n    return new BoundingBox(\r\n      this.offset.x - this._naturalRadius,\r\n      this.offset.y - this._naturalRadius,\r\n      this.offset.x + this._naturalRadius,\r\n      this.offset.y + this._naturalRadius\r\n    ).rotate(rotation).scale(scale).translate(pos);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return new BoundingBox(\r\n      this.offset.x - this._naturalRadius,\r\n      this.offset.y - this._naturalRadius,\r\n      this.offset.x + this._naturalRadius,\r\n      this.offset.y + this._naturalRadius\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get axis not implemented on circles, since there are infinite axis in a circle\r\n   */\r\n  public get axes(): Vector[] {\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Returns the moment of inertia of a circle given it's mass\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    return (mass * this.radius * this.radius) / 2;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    const globalMat = transform.matrix ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Project the circle along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n    const point = this.center;\r\n    const dotProduct = point.dot(axis);\r\n    scalars.push(dotProduct);\r\n    scalars.push(dotProduct + this.radius);\r\n    scalars.push(dotProduct - this.radius);\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const tx = this._transform;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n    ex.save();\r\n    ex.translate(pos.x, pos.y);\r\n    ex.rotate(rotation);\r\n    ex.scale(scale.x, scale.y);\r\n    ex.drawCircle((this.offset ?? Vector.Zero), this._naturalRadius, Color.Transparent, color, 2);\r\n    ex.restore();\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Physics } from '../Physics';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Pair } from './Pair';\r\nimport { SeparationInfo } from '../Colliders/SeparatingAxis';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * Collision contacts are used internally by Excalibur to resolve collision between colliders. This\r\n * Pair prevents collisions from being evaluated more than one time\r\n */\r\nexport class CollisionContact {\r\n  private _canceled = false;\r\n\r\n  /**\r\n   * Currently the ids between colliders\r\n   */\r\n  readonly id: string;\r\n\r\n  /**\r\n   * The first collider in the collision\r\n   */\r\n  colliderA: Collider;\r\n\r\n  /**\r\n   * The second collider in the collision\r\n   */\r\n  colliderB: Collider;\r\n\r\n  /**\r\n   * The minimum translation vector to resolve overlap, pointing away from colliderA\r\n   */\r\n  mtv: Vector;\r\n\r\n  /**\r\n   * World space contact points between colliderA and colliderB\r\n   */\r\n  points: Vector[];\r\n\r\n  /**\r\n   * Local space contact points between colliderA and colliderB\r\n   */\r\n  localPoints: Vector[];\r\n\r\n  /**\r\n   * The collision normal, pointing away from colliderA\r\n   */\r\n  normal: Vector;\r\n\r\n  /**\r\n   * The collision tangent\r\n   */\r\n  tangent: Vector;\r\n\r\n  /**\r\n   * Information about the specifics of the collision contact separation\r\n   */\r\n  info: SeparationInfo;\r\n\r\n  constructor(\r\n    colliderA: Collider,\r\n    colliderB: Collider,\r\n    mtv: Vector,\r\n    normal: Vector,\r\n    tangent: Vector,\r\n    points: Vector[],\r\n    localPoints: Vector[],\r\n    info: SeparationInfo\r\n  ) {\r\n    this.colliderA = colliderA;\r\n    this.colliderB = colliderB;\r\n    this.mtv = mtv;\r\n    this.normal = normal;\r\n    this.tangent = tangent;\r\n    this.points = points;\r\n    this.localPoints = localPoints;\r\n    this.info = info;\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {\r\n      // Add on the parent composite pair for start/end contact\r\n      this.id += '|' + Pair.calculatePairHash(\r\n        colliderA.__compositeColliderId ?? colliderA.id,\r\n        colliderB.__compositeColliderId ?? colliderB.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Match contact awake state, except if body's are Fixed\r\n   */\r\n  public matchAwake(): void {\r\n    const bodyA = this.colliderA.owner.get(BodyComponent);\r\n    const bodyB = this.colliderB.owner.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      if (bodyA.sleeping !== bodyB.sleeping) {\r\n        if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {\r\n          bodyA.setSleeping(false);\r\n        }\r\n        if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {\r\n          bodyB.setSleeping(false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public isCanceled() {\r\n    return this._canceled;\r\n  }\r\n\r\n  public cancel(): void {\r\n    this._canceled = true;\r\n  }\r\n}\r\n","import { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Collider } from './Collider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\n/**\r\n * Specific information about a contact and it's separation\r\n */\r\nexport interface SeparationInfo {\r\n  /**\r\n   * Collider A\r\n   */\r\n  collider: Collider;\r\n\r\n  /**\r\n   * Signed value (negative means overlap, positive no overlap)\r\n   */\r\n  separation: number;\r\n\r\n  /**\r\n   * Axis of separation from the collider's perspective\r\n   */\r\n  axis: Vector;\r\n\r\n  /**\r\n   * Side of separation (reference) from the collider's perspective\r\n   */\r\n\r\n  side?: LineSegment;\r\n\r\n  /**\r\n   * Local side of separation (reference) from the collider's perspective\r\n   */\r\n  localSide?: LineSegment;\r\n\r\n  /**\r\n   * Index of the separation side (reference) from the collider's perspective\r\n   */\r\n  sideId?: number;\r\n\r\n  /**\r\n   * Point on collider B (incident point)\r\n   */\r\n  point: Vector;\r\n\r\n  /**\r\n   * Local point on collider B (incident point)\r\n   */\r\n  localPoint?: Vector;\r\n}\r\n\r\nexport class SeparatingAxis {\r\n  static findPolygonPolygonSeparation(polyA: PolygonCollider, polyB: PolygonCollider): SeparationInfo {\r\n    let bestSeparation = -Number.MAX_VALUE;\r\n    let bestSide: LineSegment | null = null;\r\n    let bestAxis: Vector | null = null;\r\n    let bestSideIndex: number = -1;\r\n    let bestOtherPoint: Vector | null = null;\r\n    const sides = polyA.getSides();\r\n    const localSides = polyA.getLocalSides();\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const side = sides[i];\r\n      const axis = side.normal();\r\n      const vertB = polyB.getFurthestPoint(axis.negate());\r\n      // Separation on side i's axis\r\n      // We are looking for the largest separation between poly A's sides\r\n      const vertSeparation = side.distanceToPoint(vertB, true);\r\n      if (vertSeparation > bestSeparation) {\r\n        bestSeparation = vertSeparation;\r\n        bestSide = side;\r\n        bestAxis = axis;\r\n        bestSideIndex = i;\r\n        bestOtherPoint = vertB;\r\n      }\r\n    }\r\n\r\n    return {\r\n      collider: polyA,\r\n      separation: bestAxis ? bestSeparation : 99,\r\n      axis: bestAxis as Vector,\r\n      side: bestSide,\r\n      localSide: localSides[bestSideIndex],\r\n      sideId: bestSideIndex,\r\n      point: bestOtherPoint as Vector,\r\n      localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis!.negate()) : null\r\n    };\r\n  }\r\n\r\n  static findCirclePolygonSeparation(circle: CircleCollider, polygon: PolygonCollider): Vector | null {\r\n    const axes = polygon.axes;\r\n    const pc = polygon.center;\r\n    // Special SAT with circles\r\n    const polyDir = pc.sub(circle.worldPos);\r\n    const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());\r\n    axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());\r\n\r\n    let minOverlap = Number.MAX_VALUE;\r\n    let minAxis = null;\r\n    let minIndex = -1;\r\n    for (let i = 0; i < axes.length; i++) {\r\n      const proj1 = polygon.project(axes[i]);\r\n      const proj2 = circle.project(axes[i]);\r\n      const overlap = proj1.getOverlap(proj2);\r\n      if (overlap <= 0) {\r\n        return null;\r\n      } else {\r\n        if (overlap < minOverlap) {\r\n          minOverlap = overlap;\r\n          minAxis = axes[i];\r\n          minIndex = i;\r\n        }\r\n      }\r\n    }\r\n    if (minIndex < 0) {\r\n      return null;\r\n    }\r\n    return minAxis.normalize().scale(minOverlap);\r\n  }\r\n}\r\n","import { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { SeparatingAxis, SeparationInfo } from './SeparatingAxis';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { TransformComponent } from '../../EntityComponentSystem';\r\nimport { Pair } from '../Detection/Pair';\r\n\r\nexport const CollisionJumpTable = {\r\n  CollideCircleCircle(circleA: CircleCollider, circleB: CircleCollider): CollisionContact[] {\r\n    const circleAPos = circleA.worldPos;\r\n    const circleBPos = circleB.worldPos;\r\n    const combinedRadius = circleA.radius + circleB.radius;\r\n    const distance = circleAPos.distance(circleBPos);\r\n\r\n    if (distance > combinedRadius) {\r\n      return [];\r\n    }\r\n\r\n    // negative means overlap\r\n    const separation = combinedRadius - distance;\r\n\r\n    // Normal points from A -> B\r\n    const normal = circleBPos.sub(circleAPos).normalize();\r\n    const tangent = normal.perpendicular();\r\n    const mvt = normal.scale(separation);\r\n\r\n    const point = circleA.getFurthestPoint(normal);\r\n    const local = circleA.getFurthestLocalPoint(normal);\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circleA,\r\n      separation,\r\n      axis: normal,\r\n      point: point\r\n    };\r\n\r\n    return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];\r\n  },\r\n\r\n  CollideCirclePolygon(circle: CircleCollider, polygon: PolygonCollider): CollisionContact[] {\r\n    let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);\r\n    if (!minAxis) {\r\n      return [];\r\n    }\r\n\r\n    // make sure that the minAxis is pointing away from circle\r\n    const samedir = minAxis.dot(polygon.center.sub(circle.center));\r\n    minAxis = samedir < 0 ? minAxis.negate() : minAxis;\r\n\r\n    const point = circle.getFurthestPoint(minAxis);\r\n    const xf = circle.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const local = xf.applyInverse(point);\r\n    const normal = minAxis.normalize();\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: -minAxis.size,\r\n      axis: normal,\r\n      point: point,\r\n      localPoint: local,\r\n      side: polygon.findSide(normal.negate()),\r\n      localSide: polygon.findLocalSide(normal.negate())\r\n    };\r\n\r\n    return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];\r\n  },\r\n\r\n  CollideCircleEdge(circle: CircleCollider, edge: EdgeCollider): CollisionContact[] {\r\n    // TODO not sure this actually abides by local/world collisions\r\n    // Are edge.begin and edge.end local space or world space? I think they should be local\r\n\r\n    // center of the circle in world pos\r\n    const cc = circle.center;\r\n    // vector in the direction of the edge\r\n    const edgeWorld = edge.asLine();\r\n    const e = edgeWorld.end.sub(edgeWorld.begin);\r\n\r\n    // amount of overlap with the circle's center along the edge direction\r\n    const u = e.dot(edgeWorld.end.sub(cc));\r\n    const v = e.dot(cc.sub(edgeWorld.begin));\r\n    const side = edge.asLine();\r\n    const localSide = edge.asLocalLine();\r\n\r\n    // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n    if (v <= 0) {\r\n      const da = edgeWorld.begin.sub(cc);\r\n      const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n      // save some sqrts\r\n      if (dda > circle.radius * circle.radius) {\r\n        return []; // no collision\r\n      }\r\n\r\n      const normal = da.normalize();\r\n      const separation = circle.radius - Math.sqrt(dda);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.begin,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)\r\n      ];\r\n    }\r\n\r\n    // Potential region B collision (circle is on the right side of the edge, after the end)\r\n    if (u <= 0) {\r\n      const db = edgeWorld.end.sub(cc);\r\n      const ddb = db.dot(db);\r\n      if (ddb > circle.radius * circle.radius) {\r\n        return [];\r\n      }\r\n\r\n      const normal = db.normalize();\r\n      const separation = circle.radius - Math.sqrt(ddb);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.end,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)\r\n      ];\r\n    }\r\n\r\n    // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n    const den = e.dot(e);\r\n    const pointOnEdge = edgeWorld.begin\r\n      .scale(u)\r\n      .add(edgeWorld.end.scale(v))\r\n      .scale(1 / den);\r\n    const d = cc.sub(pointOnEdge);\r\n\r\n    const dd = d.dot(d);\r\n    if (dd > circle.radius * circle.radius) {\r\n      return []; // no collision\r\n    }\r\n\r\n    let normal = e.perpendicular();\r\n    // flip correct direction\r\n    if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {\r\n      normal.x = -normal.x;\r\n      normal.y = -normal.y;\r\n    }\r\n\r\n    normal = normal.normalize();\r\n    const separation = circle.radius - Math.sqrt(dd);\r\n\r\n    const mvt = normal.scale(separation);\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: separation,\r\n      axis: normal,\r\n      point: pointOnEdge,\r\n      side: side,\r\n      localSide: localSide\r\n    };\r\n\r\n    return [\r\n      new CollisionContact(\r\n        circle,\r\n        edge,\r\n        mvt,\r\n        normal.negate(),\r\n        normal.negate().perpendicular(),\r\n        [pointOnEdge],\r\n        [pointOnEdge.sub(edge.worldPos)],\r\n        info\r\n      )\r\n    ];\r\n  },\r\n\r\n  CollideEdgeEdge(): CollisionContact[] {\r\n    // Edge-edge collision doesn't make sense\r\n    return [];\r\n  },\r\n\r\n  CollidePolygonEdge(polygon: PolygonCollider, edge: EdgeCollider): CollisionContact[] {\r\n    const pc = polygon.center;\r\n    const ec = edge.center;\r\n    const dir = ec.sub(pc).normalize();\r\n\r\n    // build a temporary polygon from the edge to use SAT\r\n    const linePoly = new PolygonCollider({\r\n      points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],\r\n      offset: edge.offset\r\n    });\r\n    linePoly.owner = edge.owner;\r\n    const tx = edge.owner?.get(TransformComponent);\r\n    if (tx) {\r\n      linePoly.update(edge.owner.get(TransformComponent).get());\r\n    }\r\n    // Gross hack but poly-poly works well\r\n    const contact = this.CollidePolygonPolygon(polygon, linePoly);\r\n    if (contact.length) {\r\n      // Fudge the contact back to edge\r\n      contact[0].colliderB = edge;\r\n      (contact[0].id as any) = Pair.calculatePairHash(polygon.id, edge.id);\r\n    }\r\n    return contact;\r\n  },\r\n\r\n  CollidePolygonPolygon(polyA: PolygonCollider, polyB: PolygonCollider): CollisionContact[] {\r\n    // Multi contact from SAT\r\n    // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection\r\n    // do a SAT test to find a min axis if it exists\r\n    const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);\r\n    // If there is no overlap from boxA's perspective we can end early\r\n    if (separationA.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);\r\n    // If there is no overlap from boxB's perspective exit now\r\n    if (separationB.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    // Separations are both negative, we want to pick the least negative (minimal movement)\r\n    const separation = separationA.separation > separationB.separation ? separationA : separationB;\r\n\r\n    // The incident side is the most opposite from the axes of collision on the other collider\r\n    const other = separation.collider === polyA ? polyB : polyA;\r\n    const incident = other.findSide(separation.axis.negate()) as LineSegment;\r\n\r\n    // Clip incident side by the perpendicular lines at each end of the reference side\r\n    // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\r\n    const reference = separation.side;\r\n    const refDir = reference.dir().normalize();\r\n\r\n    // Find our contact points by clipping the incident by the collision side\r\n    const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));\r\n    let clipLeft: LineSegment | null = null;\r\n    if (clipRight) {\r\n      clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));\r\n    }\r\n\r\n    // If there is no left there is no collision\r\n    if (clipLeft) {\r\n      // We only want clip points below the reference edge, discard the others\r\n      const points = clipLeft.getPoints().filter((p) => {\r\n        return reference.below(p);\r\n      });\r\n\r\n      let normal = separation.axis;\r\n      let tangent = normal.perpendicular();\r\n      // Point Contact A -> B\r\n      if (polyB.center.sub(polyA.center).dot(normal) < 0) {\r\n        normal = normal.negate();\r\n        tangent = normal.perpendicular();\r\n      }\r\n      // Points are clipped from incident which is the other collider\r\n      // Store those as locals\r\n      let localPoints: Vector[] = [];\r\n      if (separation.collider === polyA) {\r\n        const xf = polyB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      } else {\r\n        const xf = polyA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      }\r\n      return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];\r\n    }\r\n    return [];\r\n  },\r\n\r\n  FindContactSeparation(contact: CollisionContact, localPoint: Vector) {\r\n    const shapeA = contact.colliderA;\r\n    const txA = contact.colliderA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const shapeB = contact.colliderB;\r\n    const txB = contact.colliderB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n\r\n    // both are circles\r\n    if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {\r\n      const combinedRadius = shapeA.radius + shapeB.radius;\r\n      const distance = txA.pos.distance(txB.pos);\r\n      const separation = combinedRadius - distance;\r\n      return -separation;\r\n    }\r\n\r\n    // both are polygons\r\n    if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {\r\n      if (contact.info.localSide) {\r\n        let side: LineSegment;\r\n        let worldPoint: Vector;\r\n        if (contact.info.collider === shapeA) {\r\n          side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));\r\n          worldPoint = txB.apply(localPoint);\r\n        } else {\r\n          side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));\r\n          worldPoint = txA.apply(localPoint);\r\n        }\r\n\r\n        return side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v circle\r\n    if (\r\n      (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||\r\n      (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)\r\n    ) {\r\n      const worldPoint = txA.apply(localPoint);\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v edge\r\n    if (\r\n      (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||\r\n      (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)\r\n    ) {\r\n      let worldPoint: Vector;\r\n      if (contact.info.collider === shapeA) {\r\n        worldPoint = txB.apply(localPoint);\r\n      } else {\r\n        worldPoint = txA.apply(localPoint);\r\n      }\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // circle v edge\r\n    if (\r\n      (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||\r\n      (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)\r\n    ) {\r\n      // Local point is always on the edge which is always shapeB\r\n      const worldPoint = txB.apply(localPoint);\r\n\r\n      let circlePoint: Vector;\r\n      if (shapeA instanceof CircleCollider) {\r\n        circlePoint = shapeA.getFurthestPoint(contact.normal);\r\n      }\r\n\r\n      const dist = worldPoint.distance(circlePoint);\r\n\r\n      if (contact.info.side) {\r\n        return dist > 0 ? -dist : 0;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Transform } from '../../Math/transform';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\n\r\nexport interface EdgeColliderOptions {\r\n  /**\r\n   * The beginning of the edge defined in local coordinates to the collider\r\n   */\r\n  begin: Vector;\r\n  /**\r\n   * The ending of the edge defined in local coordinates to the collider\r\n   */\r\n  end: Vector;\r\n  /**\r\n   * Optionally specify an offset\r\n   */\r\n  offset?: Vector;\r\n}\r\n\r\n/**\r\n * Edge is a single line collider to create collisions with a single line.\r\n */\r\nexport class EdgeCollider extends Collider {\r\n  offset: Vector;\r\n  begin: Vector;\r\n  end: Vector;\r\n\r\n  private _transform: Transform;\r\n  private _globalMatrix: AffineMatrix = AffineMatrix.identity();\r\n\r\n  constructor(options: EdgeColliderOptions) {\r\n    super();\r\n    this.begin = options.begin || Vector.Zero;\r\n    this.end = options.end || Vector.Zero;\r\n    this.offset = options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this Edge, not associated with any collider\r\n   */\r\n  public clone(): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: this.begin.clone(),\r\n      end: this.end.clone()\r\n    });\r\n  }\r\n\r\n  public get worldPos(): Vector {\r\n    const tx = this._transform;\r\n    return tx?.globalPos.add(this.offset) ?? this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collision area in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const pos = begin.average(end);\r\n    return pos;\r\n  }\r\n\r\n  private _getTransformedBegin(): Vector {\r\n    return this._globalMatrix.multiply(this.begin);\r\n  }\r\n\r\n  private _getTransformedEnd(): Vector {\r\n    return this._globalMatrix.multiply(this.end);\r\n  }\r\n\r\n  /**\r\n   * Returns the slope of the line in the form of a vector\r\n   */\r\n  public getSlope(): Vector {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return distance;\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collision area\r\n   */\r\n  public contains(): boolean {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    const numerator = this._getTransformedBegin().sub(ray.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {\r\n      return null;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = ray.dir.cross(this.getSlope());\r\n    if (divisor === 0) {\r\n      return null;\r\n    }\r\n\r\n    const t = numerator.cross(this.getSlope()) / divisor;\r\n\r\n    if (t >= 0 && t <= max) {\r\n      const u = numerator.cross(ray.dir) / divisor / this.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return ray.getPoint(t);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the closes line between this and another collider, from this -> collider\r\n   * @param shape\r\n   */\r\n  public getClosestLineBetween(shape: Collider): LineSegment {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(shape: Collider): CollisionContact[] {\r\n    if (shape instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(shape, this);\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideEdgeEdge();\r\n    } else {\r\n      throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    if (direction.dot(transformedBegin) > 0) {\r\n      return transformedBegin;\r\n    } else {\r\n      return transformedEnd;\r\n    }\r\n  }\r\n\r\n  private _boundsFromBeginEnd(begin: Vector, end: Vector, padding = 10) {\r\n    // A perfectly vertical or horizontal edge would have a bounds 0 width or height\r\n    // this causes problems for the collision system so we give them some padding\r\n    return new BoundingBox(\r\n      Math.min(begin.x, end.x) - padding,\r\n      Math.min(begin.y, end.y) - padding,\r\n      Math.max(begin.x, end.x) + padding,\r\n      Math.max(begin.y, end.y) + padding\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in world space\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    return this._boundsFromBeginEnd(transformedBegin, transformedEnd);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in local space\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return this._boundsFromBeginEnd(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Returns this edge represented as a line in world coordinates\r\n   */\r\n  public asLine(): LineSegment {\r\n    return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());\r\n  }\r\n\r\n  /**\r\n   * Return this edge as a line in local line coordinates (relative to the position)\r\n   */\r\n  public asLocalLine(): LineSegment {\r\n    return new LineSegment(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the edge\r\n   */\r\n  public get axes(): Vector[] {\r\n    const e = this._getTransformedEnd().sub(this._getTransformedBegin());\r\n    const edgeNormal = e.normal();\r\n\r\n    const axes = [];\r\n    axes.push(edgeNormal);\r\n    axes.push(edgeNormal.negate());\r\n    axes.push(edgeNormal.normal());\r\n    axes.push(edgeNormal.normal().negate());\r\n    return axes;\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia for an edge\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    const length = this.end.sub(this.begin).distance() / 2;\r\n    return mass * length * length;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    const globalMat = transform.matrix ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Project the edge along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n\r\n    const points = [this._getTransformedBegin(), this._getTransformedEnd()];\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      scalars.push(points[i].dot(axis));\r\n    }\r\n\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    ex.drawLine(begin, end, color, 2);\r\n    ex.drawCircle(begin, 2, color);\r\n    ex.drawCircle(end, 2, color);\r\n  }\r\n\r\n}\r\n","import { Color } from '../../Color';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { AffineMatrix } from '../../Math/affine-matrix';\r\nimport { Ray } from '../../Math/ray';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Collider } from './Collider';\r\nimport { ExcaliburGraphicsContext, Logger, range } from '../..';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Shape } from './Shape';\r\nimport { Transform } from '../../Math/transform';\r\n\r\nexport interface PolygonColliderOptions {\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   */\r\n  points: Vector[];\r\n}\r\n\r\n/**\r\n * Polygon collider for detecting collisions\r\n */\r\nexport class PolygonCollider extends Collider {\r\n  private _logger = Logger.getInstance();\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  public offset: Vector;\r\n\r\n  private _points: Vector[];\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   * Excalibur stores these in counter-clockwise order\r\n   */\r\n  public set points(points: Vector[]) {\r\n    this._localBoundsDirty = true;\r\n    this._localSidesDirty = true;\r\n    this._sidesDirty = true;\r\n    this._points = points;\r\n  }\r\n\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   * Excalibur stores these in counter-clockwise order\r\n   */\r\n  public get points(): Vector[] {\r\n    return this._points;\r\n  }\r\n\r\n  private _transform: Transform;\r\n\r\n  private _transformedPoints: Vector[] = [];\r\n  private _sides: LineSegment[] = [];\r\n  private _localSides: LineSegment[] = [];\r\n\r\n  constructor(options: PolygonColliderOptions) {\r\n    super();\r\n    this.offset = options.offset ?? Vector.Zero;\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    this.points = options.points ?? [];\r\n    const counterClockwise = this._isCounterClockwiseWinding(this.points);\r\n    if (!counterClockwise) {\r\n      this.points.reverse();\r\n    }\r\n    if (!this.isConvex()) {\r\n      this._logger.warn(\r\n        'Excalibur only supports convex polygon colliders and will not behave properly.'+\r\n        'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');\r\n    }\r\n\r\n    // calculate initial transformation\r\n    this._calculateTransformation();\r\n  }\r\n\r\n  private _isCounterClockwiseWinding(points: Vector[]): boolean {\r\n    // https://stackoverflow.com/a/1165943\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length; i++) {\r\n      sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);\r\n    }\r\n    return sum < 0;\r\n  }\r\n\r\n  /**\r\n   * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.\r\n   * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape\r\n   */\r\n  public isConvex(): boolean {\r\n    // From SO: https://stackoverflow.com/a/45372025\r\n    if (this.points.length < 3) {\r\n      return false;\r\n    }\r\n    let oldPoint = this.points[this.points.length - 2];\r\n    let newPoint = this.points[this.points.length - 1];\r\n    let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n    let oldDirection = 0;\r\n    let orientation = 0;\r\n    let angleSum = 0;\r\n    for (const [i, point] of this.points.entries()) {\r\n      oldPoint = newPoint;\r\n      oldDirection = direction;\r\n      newPoint =  point;\r\n      direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n      if (oldPoint.equals(newPoint)) {\r\n        return false; // repeat point\r\n      }\r\n      let angle = direction - oldDirection;\r\n      if (angle <= -Math.PI){\r\n        angle += Math.PI * 2;\r\n      } else if (angle > Math.PI) {\r\n        angle -= Math.PI * 2;\r\n      }\r\n      if (i === 0) {\r\n        if (angle === 0.0) {\r\n          return false;\r\n        }\r\n        orientation = angle  > 0 ? 1 : -1;\r\n      } else {\r\n        if (orientation * angle <= 0) {\r\n          return false;\r\n        }\r\n      }\r\n      angleSum += angle;\r\n    }\r\n    return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;\r\n  }\r\n\r\n  /**\r\n   * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons\r\n   */\r\n  public tessellate(): CompositeCollider {\r\n    const polygons: Vector[][] = [];\r\n    for (let i = 1; i < this.points.length - 2; i++) {\r\n      polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);\r\n    }\r\n    polygons.push([this.points[0], this.points[1], this.points[2]]);\r\n\r\n    return new CompositeCollider(polygons.map(points => Shape.Polygon(points)));\r\n  }\r\n\r\n  /**\r\n   * Triangulate the polygon collider using the \"Ear Clipping\" algorithm.\r\n   * Returns a new [[CompositeCollider]] made up of smaller triangles.\r\n   */\r\n  public triangulate(): CompositeCollider {\r\n    // https://www.youtube.com/watch?v=hTJFcHutls8\r\n    if (this.points.length < 3) {\r\n      throw Error('Invalid polygon');\r\n    }\r\n\r\n    /**\r\n     * Helper to get a vertex in the list\r\n     */\r\n    function getItem<T>(index: number, list: T[]) {\r\n      if (index >= list.length) {\r\n        return list[index % list.length];\r\n      } else if (index < 0) {\r\n        return list[index % list.length + list.length];\r\n      } else {\r\n        return list[index];\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Quick test for point in triangle\r\n     */\r\n    function isPointInTriangle(point: Vector, a: Vector, b: Vector, c: Vector) {\r\n      const ab = b.sub(a);\r\n      const bc = c.sub(b);\r\n      const ca = a.sub(c);\r\n\r\n      const ap = point.sub(a);\r\n      const bp = point.sub(b);\r\n      const cp = point.sub(c);\r\n\r\n      const cross1 = ab.cross(ap);\r\n      const cross2 = bc.cross(bp);\r\n      const cross3 = ca.cross(cp);\r\n\r\n      if (cross1 > 0 || cross2 > 0 || cross3 > 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    const triangles: Vector[][] = [];\r\n    const vertices = [...this.points];\r\n    const indices = range(0, this.points.length - 1);\r\n\r\n    // 1. Loop through vertices clockwise\r\n    //    if the vertex is convex (interior angle is < 180) (cross product positive)\r\n    //    if the polygon formed by it's edges doesn't contain the points\r\n    //         it's an ear add it to our list of triangles, and restart\r\n\r\n    while (indices.length > 3) {\r\n      for (let i = 0; i < indices.length; i++) {\r\n        const a = indices[i];\r\n        const b = getItem(i - 1, indices);\r\n        const c = getItem(i + 1, indices);\r\n\r\n        const va = vertices[a];\r\n        const vb = vertices[b];\r\n        const vc = vertices[c];\r\n\r\n        // Check convexity\r\n        const leftArm = vb.sub(va);\r\n        const rightArm = vc.sub(va);\r\n        const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex\r\n        if (!isConvex) {\r\n          continue;\r\n        }\r\n\r\n        let isEar = true;\r\n        // Check that if any vertices are in the triangle a, b, c\r\n        for (let j = 0; j < indices.length; j++) {\r\n          const vertIndex = indices[j];\r\n          // We can skip these\r\n          if (vertIndex === a || vertIndex === b || vertIndex === c) {\r\n            continue;\r\n          }\r\n\r\n          const point = vertices[vertIndex];\r\n          if (isPointInTriangle(point, vb, va, vc)) {\r\n            isEar = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Add ear to polygon list and remove from list\r\n        if (isEar) {\r\n          triangles.push([vb, va, vc]);\r\n          indices.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);\r\n\r\n    return new CompositeCollider(triangles.map(points => Shape.Polygon(points)));\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this ConvexPolygon, not associated with any collider\r\n   */\r\n  public clone(): PolygonCollider {\r\n    return new PolygonCollider({\r\n      offset: this.offset.clone(),\r\n      points: this.points.map((p) => p.clone())\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the world position of the collider, which is the current body transform plus any defined offset\r\n   */\r\n  public get worldPos(): Vector {\r\n    if (this._transform) {\r\n      return this._transform.pos.add(this.offset);\r\n    }\r\n    return this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this.bounds.center;\r\n  }\r\n\r\n  private _globalMatrix: AffineMatrix = AffineMatrix.identity();\r\n\r\n  private _transformedPointsDirty = true;\r\n  /**\r\n   * Calculates the underlying transformation from the body relative space to world space\r\n   */\r\n  private _calculateTransformation() {\r\n    const points = this.points;\r\n    const len = points.length;\r\n    this._transformedPoints.length = 0; // clear out old transform\r\n    for (let i = 0; i < len; i++) {\r\n      this._transformedPoints[i] = this._globalMatrix.multiply(points[i].clone());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n   */\r\n  public getTransformedPoints(): Vector[] {\r\n    if (this._transformedPointsDirty) {\r\n      this._calculateTransformation();\r\n      this._transformedPointsDirty = false;\r\n    }\r\n    return this._transformedPoints;\r\n  }\r\n\r\n  private _sidesDirty = true;\r\n  /**\r\n   * Gets the sides of the polygon in world space\r\n   */\r\n  public getSides(): LineSegment[] {\r\n    if (this._sidesDirty) {\r\n      const lines = [];\r\n      const points = this.getTransformedPoints();\r\n      const len = points.length;\r\n      for (let i = 0; i < len; i++) {\r\n        // This winding is important\r\n        lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n      }\r\n      this._sides = lines;\r\n      this._sidesDirty = false;\r\n    }\r\n    return this._sides;\r\n  }\r\n\r\n  private _localSidesDirty = true;\r\n  /**\r\n   * Returns the local coordinate space sides\r\n   */\r\n  public getLocalSides(): LineSegment[] {\r\n    if (this._localSidesDirty) {\r\n      const lines = [];\r\n      const points = this.points;\r\n      const len = points.length;\r\n      for (let i = 0; i < len; i++) {\r\n        // This winding is important\r\n        lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n      }\r\n      this._localSides = lines;\r\n      this._localSidesDirty = false;\r\n    }\r\n\r\n    return this._localSides;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the world space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findSide(direction: Vector): LineSegment {\r\n    const sides = this.getSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the local space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findLocalSide(direction: Vector): LineSegment {\r\n    const sides = this.getLocalSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the convex polygon\r\n   */\r\n  public get axes(): Vector[] {\r\n    const axes: Vector[] = [];\r\n    const sides = this.getSides();\r\n    for (let i = 0; i < sides.length; i++) {\r\n      axes.push(sides[i].normal());\r\n    }\r\n    return axes;\r\n  }\r\n\r\n  /**\r\n   * Updates the transform for the collision geometry\r\n   *\r\n   * Collision geometry (points/bounds) will not change until this is called.\r\n   * @param transform\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    this._transformedPointsDirty = true;\r\n    this._sidesDirty = true;\r\n    // This change means an update must be performed in order for geometry to update\r\n    const globalMat = transform.matrix ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider in world space\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    // Always cast to the right, as long as we cast in a consistent fixed direction we\r\n    // will be fine\r\n    const testRay = new Ray(point, new Vector(1, 0));\r\n    const intersectCount = this.getSides().reduce(function (accum, side) {\r\n      if (testRay.intersect(side) >= 0) {\r\n        return accum + 1;\r\n      }\r\n      return accum;\r\n    }, 0);\r\n\r\n    if (intersectCount % 2 === 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public getClosestLineBetween(collider: Collider): LineSegment {\r\n    if (collider instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a collision contact if the 2 colliders collide, otherwise collide will\r\n   * return null.\r\n   * @param collider\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(collider, this);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonPolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const pts = this.getTransformedPoints();\r\n    let furthestPoint = null;\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the collider furthest in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const pts = this.points;\r\n    let furthestPoint = pts[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Finds the closes face to the point using perpendicular distance\r\n   * @param point point to test against polygon\r\n   */\r\n  public getClosestFace(point: Vector): { distance: Vector; face: LineSegment } {\r\n    const sides = this.getSides();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let faceIndex = -1;\r\n    let distance = -1;\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const dist = sides[i].distanceToPoint(point);\r\n      if (dist < min) {\r\n        min = dist;\r\n        faceIndex = i;\r\n        distance = dist;\r\n      }\r\n    }\r\n\r\n    if (faceIndex !== -1) {\r\n      return {\r\n        distance: sides[faceIndex].normal().scale(distance),\r\n        face: sides[faceIndex]\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    return this.localBounds.transform(this._globalMatrix);\r\n  }\r\n\r\n  private _localBoundsDirty = true;\r\n  private _localBounds: BoundingBox;\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    if (this._localBoundsDirty) {\r\n      this._localBounds = BoundingBox.fromPoints(this.points);\r\n      this._localBoundsDirty = false;\r\n    }\r\n\r\n    return this._localBounds;\r\n  }\r\n\r\n  private _cachedMass: number;\r\n  private _cachedInertia: number;\r\n  /**\r\n   * Get the moment of inertia for an arbitrary polygon\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    if (this._cachedMass === mass && this._cachedInertia) {\r\n      return this._cachedInertia;\r\n    }\r\n    let numerator = 0;\r\n    let denominator = 0;\r\n    const points = this.points;\r\n    for (let i = 0; i < points.length; i++) {\r\n      const iplusone = (i + 1) % points.length;\r\n      const crossTerm = points[iplusone].cross(points[i]);\r\n      numerator +=\r\n        crossTerm *\r\n        (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));\r\n      denominator += crossTerm;\r\n    }\r\n    this._cachedMass = mass;\r\n    return this._cachedInertia = (mass / 6) * (numerator / denominator);\r\n  }\r\n\r\n  /**\r\n   * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity) {\r\n    // find the minimum contact time greater than 0\r\n    // contact times less than 0 are behind the ray and we don't want those\r\n    const sides = this.getSides();\r\n    const len = sides.length;\r\n    let minContactTime = Number.MAX_VALUE;\r\n    let contactIndex = -1;\r\n    for (let i = 0; i < len; i++) {\r\n      const contactTime = ray.intersect(sides[i]);\r\n      if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\r\n        minContactTime = contactTime;\r\n        contactIndex = i;\r\n      }\r\n    }\r\n\r\n    // contact was found\r\n    if (contactIndex >= 0) {\r\n      return ray.getPoint(minContactTime);\r\n    }\r\n\r\n    // no contact found\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Project the edges of the polygon along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const points = this.getTransformedPoints();\r\n    const len = points.length;\r\n    let min = Number.MAX_VALUE;\r\n    let max = -Number.MAX_VALUE;\r\n    for (let i = 0; i < len; i++) {\r\n      const scalar = points[i].dot(axis);\r\n      min = Math.min(min, scalar);\r\n      max = Math.max(max, scalar);\r\n    }\r\n\r\n    return new Projection(min, max);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const firstPoint = this.getTransformedPoints()[0];\r\n    const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n      ex.drawLine(points[i], points[i + 1], color, 2);\r\n      ex.drawCircle(points[i], 2, color);\r\n      ex.drawCircle(points[i + 1], 2, color);\r\n    }\r\n  }\r\n}\r\n","import { PolygonCollider } from './PolygonCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Logger } from '../..';\r\n\r\n/**\r\n * Excalibur helper for defining colliders quickly\r\n */\r\nexport class Shape {\r\n  /**\r\n   * Creates a box collider, under the hood defines a [[PolygonCollider]] collider\r\n   * @param width Width of the box\r\n   * @param height Height of the box\r\n   * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Box(width: number, height: number, anchor: Vector = Vector.Half, offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[PolygonCollider|arbitrary polygon]] collider\r\n   *\r\n   * PolygonColliders are useful for creating convex polygon shapes\r\n   * @param points Points specified in counter clockwise\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Polygon(points: Vector[], offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: points,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[CircleCollider|circle]] collider\r\n   *\r\n   * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges\r\n   * @param radius Radius of the circle collider\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Circle(radius: number, offset: Vector = Vector.Zero): CircleCollider {\r\n    return new CircleCollider({\r\n      radius: radius,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[EdgeCollider|edge]] collider\r\n   *\r\n   * Edge colliders are useful for  floors, walls, and other barriers\r\n   * @param begin Beginning of the edge in local coordinates to the collider\r\n   * @param end Ending of the edge in local coordinates to the collider\r\n   */\r\n  static Edge(begin: Vector, end: Vector): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: begin,\r\n      end: end\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box\r\n   *\r\n   * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth\r\n   * player experience.\r\n   *\r\n   * @param width\r\n   * @param height\r\n   * @param offset Optional offset\r\n   */\r\n  static Capsule(width: number, height: number, offset = Vector.Zero): CompositeCollider {\r\n    const logger = Logger.getInstance();\r\n    if (width === height) {\r\n      logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');\r\n    }\r\n\r\n    const vertical = height >= width;\r\n\r\n    if (vertical) {\r\n      // height > width, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),\r\n        Shape.Box(width, height - width, Vector.Half, offset),\r\n        Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))\r\n      ]);\r\n      return capsule;\r\n    } else {\r\n      // width > height, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),\r\n        Shape.Box(width - height, height, Vector.Half, offset),\r\n        Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))\r\n      ]);\r\n      return capsule;\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { CollisionEndEvent, CollisionStartEvent, PostCollisionEvent, PreCollisionEvent } from '../Events';\r\nimport { Observable } from '../Util/Observable';\r\nimport { BoundingBox } from './BoundingBox';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { CircleCollider } from './Colliders/CircleCollider';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { PolygonCollider } from './Colliders/PolygonCollider';\r\nimport { EdgeCollider } from './Colliders/EdgeCollider';\r\nimport { Shape } from './Colliders/Shape';\r\n\r\nexport class ColliderComponent extends Component<'ex.collider'> {\r\n  public readonly type = 'ex.collider';\r\n\r\n  public events = new EventDispatcher();\r\n  /**\r\n   * Observable that notifies when a collider is added to the body\r\n   */\r\n  public $colliderAdded = new Observable<Collider>();\r\n\r\n  /**\r\n   * Observable that notifies when a collider is removed from the body\r\n   */\r\n  public $colliderRemoved = new Observable<Collider>();\r\n\r\n  constructor(collider?: Collider) {\r\n    super();\r\n    this.set(collider);\r\n  }\r\n\r\n  private _collider: Collider;\r\n  /**\r\n   * Get the current collider geometry\r\n   */\r\n  public get() {\r\n    return this._collider;\r\n  }\r\n\r\n  /**\r\n   * Set the collider geometry\r\n   * @param collider\r\n   * @returns the collider you set\r\n   */\r\n  public set<T extends Collider>(collider: T): T {\r\n    this.clear();\r\n    if (collider) {\r\n      this._collider = collider;\r\n      this._collider.owner = this.owner;\r\n      this.events.wire(collider.events);\r\n      this.$colliderAdded.notifyAll(collider);\r\n      this.update();\r\n    }\r\n    return collider;\r\n  }\r\n\r\n  /**\r\n   * Remove collider geometry from collider component\r\n   */\r\n  public clear() {\r\n    if (this._collider) {\r\n      this.events.unwire(this._collider.events);\r\n      this.$colliderRemoved.notifyAll(this._collider);\r\n      this._collider.owner = null;\r\n      this._collider = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return world space bounds\r\n   */\r\n  public get bounds() {\r\n    return this._collider?.bounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Return local space bounds\r\n   */\r\n  public get localBounds() {\r\n    return this._collider?.localBounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Update the collider's transformed geometry\r\n   */\r\n  public update() {\r\n    const tx = this.owner?.get(TransformComponent);\r\n    if (this._collider) {\r\n      this._collider.owner = this.owner;\r\n      if (tx) {\r\n        this._collider.update(tx.get());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collide component with another\r\n   * @param other\r\n   */\r\n  collide(other: ColliderComponent): CollisionContact[] {\r\n    let colliderA = this._collider;\r\n    let colliderB = other._collider;\r\n    if (!colliderA || !colliderB) {\r\n      return [];\r\n    }\r\n\r\n    // If we have a composite lefthand side :(\r\n    // Might bite us, but to avoid updating all the handlers make composite always left side\r\n    let flipped = false;\r\n    if (colliderB instanceof CompositeCollider) {\r\n      colliderA = colliderB;\r\n      colliderB = this._collider;\r\n      flipped = true;\r\n    }\r\n\r\n    if (this._collider) {\r\n      const contacts = colliderA.collide(colliderB);\r\n      if (contacts) {\r\n        if (flipped) {\r\n          contacts.forEach((contact) => {\r\n            contact.mtv = contact.mtv.negate();\r\n            contact.normal = contact.normal.negate();\r\n            contact.tangent = contact.normal.perpendicular();\r\n            contact.colliderA = this._collider;\r\n            contact.colliderB = other._collider;\r\n          });\r\n        }\r\n        return contacts;\r\n      }\r\n      return [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  onAdd(entity: Entity) {\r\n    if (this._collider) {\r\n      this.update();\r\n    }\r\n    // Wire up the collider events to the owning entity\r\n    this.events.on('precollision', (evt: any) => {\r\n      const precollision = evt as PreCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('postcollision', (evt: any) => {\r\n      const postcollision = evt as PostCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('collisionstart', (evt: any) => {\r\n      const start = evt as CollisionStartEvent<Collider>;\r\n      entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));\r\n    });\r\n    this.events.on('collisionend', (evt: any) => {\r\n      const end = evt as CollisionEndEvent<Collider>;\r\n      entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));\r\n    });\r\n  }\r\n\r\n  onRemove() {\r\n    this.events.clear();\r\n    this.$colliderRemoved.notifyAll(this._collider);\r\n  }\r\n\r\n  /**\r\n   * Sets up a box geometry based on the current bounds of the associated actor of this physics body.\r\n   *\r\n   * If no width/height are specified the body will attempt to use the associated actor's width/height.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useBoxCollider(width: number, height: number, anchor: Vector = Vector.Half, center: Vector = Vector.Zero): PolygonCollider {\r\n    const collider = Shape.Box(width, height, anchor, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative\r\n   *  to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  usePolygonCollider(points: Vector[], center: Vector = Vector.Zero): PolygonCollider {\r\n    const poly = Shape.Polygon(points, center);\r\n    return (this.set(poly));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useCircleCollider(radius: number, center: Vector = Vector.Zero): CircleCollider {\r\n    const collider = Shape.Circle(radius, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useEdgeCollider(begin: Vector, end: Vector): EdgeCollider {\r\n    const collider = Shape.Edge(begin, end);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders\r\n   * @param colliders\r\n   */\r\n  useCompositeCollider(colliders: Collider[]): CompositeCollider {\r\n    return (this.set(new CompositeCollider(colliders)));\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { CollisionType } from './CollisionType';\r\nimport { Physics } from './Physics';\r\nimport { Clonable } from '../Interfaces/Clonable';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { CollisionGroup } from './Group/CollisionGroup';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { createId, Id } from '../Id';\r\nimport { clamp } from '../Math/util';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { Transform } from '../Math/transform';\r\n\r\nexport interface BodyComponentOptions {\r\n  type?: CollisionType;\r\n  group?: CollisionGroup;\r\n  useGravity?: boolean;\r\n}\r\n\r\nexport enum DegreeOfFreedom {\r\n  Rotation = 'rotation',\r\n  X = 'x',\r\n  Y = 'y'\r\n}\r\n\r\n/**\r\n * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of\r\n * of physics simulation.\r\n */\r\nexport class BodyComponent extends Component<'ex.body'> implements Clonable<BodyComponent> {\r\n  public readonly type = 'ex.body';\r\n  public dependencies = [TransformComponent, MotionComponent];\r\n  public static _ID = 0;\r\n  public readonly id: Id<'body'> = createId('body', BodyComponent._ID++);\r\n  public events = new EventDispatcher();\r\n\r\n  private _oldTransform = new Transform();\r\n\r\n  /**\r\n   * Indicates whether the old transform has been captured at least once for interpolation\r\n   * @internal\r\n   */\r\n  public __oldTransformCaptured: boolean = false;\r\n\r\n  /**\r\n   * Enable or disabled the fixed update interpolation, by default interpolation is on.\r\n   */\r\n  public enableFixedUpdateInterpolate = true;\r\n\r\n  constructor(options?: BodyComponentOptions) {\r\n    super();\r\n    if (options) {\r\n      this.collisionType = options.type ?? this.collisionType;\r\n      this.group = options.group ?? this.group;\r\n      this.useGravity = options.useGravity ?? this.useGravity;\r\n    }\r\n  }\r\n\r\n  public get matrix() {\r\n    return this.transform.get().matrix;\r\n  }\r\n\r\n  /**\r\n   * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]\r\n   */\r\n  public collisionType: CollisionType = CollisionType.PreventCollision;\r\n\r\n  /**\r\n   * The collision group for the body's colliders, by default body colliders collide with everything\r\n   */\r\n  public group: CollisionGroup = CollisionGroup.All;\r\n\r\n  /**\r\n   * The amount of mass the body has\r\n   */\r\n  private _mass: number = Physics.defaultMass;\r\n  public get mass(): number {\r\n    return this._mass;\r\n  }\r\n\r\n  public set mass(newMass: number) {\r\n    this._mass = newMass;\r\n    this._cachedInertia = undefined;\r\n    this._cachedInverseInertia = undefined;\r\n  }\r\n\r\n  /**\r\n   * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseMass(): number {\r\n    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;\r\n  }\r\n\r\n  /**\r\n   * Amount of \"motion\" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to \"sleep\"\r\n   */\r\n  public sleepMotion: number = Physics.sleepEpsilon * 5;\r\n\r\n  /**\r\n   * Can this body sleep, by default bodies do not sleep\r\n   */\r\n  public canSleep: boolean = Physics.bodiesCanSleepByDefault;\r\n\r\n  private _sleeping = false;\r\n  /**\r\n   * Whether this body is sleeping or not\r\n   */\r\n  public get sleeping(): boolean {\r\n    return this._sleeping;\r\n  }\r\n\r\n  /**\r\n   * Set the sleep state of the body\r\n   * @param sleeping\r\n   */\r\n  public setSleeping(sleeping: boolean) {\r\n    this._sleeping = sleeping;\r\n    if (!sleeping) {\r\n      // Give it a kick to keep it from falling asleep immediately\r\n      this.sleepMotion = Physics.sleepEpsilon * 5;\r\n    } else {\r\n      this.vel = Vector.Zero;\r\n      this.acc = Vector.Zero;\r\n      this.angularVelocity = 0;\r\n      this.sleepMotion = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping\r\n   */\r\n  public updateMotion() {\r\n    if (this._sleeping) {\r\n      this.setSleeping(true);\r\n    }\r\n    const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);\r\n    const bias = Physics.sleepBias;\r\n    this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;\r\n    this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);\r\n    if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {\r\n      this.setSleeping(true);\r\n    }\r\n  }\r\n\r\n  private _cachedInertia: number;\r\n  /**\r\n   * Get the moment of inertia from the [[ColliderComponent]]\r\n   */\r\n  public get inertia() {\r\n    if (this._cachedInertia) {\r\n      return this._cachedInertia;\r\n    }\r\n\r\n    // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?\r\n    const collider = this.owner.get(ColliderComponent);\r\n    if (collider) {\r\n      collider.$colliderAdded.subscribe(() => {\r\n        this._cachedInertia = null;\r\n      });\r\n      collider.$colliderRemoved.subscribe(() => {\r\n        this._cachedInertia = null;\r\n      });\r\n      const maybeCollider = collider.get();\r\n      if (maybeCollider) {\r\n        return this._cachedInertia = maybeCollider.getInertia(this.mass);\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private _cachedInverseInertia: number;\r\n  /**\r\n   * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseInertia() {\r\n    if (this._cachedInverseInertia) {\r\n      return this._cachedInverseInertia;\r\n    }\r\n    return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;\r\n  }\r\n\r\n  /**\r\n   * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the\r\n   * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.\r\n   */\r\n  public bounciness: number = 0.2;\r\n\r\n  /**\r\n   * The coefficient of friction on this actor\r\n   */\r\n  public friction: number = 0.99;\r\n\r\n  /**\r\n   * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true\r\n   */\r\n  public useGravity: boolean = true;\r\n\r\n  /**\r\n   * Degrees of freedom to limit\r\n   *\r\n   * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond\r\n   */\r\n  public limitDegreeOfFreedom: DegreeOfFreedom[] = [];\r\n\r\n  /**\r\n   * Returns if the owner is active\r\n   */\r\n  public get active() {\r\n    return !!this.owner?.active;\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use globalP0s\r\n   */\r\n  public get center() {\r\n    return this.globalPos;\r\n  }\r\n\r\n  public get transform(): TransformComponent {\r\n    return this.owner?.get(TransformComponent);\r\n  }\r\n\r\n  public get motion(): MotionComponent {\r\n    return  this.owner?.get(MotionComponent);\r\n  }\r\n\r\n  public get pos(): Vector {\r\n    return this.transform.pos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this.transform.pos = val;\r\n  }\r\n\r\n  /**\r\n   * The (x, y) position of the actor this will be in the middle of the actor if the\r\n   * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n   * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n   */\r\n  public get globalPos(): Vector {\r\n    return this.transform.globalPos;\r\n  }\r\n\r\n  public set globalPos(val: Vector) {\r\n    this.transform.globalPos = val;\r\n  }\r\n\r\n  /**\r\n   * The position of the actor last frame (x, y) in pixels\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this._oldTransform.pos;\r\n  }\r\n\r\n  /**\r\n   * The current velocity vector (vx, vy) of the actor in pixels/second\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this.motion.vel = val;\r\n  }\r\n\r\n  /**\r\n   * The velocity of the actor last frame (vx, vy) in pixels/second\r\n   */\r\n  public oldVel: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n   * be useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  public set acc(val: Vector) {\r\n    this.motion.acc = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public oldAcc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The current torque applied to the actor\r\n   */\r\n  public get torque(): number {\r\n    return this.motion.torque;\r\n  }\r\n\r\n  public set torque(val: number) {\r\n    this.motion.torque = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the rotation of the body from the last frame.\r\n   */\r\n  public get oldRotation(): number {\r\n    return this._oldTransform.rotation;\r\n  }\r\n\r\n  /**\r\n   * The rotation of the body in radians\r\n   */\r\n  public get rotation() {\r\n    return this.transform.globalRotation;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    this.transform.globalRotation = val;\r\n  }\r\n\r\n  /**\r\n   * The scale vector of the actor\r\n   */\r\n  public get scale(): Vector {\r\n    return this.transform.globalScale;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    this.transform.globalScale = val;\r\n  }\r\n\r\n  /**\r\n   * The scale of the actor last frame\r\n   */\r\n  public get oldScale(): Vector {\r\n    return this._oldTransform.scale;\r\n  }\r\n\r\n  /**\r\n   * The scale rate of change of the actor in scale/second\r\n   */\r\n  public get scaleFactor(): Vector {\r\n    return this.motion.scaleFactor;\r\n  }\r\n\r\n  public set scaleFactor(scaleFactor: Vector) {\r\n    this.motion.scaleFactor = scaleFactor;\r\n  }\r\n\r\n  /**\r\n   * Get the angular velocity in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Set the angular velocity in radians/second\r\n   */\r\n  public set angularVelocity(value: number) {\r\n    this.motion.angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Apply a specific impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel.addEqual(finalImpulse);\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.globalPos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply only linear impulse to the body\r\n   * @param impulse\r\n   */\r\n  public applyLinearImpulse(impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel = this.vel.add(finalImpulse);\r\n  }\r\n\r\n  /**\r\n   * Apply only angular impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyAngularImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.globalPos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the old versions of pos, vel, acc, and scale.\r\n   */\r\n  public captureOldTransform() {\r\n    // Capture old values before integration step updates them\r\n    this.__oldTransformCaptured = true;\r\n    this.transform.get().clone(this._oldTransform);\r\n    this.oldVel.setTo(this.vel.x, this.vel.y);\r\n    this.oldAcc.setTo(this.acc.x, this.acc.y);\r\n  }\r\n}\r\n","import { Component, ComponentCtor, TagComponent } from './Component';\r\n\r\nimport { Observable, Message } from '../Util/Observable';\r\nimport { Class } from '../Class';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate } from '../Interfaces/LifecycleEvents';\r\nimport { Engine } from '../Engine';\r\nimport { InitializeEvent, PreUpdateEvent, PostUpdateEvent } from '../Events';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { Util } from '..';\r\n\r\n/**\r\n * Interface holding an entity component pair\r\n */\r\nexport interface EntityComponent {\r\n  component: Component;\r\n  entity: Entity;\r\n}\r\n\r\n/**\r\n * AddedComponent message\r\n */\r\nexport class AddedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Added' = 'Component Added';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is f an Added Component\r\n */\r\nexport function isAddedComponent(x: Message<EntityComponent>): x is AddedComponent {\r\n  return !!x && x.type === 'Component Added';\r\n}\r\n\r\n/**\r\n * RemovedComponent message\r\n */\r\nexport class RemovedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Removed' = 'Component Removed';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is for a Removed Component\r\n */\r\nexport function isRemovedComponent(x: Message<EntityComponent>): x is RemovedComponent {\r\n  return !!x && x.type === 'Component Removed';\r\n}\r\n\r\n/**\r\n * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system\r\n *\r\n * Entities can be strongly typed with the components they contain\r\n *\r\n * ```typescript\r\n * const entity = new Entity<ComponentA | ComponentB>();\r\n * entity.components.a; // Type ComponentA\r\n * entity.components.b; // Type ComponentB\r\n * ```\r\n */\r\nexport class Entity extends Class implements OnInitialize, OnPreUpdate, OnPostUpdate {\r\n  private static _ID = 0;\r\n\r\n  constructor(components?: Component[], name?: string) {\r\n    super();\r\n    this._setName(name);\r\n    if (components) {\r\n      for (const component of components) {\r\n        this.addComponent(component);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The unique identifier for the entity\r\n   */\r\n  public id: number = Entity._ID++;\r\n\r\n  private _name: string = 'anonymous';\r\n  protected _setName(name: string) {\r\n    if (name) {\r\n      this._name = name;\r\n    }\r\n  }\r\n  public get name(): string {\r\n    return this._name;\r\n  }\r\n\r\n  public get events(): EventDispatcher {\r\n    return this.eventDispatcher;\r\n  }\r\n\r\n  /**\r\n   * Whether this entity is active, if set to false it will be reclaimed\r\n   */\r\n  public active: boolean = true;\r\n\r\n  /**\r\n   * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.\r\n   */\r\n  public kill() {\r\n    this.active = false;\r\n  }\r\n\r\n  public isKilled() {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Specifically get the tags on the entity from [[TagComponent]]\r\n   */\r\n  public get tags(): readonly string[] {\r\n    return this._tagsMemo;\r\n  }\r\n\r\n  /**\r\n   * Check if a tag exists on the entity\r\n   * @param tag name to check for\r\n   */\r\n  public hasTag(tag: string): boolean {\r\n    return this.tags.includes(tag);\r\n  }\r\n\r\n  /**\r\n   * Adds a tag to an entity\r\n   * @param tag\r\n   * @returns Entity\r\n   */\r\n  public addTag(tag: string) {\r\n    return this.addComponent(new TagComponent(tag));\r\n  }\r\n\r\n  /**\r\n   * Removes a tag on the entity\r\n   *\r\n   * Removals are deferred until the end of update\r\n   * @param tag\r\n   * @param force Remove component immediately, no deferred\r\n   */\r\n  public removeTag(tag: string, force = false) {\r\n    return this.removeComponent(tag, force);\r\n  }\r\n\r\n  /**\r\n   * The types of the components on the Entity\r\n   */\r\n  public get types(): string[] {\r\n    return this._typesMemo;\r\n  }\r\n\r\n  /**\r\n   * Bucket to hold on to deferred removals\r\n   */\r\n  private _componentsToRemove: (Component | string)[] = [];\r\n  private _componentTypeToInstance = new Map<ComponentCtor, Component>();\r\n  private _componentStringToInstance = new Map<string, Component>();\r\n\r\n  private _tagsMemo: string[] = [];\r\n  private _typesMemo: string[] = [];\r\n  private _rebuildMemos() {\r\n    this._tagsMemo = Array.from(this._componentStringToInstance.values())\r\n      .filter((c) => c instanceof TagComponent)\r\n      .map((c) => c.type);\r\n    this._typesMemo = Array.from(this._componentStringToInstance.keys());\r\n  }\r\n\r\n  public getComponents(): Component[] {\r\n    return Array.from(this._componentStringToInstance.values());\r\n  }\r\n\r\n  /**\r\n   * Observable that keeps track of component add or remove changes on the entity\r\n   */\r\n  public componentAdded$ = new Observable<AddedComponent>();\r\n  private _notifyAddComponent(component: Component) {\r\n    this._rebuildMemos();\r\n    const added = new AddedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentAdded$.notifyAll(added);\r\n  }\r\n\r\n  public componentRemoved$ = new Observable<RemovedComponent>();\r\n  private _notifyRemoveComponent(component: Component) {\r\n    const removed = new RemovedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentRemoved$.notifyAll(removed);\r\n    this._rebuildMemos();\r\n  }\r\n\r\n  private _parent: Entity = null;\r\n  public get parent(): Entity {\r\n    return this._parent;\r\n  }\r\n\r\n  public childrenAdded$ = new Observable<Entity>();\r\n  public childrenRemoved$ = new Observable<Entity>();\r\n\r\n  private _children: Entity[] = [];\r\n  /**\r\n   * Get the direct children of this entity\r\n   */\r\n  public get children(): readonly Entity[] {\r\n    return this._children;\r\n  }\r\n\r\n  /**\r\n   * Unparents this entity, if there is a parent. Otherwise it does nothing.\r\n   */\r\n  public unparent() {\r\n    if (this._parent) {\r\n      this._parent.removeChild(this);\r\n      this._parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be a child of this entity\r\n   * @param entity\r\n   */\r\n  public addChild(entity: Entity): Entity {\r\n    if (entity.parent === null) {\r\n      if (this.getAncestors().includes(entity)) {\r\n        throw new Error('Cycle detected, cannot add entity');\r\n      }\r\n      this._children.push(entity);\r\n      entity._parent = this;\r\n      this.childrenAdded$.notifyAll(entity);\r\n    } else {\r\n      throw new Error('Entity already has a parent, cannot add without unparenting');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from children if it exists\r\n   * @param entity\r\n   */\r\n  public removeChild(entity: Entity): Entity {\r\n    if (entity.parent === this) {\r\n      Util.removeItemFromArray(entity, this._children);\r\n      entity._parent = null;\r\n      this.childrenRemoved$.notifyAll(entity);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all children from this entity\r\n   */\r\n  public removeAllChildren(): Entity {\r\n    this.children.forEach((c) => {\r\n      this.removeChild(c);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of parent entities starting with the topmost parent. Includes the current entity.\r\n   */\r\n  public getAncestors(): Entity[] {\r\n    const result: Entity[] = [this];\r\n    let current = this.parent;\r\n    while (current) {\r\n      result.push(current);\r\n      current = current.parent;\r\n    }\r\n    return result.reverse();\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all the entities that descend from this entity. Includes the current entity.\r\n   */\r\n  public getDescendants(): Entity[] {\r\n    let result: Entity[] = [this];\r\n    let queue: Entity[] = [this];\r\n    while (queue.length > 0) {\r\n      const curr = queue.pop();\r\n      queue = queue.concat(curr.children);\r\n      result = result.concat(curr.children);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a deep copy of the entity and a copy of all its components\r\n   */\r\n  public clone(): Entity {\r\n    const newEntity = new Entity();\r\n    for (const c of this.types) {\r\n      newEntity.addComponent(this.get(c).clone());\r\n    }\r\n    for (const child of this.children) {\r\n      newEntity.addChild(child.clone());\r\n    }\r\n    return newEntity;\r\n  }\r\n\r\n  /**\r\n   * Adds a copy of all the components from another template entity as a \"prefab\"\r\n   * @param templateEntity Entity to use as a template\r\n   * @param force Force component replacement if it already exists on the target entity\r\n   */\r\n  public addTemplate(templateEntity: Entity, force: boolean = false): Entity {\r\n    for (const c of templateEntity.getComponents()) {\r\n      this.addComponent(c.clone(), force);\r\n    }\r\n    for (const child of templateEntity.children) {\r\n      this.addChild(child.clone().addTemplate(child));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a component to the entity\r\n   * @param component Component or Entity to add copy of components from\r\n   * @param force Optionally overwrite any existing components of the same type\r\n   */\r\n  public addComponent<T extends Component>(component: T, force: boolean = false): Entity {\r\n    // if component already exists, skip if not forced\r\n    if (this.has(component.type)) {\r\n      if (force) {\r\n        // Remove existing component type if exists when forced\r\n        this.removeComponent(component);\r\n      } else {\r\n        // early exit component exits\r\n        return this;\r\n      }\r\n    }\r\n\r\n    // TODO circular dependencies will be a problem\r\n    if (component.dependencies && component.dependencies.length) {\r\n      for (const ctor of component.dependencies) {\r\n        this.addComponent(new ctor());\r\n      }\r\n    }\r\n\r\n    component.owner = this;\r\n    const constuctorType = component.constructor as ComponentCtor<T>;\r\n    this._componentTypeToInstance.set(constuctorType, component);\r\n    this._componentStringToInstance.set(component.type, component);\r\n    if (component.onAdd) {\r\n      component.onAdd(this);\r\n    }\r\n    this._notifyAddComponent(component);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues\r\n   *\r\n   * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately\r\n   * @param componentOrType\r\n   * @param force\r\n   */\r\n  public removeComponent<ComponentOrType extends string | Component>(componentOrType: ComponentOrType, force = false): Entity {\r\n    if (force) {\r\n      if (typeof componentOrType === 'string') {\r\n        this._removeComponentByType(componentOrType);\r\n      } else if (componentOrType instanceof Component) {\r\n        this._removeComponentByType(componentOrType.type);\r\n      }\r\n    } else {\r\n      this._componentsToRemove.push(componentOrType);\r\n    }\r\n\r\n    return this as any;\r\n  }\r\n\r\n  private _removeComponentByType(type: string) {\r\n    if (this.has(type)) {\r\n      const component = this.get(type);\r\n      component.owner = null;\r\n      if (component.onRemove) {\r\n        component.onRemove(this);\r\n      }\r\n      const ctor = component.constructor as ComponentCtor;\r\n      this._componentTypeToInstance.delete(ctor);\r\n      this._componentStringToInstance.delete(component.type);\r\n      this._notifyRemoveComponent(component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @internal\r\n   */\r\n  public processComponentRemoval() {\r\n    for (const componentOrType of this._componentsToRemove) {\r\n      const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;\r\n      this._removeComponentByType(type);\r\n    }\r\n    this._componentsToRemove.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Check if a component type exists\r\n   * @param type\r\n   */\r\n  public has<T extends Component>(type: ComponentCtor<T>): boolean;\r\n  public has(type: string): boolean;\r\n  public has<T extends Component>(type: ComponentCtor<T> | string): boolean {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.has(type);\r\n    } else {\r\n      return this._componentTypeToInstance.has(type);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a component by type with typecheck\r\n   *\r\n   * (Does not work on tag components, use .hasTag(\"mytag\") instead)\r\n   * @param type\r\n   */\r\n  public get<T extends Component>(type: ComponentCtor<T>): T | null;\r\n  public get<T extends Component>(type: string): T | null;\r\n  public get<T extends Component>(type: ComponentCtor<T> | string): T | null {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.get(type) as T;\r\n    } else {\r\n      return this._componentTypeToInstance.get(type) as T;\r\n    }\r\n  }\r\n\r\n  private _isInitialized = false;\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the entity. This method is meant to be\r\n   * overridden.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an entity is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an entity is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Entity update lifecycle, called internally\r\n   *\r\n   * @internal\r\n   * @param engine\r\n   * @param delta\r\n   */\r\n  public update(engine: Engine, delta: number): void {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    for (const child of this.children) {\r\n      child.update(engine, delta);\r\n    }\r\n    this._postupdate(engine, delta);\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { Graphic } from './Graphic';\r\nimport { HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Logger } from '../Util/Log';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)\r\n * @param graphic\r\n */\r\nexport function hasGraphicsTick(graphic: Graphic): graphic is Graphic & HasTick {\r\n  return !!(graphic as unknown as HasTick).tick;\r\n}\r\nexport interface GraphicsShowOptions {\r\n  offset?: Vector;\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsComponentOptions {\r\n  onPostDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n  onPreDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n\r\n  /**\r\n   * Name of current graphic to use\r\n   */\r\n  current?: string;\r\n\r\n  /**\r\n   * Optionally copy instances of graphics by calling .clone(), you may set this to false to avoid sharing graphics when added to the\r\n   * component for performance reasons. By default graphics are not copied and are shared when added to the component.\r\n   */\r\n  copyGraphics?: boolean;\r\n\r\n  /**\r\n   * Optional visible flag, if the graphics component is not visible it will not be displayed\r\n   */\r\n  visible?: boolean;\r\n\r\n  /**\r\n   * Optional opacity\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * List of graphics\r\n   */\r\n  graphics?: { [graphicName: string]: Graphic };\r\n\r\n  /**\r\n   * Optional offset in absolute pixels to shift all graphics in this component from each graphic's anchor (default is top left corner)\r\n   */\r\n  offset?: Vector;\r\n\r\n  /**\r\n   * Optional anchor\r\n   */\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsLayerOptions {\r\n  /**\r\n   * Name of the layer required, for example 'background'\r\n   */\r\n  name: string;\r\n  /**\r\n   * Order of the layer, a layer with order -1 will be below a layer with order of 1\r\n   */\r\n  order: number;\r\n  /**\r\n   * Offset to shift the entire layer\r\n   */\r\n  offset?: Vector;\r\n}\r\nexport class GraphicsLayer {\r\n  public graphics: { graphic: Graphic; options: GraphicsShowOptions }[] = [];\r\n  constructor(private _options: GraphicsLayerOptions, private _graphics: GraphicsComponent) {}\r\n  public get name(): string {\r\n    return this._options.name;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in this layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in this layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    if (!nameOrGraphic) {\r\n      this.graphics.length = 0;\r\n    } else {\r\n      let gfx: Graphic = null;\r\n      if (nameOrGraphic instanceof Graphic) {\r\n        gfx = nameOrGraphic;\r\n      } else {\r\n        gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      }\r\n      this.graphics = this.graphics.filter((g) => g.graphic !== gfx);\r\n      this._graphics.recalculateBounds();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.\r\n   *\r\n   * If `show()` is called multiple times for the same graphic it will be shown multiple times.\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    let gfx: Graphic;\r\n    if (nameOrGraphic instanceof Graphic) {\r\n      gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;\r\n    } else {\r\n      gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      if (!gfx) {\r\n        Logger.getInstance().error(\r\n          `No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `,\r\n          this._graphics.getNames()\r\n        );\r\n      }\r\n    }\r\n    if (gfx) {\r\n      this.graphics.push({ graphic: gfx, options });\r\n      this._graphics.recalculateBounds();\r\n      return gfx as T;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use a specific graphic, swap out any current graphics being shown\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    this.hide();\r\n    return this.show<T>(nameOrGraphic, options);\r\n  }\r\n\r\n  /**\r\n   * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public get order(): number {\r\n    return this._options.order;\r\n  }\r\n\r\n  /**\r\n   * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public set order(order: number) {\r\n    this._options.order = order;\r\n  }\r\n\r\n  /**\r\n   * Get or set the pixel offset from the layer anchor for all graphics in the layer\r\n   */\r\n  public get offset(): Vector {\r\n    return this._options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  public set offset(value: Vector) {\r\n    this._options.offset = value;\r\n  }\r\n\r\n  public get currentKeys(): string {\r\n    return this.name ?? 'anonymous';\r\n  }\r\n}\r\n\r\nexport class GraphicsLayers {\r\n  private _layers: GraphicsLayer[] = [];\r\n  private _layerMap: { [layerName: string]: GraphicsLayer } = {};\r\n  public default: GraphicsLayer;\r\n  constructor(private _component: GraphicsComponent) {\r\n    this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);\r\n    this._maybeAddLayer(this.default);\r\n  }\r\n  public create(options: GraphicsLayerOptions): GraphicsLayer {\r\n    const layer = new GraphicsLayer(options, this._component);\r\n    return this._maybeAddLayer(layer);\r\n  }\r\n\r\n  /**\r\n   * Retrieve a single layer by name\r\n   * @param name\r\n   */\r\n  public get(name: string): GraphicsLayer;\r\n  /**\r\n   * Retrieve all layers\r\n   */\r\n  public get(): readonly GraphicsLayer[];\r\n  public get(name?: string): GraphicsLayer | readonly GraphicsLayer[] {\r\n    if (name) {\r\n      return this._getLayer(name);\r\n    }\r\n    return this._layers;\r\n  }\r\n\r\n  public currentKeys() {\r\n    const graphicsLayerKeys = [];\r\n    for (const layer of this._layers) {\r\n      graphicsLayerKeys.push(layer.currentKeys);\r\n    }\r\n    return graphicsLayerKeys;\r\n  }\r\n\r\n  public has(name: string): boolean {\r\n    return name in this._layerMap;\r\n  }\r\n\r\n  private _maybeAddLayer(layer: GraphicsLayer) {\r\n    if (this._layerMap[layer.name]) {\r\n      // todo log warning\r\n      return this._layerMap[layer.name];\r\n    }\r\n    this._layerMap[layer.name] = layer;\r\n    this._layers.push(layer);\r\n    this._layers.sort((a, b) => a.order - b.order);\r\n    return layer;\r\n  }\r\n\r\n  private _getLayer(name: string): GraphicsLayer | undefined {\r\n    return this._layerMap[name];\r\n  }\r\n}\r\n\r\n/**\r\n * Component to manage drawings, using with the position component\r\n */\r\nexport class GraphicsComponent extends Component<'ex.graphics'> {\r\n  readonly type = 'ex.graphics';\r\n\r\n  private _graphics: { [graphicName: string]: Graphic } = {};\r\n\r\n  public layers: GraphicsLayers;\r\n\r\n  public getGraphic(name: string): Graphic | undefined {\r\n    return this._graphics[name];\r\n  }\r\n\r\n  /**\r\n   * Get registered graphics names\r\n   */\r\n  public getNames(): string[] {\r\n    return Object.keys(this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Draws after the entity transform has bene applied, but before graphics component graphics have been drawn\r\n   */\r\n  public onPreDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Draws after the entity transform has been applied, and after graphics component graphics has been drawn\r\n   */\r\n  public onPostDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Sets or gets wether any drawing should be visible in this component\r\n   */\r\n  public visible: boolean = true;\r\n\r\n  /**\r\n   * Sets or gets wither all drawings should have an opacity applied\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  /**\r\n   * Offset to apply to graphics by default\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Anchor to apply to graphics by default\r\n   */\r\n  public anchor: Vector = Vector.Half;\r\n\r\n  /**\r\n   * If set to true graphics added to the component will be copied. This can affect performance\r\n   */\r\n  public copyGraphics: boolean = false;\r\n\r\n  constructor(options?: GraphicsComponentOptions) {\r\n    super();\r\n    // Defaults\r\n    options = {\r\n      visible: this.visible,\r\n      ...options\r\n    };\r\n\r\n    const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;\r\n\r\n    this._graphics = graphics || {};\r\n    this.offset = offset ?? this.offset;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.anchor = anchor ?? this.anchor;\r\n    this.copyGraphics = copyGraphics ?? this.copyGraphics;\r\n    this.onPreDraw = onPreDraw ?? this.onPreDraw;\r\n    this.onPostDraw = onPostDraw ?? this.onPostDraw;\r\n    this.visible = !!visible;\r\n\r\n    this.layers = new GraphicsLayers(this);\r\n    if (current && this._graphics[current]) {\r\n      this.show(this._graphics[current]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the currently displayed graphics and their offsets, empty array if hidden\r\n   */\r\n  public get current(): { graphic: Graphic; options: GraphicsShowOptions }[] {\r\n    return this.layers.default.graphics;\r\n  }\r\n\r\n  /**\r\n   * Returns all graphics associated with this component\r\n   */\r\n  public get graphics(): { [graphicName: string]: Graphic } {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Adds a named graphic to this component, if the name is \"default\" or not specified, it will be shown by default without needing to call\r\n   * `show(\"default\")`\r\n   * @param graphic\r\n   */\r\n  public add(graphic: Graphic): Graphic;\r\n  public add(name: string, graphic: Graphic): Graphic;\r\n  public add(nameOrGraphic: string | Graphic, graphic?: Graphic): Graphic {\r\n    let name = 'default';\r\n    let graphicToSet: Graphic = null;\r\n    if (typeof nameOrGraphic === 'string') {\r\n      name = nameOrGraphic;\r\n      graphicToSet = graphic;\r\n    } else {\r\n      graphicToSet = nameOrGraphic;\r\n    }\r\n\r\n    this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;\r\n    if (name === 'default') {\r\n      this.show('default');\r\n    }\r\n    return graphicToSet;\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name on the **default** layer, returns the new [[Graphic]]\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    const result = this.layers.default.show<T>(nameOrGraphic, options);\r\n    this.recalculateBounds();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    const result = this.layers.default.use<T>(nameOrGraphic, options);\r\n    this.recalculateBounds();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in the **default** layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in the **default** layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    this.layers.default.hide(nameOrGraphic);\r\n  }\r\n\r\n  private _localBounds: BoundingBox = null;\r\n  public set localBounds(bounds: BoundingBox) {\r\n    this._localBounds = bounds;\r\n  }\r\n\r\n  public recalculateBounds() {\r\n    let bb = new BoundingBox();\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic, options } of layer.graphics) {\r\n        let anchor = this.anchor;\r\n        let offset = this.offset;\r\n        if (options?.anchor) {\r\n          anchor = options.anchor;\r\n        }\r\n        if (options?.offset) {\r\n          offset = options.offset;\r\n        }\r\n        const bounds = graphic.localBounds;\r\n        const offsetX = -bounds.width *  anchor.x + offset.x;\r\n        const offsetY = -bounds.height *  anchor.y + offset.y;\r\n        bb = graphic?.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);\r\n      }\r\n    }\r\n    this._localBounds = bb;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    if (!this._localBounds || this._localBounds.hasZeroDimensions()) {\r\n      this.recalculateBounds();\r\n    }\r\n    return this._localBounds;\r\n  }\r\n\r\n  /**\r\n   * Update underlying graphics if necesary, called internally\r\n   * @param elapsed\r\n   * @internal\r\n   */\r\n  public update(elapsed: number, idempotencyToken: number = 0) {\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic } of layer.graphics) {\r\n        if (hasGraphicsTick(graphic)) {\r\n          graphic?.tick(elapsed, idempotencyToken);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface RectangleOptions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\n/**\r\n * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]\r\n */\r\nexport class Rectangle extends Raster {\r\n  constructor(options: RasterOptions & RectangleOptions) {\r\n    super(options);\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Rectangle {\r\n    return new Rectangle({\r\n      width: this.width,\r\n      height: this.height,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.color) {\r\n      ctx.fillRect(0, 0, this.width, this.height);\r\n    }\r\n    if (this.strokeColor) {\r\n      ctx.strokeRect(0, 0, this.width, this.height);\r\n    }\r\n  }\r\n}\r\n","import { ImageFiltering } from '.';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CircleOptions {\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Circles default to [[ImageFiltering.Blended]]\r\n */\r\nexport class Circle extends Raster {\r\n  private _radius: number = 0;\r\n  public get radius() {\r\n    return this._radius;\r\n  }\r\n  public set radius(value: number) {\r\n    this._radius = value;\r\n    this.width = this._radius * 2;\r\n    this.height = this._radius * 2;\r\n    this.flagDirty();\r\n  }\r\n  constructor(options: RasterOptions & CircleOptions) {\r\n    super(options);\r\n    this.padding = options.padding ?? 2; // default 2 padding for circles looks nice\r\n    this.radius = options.radius;\r\n    this.filtering = options.filtering ?? ImageFiltering.Blended;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Circle {\r\n    return new Circle({\r\n      radius: this.radius,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.radius > 0) {\r\n      ctx.beginPath();\r\n      ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);\r\n\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Add this component to optionally configure how the pointer\r\n * system detects pointer events.\r\n *\r\n * By default the collider shape is used and graphics bounds is not.\r\n *\r\n * If both collider shape and graphics bounds are enabled it will fire events if either or\r\n * are intersecting the pointer.\r\n */\r\nexport class PointerComponent extends Component<'ex.pointer'> {\r\n  public readonly type = 'ex.pointer';\r\n  /**\r\n   * Use any existing Collider component geometry for pointer events. This is useful if you want\r\n   * user pointer events only to trigger on the same collision geometry used in the collider component\r\n   * for collision resolution. Default is `true`.\r\n   */\r\n  public useColliderShape = true;\r\n  /**\r\n   * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned\r\n   * bounds around the graphic to trigger pointer events. Default is `false`.\r\n   */\r\n  public useGraphicsBounds = false;\r\n}","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * A definition of an EasingFunction. See [[EasingFunctions]].\r\n */\r\n// tslint:disable-next-line\r\nexport interface EasingFunction {\r\n  (currentTime: number, startValue: number, endValue: number, duration: number): number;\r\n}\r\n\r\n/**\r\n * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\r\n * Given a time, the function will return a value from positive startValue to positive endValue.\r\n *\r\n * ```js\r\n * function Linear (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInQuad (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutQuad (t) {\r\n *    return t * (2 - t);\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutQuad (t) {\r\n *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInCubic (t) {\r\n *    return t * t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutCubic (t) {\r\n *    return (--t) * t * t + 1;\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutCubic (t) {\r\n *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n * }\r\n * ```\r\n */\r\nexport class EasingFunctions {\r\n  public static CreateReversibleEasingFunction(easing: EasingFunction) {\r\n    return (time: number, start: number, end: number, duration: number) => {\r\n      if (end < start) {\r\n        return start - (easing(time, end, start, duration) - end);\r\n      } else {\r\n        return easing(time, start, end, duration);\r\n      }\r\n    };\r\n  }\r\n\r\n  public static CreateVectorEasingFunction(easing: EasingFunction) {\r\n    return (time: number, start: Vector, end: Vector, duration: number) => {\r\n      return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));\r\n    };\r\n  }\r\n\r\n  public static Linear: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      return (endValue * currentTime) / duration + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInQuad = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n\r\n      return endValue * currentTime * currentTime + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      return -endValue * currentTime * (currentTime - 2) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration / 2;\r\n\r\n      if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime + startValue;\r\n      }\r\n      currentTime--;\r\n\r\n      return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      return endValue * currentTime * currentTime * currentTime + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      currentTime--;\r\n      return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration / 2;\r\n      if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;\r\n      }\r\n      currentTime -= 2;\r\n      return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;\r\n    }\r\n  );\r\n}\r\n","import { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * Action Queues represent an ordered sequence of actions\r\n *\r\n * Action queues are part of the [[ActionContext|Action API]] and\r\n * store the list of actions to be executed for an [[Actor]].\r\n *\r\n * Actors implement [[Actor.actions]] which can be manipulated by\r\n * advanced users to adjust the actions currently being executed in the\r\n * queue.\r\n */\r\nexport class ActionQueue {\r\n  private _entity: Entity;\r\n  private _actions: Action[] = [];\r\n  private _currentAction: Action;\r\n  private _completedActions: Action[] = [];\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  /**\r\n   * Add an action to the sequence\r\n   * @param action\r\n   */\r\n  public add(action: Action) {\r\n    this._actions.push(action);\r\n  }\r\n\r\n  /**\r\n   * Remove an action by reference from the sequence\r\n   * @param action\r\n   */\r\n  public remove(action: Action) {\r\n    const index = this._actions.indexOf(action);\r\n    this._actions.splice(index, 1);\r\n  }\r\n\r\n  /**\r\n   * Removes all actions from this sequence\r\n   */\r\n  public clearActions(): void {\r\n    this._actions.length = 0;\r\n    this._completedActions.length = 0;\r\n    if (this._currentAction) {\r\n      this._currentAction.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns The total list of actions in this sequence complete or not\r\n   */\r\n  public getActions(): Action[] {\r\n    return this._actions.concat(this._completedActions);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns `true` if there are more actions to process in the sequence\r\n   */\r\n  public hasNext(): boolean {\r\n    return this._actions.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @returns `true` if the current sequence of actions is done\r\n   */\r\n  public isComplete(): boolean {\r\n    return this._actions.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Resets the sequence of actions, this is used to restart a sequence from the beginning\r\n   */\r\n  public reset(): void {\r\n    this._actions = this.getActions();\r\n\r\n    const len = this._actions.length;\r\n    for (let i = 0; i < len; i++) {\r\n      this._actions[i].reset();\r\n    }\r\n    this._completedActions = [];\r\n  }\r\n\r\n  /**\r\n   * Update the queue which updates actions and handles completing actions\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number) {\r\n    if (this._actions.length > 0) {\r\n      this._currentAction = this._actions[0];\r\n      this._currentAction.update(elapsedMs);\r\n\r\n      if (this._currentAction.isComplete(this._entity)) {\r\n        this._completedActions.push(this._actions.shift());\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\nexport class Repeat implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _repeat: number;\r\n  private _originalRepeat: number;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any, repeat: number) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeat = repeat;\r\n    this._originalRepeat = repeat;\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n    this._repeat--; // current execution is the first repeat\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n      this._repeat--;\r\n    }\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._repeat = this._originalRepeat;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\n/**\r\n * RepeatForever Action implementation, it is recommended you use the fluent action\r\n * context API.\r\n *\r\n *\r\n */\r\nexport class RepeatForever implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._stopped) {\r\n      return;\r\n    }\r\n\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n    }\r\n\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n    this._actionQueue.clearActions();\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _entity: Entity;\r\n  public x: number;\r\n  public y: number;\r\n  private _distance: number;\r\n  private _speed: number;\r\n\r\n  private _start: Vector;\r\n  private _offset: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, offsetX: number, offsetY: number, speed: number) {\r\n    this._entity = entity;\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = new Vector(offsetX, offsetY);\r\n    if (speed <= 0) {\r\n      Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);\r\n      throw new Error('Speed must be greater than 0 pixels per second');\r\n    }\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._end = this._start.add(this._offset);\r\n      this._distance = this._offset.size;\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n\r\n    if (this.isComplete(this._entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    } else {\r\n      this._motion.vel = this._dir.scale(this._speed);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || tx.pos.distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distance: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(public entity: Entity, destx: number, desty: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = new Vector(destx, desty);\r\n    this._speed = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._distance = this._start.distance(this._end);\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete(this.entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the strategies that rotation actions can use\r\n */\r\nexport enum RotationType {\r\n  /**\r\n   * Rotation via `ShortestPath` will use the smallest angle\r\n   * between the starting and ending points. This strategy is the default behavior.\r\n   */\r\n  ShortestPath = 0,\r\n  /**\r\n   * Rotation via `LongestPath` will use the largest angle\r\n   * between the starting and ending points.\r\n   */\r\n  LongestPath = 1,\r\n  /**\r\n   * Rotation via `Clockwise` will travel in a clockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  Clockwise = 2,\r\n  /**\r\n   * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  CounterClockwise = 3\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { TwoPI } from '../../Math/util';\r\n\r\nexport class RotateTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadians: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = angleRadians;\r\n    this._speed = speed;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (!this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTraveled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { TwoPI } from '../../Math/util';\r\n\r\nexport class RotateBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _offset: number;\r\n\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadiansOffset: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = angleRadiansOffset;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      this._end = this._start + this._offset;\r\n\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortDistance >= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (this._shortDistance <= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTraveled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n    this._start = undefined;\r\n    this._currentNonCannonAngle = undefined;\r\n    this._distance = undefined;\r\n  }\r\n}\r\n","import { vec } from '../../Math/vector';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\n\r\nexport class ScaleTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startX: number;\r\n  private _startY: number;\r\n  private _endX: number;\r\n  private _endY: number;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, scaleX: number, scaleY: number, speedX: number, speedY: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._endX = scaleX;\r\n    this._endY = scaleY;\r\n    this._speedX = speedX;\r\n    this._speedY = speedY;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startX = this._tx.scale.x;\r\n      this._startY = this._tx.scale.y;\r\n      this._distanceX = Math.abs(this._endX - this._startX);\r\n      this._distanceY = Math.abs(this._endY - this._startY);\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {\r\n      const directionX = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.x = this._speedX * directionX;\r\n    } else {\r\n      this._motion.scaleFactor.x = 0;\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {\r\n      const directionY = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.y = this._speedY * directionY;\r\n    } else {\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = vec(this._endX, this._endY);\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.y - this._startX) >= (this._distanceX - 0.01) &&\r\n        Math.abs(this._tx.scale.y - this._startY) >= (this._distanceY - 0.01))\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\n\r\nexport class ScaleBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startScale: Vector;\r\n  private _endScale: Vector;\r\n  private _offset: Vector;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _directionX: number;\r\n  private _directionY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  constructor(entity: Entity, scaleOffsetX: number, scaleOffsetY: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._offset = new Vector(scaleOffsetX, scaleOffsetY);\r\n    this._speedX = this._speedY = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startScale = this._tx.scale.clone();\r\n      this._endScale = this._startScale.add(this._offset);\r\n      this._distanceX = Math.abs(this._endScale.x - this._startScale.x);\r\n      this._distanceY = Math.abs(this._endScale.y - this._startScale.y);\r\n      this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;\r\n      this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;\r\n    }\r\n\r\n    this._motion.scaleFactor.x = this._speedX * this._directionX;\r\n    this._motion.scaleFactor.y = this._speedY * this._directionY;\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = this._endScale;\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.x - this._startScale.x) >= (this._distanceX - 0.01) &&\r\n        Math.abs(this._tx.scale.y - this._startScale.y) >= (this._distanceY - 0.01))\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class CallMethod implements Action {\r\n  private _method: () => any = null;\r\n  private _hasBeenCalled: boolean = false;\r\n  constructor(method: () => any) {\r\n    this._method = method;\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    this._method();\r\n    this._hasBeenCalled = true;\r\n  }\r\n  public isComplete() {\r\n    return this._hasBeenCalled;\r\n  }\r\n  public reset() {\r\n    this._hasBeenCalled = false;\r\n  }\r\n  public stop() {\r\n    this._hasBeenCalled = true;\r\n  }\r\n}\r\n","import { Entity} from '../../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class EaseTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1 * 1000; // 1 second\r\n  private _lerpStart: Vector = new Vector(0, 0);\r\n  private _lerpEnd: Vector = new Vector(0, 0);\r\n  private _initialized: boolean = false;\r\n  private _stopped: boolean = false;\r\n  constructor(\r\n    entity: Entity,\r\n    x: number,\r\n    y: number,\r\n    duration: number,\r\n    public easingFcn: (currentTime: number, startValue: number, endValue: number, duration: number) => number\r\n  ) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = new Vector(x, y);\r\n  }\r\n  private _initialize() {\r\n    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._currentLerpTime = 0;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._initialized) {\r\n      this._initialize();\r\n      this._initialized = true;\r\n    }\r\n\r\n    // Need to update lerp time first, otherwise the first update will always be zero\r\n    this._currentLerpTime += delta;\r\n    let newX = this._tx.pos.x;\r\n    let newY = this._tx.pos.y;\r\n    if (this._currentLerpTime < this._lerpDuration) {\r\n      if (this._lerpEnd.x < this._lerpStart.x) {\r\n        newX =\r\n          this._lerpStart.x -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n      } else {\r\n        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n      }\r\n\r\n      if (this._lerpEnd.y < this._lerpStart.y) {\r\n        newY =\r\n          this._lerpStart.y -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n      } else {\r\n        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n      }\r\n      // Given the lerp position figure out the velocity in pixels per second\r\n      this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n    } else {\r\n      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n      this._motion.vel = Vector.Zero;\r\n    }\r\n  }\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._currentLerpTime >= this._lerpDuration;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._initialized = false;\r\n    this._stopped = false;\r\n    this._currentLerpTime = 0;\r\n  }\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class EaseBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1 * 1000; // 1 second\r\n  private _lerpStart: Vector = new Vector(0, 0);\r\n  private _lerpEnd: Vector = new Vector(0, 0);\r\n  private _offset: Vector;\r\n  private _initialized: boolean = false;\r\n  private _stopped: boolean = false;\r\n  constructor(\r\n    entity: Entity,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    duration: number,\r\n    public easingFcn: (currentTime: number, startValue: number, endValue: number, duration: number) => number\r\n  ) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._lerpDuration = duration;\r\n    this._offset = new Vector(offsetX, offsetY);\r\n  }\r\n  private _initialize() {\r\n    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._currentLerpTime = 0;\r\n    this._lerpEnd = this._lerpStart.add(this._offset);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._initialized) {\r\n      this._initialize();\r\n      this._initialized = true;\r\n    }\r\n\r\n    // Need to update lerp time first, otherwise the first update will always be zero\r\n    this._currentLerpTime += delta;\r\n    let newX = this._tx.pos.x;\r\n    let newY = this._tx.pos.y;\r\n    if (this._currentLerpTime < this._lerpDuration) {\r\n      if (this._lerpEnd.x < this._lerpStart.x) {\r\n        newX =\r\n          this._lerpStart.x -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n      } else {\r\n        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n      }\r\n\r\n      if (this._lerpEnd.y < this._lerpStart.y) {\r\n        newY =\r\n          this._lerpStart.y -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n      } else {\r\n        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n      }\r\n      // Given the lerp position figure out the velocity in pixels per second\r\n      this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n    } else {\r\n      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n      this._motion.vel = Vector.Zero;\r\n    }\r\n  }\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._currentLerpTime >= this._lerpDuration;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._initialized = false;\r\n    this._stopped = false;\r\n    this._currentLerpTime = 0;\r\n  }\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n}","import { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\n\r\nexport class Blink implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  private _timeVisible: number = 0;\r\n  private _timeNotVisible: number = 0;\r\n  private _elapsedTime: number = 0;\r\n  private _totalTime: number = 0;\r\n  private _duration: number;\r\n  private _stopped: boolean = false;\r\n  private _started: boolean = false;\r\n  constructor(entity: Entity, timeVisible: number, timeNotVisible: number, numBlinks: number = 1) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._timeVisible = timeVisible;\r\n    this._timeNotVisible = timeNotVisible;\r\n    this._duration = (timeVisible + timeNotVisible) * numBlinks;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._elapsedTime = 0;\r\n      this._totalTime = 0;\r\n    }\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n    this._totalTime += delta;\r\n    if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {\r\n      this._graphics.visible = false;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {\r\n      this._graphics.visible = true;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.visible = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._totalTime >= this._duration;\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this._graphics) {\r\n      this._graphics.visible = true;\r\n    }\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset() {\r\n    this._started = false;\r\n    this._stopped = false;\r\n    this._elapsedTime = 0;\r\n    this._totalTime = 0;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class Fade implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  public x: number;\r\n  public y: number;\r\n\r\n  private _endOpacity: number;\r\n  private _speed: number;\r\n  private _ogspeed: number;\r\n  private _multiplier: number = 1;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, endOpacity: number, speed: number) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._endOpacity = endOpacity;\r\n    this._speed = this._ogspeed = speed;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._speed = this._ogspeed;\r\n\r\n      // determine direction when we start\r\n      if (this._endOpacity < this._graphics.opacity) {\r\n        this._multiplier = -1;\r\n      } else {\r\n        this._multiplier = 1;\r\n      }\r\n    }\r\n\r\n    if (this._speed > 0) {\r\n      this._graphics.opacity += (this._multiplier *\r\n        (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;\r\n    }\r\n\r\n    this._speed -= delta;\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.opacity = this._endOpacity;\r\n    }\r\n\r\n    Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class Delay implements Action {\r\n  private _elapsedTime: number = 0;\r\n  private _delay: number;\r\n  private _started: boolean = false;\r\n  private _stopped = false;\r\n  constructor(delay: number) {\r\n    this._delay = delay;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n  }\r\n\r\n  isComplete(): boolean {\r\n    return this._stopped || this._elapsedTime >= this._delay;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  reset(): void {\r\n    this._elapsedTime = 0;\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionsComponent } from '../ActionsComponent';\r\n\r\nexport class Die implements Action {\r\n  private _entity: Entity;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    this._entity.get(ActionsComponent).clearActions();\r\n    this._entity.kill();\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    return;\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Follow implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _followTx: TransformComponent;\r\n  private _followMotion: MotionComponent;\r\n\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _maximumDistance: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, entityToFollow: Entity, followDistance?: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._followTx = entityToFollow.get(TransformComponent);\r\n    this._followMotion = entityToFollow.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);\r\n    this._speed = 0;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));\r\n    if (actorToFollowSpeed !== 0) {\r\n      this._speed = actorToFollowSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    if (this._distanceBetween >= this._maximumDistance) {\r\n      const m = this._dir.scale(this._speed);\r\n      this._motion.vel = vec(m.x, m.y);\r\n    } else {\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    // the actor following should never stop unless specified to do so\r\n    return this._stopped;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Meet implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _meetTx: TransformComponent;\r\n  private _meetMotion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedWasSpecified = false;\r\n\r\n  constructor(actor: Entity, actorToMeet: Entity, speed?: number) {\r\n    this._tx = actor.get(TransformComponent);\r\n    this._motion = actor.get(MotionComponent);\r\n    this._meetTx = actorToMeet.get(TransformComponent);\r\n    this._meetMotion = actorToMeet.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._speed = speed || 0;\r\n\r\n    if (speed !== undefined) {\r\n      this._speedWasSpecified = true;\r\n    }\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));\r\n    if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {\r\n      this._speed = actorToMeetSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._distanceBetween <= 1;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n    this._stopped = false;\r\n    this._distanceBetween = undefined;\r\n  }\r\n}\r\n","import { RotationType } from './RotationType';\r\n\r\nimport { EasingFunction, EasingFunctions } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { Repeat } from './Action/Repeat';\r\nimport { RepeatForever } from './Action/RepeatForever';\r\nimport { MoveBy } from './Action/MoveBy';\r\nimport { MoveTo } from './Action/MoveTo';\r\nimport { RotateTo } from './Action/RotateTo';\r\nimport { RotateBy } from './Action/RotateBy';\r\nimport { ScaleTo } from './Action/ScaleTo';\r\nimport { ScaleBy } from './Action/ScaleBy';\r\nimport { CallMethod } from './Action/CallMethod';\r\nimport { EaseTo } from './Action/EaseTo';\r\nimport { EaseBy } from './Action/EaseBy';\r\nimport { Blink } from './Action/Blink';\r\nimport { Fade } from './Action/Fade';\r\nimport { Delay } from './Action/Delay';\r\nimport { Die } from './Action/Die';\r\nimport { Follow } from './Action/Follow';\r\nimport { Meet } from './Action/Meet';\r\nimport { Vector } from '../Math/vector';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * The fluent Action API allows you to perform \"actions\" on\r\n * [[Actor|Actors]] such as following, moving, rotating, and\r\n * more. You can implement your own actions by implementing\r\n * the [[Action]] interface.\r\n */\r\nexport class ActionContext {\r\n  private _entity: Entity;\r\n  private _queue: ActionQueue;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n    this._queue = new ActionQueue(entity);\r\n  }\r\n\r\n  public getQueue(): ActionQueue {\r\n    return this._queue;\r\n  }\r\n\r\n  public update(elapsedMs: number) {\r\n    this._queue.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._queue.clearActions();\r\n  }\r\n\r\n  public runAction(action: Action) {\r\n    action.reset();\r\n    this._queue.add(action);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  public easeTo(...args: any[]): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let duration = 0;\r\n    let easingFcn = EasingFunctions.Linear;\r\n    if (args[0] instanceof Vector) {\r\n      x = args[0].x;\r\n      y = args[0].y;\r\n      duration = args[1];\r\n      easingFcn = args[2] ?? easingFcn;\r\n    } else {\r\n      x = args[0];\r\n      y = args[1];\r\n      duration = args[2];\r\n      easingFcn = args[3] ?? easingFcn;\r\n    }\r\n\r\n    this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by a specified vector offset relative to the current position given\r\n   * a duration and a [[EasingFunction]]. This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset Vector offset relative to the current position\r\n   * @param duration The duration in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeBy(offset: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  /**\r\n   * This method will move an actor by a specified x and y offset relative to the current position given\r\n   * a duration and a [[EasingFunction]]. This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset Vector offset relative to the current position\r\n   * @param duration The duration in milliseconds\r\n   * @param easingFcn Use [[EasingFunction]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeBy(offsetX: number, offsetY: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeBy(...args: any[]): ActionContext {\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n    let duration = 0;\r\n    let easingFcn = EasingFunctions.Linear;\r\n    if (args[0] instanceof Vector) {\r\n      offsetX = args[0].x;\r\n      offsetY = args[0].y;\r\n      duration = args[1];\r\n      easingFcn = args[2] ?? easingFcn;\r\n    } else {\r\n      offsetX = args[0];\r\n      offsetY = args[1];\r\n      duration = args[2];\r\n      easingFcn = args[3] ?? easingFcn;\r\n    }\r\n\r\n    this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let speed = 0;\r\n    if (xOrPos instanceof Vector) {\r\n      x = xOrPos.x;\r\n      y = xOrPos.y;\r\n      speed = yOrSpeed;\r\n    } else {\r\n      x = xOrPos;\r\n      y = yOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveTo(this._entity, x, y, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let xOffset = 0;\r\n    let yOffset = 0;\r\n    let speed = 0;\r\n    if (xOffsetOrVector instanceof Vector) {\r\n      xOffset = xOffsetOrVector.x;\r\n      yOffset = xOffsetOrVector.y;\r\n      speed = yOffsetOrSpeed;\r\n    } else {\r\n      xOffset = xOffsetOrVector;\r\n      yOffset = yOffsetOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number | undefined,\r\n    speedYOrUndefined?: number | undefined): ActionContext {\r\n\r\n    let sizeX = 1;\r\n    let sizeY = 1;\r\n    let speedX = 0;\r\n    let speedY = 0;\r\n\r\n    if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {\r\n      sizeX = sizeXOrVector.x;\r\n      sizeY = sizeXOrVector.y;\r\n\r\n      speedX = sizeYOrSpeed.x;\r\n      speedY = sizeYOrSpeed.y;\r\n    }\r\n    if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {\r\n      sizeX = sizeXOrVector;\r\n      sizeY = sizeYOrSpeed;\r\n\r\n      speedX = speedXOrUndefined;\r\n      speedY = speedYOrUndefined;\r\n    }\r\n\r\n    this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number | undefined): ActionContext {\r\n    let sizeOffsetX = 1;\r\n    let sizeOffsetY = 1;\r\n\r\n    if (sizeOffsetXOrVector instanceof Vector) {\r\n      sizeOffsetX = sizeOffsetXOrVector.x;\r\n      sizeOffsetY = sizeOffsetXOrVector.y;\r\n\r\n      speed = sizeOffsetYOrSpeed;\r\n    }\r\n    if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {\r\n      sizeOffsetX = sizeOffsetXOrVector;\r\n      sizeOffsetY = sizeOffsetYOrSpeed;\r\n    }\r\n\r\n    this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks: number = 1): ActionContext {\r\n    this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    this._queue.add(new Fade(this._entity, opacity, time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    this._queue.add(new Delay(time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    this._queue.add(new Die(this._entity));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    this._queue.add(new CallMethod(method));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    if (!times) {\r\n      this.repeatForever(repeatBuilder);\r\n      return this;\r\n    }\r\n    this._queue.add(new Repeat(this._entity, repeatBuilder, times));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    this._queue.add(new RepeatForever(this._entity, repeatBuilder));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Entity, followDistance?: number): ActionContext {\r\n    if (followDistance === undefined) {\r\n      this._queue.add(new Follow(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Follow(this._entity, entity, followDistance));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Entity, speed?: number): ActionContext {\r\n    if (speed === undefined) {\r\n      this._queue.add(new Meet(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Meet(this._entity, entity, speed));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    const temp = new Promise<void>((resolve) => {\r\n      this._queue.add(\r\n        new CallMethod(() => {\r\n          resolve();\r\n        })\r\n      );\r\n    });\r\n    return temp;\r\n  }\r\n}\r\n","import { ActionContext } from './ActionContext';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Actor } from '../Actor';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Vector } from '../Math/vector';\r\nimport { EasingFunction } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { RotationType } from './RotationType';\r\nimport { Action } from './Action';\r\n\r\nexport interface ActionContextMethods extends Pick<ActionContext, keyof ActionContext> { };\r\n\r\nexport class ActionsComponent extends Component<'ex.actions'> implements ActionContextMethods {\r\n  public readonly type = 'ex.actions';\r\n  dependencies = [TransformComponent, MotionComponent];\r\n  private _ctx: ActionContext;\r\n\r\n  onAdd(entity: Entity) {\r\n    this._ctx = new ActionContext(entity);\r\n  }\r\n\r\n  onRemove() {\r\n    this._ctx = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal action queue\r\n   * @returns action queue\r\n   */\r\n  public getQueue(): ActionQueue {\r\n    return this._ctx?.getQueue();\r\n  }\r\n\r\n  public runAction(action: Action): ActionContext {\r\n    return this._ctx?.runAction(action);\r\n  }\r\n\r\n  /**\r\n   * Updates the internal action context, performing action and moving through the internal queue\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number): void {\r\n    return this._ctx?.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._ctx?.clearActions();\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeTo(...args: any[]): ActionContext {\r\n    return this._ctx.easeTo.apply(this._ctx, args);\r\n  }\r\n\r\n  public easeBy(offset: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeBy(offsetX: number, offsetY: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeBy(...args: any[]): ActionContext {\r\n    return this._ctx.easeBy.apply(this._ctx, args);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset The (x, y) offset to apply to this actor\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateTo(angleRadians, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(\r\n    sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number,\r\n    speedYOrUndefined?: number): ActionContext {\r\n    return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number): ActionContext {\r\n    return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks?: number): ActionContext {\r\n    return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    return this._ctx.fade(opacity, time);\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    return this._ctx.delay(time);\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    return this._ctx.die();\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    return this._ctx.callMethod(method);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    return this._ctx.repeat(repeatBuilder, times);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    return this._ctx.repeatForever(repeatBuilder);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Actor, followDistance?: number): ActionContext {\r\n    return this._ctx.follow(entity, followDistance);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Actor, speed?: number): ActionContext {\r\n    return this._ctx.meet(entity, speed);\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    return this._ctx.toPromise();\r\n  }\r\n}","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\n\r\n/**\r\n * Enum representing the different font size units\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\r\n */\r\nexport enum FontUnit {\r\n  /**\r\n   * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\r\n   */\r\n  Em = 'em',\r\n  /**\r\n   * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element\r\n   */\r\n  Rem = 'rem',\r\n  /**\r\n   * Pixel is a unit of length in screen pixels\r\n   */\r\n  Px = 'px',\r\n  /**\r\n   * Point is a physical unit length (1/72 of an inch)\r\n   */\r\n  Pt = 'pt',\r\n  /**\r\n   * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\r\n   */\r\n  Percent = '%'\r\n}\r\n\r\n/**\r\n * Enum representing the different horizontal text alignments\r\n */\r\nexport enum TextAlign {\r\n  /**\r\n   * The text is left-aligned.\r\n   */\r\n  Left = 'left',\r\n  /**\r\n   * The text is right-aligned.\r\n   */\r\n  Right = 'right',\r\n  /**\r\n   * The text is centered.\r\n   */\r\n  Center = 'center',\r\n  /**\r\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\r\n   * right-aligned for right-to-left locales).\r\n   */\r\n  Start = 'start',\r\n  /**\r\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\r\n   * left-aligned for right-to-left locales).\r\n   */\r\n  End = 'end'\r\n}\r\n\r\n/**\r\n * Enum representing the different baseline text alignments\r\n */\r\nexport enum BaseAlign {\r\n  /**\r\n   * The text baseline is the top of the em square.\r\n   */\r\n  Top = 'top',\r\n  /**\r\n   * The text baseline is the hanging baseline.  Currently unsupported; this will act like\r\n   * alphabetic.\r\n   */\r\n  Hanging = 'hanging',\r\n  /**\r\n   * The text baseline is the middle of the em square.\r\n   */\r\n  Middle = 'middle',\r\n  /**\r\n   * The text baseline is the normal alphabetic baseline.\r\n   */\r\n  Alphabetic = 'alphabetic',\r\n  /**\r\n   * The text baseline is the ideographic baseline; this is the bottom of\r\n   * the body of the characters, if the main body of characters protrudes\r\n   * beneath the alphabetic baseline.  Currently unsupported; this will\r\n   * act like alphabetic.\r\n   */\r\n  Ideographic = 'ideographic',\r\n  /**\r\n   * The text baseline is the bottom of the bounding box.  This differs\r\n   * from the ideographic baseline in that the ideographic baseline\r\n   * doesn't consider descenders.\r\n   */\r\n  Bottom = 'bottom'\r\n}\r\n\r\n/**\r\n * Enum representing the different possible font styles\r\n */\r\nexport enum FontStyle {\r\n  Normal = 'normal',\r\n  Italic = 'italic',\r\n  Oblique = 'oblique'\r\n}\r\n\r\n/**\r\n * Enum representing the text direction, useful for other languages, or writing text in reverse\r\n */\r\nexport enum Direction {\r\n  LeftToRight = 'ltr',\r\n  RightToLeft = 'rtl'\r\n}\r\n\r\n/**\r\n * Font rendering option\r\n */\r\nexport interface FontOptions {\r\n  /**\r\n   * Optionally the size of the font in the specified [[FontUnit]] by default 10.\r\n   */\r\n  size?: number;\r\n  /**\r\n   * Optionally specify unit to measure fonts in, by default Pixels\r\n   */\r\n  unit?: FontUnit;\r\n  /**\r\n   * Optionally specify the font family, by default 'sans-serif'\r\n   */\r\n  family?: string;\r\n  /**\r\n   * Optionally specify the font style, by default Normal\r\n   */\r\n  style?: FontStyle;\r\n  /**\r\n   * Optionally set whether the font is bold, by default false\r\n   */\r\n  bold?: boolean;\r\n  /**\r\n   * Optionally specify the text align, by default Left\r\n   */\r\n  textAlign?: TextAlign;\r\n  /**\r\n   * Optionally specify the text base align, by default Alphabetic\r\n   */\r\n  baseAlign?: BaseAlign;\r\n  /**\r\n   * Optionally specify the text direction, by default LeftToRight\r\n   */\r\n  direction?: Direction;\r\n  /**\r\n   * Optionally specify the quality of the text bitmap, it is a multiplier on the size size, by default 2.\r\n   * Higher quality text has a higher memory impact\r\n   */\r\n  quality?: number;\r\n  /**\r\n   * Optionally specify a text shadow, by default none is specified\r\n   */\r\n  shadow?: {\r\n    blur?: number;\r\n    offset?: Vector;\r\n    color?: Color;\r\n  };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface FontRenderer {\r\n  measureText(text: string): BoundingBox;\r\n  render(ex: ExcaliburGraphicsContext, text: string, color: Color, x: number, y: number): void;\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Color } from '../Color';\r\nimport { line } from '../Util/DrawUtil';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BaseAlign, Direction, FontOptions, FontStyle, FontUnit, TextAlign, FontRenderer } from './FontCommon';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { RasterOptions } from './Raster';\r\nimport { TextureLoader } from '.';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\n/**\r\n * Represents a system or web font in Excalibur\r\n *\r\n * If no options specified, the system sans-serif 10 pixel is used\r\n *\r\n * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/\r\n */\r\nexport class Font extends Graphic implements FontRenderer {\r\n  /**\r\n   * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing\r\n   *\r\n   * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]\r\n   */\r\n  public filtering: ImageFiltering = ImageFiltering.Blended;\r\n  constructor(options: FontOptions & GraphicOptions & RasterOptions = {}) {\r\n    super(options); // <- Graphics properties\r\n\r\n    // Raster properties\r\n    this.smoothing = options?.smoothing ?? this.smoothing;\r\n    this.padding = options?.padding ?? this.padding;\r\n    this.color = options?.color ?? this.color;\r\n    this.strokeColor = options?.strokeColor ?? this.strokeColor;\r\n    this.lineDash = options?.lineDash ?? this.lineDash;\r\n    this.lineWidth = options?.lineWidth ?? this.lineWidth;\r\n    this.filtering = options?.filtering ?? this.filtering;\r\n\r\n    // Font specific properties\r\n    this.family = options?.family ?? this.family;\r\n    this.style = options?.style ?? this.style;\r\n    this.bold = options?.bold ?? this.bold;\r\n    this.size = options?.size ?? this.size;\r\n    this.unit = options?.unit ?? this.unit;\r\n    this.textAlign = options?.textAlign ?? this.textAlign;\r\n    this.baseAlign = options?.baseAlign ?? this.baseAlign;\r\n    this.direction = options?.direction ?? this.direction;\r\n    this.quality = options?.quality ?? this.quality;\r\n    if (options?.shadow) {\r\n      this.shadow = {};\r\n      this.shadow.blur = options.shadow.blur ?? this.shadow.blur;\r\n      this.shadow.offset = options.shadow.offset ?? this.shadow.offset;\r\n      this.shadow.color = options.shadow.color ?? this.shadow.color;\r\n    }\r\n  }\r\n\r\n  public clone() {\r\n    return new Font({\r\n      ...this.cloneGraphicOptions(),\r\n      size: this.size,\r\n      unit: this.unit,\r\n      family: this.family,\r\n      style: this.style,\r\n      bold: this.bold,\r\n      textAlign: this.textAlign,\r\n      baseAlign: this.baseAlign,\r\n      direction: this.direction,\r\n      shadow: this.shadow\r\n        ? {\r\n          blur: this.shadow.blur,\r\n          offset: this.shadow.offset,\r\n          color: this.shadow.color\r\n        }\r\n        : null\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.\r\n   * If quality is set to 1, then just enough raster bitmap is generated to render the text.\r\n   *\r\n   * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.\r\n   *\r\n   * (Default 2)\r\n   */\r\n  public quality = 2;\r\n\r\n  // Raster properties for fonts\r\n  public padding = 2;\r\n  public smoothing = false;\r\n  public lineWidth = 1;\r\n  public lineDash: number[] = [];\r\n  public color: Color = Color.Black;\r\n  public strokeColor: Color;\r\n\r\n  public family: string = 'sans-serif';\r\n  public style: FontStyle = FontStyle.Normal;\r\n  public bold: boolean = false;\r\n  public unit: FontUnit = FontUnit.Px;\r\n  public textAlign: TextAlign = TextAlign.Left;\r\n  public baseAlign: BaseAlign = BaseAlign.Alphabetic;\r\n  public direction: Direction = Direction.LeftToRight;\r\n  public size: number = 10;\r\n  public shadow: { blur?: number; offset?: Vector; color?: Color } = null;\r\n\r\n  public get fontString() {\r\n    return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;\r\n  }\r\n\r\n  private _textBounds: BoundingBox = new BoundingBox();\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this._textBounds;\r\n  }\r\n\r\n\r\n  protected _drawImage(_ex: ExcaliburGraphicsContext, _x: number, _y: number) {\r\n    // TODO weird vestigial drawimage\r\n  }\r\n\r\n\r\n  protected _rotate(ex: ExcaliburGraphicsContext) {\r\n    // TODO this needs to change depending on the bounding box...\r\n    const origin = this.origin ?? this._textBounds.center;\r\n    ex.translate(origin.x, origin.y);\r\n    ex.rotate(this.rotation);\r\n    ex.translate(-origin.x, -origin.y);\r\n  }\r\n\r\n  protected _flip(ex: ExcaliburGraphicsContext) {\r\n    if (this.flipHorizontal) {\r\n      ex.translate(this._textBounds.width / this.scale.x, 0);\r\n      ex.scale(-1, 1);\r\n    }\r\n\r\n    if (this.flipVertical) {\r\n      ex.translate(0, -this._textBounds.height / 2 / this.scale.y);\r\n      ex.scale(1, -1);\r\n    }\r\n  }\r\n\r\n\r\n  private _cachedTextMeasurement = new Map<string, {text: string, measurement: BoundingBox, rasterProps: string}>();\r\n  private _bitmapToTextMeasurement = new Map<CanvasRenderingContext2D, {text: string, measurement: BoundingBox, rasterProps: string}>();\r\n  /**\r\n   * Returns a BoundingBox that is the total size of the text including multiple lines\r\n   *\r\n   * Does not include any padding or adjustment\r\n   * @param text\r\n   * @returns BoundingBox\r\n   */\r\n  public measureText(text: string): BoundingBox {\r\n    let measurementDirty = false;\r\n    let cached = this._cachedTextMeasurement.get(text);\r\n    if (!cached) {\r\n      measurementDirty = true;\r\n    }\r\n\r\n    const rasterProps = this._getRasterPropertiesHash();\r\n    if (!cached || rasterProps !== cached.rasterProps) {\r\n      measurementDirty = true;\r\n    }\r\n\r\n    if (measurementDirty) {\r\n      const lines = text.split('\\n');\r\n      const maxWidthLine = lines.reduce((a, b) => {\r\n        return a.length > b.length ? a : b;\r\n      });\r\n      const ctx = this._getTextBitmap(text);\r\n\r\n      this._applyFont(ctx); // font must be applied to the context to measure it\r\n      const metrics = ctx.measureText(maxWidthLine);\r\n      let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);\r\n\r\n      // TODO lineheight makes the text bounds wonky\r\n      const lineAdjustedHeight = textHeight * lines.length;\r\n      textHeight = lineAdjustedHeight;\r\n      const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);\r\n      const x = 0;\r\n      const y = 0;\r\n      // this._cachedText = text;\r\n      // this._cachedRasterProps = rasterProps;\r\n      // this._measurementDirty = false;\r\n      const measurement = new BoundingBox({\r\n        left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,\r\n        top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,\r\n        bottom: y + bottomBounds + this.padding,\r\n        right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding\r\n      });\r\n      cached = {\r\n        text,\r\n        rasterProps,\r\n        measurement\r\n      };\r\n      this._cachedTextMeasurement.set(text, cached);\r\n      this._bitmapToTextMeasurement.set(ctx, cached);\r\n      return cached.measurement;\r\n    } else {\r\n      return cached.measurement;\r\n    }\r\n  }\r\n\r\n  private _setDimension(textBounds: BoundingBox, bitmap: CanvasRenderingContext2D) {\r\n\r\n    // Changing the width and height clears the context properties\r\n    // We double the bitmap width to account for all possible alignment\r\n    // We scale by \"quality\" so we render text without jaggies\r\n    bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;\r\n    bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;\r\n  }\r\n\r\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\r\n    ex.restore();\r\n  }\r\n\r\n  /**\r\n   * We need to identify bitmaps with more than just the text content\r\n   *\r\n   * Any properties that can change the rendering of the text\r\n   */\r\n  private _getRasterPropertiesHash(color?: Color): string {\r\n    const hash = '__hashcode__' +\r\n    this.fontString +\r\n    this.showDebug +\r\n    this.textAlign +\r\n    this.baseAlign +\r\n    this.direction +\r\n    JSON.stringify(this.shadow) +\r\n    (this.padding.toString() +\r\n    this.smoothing.toString() +\r\n    this.lineWidth.toString() +\r\n    this.lineDash.toString() +\r\n    this.strokeColor?.toString() +\r\n    ( color ? color.toString() : this.color?.toString()).toString());\r\n    return hash;\r\n  }\r\n\r\n  protected _applyRasterProperties(ctx: CanvasRenderingContext2D, color: Color) {\r\n    ctx.translate(this.padding, this.padding);\r\n    ctx.imageSmoothingEnabled = this.smoothing;\r\n    ctx.lineWidth = this.lineWidth;\r\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\r\n    ctx.strokeStyle = this.strokeColor?.toString();\r\n    ctx.fillStyle = color ? color.toString() : this.color?.toString();\r\n  }\r\n\r\n  private _applyFont(ctx: CanvasRenderingContext2D) {\r\n    ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);\r\n    ctx.scale(this.quality, this.quality);\r\n    ctx.textAlign = this.textAlign;\r\n    ctx.textBaseline = this.baseAlign;\r\n    ctx.font = this.fontString;\r\n    ctx.direction = this.direction;\r\n\r\n    if (this.shadow) {\r\n      ctx.shadowColor = this.shadow.color.toString();\r\n      ctx.shadowBlur = this.shadow.blur;\r\n      ctx.shadowOffsetX = this.shadow.offset.x;\r\n      ctx.shadowOffsetY = this.shadow.offset.y;\r\n    }\r\n  }\r\n\r\n  private _drawText(ctx: CanvasRenderingContext2D, text: string, colorOverride: Color, lineHeight: number): void {\r\n    const lines = text.split('\\n');\r\n    this._applyRasterProperties(ctx, colorOverride);\r\n    this._applyFont(ctx);\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i];\r\n      if (this.color) {\r\n        ctx.fillText(line, 0, i * lineHeight);\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.strokeText(line, 0, i * lineHeight);\r\n      }\r\n    }\r\n\r\n    if (this.showDebug) {\r\n      // Horizontal line\r\n      /* istanbul ignore next */\r\n      line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);\r\n      // Vertical line\r\n      /* istanbul ignore next */\r\n      line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);\r\n    }\r\n  }\r\n\r\n  private _textToBitmap = new Map<string, CanvasRenderingContext2D>();\r\n  private _bitmapUsage = new Map<CanvasRenderingContext2D, number>();\r\n  private _getTextBitmap(text: string, color?: Color): CanvasRenderingContext2D {\r\n    const textAndHash = text + this._getRasterPropertiesHash(color);\r\n    const bitmap = this._textToBitmap.get(textAndHash);\r\n    if (bitmap) {\r\n      return bitmap;\r\n    }\r\n\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    this._textToBitmap.set(textAndHash, ctx);\r\n    return ctx;\r\n  }\r\n\r\n  private _splitTextBitmap(bitmap: CanvasRenderingContext2D) {\r\n    const textImages: {x: number, y: number, canvas: HTMLCanvasElement}[] = [];\r\n    let currentX = 0;\r\n    let currentY = 0;\r\n    // 4k is the max for mobile devices\r\n    const width = Math.min(4096, bitmap.canvas.width);\r\n    const height = Math.min(4096, bitmap.canvas.height);\r\n\r\n    // Splits the original bitmap into 4k max chunks\r\n    while (currentX < bitmap.canvas.width) {\r\n      while (currentY < bitmap.canvas.height) {\r\n        // create new bitmap\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // draw current slice to new bitmap in < 4k chunks\r\n        ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);\r\n\r\n        textImages.push({x: currentX, y: currentY, canvas});\r\n        currentY += height;\r\n      }\r\n      currentX += width;\r\n      currentY = 0;\r\n    }\r\n    return textImages;\r\n  }\r\n\r\n  private _textFragments: {x: number, y: number, canvas: HTMLCanvasElement}[] = [];\r\n  public render(ex: ExcaliburGraphicsContext, text: string, colorOverride: Color, x: number, y: number) {\r\n    if (this.showDebug) {\r\n      this.clearCache();\r\n    }\r\n    this.checkAndClearCache();\r\n    // Get bitmap for rastering text, this is cached by raster properties\r\n    const bitmap = this._getTextBitmap(text, colorOverride);\r\n    const isNewBitmap = !this._bitmapUsage.get(bitmap);\r\n\r\n    // Bounds of the text\r\n    this._textBounds = this.measureText(text);\r\n\r\n    if (isNewBitmap) {\r\n      // Setting dimension is expensive because it invalidates the bitmap\r\n      this._setDimension(this._textBounds, bitmap);\r\n    }\r\n\r\n    // Apply affine transformations\r\n    this._preDraw(ex, x, y);\r\n\r\n    const lines = text.split('\\n');\r\n    const lineHeight = this._textBounds.height / lines.length;\r\n\r\n    if (isNewBitmap) {\r\n      // draws the text to the bitmap\r\n      this._drawText(bitmap, text, colorOverride, lineHeight);\r\n\r\n      // clean up any existing fragments\r\n      for (const frag of this._textFragments) {\r\n        TextureLoader.delete(frag.canvas);\r\n      }\r\n\r\n      this._textFragments = this._splitTextBitmap(bitmap);\r\n\r\n      for (const frag of this._textFragments) {\r\n        TextureLoader.load(frag.canvas, this.filtering, true);\r\n      }\r\n    }\r\n\r\n    // draws the bitmap fragments to excalibur graphics context\r\n    for (const frag of this._textFragments) {\r\n      ex.drawImage(\r\n        frag.canvas,\r\n        0,\r\n        0,\r\n        frag.canvas.width,\r\n        frag.canvas.height,\r\n        frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2,\r\n        frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2,\r\n        frag.canvas.width / this.quality,\r\n        frag.canvas.height / this.quality\r\n      );\r\n    }\r\n\r\n    this._postDraw(ex);\r\n\r\n    // Cache the bitmap for certain amount of time\r\n    this._bitmapUsage.set(bitmap, performance.now());\r\n  }\r\n\r\n  /**\r\n   * Get the internal cache size of the font\r\n   * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps\r\n   */\r\n  public get cacheSize() {\r\n    return this._bitmapUsage.size;\r\n  }\r\n\r\n  /**\r\n   * Force clear all cached text bitmaps\r\n   */\r\n  public clearCache() {\r\n    this._bitmapUsage.clear();\r\n  }\r\n\r\n  /**\r\n   * Remove any expired cached text bitmaps\r\n   */\r\n  public checkAndClearCache() {\r\n    for (const [bitmap, time] of this._bitmapUsage.entries()) {\r\n      // if bitmap hasn't been used in 1 second clear it\r\n      if (time + 1000 < performance.now()) {\r\n        this._bitmapUsage.delete(bitmap);\r\n        // Cleanup measurements\r\n        const measurement = this._bitmapToTextMeasurement.get(bitmap);\r\n        if (measurement) {\r\n          this._cachedTextMeasurement.delete(measurement.text);\r\n          this._bitmapToTextMeasurement.delete(bitmap);\r\n        }\r\n        TextureLoader.delete(bitmap.canvas);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { SpriteFont } from './SpriteFont';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Color } from '../Color';\r\nimport { Font } from './Font';\r\n\r\nexport interface TextOptions {\r\n  /**\r\n   * Text to draw\r\n   */\r\n  text: string;\r\n\r\n  /**\r\n   * Optionally override the font color, currently unsupported by SpriteFont\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Optionally specify a font, if none specified a default font is used (System sans-serif 10 pixel)\r\n   */\r\n  font?: Font | SpriteFont;\r\n}\r\n\r\n/**\r\n * Represent Text graphics in excalibur\r\n *\r\n * Useful for in game labels, ui, or overlays\r\n */\r\nexport class Text extends Graphic {\r\n  public color?: Color;\r\n  constructor(options: TextOptions & GraphicOptions) {\r\n    super(options);\r\n    // This order is important font, color, then text\r\n    this.font = options.font ?? new Font();\r\n    this.color = options.color ?? this.color;\r\n    this.text = options.text;\r\n  }\r\n\r\n  public clone(): Text {\r\n    return new Text({\r\n      text: this.text.slice(),\r\n      color: this.color?.clone() ?? Color.Black,\r\n      font: this.font.clone()\r\n    });\r\n  }\r\n\r\n  private _text: string = '';\r\n  public get text() {\r\n    return this._text;\r\n  }\r\n\r\n  public set text(value: string) {\r\n    this._text = value;\r\n    const bounds = this.font.measureText(this._text);\r\n    this._textWidth = bounds.width;\r\n    this._textHeight = bounds.height;\r\n  }\r\n\r\n  private _font: Font | SpriteFont;\r\n  public get font(): Font | SpriteFont {\r\n    return this._font;\r\n  }\r\n  public set font(font: Font | SpriteFont) {\r\n    this._font = font;\r\n  }\r\n\r\n  private _textWidth: number = 0;\r\n\r\n  public get width() {\r\n    if (this._textWidth === 0) {\r\n      this._calculateDimension();\r\n    }\r\n    return this._textWidth * this.scale.x;\r\n  }\r\n\r\n  private _textHeight: number = 0;\r\n  public get height() {\r\n    if (this._textHeight === 0) {\r\n      this._calculateDimension();\r\n    }\r\n    return this._textHeight * this.scale.y;\r\n  }\r\n\r\n  private _calculateDimension() {\r\n    const { width, height } = this.font.measureText(this._text);\r\n    this._textWidth = width;\r\n    this._textHeight = height;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this.font.measureText(this._text).scale(this.scale);\r\n  }\r\n\r\n  protected override _rotate(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected override _flip(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected override _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    let color = Color.Black;\r\n    if (this.font instanceof Font) {\r\n      color = this.color ?? this.font.color;\r\n    }\r\n\r\n    if (this.isStale() || this.font.isStale()) {\r\n      this.font.flipHorizontal = this.flipHorizontal;\r\n      this.font.flipVertical = this.flipVertical;\r\n      this.font.rotation = this.rotation;\r\n      this.font.origin = this.origin;\r\n      this.font.opacity = this.opacity;\r\n    }\r\n    this.font.tint = this.tint;\r\n\r\n    const { width, height } = this.font.measureText(this._text);\r\n    this._textWidth = width;\r\n    this._textHeight = height;\r\n\r\n    this.font.render(ex, this._text, color, x, y);\r\n    if (this.font.showDebug) {\r\n      ex.debug.drawRect(x - width, y - height, width * 2, height * 2);\r\n    }\r\n  }\r\n}\r\n","import {\r\n  InitializeEvent,\r\n  KillEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PostCollisionEvent,\r\n  PreCollisionEvent,\r\n  CollisionStartEvent,\r\n  CollisionEndEvent,\r\n  PostKillEvent,\r\n  PreKillEvent,\r\n  GameEvent,\r\n  ExitTriggerEvent,\r\n  EnterTriggerEvent,\r\n  EnterViewPortEvent,\r\n  ExitViewPortEvent\r\n} from './Events';\r\nimport { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { CanInitialize, CanUpdate, CanBeKilled } from './Interfaces/LifecycleEvents';\r\nimport { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { Eventable } from './Interfaces/Evented';\r\nimport * as Events from './Events';\r\nimport { PointerEvents } from './Interfaces/PointerEventHandlers';\r\nimport { CollisionType } from './Collision/CollisionType';\r\n\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from './EntityComponentSystem/Components/MotionComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Rectangle } from './Graphics/Rectangle';\r\nimport { ColliderComponent } from './Collision/ColliderComponent';\r\nimport { Shape } from './Collision/Colliders/Shape';\r\nimport { watch } from './Util/Watch';\r\nimport { Collider, CollisionGroup } from './Collision/Index';\r\nimport { Circle } from './Graphics/Circle';\r\nimport { PointerEvent } from './Input/PointerEvent';\r\nimport { WheelEvent } from './Input/WheelEvent';\r\nimport { PointerComponent } from './Input/PointerComponent';\r\nimport { ActionsComponent } from './Actions/ActionsComponent';\r\nimport { Raster } from './Graphics/Raster';\r\nimport { Text } from './Graphics/Text';\r\nimport { CoordPlane } from './Math/coord-plane';\r\n\r\n/**\r\n * Type guard for checking if something is an Actor\r\n * @param x\r\n */\r\nexport function isActor(x: any): x is Actor {\r\n  return x instanceof Actor;\r\n}\r\n\r\n/**\r\n * Actor contructor options\r\n */\r\nexport interface ActorArgs {\r\n  /**\r\n   * Optionally set the name of the actor, default is 'anonymous'\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally set the x position of the actor, default is 0\r\n   */\r\n  x?: number;\r\n  /**\r\n   * Optionally set the y position of the actor, default is 0\r\n   */\r\n  y?: number;\r\n  /**\r\n   * Optionally set the (x, y) position of the actor as a vector, default is (0, 0)\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally set the coordinate plane of the actor, default is [[CoordPlane.World]] meaning actor is subject to camera positioning\r\n   */\r\n  coordPlane?: CoordPlane;\r\n  /**\r\n   * Optionally set the width of a box collider for the actor\r\n   */\r\n  width?: number;\r\n  /**\r\n   * Optionally set the height of a box collider for the actor\r\n   */\r\n  height?: number;\r\n  /**\r\n   * Optionally set the radius of the circle collider for the actor\r\n   */\r\n  radius?: number;\r\n  /**\r\n   * Optionally set the velocity of the actor in pixels/sec\r\n   */\r\n  vel?: Vector;\r\n  /**\r\n   * Optionally set the acceleration of the actor in pixels/sec^2\r\n   */\r\n  acc?: Vector;\r\n  /**\r\n   * Optionally se the rotation in radians (180 degrees = Math.PI radians)\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * Optionally set the angular velocity of the actor in radians/sec (180 degrees = Math.PI radians)\r\n   */\r\n  angularVelocity?: number;\r\n  /**\r\n   * Optionally set the scale of the actor's transform\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * Optionally set the z index of the actor, default is 0\r\n   */\r\n  z?: number;\r\n  /**\r\n   * Optionally set the color of an actor, only used if no graphics are present\r\n   * If a width/height or a radius was set a default graphic will be added\r\n   */\r\n  color?: Color;\r\n  /**\r\n   * Optionally set the visibility of the actor\r\n   */\r\n  visible?: boolean;\r\n  /**\r\n   * Optionally set the anchor for graphics in the actor\r\n   */\r\n  anchor?: Vector;\r\n  /**\r\n   * Optionally set the collision type\r\n   */\r\n  collisionType?: CollisionType;\r\n  /**\r\n   * Optionally supply a collider for an actor, if supplied ignores any supplied width/height\r\n   */\r\n  collider?: Collider;\r\n  /**\r\n   * Optionally suppy a [[CollisionGroup]]\r\n   */\r\n  collisionGroup?: CollisionGroup;\r\n}\r\n\r\n/**\r\n * The most important primitive in Excalibur is an `Actor`. Anything that\r\n * can move on the screen, collide with another `Actor`, respond to events,\r\n * or interact with the current scene, must be an actor. An `Actor` **must**\r\n * be part of a [[Scene]] for it to be drawn to the screen.\r\n */\r\nexport class Actor extends Entity implements Eventable, PointerEvents, CanInitialize, CanUpdate, CanBeKilled {\r\n  // #region Properties\r\n\r\n  /**\r\n   * Set defaults for all Actors\r\n   */\r\n  public static defaults = {\r\n    anchor: Vector.Half\r\n  };\r\n\r\n  /**\r\n   * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n   * acceleration, mass, inertia, etc.\r\n   */\r\n  public get body(): BodyComponent {\r\n    return this.get(BodyComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[TransformComponent]]\r\n   */\r\n  public get transform(): TransformComponent {\r\n    return this.get(TransformComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[MotionComponent]]\r\n   */\r\n  public get motion(): MotionComponent {\r\n    return this.get(MotionComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[GraphicsComponent]]\r\n   */\r\n  public get graphics(): GraphicsComponent {\r\n    return this.get(GraphicsComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[ColliderComponent]]\r\n   */\r\n  public get collider(): ColliderComponent {\r\n    return this.get(ColliderComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[PointerComponent]] config\r\n   */\r\n  public get pointer(): PointerComponent {\r\n    return this.get(PointerComponent);\r\n  }\r\n\r\n  /**\r\n   * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.\r\n   *\r\n   *  Access to the Actor's built in [[ActionsComponent]] which forwards to the\r\n   * [[ActionContext|Action context]] of the actor.\r\n   */\r\n  public get actions(): ActionsComponent {\r\n    return this.get(ActionsComponent);\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor in pixels\r\n   */\r\n  public get pos(): Vector {\r\n    return this.transform.pos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in pixels\r\n   */\r\n  public set pos(thePos: Vector) {\r\n    this.transform.pos = thePos.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor from the last frame\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this.body.oldPos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in the last frame\r\n   */\r\n  public set oldPos(thePos: Vector) {\r\n    this.body.oldPos.setTo(thePos.x, thePos.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public set vel(theVel: Vector) {\r\n    this.motion.vel = theVel.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor from the last frame\r\n   */\r\n  public get oldVel(): Vector {\r\n    return this.body.oldVel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor from the last frame\r\n   */\r\n  public set oldVel(theVel: Vector) {\r\n    this.body.oldVel.setTo(theVel.x, theVel.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n   * useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration vector of teh actor in pixels/second/second\r\n   */\r\n  public set acc(theAcc: Vector) {\r\n    this.motion.acc = theAcc.clone();\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public set oldAcc(theAcc: Vector) {\r\n    this.body.oldAcc.setTo(theAcc.x, theAcc.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public get oldAcc(): Vector {\r\n    return this.body.oldAcc;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public get rotation(): number {\r\n    return this.transform.rotation;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public set rotation(theAngle: number) {\r\n    this.transform.rotation = theAngle;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotational velocity of the actor in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotational velocity of the actor in radians/sec\r\n   */\r\n  public set angularVelocity(angularVelocity: number) {\r\n    this.motion.angularVelocity = angularVelocity;\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this.get(TransformComponent).scale;\r\n  }\r\n\r\n  public set scale(scale: Vector) {\r\n    this.get(TransformComponent).scale = scale;\r\n  }\r\n\r\n  /**\r\n   * The anchor to apply all actor related transformations like rotation,\r\n   * translation, and scaling. By default the anchor is in the center of\r\n   * the actor. By default it is set to the center of the actor (.5, .5)\r\n   *\r\n   * An anchor of (.5, .5) will ensure that drawings are centered.\r\n   *\r\n   * Use `anchor.setTo` to set the anchor to a different point using\r\n   * values between 0 and 1. For example, anchoring to the top-left would be\r\n   * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.\r\n   */\r\n  private _anchor: Vector = watch(Vector.Half, (v) => this._handleAnchorChange(v));\r\n  public get anchor(): Vector {\r\n    return this._anchor;\r\n  }\r\n\r\n  public set anchor(vec: Vector) {\r\n    this._anchor = watch(vec, (v) => this._handleAnchorChange(v));\r\n    this._handleAnchorChange(vec);\r\n  }\r\n\r\n  private _handleAnchorChange(v: Vector) {\r\n    if (this.graphics) {\r\n      this.graphics.anchor = v;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates whether the actor is physically in the viewport\r\n   */\r\n  public get isOffScreen(): boolean {\r\n    return this.hasTag('ex.offscreen');\r\n  }\r\n\r\n  /**\r\n   * Convenience reference to the global logger\r\n   */\r\n  public logger: Logger = Logger.getInstance();\r\n\r\n  /**\r\n   * The scene that the actor is in\r\n   */\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * Draggable helper\r\n   */\r\n  private _draggable: boolean = false;\r\n  private _dragging: boolean = false;\r\n\r\n  private _pointerDragStartHandler = () => {\r\n    this._dragging = true;\r\n  };\r\n\r\n  private _pointerDragEndHandler = () => {\r\n    this._dragging = false;\r\n  };\r\n\r\n  private _pointerDragMoveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.worldPos;\r\n    }\r\n  };\r\n\r\n  private _pointerDragLeaveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.worldPos;\r\n    }\r\n  };\r\n\r\n  public get draggable(): boolean {\r\n    return this._draggable;\r\n  }\r\n\r\n  public set draggable(isDraggable: boolean) {\r\n    if (isDraggable) {\r\n      if (isDraggable && !this._draggable) {\r\n        this.on('pointerdragstart', this._pointerDragStartHandler);\r\n        this.on('pointerdragend', this._pointerDragEndHandler);\r\n        this.on('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.on('pointerdragleave', this._pointerDragLeaveHandler);\r\n      } else if (!isDraggable && this._draggable) {\r\n        this.off('pointerdragstart', this._pointerDragStartHandler);\r\n        this.off('pointerdragend', this._pointerDragEndHandler);\r\n        this.off('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.off('pointerdragleave', this._pointerDragLeaveHandler);\r\n      }\r\n\r\n      this._draggable = isDraggable;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the color of the actor's current graphic\r\n   */\r\n  public get color(): Color {\r\n    return this._color;\r\n  }\r\n  public set color(v: Color) {\r\n    this._color = v.clone();\r\n    const defaultLayer = this.graphics.layers.default;\r\n    const currentGraphic = defaultLayer.graphics[0]?.graphic;\r\n    if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {\r\n      currentGraphic.color = this._color;\r\n    }\r\n  }\r\n  private _color: Color;\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   *\r\n   * @param config\r\n   */\r\n  constructor(config?: ActorArgs) {\r\n    super();\r\n\r\n    const {\r\n      name,\r\n      x,\r\n      y,\r\n      pos,\r\n      coordPlane,\r\n      scale,\r\n      width,\r\n      height,\r\n      radius,\r\n      collider,\r\n      vel,\r\n      acc,\r\n      rotation,\r\n      angularVelocity,\r\n      z,\r\n      color,\r\n      visible,\r\n      anchor,\r\n      collisionType,\r\n      collisionGroup\r\n    } = {\r\n      ...config\r\n    };\r\n\r\n    this._setName(name);\r\n    this.anchor = anchor ?? Actor.defaults.anchor.clone();\r\n    const tx = new TransformComponent();\r\n    this.addComponent(tx);\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.rotation = rotation ?? 0;\r\n    this.scale = scale ?? vec(1, 1);\r\n    this.z = z ?? 0;\r\n    tx.coordPlane = coordPlane ?? CoordPlane.World;\r\n\r\n    this.addComponent(new PointerComponent);\r\n\r\n    this.addComponent(new GraphicsComponent({\r\n      anchor: this.anchor\r\n    }));\r\n    this.addComponent(new MotionComponent());\r\n    this.vel = vel ?? Vector.Zero;\r\n    this.acc = acc ?? Vector.Zero;\r\n    this.angularVelocity = angularVelocity ?? 0;\r\n\r\n    this.addComponent(new ActionsComponent());\r\n\r\n    this.addComponent(new BodyComponent());\r\n    this.body.collisionType = collisionType ?? CollisionType.Passive;\r\n    if (collisionGroup) {\r\n      this.body.group = collisionGroup;\r\n    }\r\n\r\n    if (collider) {\r\n      this.addComponent(new ColliderComponent(collider));\r\n    } else if (radius) {\r\n      this.addComponent(new ColliderComponent(Shape.Circle(radius)));\r\n    } else {\r\n      if (width > 0 && height > 0) {\r\n        this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));\r\n      } else {\r\n        this.addComponent(new ColliderComponent()); // no collider\r\n      }\r\n    }\r\n\r\n    this.graphics.visible = visible ?? true;\r\n\r\n    if (color) {\r\n      this.color = color;\r\n      if (width && height) {\r\n        this.graphics.add(\r\n          new Rectangle({\r\n            color: color,\r\n            width,\r\n            height\r\n          })\r\n        );\r\n      } else if (radius) {\r\n        this.graphics.add(\r\n          new Circle({\r\n            color: color,\r\n            radius\r\n          })\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the actor. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n    for (const child of this.children) {\r\n      child._initialize(engine);\r\n    }\r\n  }\r\n\r\n  // #region Events\r\n\r\n  public on(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public on(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touched a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public on(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public on(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public on(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public on(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public on(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public on(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public on(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public on(eventName: Events.pointerdragstart, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragend, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragmove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public on(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public once(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public once(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public once(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public once(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public once(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public once(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public once(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public once(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public once(eventName: Events.pointerdragstart, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragend, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragmove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public once(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.exittrigger, handler?: (event: ExitTriggerEvent) => void): void;\r\n  public off(eventName: Events.entertrigger, handler?: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public off(eventName: Events.collisionstart, handler?: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public off(eventName: Events.collisionend, handler?: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public off(eventName: Events.precollision, handler?: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public off(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public off(eventName: Events.pointerup, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdown, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointermove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointercancel, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerwheel, handler?: (event: WheelEvent) => void): void;\r\n  public off(eventName: Events.pointerdragstart, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragend, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragmove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.prekill, handler?: (event: PreKillEvent) => void): void;\r\n  public off(eventName: Events.postkill, handler?: (event: PostKillEvent) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Actor>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.enterviewport, handler?: (event: EnterViewPortEvent) => void): void;\r\n  public off(eventName: Events.exitviewport, handler?: (event: ExitViewPortEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<Actor>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPreKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _prekill(_scene: Scene) {\r\n    super.emit('prekill', new PreKillEvent(this));\r\n    this.onPreKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`\r\n   *\r\n   * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].\r\n   */\r\n  public onPreKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPostKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postkill(_scene: Scene) {\r\n    super.emit('postkill', new PostKillEvent(this));\r\n    this.onPostKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`\r\n   *\r\n   * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].\r\n   */\r\n  public onPostKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If the current actor is a member of the scene, this will remove\r\n   * it from the scene graph. It will no longer be drawn or updated.\r\n   */\r\n  public kill() {\r\n    if (this.scene) {\r\n      this._prekill(this.scene);\r\n      this.emit('kill', new KillEvent(this));\r\n      super.kill();\r\n      this._postkill(this.scene);\r\n    } else {\r\n      this.logger.warn('Cannot kill actor, it was never added to the Scene');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the current actor is killed, it will now not be killed.\r\n   */\r\n  public unkill() {\r\n    this.active = true;\r\n  }\r\n\r\n  /**\r\n   * Indicates wether the actor has been killed.\r\n   */\r\n  public isKilled(): boolean {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   */\r\n  public get z(): number {\r\n    return this.get(TransformComponent).z;\r\n  }\r\n\r\n\r\n  /**\r\n   * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n   * The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   * @param newZ new z-index to assign\r\n   */\r\n  public set z(newZ: number) {\r\n    this.get(TransformComponent).z = newZ;\r\n  }\r\n\r\n  /**\r\n   * Get the center point of an actor (global position)\r\n   */\r\n  public get center(): Vector {\r\n    const globalPos = this.getGlobalPos();\r\n    return new Vector(\r\n      globalPos.x + this.width / 2 - this.anchor.x * this.width,\r\n      globalPos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  /**\r\n   * Get the local center point of an actor\r\n   */\r\n  public get localCenter(): Vector {\r\n    return new Vector(\r\n      this.pos.x + this.width / 2 - this.anchor.x * this.width,\r\n      this.pos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  public get width() {\r\n    return this.collider.localBounds.width * this.getGlobalScale().x;\r\n  }\r\n\r\n  public get height() {\r\n    return this.collider.localBounds.height * this.getGlobalScale().y;\r\n  }\r\n\r\n  /**\r\n   * Gets this actor's rotation taking into account any parent relationships\r\n   *\r\n   * @returns Rotation angle in radians\r\n   */\r\n  public getGlobalRotation(): number {\r\n    return this.get(TransformComponent).globalRotation;\r\n  }\r\n\r\n  /**\r\n   * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation\r\n   *\r\n   * @returns Position in world coordinates\r\n   */\r\n  public getGlobalPos(): Vector {\r\n    return this.get(TransformComponent).globalPos;\r\n  }\r\n\r\n  /**\r\n   * Gets the global scale of the Actor\r\n   */\r\n  public getGlobalScale(): Vector {\r\n    return this.get(TransformComponent).globalScale;\r\n  }\r\n\r\n  // #region Collision\r\n\r\n  /**\r\n   * Tests whether the x/y specified are contained in the actor\r\n   * @param x  X coordinate to test (in world coordinates)\r\n   * @param y  Y coordinate to test (in world coordinates)\r\n   * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n   */\r\n  public contains(x: number, y: number, recurse: boolean = false): boolean {\r\n    const point = vec(x, y);\r\n    const collider = this.get(ColliderComponent);\r\n    collider.update();\r\n    const geom = collider.get();\r\n    if (!geom) {\r\n      return false;\r\n    }\r\n    const containment = geom.contains(point);\r\n\r\n    if (recurse) {\r\n      return (\r\n        containment ||\r\n        this.children.some((child: Actor) => {\r\n          return child.contains(x, y, true);\r\n        })\r\n      );\r\n    }\r\n\r\n    return containment;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other\r\n   * @param actor     Actor to test\r\n   * @param distance  Distance in pixels to test\r\n   */\r\n  public within(actor: Actor, distance: number): boolean {\r\n    const collider = this.get(ColliderComponent);\r\n    const otherCollider = actor.get(ColliderComponent);\r\n    const me = collider.get();\r\n    const other = otherCollider.get();\r\n    if (me && other) {\r\n      return me.getClosestLineBetween(other).getLength() <= distance;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // #endregion\r\n\r\n  // #region Update\r\n\r\n  /**\r\n   * Called by the Engine, updates the state of the actor\r\n   * @internal\r\n   * @param engine The reference to the current game engine\r\n   * @param delta  The time elapsed since the last update in milliseconds\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an actor is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an actor is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  // endregion\r\n}\r\n","import { Vector, vec } from './Math/vector';\r\nimport { Engine } from './Engine';\r\nimport { Actor, ActorArgs } from './Actor';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { CoordPlane } from './Math/coord-plane';\r\n\r\n/**\r\n * Type guard to detect a screen element\r\n */\r\nexport function isScreenElement(actor: Actor) {\r\n  return actor instanceof ScreenElement;\r\n}\r\n\r\n/**\r\n * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does\r\n * not participate in collisions. Drawn on top of all other actors.\r\n */\r\nexport class ScreenElement extends Actor {\r\n  protected _engine: Engine;\r\n\r\n  constructor();\r\n  constructor(config?: ActorArgs);\r\n\r\n  constructor(config?: ActorArgs) {\r\n    super({ ...config });\r\n    this.get(TransformComponent).coordPlane = CoordPlane.Screen;\r\n    this.anchor = vec(0, 0);\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n    this.collider.useBoxCollider(this.width, this.height, this.anchor);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    this._engine = engine;\r\n    super._initialize(engine);\r\n  }\r\n\r\n  public contains(x: number, y: number, useWorld: boolean = true) {\r\n    if (useWorld) {\r\n      return super.contains(x, y);\r\n    }\r\n\r\n    const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));\r\n    return super.contains(coords.x, coords.y);\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\nimport * as ex from './index';\r\nimport { Random } from './Math/Random';\r\n\r\n\r\nexport interface TimerOptions {\r\n  repeats?: boolean;\r\n  numberOfRepeats?: number;\r\n  fcn?: () => void;\r\n  interval: number;\r\n  randomRange?: [number, number];\r\n  random?: ex.Random;\r\n}\r\n\r\n/**\r\n * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n * after a certain interval, optionally repeating.\r\n */\r\nexport class Timer {\r\n  private _logger = Logger.getInstance();\r\n  private static _MAX_ID: number = 0;\r\n  public id: number = 0;\r\n\r\n  private _elapsedTime: number = 0;\r\n  private _totalTimeAlive: number = 0;\r\n\r\n  private _running = false;\r\n\r\n  private _numberOfTicks: number = 0;\r\n  private _callbacks: Array<() => void>;\r\n\r\n  public interval: number = 10;\r\n  public repeats: boolean = false;\r\n  public maxNumberOfRepeats: number = -1;\r\n  public randomRange: [number, number] = [0,0];\r\n  public random: ex.Random;\r\n  private _baseInterval = 10;\r\n  private _generateRandomInterval = () => {\r\n    return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);\r\n  };\r\n\r\n  private _complete = false;\r\n  public get complete() {\r\n    return this._complete;\r\n  }\r\n\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * @param options    Options - repeats, numberOfRepeats, fcn, interval\r\n   * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.\r\n   * @param numberOfRepeats Specifies a maximum number of times that this timer will execute.\r\n   * @param fcn        The callback to be fired after the interval is complete.\r\n   * @param randomRange Indicates a range to select a random number to be added onto the interval\r\n   */\r\n  constructor(options: TimerOptions);\r\n  constructor(fcn: TimerOptions | (() => void), interval?: number,\r\n    repeats?: boolean, numberOfRepeats?: number, randomRange?: [number, number], random?: ex.Random) {\r\n    if (typeof fcn !== 'function') {\r\n      const options = fcn;\r\n      fcn = options.fcn;\r\n      interval = options.interval;\r\n      repeats = options.repeats;\r\n      numberOfRepeats = options.numberOfRepeats;\r\n      randomRange = options.randomRange;\r\n      random= options.random;\r\n    }\r\n\r\n    if (!!numberOfRepeats && numberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = numberOfRepeats;\r\n      if (!repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this.id = Timer._MAX_ID++;\r\n    this._callbacks = [];\r\n    this._baseInterval = this.interval = interval;\r\n    if (!!randomRange){\r\n      if (randomRange[0] > randomRange[1]) {\r\n        throw new Error('min value must be lower than max value for range');\r\n      }\r\n      //We use the instance of ex.Random to generate the range\r\n      this.random = random ?? new Random();\r\n      this.randomRange = randomRange;\r\n\r\n      this.interval = this._generateRandomInterval();\r\n      this.on(() => {\r\n        this.interval = this._generateRandomInterval();\r\n      });\r\n    };\r\n    this.repeats = repeats || this.repeats;\r\n    if (fcn) {\r\n      this.on(fcn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new callback to be fired after the interval is complete\r\n   * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.\r\n   */\r\n  public on(fcn: () => void) {\r\n    this._callbacks.push(fcn);\r\n  }\r\n\r\n  /**\r\n   * Removes a callback from the callback list to be fired after the interval is complete.\r\n   * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.\r\n   */\r\n  public off(fcn: () => void) {\r\n    const index = this._callbacks.indexOf(fcn);\r\n    this._callbacks.splice(index, 1);\r\n  }\r\n  /**\r\n   * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n   * @param delta  Number of elapsed milliseconds since the last update.\r\n   */\r\n  public update(delta: number) {\r\n    if (this._running) {\r\n      this._totalTimeAlive += delta;\r\n      this._elapsedTime += delta;\r\n\r\n      if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {\r\n        this._complete = true;\r\n        this._running = false;\r\n        this._elapsedTime = 0;\r\n      }\r\n\r\n      if (!this.complete && this._elapsedTime >= this.interval) {\r\n        this._callbacks.forEach((c) => {\r\n          c.call(this);\r\n        });\r\n        this._numberOfTicks++;\r\n        if (this.repeats) {\r\n          this._elapsedTime = 0;\r\n        } else {\r\n          this._complete = true;\r\n          this._running = false;\r\n          this._elapsedTime = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n   *\r\n   * Warning** you may need to call `timer.start()` again if the timer had completed\r\n   * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n   * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes\r\n   */\r\n  public reset(newInterval?: number, newNumberOfRepeats?: number) {\r\n    if (!!newInterval && newInterval >= 0) {\r\n      this._baseInterval = this.interval= newInterval;\r\n    }\r\n\r\n    if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = newNumberOfRepeats;\r\n      if (!this.repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this._complete = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n  }\r\n\r\n  public get timesRepeated(): number {\r\n    return this._numberOfTicks;\r\n  }\r\n\r\n  public getTimeRunning(): number {\r\n    return this._totalTimeAlive;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds until the next action callback, if complete will return 0\r\n   */\r\n  public get timeToNextAction() {\r\n    if (this.complete) {\r\n      return 0;\r\n    }\r\n    return this.interval - this._elapsedTime;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds elapsed toward the next action\r\n   */\r\n  public get timeElapsedTowardNextAction() {\r\n    return this._elapsedTime;\r\n  }\r\n\r\n  public get isRunning() {\r\n    return this._running;\r\n  }\r\n\r\n  /**\r\n   * Pauses the timer, time will no longer increment towards the next call\r\n   */\r\n  public pause(): Timer {\r\n    this._running = false;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resumes the timer, time will now increment towards the next call.\r\n   */\r\n  public resume(): Timer {\r\n    this._running = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter\r\n   */\r\n  public start(): Timer {\r\n    if (!this.scene) {\r\n      this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');\r\n    }\r\n\r\n    this._running = true;\r\n    if (this.complete) {\r\n      this._complete = false;\r\n      this._elapsedTime = 0;\r\n      this._numberOfTicks = 0;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops the timer and resets the elapsed time counter towards the next action invocation\r\n   */\r\n  public stop(): Timer {\r\n    this._running = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cancels the timer, preventing any further executions.\r\n   */\r\n  public cancel() {\r\n    this.pause();\r\n    if (this.scene) {\r\n      this.scene.cancelTimer(this);\r\n    }\r\n  }\r\n}\r\n\r\n","import { Component } from '../EntityComponentSystem/Component';\r\nimport { vec, Vector } from '../Math/vector';\r\n\r\nexport class ParallaxComponent extends Component<'ex.parallax'> {\r\n  readonly type = 'ex.parallax';\r\n\r\n  parallaxFactor = vec(1.0, 1.0);\r\n\r\n  constructor(parallaxFactor?: Vector) {\r\n    super();\r\n    this.parallaxFactor = parallaxFactor ?? this.parallaxFactor;\r\n  }\r\n}","import { ExcaliburGraphicsContext } from '.';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n\r\n/**\r\n * Provide arbitrary drawing for the purposes of debugging your game\r\n *\r\n * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]\r\n *\r\n */\r\nexport class DebugGraphicsComponent extends Component<'ex.debuggraphics'> {\r\n  readonly type = 'ex.debuggraphics';\r\n  constructor(public draw: (ctx: ExcaliburGraphicsContext) => void, public useTransform = true) {\r\n    super();\r\n  }\r\n}","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Engine } from '../Engine';\r\nimport { Vector, vec } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport * as Events from '../Events';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { BodyComponent } from '../Collision/BodyComponent';\r\nimport { CollisionType } from '../Collision/CollisionType';\r\nimport { Shape } from '../Collision/Colliders/Shape';\r\nimport { ExcaliburGraphicsContext, Graphic, GraphicsComponent, hasGraphicsTick, ParallaxComponent } from '../Graphics';\r\nimport { removeItemFromArray } from '../Util/Util';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { CompositeCollider } from '../Collision/Colliders/CompositeCollider';\r\nimport { Color } from '../Color';\r\nimport { DebugGraphicsComponent } from '../Graphics/DebugGraphicsComponent';\r\nimport { Collider } from '../Collision/Colliders/Collider';\r\n\r\nexport interface TileMapOptions {\r\n  /**\r\n   * Optionally name the isometric tile map\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally specify the position of the isometric tile map\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Width of an individual tile in pixels\r\n   */\r\n  tileWidth: number;\r\n  /**\r\n   * Height of an individual tile in pixels\r\n   */\r\n  tileHeight: number;\r\n  /**\r\n   * The number of tile columns, or the number of tiles wide\r\n   */\r\n  columns: number;\r\n  /**\r\n   * The number of tile  rows, or the number of tiles high\r\n   */\r\n  rows: number;\r\n\r\n  /**\r\n   * Optionally render from the top of the graphic, by default tiles are rendered from the bottom\r\n   */\r\n  renderFromTopOfGraphic?: boolean;\r\n}\r\n\r\n/**\r\n * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.\r\n *\r\n * TileMaps are useful for top down or side scrolling grid oriented games.\r\n */\r\nexport class TileMap extends Entity {\r\n  private _token = 0;\r\n  private _onScreenXStart: number = 0;\r\n  private _onScreenXEnd: number = Number.MAX_VALUE;\r\n  private _onScreenYStart: number = 0;\r\n  private _onScreenYEnd: number = Number.MAX_VALUE;\r\n\r\n  public logger: Logger = Logger.getInstance();\r\n  public readonly tiles: Tile[] = [];\r\n  private _rows: Tile[][] = [];\r\n  private _cols: Tile[][] = [];\r\n\r\n  public readonly tileWidth: number;\r\n  public readonly tileHeight: number;\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  public renderFromTopOfGraphic = false;\r\n\r\n  private _collidersDirty = true;\r\n  public flagCollidersDirty() {\r\n    this._collidersDirty = true;\r\n\r\n  }\r\n  private _transform: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _graphics: GraphicsComponent;\r\n  private _collider: ColliderComponent;\r\n  private _composite: CompositeCollider;\r\n\r\n  public get x(): number {\r\n    return this._transform.pos.x ?? 0;\r\n  }\r\n\r\n  public set x(val: number) {\r\n    if (this._transform?.pos) {\r\n      this.get(TransformComponent).pos = vec(val, this.y);\r\n    }\r\n  }\r\n\r\n  public get y(): number {\r\n    return this._transform?.pos.y ?? 0;\r\n  }\r\n\r\n  public set y(val: number) {\r\n    if (this._transform?.pos) {\r\n      this._transform.pos = vec(this.x, val);\r\n    }\r\n  }\r\n\r\n  public get z(): number {\r\n    return this._transform.z ?? 0;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    if (this._transform) {\r\n      this._transform.z = val;\r\n    }\r\n  }\r\n\r\n  public get rotation(): number {\r\n    return this._transform?.rotation ?? 0;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    if (this._transform?.rotation) {\r\n      this._transform.rotation = val;\r\n    }\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this._transform?.scale ?? Vector.One;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    if (this._transform?.scale) {\r\n      this._transform.scale = val;\r\n    }\r\n  }\r\n\r\n  private _oldPos: Vector;\r\n  public get pos(): Vector {\r\n    return this._transform.pos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this._transform.pos = val;\r\n  }\r\n\r\n  public get vel(): Vector {\r\n    return this._motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this._motion.vel = val;\r\n  }\r\n\r\n  public on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n\r\n  /**\r\n   * @param options\r\n   */\r\n  constructor(options: TileMapOptions) {\r\n    super(null, options.name);\r\n    this.addComponent(new TransformComponent());\r\n    this.addComponent(new MotionComponent());\r\n    this.addComponent(\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      })\r\n    );\r\n    this.addComponent(\r\n      new GraphicsComponent({\r\n        onPostDraw: (ctx, delta) => this.draw(ctx, delta)\r\n      })\r\n    );\r\n    this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));\r\n    this.addComponent(new ColliderComponent());\r\n    this._graphics = this.get(GraphicsComponent);\r\n    this._transform = this.get(TransformComponent);\r\n    this._motion = this.get(MotionComponent);\r\n    this._collider = this.get(ColliderComponent);\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n\r\n    this._transform.pos = options.pos ?? Vector.Zero;\r\n    this._oldPos = this._transform.pos;\r\n    this.renderFromTopOfGraphic = options.renderFromTopOfGraphic ?? this.renderFromTopOfGraphic;\r\n    this.tileWidth = options.tileWidth;\r\n    this.tileHeight = options.tileHeight;\r\n    this.rows = options.rows;\r\n    this.columns = options.columns;\r\n    this.tiles = new Array<Tile>(this.rows * this.columns);\r\n    this._rows = new Array(this.rows);\r\n    this._cols = new Array(this.columns);\r\n    let currentCol: Tile[] = [];\r\n    for (let i = 0; i < this.columns; i++) {\r\n      for (let j = 0; j < this.rows; j++) {\r\n        const cd = new Tile({\r\n          x: i,\r\n          y: j,\r\n          map: this\r\n        });\r\n        cd.map = this;\r\n        this.tiles[i + j * this.columns] = cd;\r\n        currentCol.push(cd);\r\n        if (!this._rows[j]) {\r\n          this._rows[j] = [];\r\n        }\r\n        this._rows[j].push(cd);\r\n      }\r\n      this._cols[i] = currentCol;\r\n      currentCol = [];\r\n    }\r\n\r\n    this._graphics.localBounds = new BoundingBox({\r\n      left: 0,\r\n      top: 0,\r\n      right: this.columns * this.tileWidth,\r\n      bottom: this.rows * this.tileHeight\r\n    });\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n\r\n  private _originalOffsets = new WeakMap<Collider, Vector>();\r\n  private _getOrSetColliderOriginalOffset(collider: Collider): Vector {\r\n    if (!this._originalOffsets.has(collider)) {\r\n      const originalOffset = collider.offset;\r\n      this._originalOffsets.set(collider, originalOffset);\r\n      return originalOffset;\r\n    } else {\r\n      return this._originalOffsets.get(collider);\r\n    }\r\n  }\r\n  /**\r\n   * Tiles colliders based on the solid tiles in the tilemap.\r\n   */\r\n  private _updateColliders(): void {\r\n    this._composite.clearColliders();\r\n    const colliders: BoundingBox[] = [];\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n    let current: BoundingBox;\r\n    // Bad square tesselation algo\r\n    for (let i = 0; i < this.columns; i++) {\r\n      // Scan column for colliders\r\n      for (let j = 0; j < this.rows; j++) {\r\n        // Columns start with a new collider\r\n        if (j === 0) {\r\n          current = null;\r\n        }\r\n        const tile = this.tiles[i + j * this.columns];\r\n        // Current tile in column is solid build up current collider\r\n        if (tile.solid) {\r\n          // Use custom collider otherwise bounding box\r\n          if (tile.getColliders().length > 0) {\r\n            for (const collider of tile.getColliders()) {\r\n              const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n              collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);\r\n              collider.owner = this;\r\n              this._composite.addCollider(collider);\r\n            }\r\n            current = null;\r\n          } else {\r\n            if (!current) {\r\n              current = tile.bounds;\r\n            } else {\r\n              current = current.combine(tile.bounds);\r\n            }\r\n          }\r\n        } else {\r\n          // Not solid skip and cut off the current collider\r\n          if (current) {\r\n            colliders.push(current);\r\n          }\r\n          current = null;\r\n        }\r\n      }\r\n      // After a column is complete check to see if it can be merged into the last one\r\n      if (current) {\r\n        // if previous is the same combine it\r\n        const prev = colliders[colliders.length - 1];\r\n        if (prev && prev.top === current.top && prev.bottom === current.bottom) {\r\n          colliders[colliders.length - 1] = prev.combine(current);\r\n        } else {\r\n          // else new collider\r\n          colliders.push(current);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const c of colliders) {\r\n      const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));\r\n      collider.owner = this;\r\n      this._composite.addCollider(collider);\r\n    }\r\n    this._collider.update();\r\n  }\r\n\r\n  /**\r\n   * Returns the [[Tile]] by index (row major order)\r\n   */\r\n  public getTileByIndex(index: number): Tile {\r\n    return this.tiles[index];\r\n  }\r\n  /**\r\n   * Returns the [[Tile]] by its x and y integer coordinates\r\n   */\r\n  public getTile(x: number, y: number): Tile {\r\n    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.tiles[x + y * this.columns];\r\n  }\r\n  /**\r\n   * Returns the [[Tile]] by testing a point in world coordinates,\r\n   * returns `null` if no Tile was found.\r\n   */\r\n  public getTileByPoint(point: Vector): Tile {\r\n    const x = Math.floor((point.x - this.pos.x) / this.tileWidth);\r\n    const y = Math.floor((point.y - this.pos.y) / this.tileHeight);\r\n    const tile = this.getTile(x, y);\r\n    if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {\r\n      return tile;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public getRows(): readonly Tile[][] {\r\n    return this._rows;\r\n  }\r\n\r\n  public getColumns(): readonly Tile[][] {\r\n    return this._cols;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    this.onPreUpdate(engine, delta);\r\n    this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));\r\n    if (!this._oldPos.equals(this.pos)) {\r\n      this.flagCollidersDirty();\r\n      for (let i = 0; i < this.tiles.length; i++) {\r\n        if (this.tiles[i]) {\r\n          this.tiles[i].flagDirty();\r\n        }\r\n      }\r\n    }\r\n    if (this._collidersDirty) {\r\n      this._collidersDirty = false;\r\n      this._updateColliders();\r\n    }\r\n\r\n    this._token++;\r\n    const worldBounds = engine.getWorldBounds();\r\n    const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);\r\n    const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);\r\n\r\n    let pos = this.pos;\r\n    const maybeParallax = this.get(ParallaxComponent);\r\n    let parallaxOffset = Vector.One;\r\n    if (maybeParallax) {\r\n      const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n      parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);\r\n      pos = pos.add(parallaxOffset);\r\n    }\r\n\r\n    this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);\r\n    this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);\r\n    this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);\r\n    this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);\r\n    // why are we resetting pos?\r\n    this._transform.pos = vec(this.x, this.y);\r\n\r\n    this.onPostUpdate(engine, delta);\r\n    this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));\r\n  }\r\n\r\n  /**\r\n   * Draws the tile map to the screen. Called by the [[Scene]].\r\n   * @param ctx ExcaliburGraphicsContext\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext, delta: number): void {\r\n    this.emit('predraw', new Events.PreDrawEvent(ctx as any, delta, this)); // TODO fix event\r\n\r\n    let x = this._onScreenXStart;\r\n    const xEnd = Math.min(this._onScreenXEnd, this.columns);\r\n    let y = this._onScreenYStart;\r\n    const yEnd = Math.min(this._onScreenYEnd, this.rows);\r\n\r\n    let graphics: readonly Graphic[], graphicsIndex: number, graphicsLen: number;\r\n\r\n    for (x; x < xEnd; x++) {\r\n      for (y; y < yEnd; y++) {\r\n        // get non-negative tile sprites\r\n        graphics = this.getTile(x, y).getGraphics();\r\n\r\n        for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {\r\n          // draw sprite, warning if sprite doesn't exist\r\n          const graphic = graphics[graphicsIndex];\r\n          if (graphic) {\r\n            if (hasGraphicsTick(graphic)) {\r\n              graphic?.tick(delta, this._token);\r\n            }\r\n            const offsetY = this.renderFromTopOfGraphic ? 0 : (graphic.height - this.tileHeight);\r\n            graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight - offsetY);\r\n          }\r\n        }\r\n      }\r\n      y = this._onScreenYStart;\r\n    }\r\n\r\n    this.emit('postdraw', new Events.PostDrawEvent(ctx as any, delta, this));\r\n  }\r\n\r\n  public debug(gfx: ExcaliburGraphicsContext) {\r\n    const width = this.tileWidth * this.columns;\r\n    const height = this.tileHeight * this.rows;\r\n    const pos = Vector.Zero;\r\n    for (let r = 0; r < this.rows + 1; r++) {\r\n      const yOffset = vec(0, r * this.tileHeight);\r\n      gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);\r\n    }\r\n\r\n    for (let c = 0; c < this.columns + 1; c++) {\r\n      const xOffset = vec(c * this.tileWidth, 0);\r\n      gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);\r\n    }\r\n\r\n    const colliders = this._composite.getColliders();\r\n    for (const collider of colliders) {\r\n      const grayish = Color.Gray;\r\n      grayish.a = 0.5;\r\n      const bounds = collider.localBounds;\r\n      const pos = collider.worldPos.sub(this.pos);\r\n      gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);\r\n    }\r\n  }\r\n}\r\n\r\nexport interface TileOptions {\r\n  /**\r\n   * Integer tile x coordinate\r\n   */\r\n  x: number;\r\n  /**\r\n   * Integer tile y coordinate\r\n   */\r\n  y: number;\r\n  map: TileMap;\r\n  solid?: boolean;\r\n  graphics?: Graphic[];\r\n}\r\n\r\n/**\r\n * TileMap Tile\r\n *\r\n * A light-weight object that occupies a space in a collision map. Generally\r\n * created by a [[TileMap]].\r\n *\r\n * Tiles can draw multiple sprites. Note that the order of drawing is the order\r\n * of the sprites in the array so the last one will be drawn on top. You can\r\n * use transparency to create layers this way.\r\n */\r\nexport class Tile extends Entity {\r\n  private _bounds: BoundingBox;\r\n  private _pos: Vector;\r\n  private _posDirty = false;\r\n  // private _transform: TransformComponent;\r\n\r\n  /**\r\n   * Return the world position of the top left corner of the tile\r\n   */\r\n  public get pos() {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n      this._posDirty = false;\r\n    }\r\n    return this._pos;\r\n  }\r\n\r\n  /**\r\n   * Integer x coordinate of the tile\r\n   */\r\n  public readonly x: number;\r\n\r\n  /**\r\n   * Integer y coordinate of the tile\r\n   */\r\n  public readonly y: number;\r\n\r\n  /**\r\n   * Width of the tile in pixels\r\n   */\r\n  public readonly width: number;\r\n\r\n  /**\r\n   * Height of the tile in pixels\r\n   */\r\n  public readonly height: number;\r\n\r\n  /**\r\n   * Reference to the TileMap this tile is associated with\r\n   */\r\n  public map: TileMap;\r\n\r\n  private _solid = false;\r\n  /**\r\n   * Wether this tile should be treated as solid by the tilemap\r\n   */\r\n  public get solid(): boolean {\r\n    return this._solid;\r\n  }\r\n  /**\r\n   * Wether this tile should be treated as solid by the tilemap\r\n   */\r\n  public set solid(val: boolean) {\r\n    this.map?.flagCollidersDirty();\r\n    this._solid = val;\r\n  }\r\n\r\n  private _graphics: Graphic[] = [];\r\n\r\n  /**\r\n   * Current list of graphics for this tile\r\n   */\r\n  public getGraphics(): readonly Graphic[] {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Add another [[Graphic]] to this TileMap tile\r\n   * @param graphic\r\n   */\r\n  public addGraphic(graphic: Graphic) {\r\n    this._graphics.push(graphic);\r\n  }\r\n\r\n  /**\r\n   * Remove an instance of a [[Graphic]] from this tile\r\n   */\r\n  public removeGraphic(graphic: Graphic) {\r\n    removeItemFromArray(graphic, this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Clear all graphics from this tile\r\n   */\r\n  public clearGraphics() {\r\n    this._graphics.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Current list of colliders for this tile\r\n   */\r\n  private _colliders: Collider[] = [];\r\n\r\n  /**\r\n   * Returns the list of colliders\r\n   */\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Adds a custom collider to the [[Tile]] to use instead of it's bounds\r\n   *\r\n   * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.\r\n   *\r\n   * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n   * @param collider\r\n   */\r\n  public addCollider(collider: Collider) {\r\n    this._colliders.push(collider);\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes a collider from the [[Tile]]\r\n   * @param collider\r\n   */\r\n  public removeCollider(collider: Collider) {\r\n    const index = this._colliders.indexOf(collider);\r\n    if (index > -1) {\r\n      this._colliders.splice(index, 1);\r\n    }\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Clears all colliders from the [[Tile]]\r\n   */\r\n  public clearColliders() {\r\n    this._colliders.length = 0;\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Arbitrary data storage per tile, useful for any game specific data\r\n   */\r\n  public data = new Map<string, any>();\r\n\r\n  constructor(options: TileOptions) {\r\n    super();\r\n    this.x = options.x;\r\n    this.y = options.y;\r\n    this.map = options.map;\r\n    this.width = options.map.tileWidth;\r\n    this.height = options.map.tileHeight;\r\n    this.solid = options.solid ?? this.solid;\r\n    this._graphics = options.graphics ?? [];\r\n    this._recalculate();\r\n  }\r\n\r\n  public flagDirty() {\r\n    return this._posDirty = true;\r\n  }\r\n\r\n  private _recalculate() {\r\n    this._pos = this.map.pos.add(\r\n      vec(\r\n        this.x * this.map.tileWidth,\r\n        this.y * this.map.tileHeight));\r\n    this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);\r\n    this._posDirty = false;\r\n  }\r\n\r\n  public get bounds() {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._bounds;\r\n  }\r\n\r\n  public get center(): Vector {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n    }\r\n    return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);\r\n  }\r\n}","import { Engine } from './Engine';\r\nimport { Screen } from './Screen';\r\nimport { EasingFunction, EasingFunctions } from './Util/EasingFunctions';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { removeItemFromArray } from './Util/Util';\r\nimport { CanUpdate, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { PreUpdateEvent, PostUpdateEvent, GameEvent, InitializeEvent } from './Events';\r\nimport { Class } from './Class';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { Logger } from './Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { watchAny } from './Util/Watch';\r\nimport { AffineMatrix } from './Math/affine-matrix';\r\n\r\n/**\r\n * Interface that describes a custom camera strategy for tracking targets\r\n */\r\nexport interface CameraStrategy<T> {\r\n  /**\r\n   * Target of the camera strategy that will be passed to the action\r\n   */\r\n  target: T;\r\n\r\n  /**\r\n   * Camera strategies perform an action to calculate a new focus returned out of the strategy\r\n   * @param target The target object to apply this camera strategy (if any)\r\n   * @param camera The current camera implementation in excalibur running the game\r\n   * @param engine The current engine running the game\r\n   * @param delta The elapsed time in milliseconds since the last frame\r\n   */\r\n  action: (target: T, camera: Camera, engine: Engine, delta: number) => Vector;\r\n}\r\n\r\n/**\r\n * Container to house convenience strategy methods\r\n * @internal\r\n */\r\nexport class StrategyContainer {\r\n  constructor(public camera: Camera) {}\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n   * @param actor The actor to lock the camera to\r\n   */\r\n  public lockToActor(actor: Actor) {\r\n    this.camera.addStrategy(new LockCameraToActorStrategy(actor));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n   * @param actor The actor to lock the camera to\r\n   * @param axis The axis to follow the actor on\r\n   */\r\n  public lockToActorAxis(actor: Actor, axis: Axis) {\r\n    this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param actor Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  public elasticToActor(actor: Actor, cameraElasticity: number, cameraFriction: number) {\r\n    this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n   * @param actor Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  public radiusAroundActor(actor: Actor, radius: number) {\r\n    this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera\r\n   * @param box The bounding box to limit the camera to.\r\n   */\r\n  public limitCameraBounds(box: BoundingBox) {\r\n    this.camera.addStrategy(new LimitCameraBoundsStrategy(box));\r\n  }\r\n}\r\n\r\n/**\r\n * Camera axis enum\r\n */\r\nexport enum Axis {\r\n  X,\r\n  Y\r\n}\r\n\r\n/**\r\n * Lock a camera to the exact x/y position of an actor.\r\n */\r\nexport class LockCameraToActorStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor) {}\r\n  public action = (target: Actor, _cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    return center;\r\n  };\r\n}\r\n\r\n/**\r\n * Lock a camera to a specific axis around an actor.\r\n */\r\nexport class LockCameraToActorAxisStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor, public axis: Axis) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    const currentFocus = cam.getFocus();\r\n    if (this.axis === Axis.X) {\r\n      return new Vector(center.x, currentFocus.y);\r\n    } else {\r\n      return new Vector(currentFocus.x, center.y);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.\r\n */\r\nexport class ElasticToActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param target Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  constructor(public target: Actor, public cameraElasticity: number, public cameraFriction: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    let focus = cam.getFocus();\r\n    let cameraVel = cam.vel.clone();\r\n\r\n    // Calculate the stretch vector, using the spring equation\r\n    // F = kX\r\n    // https://en.wikipedia.org/wiki/Hooke's_law\r\n    // Apply to the current camera velocity\r\n    const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X\r\n    cameraVel = cameraVel.add(stretch);\r\n\r\n    // Calculate the friction (-1 to apply a force in the opposition of motion)\r\n    // Apply to the current camera velocity\r\n    const friction = cameraVel.scale(-1).scale(this.cameraFriction);\r\n    cameraVel = cameraVel.add(friction);\r\n\r\n    // Update position by velocity deltas\r\n    focus = focus.add(cameraVel);\r\n\r\n    return focus;\r\n  };\r\n}\r\n\r\nexport class RadiusAroundActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   *\r\n   * @param target Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  constructor(public target: Actor, public radius: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    const focus = cam.getFocus();\r\n\r\n    const direction = position.sub(focus);\r\n    const distance = direction.size;\r\n    if (distance >= this.radius) {\r\n      const offset = distance - this.radius;\r\n      return focus.add(direction.normalize().scale(offset));\r\n    }\r\n    return focus;\r\n  };\r\n}\r\n\r\n/**\r\n * Prevent a camera from going beyond the given camera dimensions.\r\n */\r\nexport class LimitCameraBoundsStrategy implements CameraStrategy<BoundingBox> {\r\n  /**\r\n   * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.\r\n   *\r\n   * Note that this strategy does not perform any movement by itself.\r\n   * It only sets the camera position to within the given bounds when the camera has gone beyond them.\r\n   * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.\r\n   *\r\n   * Make sure that the camera bounds are at least as large as the viewport size.\r\n   *\r\n   * @param target The bounding box to limit the camera to\r\n   */\r\n\r\n  boundSizeChecked: boolean = false; // Check and warn only once\r\n\r\n  constructor(public target: BoundingBox) {}\r\n\r\n  public action = (target: BoundingBox, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const focus = cam.getFocus();\r\n\r\n    if (!this.boundSizeChecked) {\r\n      if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {\r\n        Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');\r\n      }\r\n      this.boundSizeChecked = true;\r\n    }\r\n\r\n    let focusX = focus.x;\r\n    let focusY = focus.y;\r\n    if (focus.x < target.left + _eng.halfDrawWidth) {\r\n      focusX = target.left + _eng.halfDrawWidth;\r\n    } else if (focus.x > target.right - _eng.halfDrawWidth) {\r\n      focusX = target.right - _eng.halfDrawWidth;\r\n    }\r\n\r\n    if (focus.y < target.top + _eng.halfDrawHeight) {\r\n      focusY = target.top + _eng.halfDrawHeight;\r\n    } else if (focus.y > target.bottom - _eng.halfDrawHeight) {\r\n      focusY = target.bottom - _eng.halfDrawHeight;\r\n    }\r\n\r\n    return vec(focusX, focusY);\r\n  };\r\n}\r\n\r\n/**\r\n * Cameras\r\n *\r\n * [[Camera]] is the base class for all Excalibur cameras. Cameras are used\r\n * to move around your game and set focus. They are used to determine\r\n * what is \"off screen\" and can be used to scale the game.\r\n *\r\n */\r\nexport class Camera extends Class implements CanUpdate, CanInitialize {\r\n  public transform: AffineMatrix = AffineMatrix.identity();\r\n  public inverse: AffineMatrix = AffineMatrix.identity();\r\n\r\n\r\n  protected _follow: Actor;\r\n\r\n  private _cameraStrategies: CameraStrategy<any>[] = [];\r\n\r\n  public strategy: StrategyContainer = new StrategyContainer(this);\r\n\r\n  /**\r\n   * Get or set current zoom of the camera, defaults to 1\r\n   */\r\n  private _z = 1;\r\n  public get zoom(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set zoom(val: number) {\r\n    this._z = val;\r\n    if (this._engine) {\r\n      this._halfWidth = this._engine.halfDrawWidth;\r\n      this._halfHeight = this._engine.halfDrawHeight;\r\n    }\r\n  }\r\n  /**\r\n   * Get or set rate of change in zoom, defaults to 0\r\n   */\r\n  public dz: number = 0;\r\n  /**\r\n   * Get or set zoom acceleration\r\n   */\r\n  public az: number = 0;\r\n\r\n  /**\r\n   * Current rotation of the camera\r\n   */\r\n  public rotation: number = 0;\r\n\r\n  private _angularVelocity: number = 0;\r\n\r\n  /**\r\n   * Get or set the camera's angular velocity\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this._angularVelocity;\r\n  }\r\n\r\n  public set angularVelocity(value: number) {\r\n    this._angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's position\r\n   */\r\n  private _posChanged = false;\r\n  private _pos: Vector = watchAny(Vector.Zero, () => (this._posChanged = true));\r\n  public get pos(): Vector {\r\n    return this._pos;\r\n  }\r\n  public set pos(vec: Vector) {\r\n    this._pos = watchAny(vec, () => (this._posChanged = true));\r\n    this._posChanged = true;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's velocity\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Get or set the camera's acceleration\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  private _cameraMoving: boolean = false;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1000; // 1 second\r\n  private _lerpStart: Vector = null;\r\n  private _lerpEnd: Vector = null;\r\n  private _lerpResolve: (value: Vector) => void;\r\n  private _lerpPromise: Promise<Vector>;\r\n\r\n  //camera effects\r\n  protected _isShaking: boolean = false;\r\n  private _shakeMagnitudeX: number = 0;\r\n  private _shakeMagnitudeY: number = 0;\r\n  private _shakeDuration: number = 0;\r\n  private _elapsedShakeTime: number = 0;\r\n  private _xShake: number = 0;\r\n  private _yShake: number = 0;\r\n\r\n  protected _isZooming: boolean = false;\r\n  private _zoomStart: number = 1;\r\n  private _zoomEnd: number = 1;\r\n  private _currentZoomTime: number = 0;\r\n  private _zoomDuration: number = 0;\r\n\r\n  private _zoomResolve: (val: boolean) => void;\r\n  private _zoomPromise: Promise<boolean>;\r\n  private _zoomEasing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n  private _easing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n\r\n  private _halfWidth: number = 0;\r\n  private _halfHeight: number = 0;\r\n\r\n  /**\r\n   * Get the camera's x position\r\n   */\r\n  public get x() {\r\n    return this.pos.x;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set x(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(value, this.pos.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the camera's y position\r\n   */\r\n  public get y() {\r\n    return this.pos.y;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set y(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(this.pos.x, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x velocity\r\n   */\r\n  public get dx() {\r\n    return this.vel.x;\r\n  }\r\n\r\n  public set dx(value: number) {\r\n    this.vel = vec(value, this.vel.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y velocity\r\n   */\r\n  public get dy() {\r\n    return this.vel.y;\r\n  }\r\n\r\n  public set dy(value: number) {\r\n    this.vel = vec(this.vel.x, value);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x acceleration\r\n   */\r\n  public get ax() {\r\n    return this.acc.x;\r\n  }\r\n\r\n  public set ax(value: number) {\r\n    this.acc = vec(value, this.acc.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y acceleration\r\n   */\r\n  public get ay() {\r\n    return this.acc.y;\r\n  }\r\n\r\n  public set ay(value: number) {\r\n    this.acc = vec(this.acc.x, value);\r\n  }\r\n\r\n  /**\r\n   * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n   */\r\n  public getFocus() {\r\n    return this.pos;\r\n  }\r\n\r\n  /**\r\n   * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n   *\r\n   * @param pos The target position to move to\r\n   * @param duration The duration in milliseconds the move should last\r\n   * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n   * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.\r\n   *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n   */\r\n  public move(pos: Vector, duration: number, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<Vector> {\r\n    if (typeof easingFn !== 'function') {\r\n      throw 'Please specify an EasingFunction';\r\n    }\r\n\r\n    // cannot move when following an actor\r\n    if (this._follow) {\r\n      return Promise.reject(pos);\r\n    }\r\n\r\n    // resolve existing promise, if any\r\n    if (this._lerpPromise && this._lerpResolve) {\r\n      this._lerpResolve(pos);\r\n    }\r\n\r\n    this._lerpPromise = new Promise<Vector>((resolve) => {\r\n      this._lerpResolve = resolve;\r\n    });\r\n    this._lerpStart = this.getFocus().clone();\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = pos;\r\n    this._currentLerpTime = 0;\r\n    this._cameraMoving = true;\r\n    this._easing = easingFn;\r\n\r\n    return this._lerpPromise;\r\n  }\r\n\r\n  /**\r\n   * Sets the camera to shake at the specified magnitudes for the specified duration\r\n   * @param magnitudeX  The x magnitude of the shake\r\n   * @param magnitudeY  The y magnitude of the shake\r\n   * @param duration    The duration of the shake in milliseconds\r\n   */\r\n  public shake(magnitudeX: number, magnitudeY: number, duration: number) {\r\n    this._isShaking = true;\r\n    this._shakeMagnitudeX = magnitudeX;\r\n    this._shakeMagnitudeY = magnitudeY;\r\n    this._shakeDuration = duration;\r\n  }\r\n\r\n  /**\r\n   * Zooms the camera in or out by the specified scale over the specified duration.\r\n   * If no duration is specified, it take effect immediately.\r\n   * @param scale    The scale of the zoom\r\n   * @param duration The duration of the zoom in milliseconds\r\n   */\r\n  public zoomOverTime(scale: number, duration: number = 0, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<boolean> {\r\n    this._zoomPromise = new Promise<boolean>((resolve) => {\r\n      this._zoomResolve = resolve;\r\n    });\r\n\r\n    if (duration) {\r\n      this._isZooming = true;\r\n      this._zoomEasing = easingFn;\r\n      this._currentZoomTime = 0;\r\n      this._zoomDuration = duration;\r\n      this._zoomStart = this.zoom;\r\n      this._zoomEnd = scale;\r\n    } else {\r\n      this._isZooming = false;\r\n      this.zoom = scale;\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    return this._zoomPromise;\r\n  }\r\n\r\n  private _viewport: BoundingBox = null;\r\n  /**\r\n   * Gets the bounding box of the viewport of this camera in world coordinates\r\n   */\r\n  public get viewport(): BoundingBox {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n\r\n    return new BoundingBox(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Adds a new camera strategy to this camera\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public addStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    this._cameraStrategies.push(cameraStrategy);\r\n  }\r\n\r\n  /**\r\n   * Removes a camera strategy by reference\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public removeStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    removeItemFromArray(cameraStrategy, this._cameraStrategies);\r\n  }\r\n\r\n  /**\r\n   * Clears all camera strategies from the camera\r\n   */\r\n  public clearAllStrategies() {\r\n    this._cameraStrategies.length = 0;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  private _engine: Engine;\r\n  private _screen: Screen;\r\n  private _isInitialized = false;\r\n  public get isInitialized() {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public _initialize(_engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this._engine = _engine;\r\n      this._screen = _engine.screen;\r\n\r\n      const currentRes = this._screen.resolution;\r\n      let center = vec(currentRes.width / 2, currentRes.height / 2);\r\n      if (!this._engine.loadingComplete) {\r\n        // If there was a loading screen, we peek the configured resolution\r\n        const res = this._screen.peekResolution();\r\n        if (res) {\r\n          center = vec(res.width / 2, res.height / 2);\r\n        }\r\n      }\r\n      this._halfWidth = center.x;\r\n      this._halfHeight = center.y;\r\n\r\n      // If the user has not set the camera pos, apply default center screen position\r\n      if (!this._posChanged) {\r\n        this.pos = center;\r\n      }\r\n      // First frame bootstrap\r\n\r\n      // Ensure camera tx is correct\r\n      // Run update twice to ensure properties are init'd\r\n      this.updateTransform();\r\n\r\n      // Run strategies for first frame\r\n      this.runStrategies(_engine, _engine.clock.elapsed());\r\n\r\n      // Setup the first frame viewport\r\n      this.updateViewport();\r\n\r\n      // It's important to update the camera after strategies\r\n      // This prevents jitter\r\n      this.updateTransform();\r\n\r\n      this.onInitialize(_engine);\r\n      super.emit('initialize', new InitializeEvent(_engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onInitialize(_engine: Engine) {\r\n    // Overridable\r\n  }\r\n\r\n  public on(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public on(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public on(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public on(eventName: any, handler: any) {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'initialize', handler?: (event: InitializeEvent) => void): void;\r\n  public off(eventName: 'preupdate', handler?: (event: PreUpdateEvent) => void): void;\r\n  public off(eventName: 'postupdate', handler?: (event: PostUpdateEvent) => void): void;\r\n  public off(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public off(eventName: string, handler: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public once(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public once(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public runStrategies(engine: Engine, delta: number) {\r\n    for (const s of this._cameraStrategies) {\r\n      this.pos = s.action.call(s, s.target, this, engine, delta);\r\n    }\r\n  }\r\n\r\n  public updateViewport() {\r\n    // recalc viewport\r\n    this._viewport = new BoundingBox(\r\n      this.x - this._halfWidth,\r\n      this.y - this._halfHeight,\r\n      this.x + this._halfWidth,\r\n      this.y + this._halfHeight\r\n    );\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this._initialize(_engine);\r\n    this._preupdate(_engine, delta);\r\n\r\n    // Update placements based on linear algebra\r\n    this.pos = this.pos.add(this.vel.scale(delta / 1000));\r\n    this.zoom += (this.dz * delta) / 1000;\r\n\r\n    this.vel = this.vel.add(this.acc.scale(delta / 1000));\r\n    this.dz += (this.az * delta) / 1000;\r\n\r\n    this.rotation += (this.angularVelocity * delta) / 1000;\r\n\r\n    if (this._isZooming) {\r\n      if (this._currentZoomTime < this._zoomDuration) {\r\n        const zoomEasing = this._zoomEasing;\r\n        const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);\r\n\r\n        this.zoom = newZoom;\r\n        this._currentZoomTime += delta;\r\n      } else {\r\n        this._isZooming = false;\r\n        this.zoom = this._zoomEnd;\r\n        this._currentZoomTime = 0;\r\n        this._zoomResolve(true);\r\n      }\r\n    }\r\n\r\n    if (this._cameraMoving) {\r\n      if (this._currentLerpTime < this._lerpDuration) {\r\n        const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);\r\n\r\n        const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);\r\n\r\n        this.pos = lerpPoint;\r\n\r\n        this._currentLerpTime += delta;\r\n      } else {\r\n        this.pos = this._lerpEnd;\r\n        const end = this._lerpEnd.clone();\r\n\r\n        this._lerpStart = null;\r\n        this._lerpEnd = null;\r\n        this._currentLerpTime = 0;\r\n        this._cameraMoving = false;\r\n        // Order matters here, resolve should be last so any chain promises have a clean slate\r\n        this._lerpResolve(end);\r\n      }\r\n    }\r\n\r\n    if (this._isDoneShaking()) {\r\n      this._isShaking = false;\r\n      this._elapsedShakeTime = 0;\r\n      this._shakeMagnitudeX = 0;\r\n      this._shakeMagnitudeY = 0;\r\n      this._shakeDuration = 0;\r\n      this._xShake = 0;\r\n      this._yShake = 0;\r\n    } else {\r\n      this._elapsedShakeTime += delta;\r\n      this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;\r\n      this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;\r\n    }\r\n\r\n    this.runStrategies(_engine, delta);\r\n\r\n    this.updateViewport();\r\n\r\n    // It's important to update the camera after strategies\r\n    // This prevents jitter\r\n    this.updateTransform();\r\n\r\n    this._postupdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Applies the relevant transformations to the game canvas to \"move\" or apply effects to the Camera\r\n   * @param ctx Canvas context to apply transformations\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext): void {\r\n    ctx.multiply(this.transform);\r\n  }\r\n\r\n  public updateTransform() {\r\n    // center the camera\r\n    const newCanvasWidth = this._screen.resolution.width / this.zoom;\r\n    const newCanvasHeight = this._screen.resolution.height / this.zoom;\r\n    const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);\r\n\r\n    // Calculate camera transform\r\n    this.transform.reset();\r\n    this.transform.scale(this.zoom, this.zoom);\r\n    this.transform.translate(cameraPos.x, cameraPos.y);\r\n    this.transform.inverse(this.inverse);\r\n  }\r\n\r\n  private _isDoneShaking(): boolean {\r\n    return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;\r\n  }\r\n}\r\n","import { Engine } from './Engine';\r\nimport { EventDispatcher } from './EventDispatcher';\r\nimport { Vector } from './Math/vector';\r\nimport { ExitTriggerEvent, EnterTriggerEvent, CollisionEndEvent, CollisionStartEvent } from './Events';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { Entity } from './EntityComponentSystem';\r\nimport { Actor } from './Actor';\r\n\r\n/**\r\n * ITriggerOptions\r\n */\r\nexport interface TriggerOptions {\r\n  // position of the trigger\r\n  pos: Vector;\r\n  // width of the trigger\r\n  width: number;\r\n  // height of the trigger\r\n  height: number;\r\n  // whether the trigger is visible or not\r\n  visible: boolean;\r\n  // action to take when triggered\r\n  action: () => void;\r\n  // if specified the trigger will only fire on a specific actor and overrides any filter\r\n  target: Entity;\r\n  // Returns true if the triggers should fire on the collided actor\r\n  filter: (actor: Entity) => boolean;\r\n  // -1 if it should repeat forever\r\n  repeat: number;\r\n}\r\n\r\nconst triggerDefaults: Partial<TriggerOptions> = {\r\n  pos: Vector.Zero,\r\n  width: 10,\r\n  height: 10,\r\n  visible: false,\r\n  action: () => {\r\n    return;\r\n  },\r\n  filter: () => true,\r\n  repeat: -1\r\n};\r\n\r\n/**\r\n * Triggers are a method of firing arbitrary code on collision. These are useful\r\n * as 'buttons', 'switches', or to trigger effects in a game. By default triggers\r\n * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\r\n */\r\nexport class Trigger extends Actor {\r\n  private _target: Entity;\r\n  /**\r\n   * Action to fire when triggered by collision\r\n   */\r\n  public action: () => void = () => {\r\n    return;\r\n  };\r\n  /**\r\n   * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\r\n   * filter return true for the collided actor.\r\n   */\r\n  public filter: (actor: Entity) => boolean = () => true;\r\n  /**\r\n   * Number of times to repeat before killing the trigger,\r\n   */\r\n  public repeat: number = -1;\r\n\r\n  /**\r\n   *\r\n   * @param opts Trigger options\r\n   */\r\n  constructor(opts: Partial<TriggerOptions>) {\r\n    super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });\r\n    opts = {\r\n      ...triggerDefaults,\r\n      ...opts\r\n    };\r\n\r\n    this.filter = opts.filter || this.filter;\r\n    this.repeat = opts.repeat || this.repeat;\r\n    this.action = opts.action || this.action;\r\n    if (opts.target) {\r\n      this.target = opts.target;\r\n    }\r\n\r\n    this.graphics.visible = opts.visible;\r\n    this.body.collisionType = CollisionType.Passive;\r\n    this.eventDispatcher = new EventDispatcher();\r\n\r\n    this.events.on('collisionstart', (evt: CollisionStartEvent<Actor>) => {\r\n      if (this.filter(evt.other)) {\r\n        this.emit('enter', new EnterTriggerEvent(this, evt.other));\r\n        this._dispatchAction();\r\n        // remove trigger if its done, -1 repeat forever\r\n        if (this.repeat === 0) {\r\n          this.kill();\r\n        }\r\n      }\r\n    });\r\n\r\n    this.events.on('collisionend', (evt: CollisionEndEvent<Actor>) => {\r\n      if (this.filter(evt.other)) {\r\n        this.emit('exit', new ExitTriggerEvent(this, evt.other));\r\n      }\r\n    });\r\n  }\r\n\r\n  public set target(target: Entity) {\r\n    this._target = target;\r\n    this.filter = (actor: Entity) => actor === target;\r\n  }\r\n\r\n  public get target() {\r\n    return this._target;\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  private _dispatchAction() {\r\n    if (this.repeat !== 0) {\r\n      this.action.call(this);\r\n      this.repeat--;\r\n    }\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { Message, Observer } from '../Util/Observable';\r\nimport { Component } from './Component';\r\nimport { Scene } from '../Scene';\r\n\r\n/**\r\n * Enum that determines whether to run the system in the update or draw phase\r\n */\r\nexport enum SystemType {\r\n  Update = 'update',\r\n  Draw = 'draw'\r\n}\r\n\r\nexport type SystemTypes<ComponentTypes> = ComponentTypes extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * An Excalibur [[System]] that updates entities of certain types.\r\n * Systems are scene specific\r\n *\r\n * Excalibur Systems currently require at least 1 Component type to operated\r\n *\r\n * Multiple types are declared as a type union\r\n * For example:\r\n *\r\n * ```typescript\r\n * class MySystem extends System<ComponentA | ComponentB> {\r\n *   public readonly types = ['a', 'b'] as const;\r\n *   public readonly systemType = SystemType.Update;\r\n *   public update(entities: Entity<ComponentA | ComponentB>) {\r\n *      ...\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport abstract class System<ComponentTypeUnion extends Component = Component, ContextType = Scene>\r\nimplements Observer<AddedEntity | RemovedEntity> {\r\n  /**\r\n   * The types of entities that this system operates on\r\n   * For example ['transform', 'motion']\r\n   */\r\n  abstract readonly types: readonly SystemTypes<ComponentTypeUnion>[];\r\n\r\n  /**\r\n   * Determine whether the system is called in the [[SystemType.Update]] or the [[SystemType.Draw]] phase. Update is first, then Draw.\r\n   */\r\n  abstract readonly systemType: SystemType;\r\n\r\n  /**\r\n   * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.\r\n   * For a system to execute before all other a lower priority value (-1 for example) must be set.\r\n   * For a system to execute after all other a higher priority value (10 for example) must be set.\r\n   */\r\n  public priority: number = 0;\r\n\r\n  /**\r\n   * Optionally specify a sort order for entities passed to the your system\r\n   * @param a The left entity\r\n   * @param b The right entity\r\n   */\r\n  sort?(a: Entity, b: Entity): number;\r\n\r\n  /**\r\n   * Optionally specify an initialize handler\r\n   * @param scene\r\n   */\r\n  initialize?(engine: ContextType): void;\r\n\r\n  /**\r\n   * Update all entities that match this system's types\r\n   * @param entities Entities to update that match this system's types\r\n   * @param delta Time in milliseconds\r\n   */\r\n  abstract update(entities: Entity[], delta: number): void;\r\n\r\n  /**\r\n   * Optionally run a preupdate before the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  preupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Optionally run a postupdate after the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  postupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Systems observe when entities match their types or no longer match their types, override\r\n   * @param _entityAddedOrRemoved\r\n   */\r\n  public notify(_entityAddedOrRemoved: AddedEntity | RemovedEntity) {\r\n    // Override me\r\n  }\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.\r\n */\r\nexport class AddedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Added' = 'Entity Added';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * Type guard to check for AddedEntity messages\r\n * @param x\r\n */\r\nexport function isAddedSystemEntity(x: Message<Entity>): x is AddedEntity {\r\n  return !!x && x.type === 'Entity Added';\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.\r\n */\r\nexport class RemovedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Removed' = 'Entity Removed';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * type guard to check for the RemovedEntity message\r\n */\r\nexport function isRemoveSystemEntity(x: Message<Entity>): x is RemovedEntity {\r\n  return !!x && x.type === 'Entity Removed';\r\n}\r\n","import { Entity, RemovedComponent, AddedComponent, isAddedComponent, isRemovedComponent } from './Entity';\r\nimport { Observer } from '../Util/Observable';\r\nimport { World } from './World';\r\nimport { Util } from '..';\r\n\r\n// Add/Remove entities and components\r\n\r\nexport class EntityManager<ContextType = any> implements Observer<RemovedComponent | AddedComponent> {\r\n  public entities: Entity[] = [];\r\n  public _entityIndex: { [entityId: string]: Entity } = {};\r\n\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Runs the entity lifecycle\r\n   * @param _context\r\n   */\r\n  public updateEntities(_context: ContextType, elapsed: number) {\r\n    for (const entity of this.entities) {\r\n      // TODO is this right?\r\n      entity.update((_context as any).engine, elapsed);\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  public findEntitiesForRemoval() {\r\n    for (const entity of this.entities) {\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EntityManager observes changes on entities\r\n   * @param message\r\n   */\r\n  public notify(message: RemovedComponent | AddedComponent): void {\r\n    if (isAddedComponent(message)) {\r\n      // we don't need the component, it's already on the entity\r\n      this._world.queryManager.addEntity(message.data.entity);\r\n    }\r\n\r\n    if (isRemovedComponent(message)) {\r\n      this._world.queryManager.removeComponent(message.data.entity, message.data.component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be tracked by the EntityManager\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    entity.active = true;\r\n    if (entity && !this._entityIndex[entity.id]) {\r\n      this._entityIndex[entity.id] = entity;\r\n      this.entities.push(entity);\r\n      this._world.queryManager.addEntity(entity);\r\n      entity.componentAdded$.register(this);\r\n      entity.componentRemoved$.register(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.addEntity(c));\r\n      entity.childrenAdded$.register({\r\n        notify: (e) => {\r\n          this.addEntity(e);\r\n        }\r\n      });\r\n      entity.childrenRemoved$.register({\r\n        notify: (e) => {\r\n          this.removeEntity(e, false);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  public removeEntity(entity: Entity, deferred?: boolean): void;\r\n  public removeEntity(id: number, deferred?: boolean): void;\r\n  public removeEntity(idOrEntity: number | Entity, deferred = true): void {\r\n    let id = 0;\r\n    if (idOrEntity instanceof Entity) {\r\n      id = idOrEntity.id;\r\n    } else {\r\n      id = idOrEntity;\r\n    }\r\n    const entity = this._entityIndex[id];\r\n    if (entity && entity.active) {\r\n      entity.kill();\r\n    }\r\n\r\n    if (entity && deferred) {\r\n      this._entitiesToRemove.push(entity);\r\n      return;\r\n    }\r\n\r\n    delete this._entityIndex[id];\r\n    if (entity) {\r\n      Util.removeItemFromArray(entity, this.entities);\r\n      this._world.queryManager.removeEntity(entity);\r\n      entity.componentAdded$.unregister(this);\r\n      entity.componentRemoved$.unregister(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.removeEntity(c, deferred));\r\n      entity.childrenAdded$.clear();\r\n      entity.childrenRemoved$.clear();\r\n\r\n      // stats\r\n      if ((this._world.context as any)?.engine) {\r\n        (this._world.context as any).engine.stats.currFrame.actors.killed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _entitiesToRemove: Entity[] = [];\r\n  public processEntityRemovals(): void {\r\n    for (const entity of this._entitiesToRemove) {\r\n      if (entity.active) {\r\n        continue;\r\n      }\r\n      this.removeEntity(entity, false);\r\n    }\r\n  }\r\n\r\n  public processComponentRemovals(): void {\r\n    for (const entity of this.entities) {\r\n      entity.processComponentRemoval();\r\n    }\r\n  }\r\n\r\n  public getById(id: number): Entity {\r\n    return this._entityIndex[id];\r\n  }\r\n\r\n  public getByName(name: string): Entity[]{\r\n    return this.entities.filter(e => e.name === name);\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const entity of this.entities) {\r\n      this.removeEntity(entity);\r\n    }\r\n  }\r\n}\r\n","export const buildTypeKey = (types: readonly string[]) => {\r\n  const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');\r\n  return key;\r\n};\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Observable } from '../Util/Observable';\r\nimport { Util, Component, ComponentCtor } from '..';\r\nimport { AddedEntity, RemovedEntity } from './System';\r\n\r\n/**\r\n * Represents query for entities that match a list of types that is cached and observable\r\n *\r\n * Queries can be strongly typed by supplying a type union in the optional type parameter\r\n * ```typescript\r\n * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);\r\n * ```\r\n */\r\nexport class Query<T extends Component = Component> extends Observable<AddedEntity | RemovedEntity> {\r\n  public types: readonly string[];\r\n  private _entities: Entity[] = [];\r\n  private _key: string;\r\n  public get key(): string {\r\n    if (this._key) {\r\n      return this._key;\r\n    }\r\n    return (this._key = buildTypeKey(this.types));\r\n  }\r\n\r\n  constructor(types: readonly string[]);\r\n  constructor(types: readonly ComponentCtor<T>[]);\r\n  constructor(types: readonly string[] | readonly ComponentCtor<T>[]) {\r\n    super();\r\n    if (types[0] instanceof Function) {\r\n      this.types = (types as ComponentCtor<T>[]).map(T =>  (new T).type);\r\n    } else {\r\n      this.types = types as string[];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a list of entities that match the query\r\n   *\r\n   * @param sort Optional sorting function to sort entities returned from the query\r\n   */\r\n  public getEntities(sort?: (a: Entity, b: Entity) => number): Entity[] {\r\n    if (sort) {\r\n      this._entities.sort(sort);\r\n    }\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the query, will only be added if the entity matches the query types\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    if (!Util.contains(this._entities, entity) && this.matches(entity)) {\r\n      this._entities.push(entity);\r\n      this.notifyAll(new AddedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the entity is part of the query it will be removed regardless of types\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity): void {\r\n    if (Util.removeItemFromArray(entity, this._entities)) {\r\n      this.notifyAll(new RemovedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and observers from the query\r\n   */\r\n  public clear(): void {\r\n    this._entities.length = 0;\r\n    for (const observer of this.observers) {\r\n      this.unregister(observer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether the entity's types match query\r\n   * @param entity\r\n   */\r\n  public matches(entity: Entity): boolean;\r\n\r\n  /**\r\n   * Returns whether the list of ComponentTypes have at least the same types as the query\r\n   * @param types\r\n   */\r\n  public matches(types: string[]): boolean;\r\n  public matches(typesOrEntity: string[] | Entity): boolean {\r\n    let types: string[] = [];\r\n    if (typesOrEntity instanceof Entity) {\r\n      types = typesOrEntity.types;\r\n    } else {\r\n      types = typesOrEntity;\r\n    }\r\n\r\n    let matches = true;\r\n    for (const type of this.types) {\r\n      matches = matches && types.indexOf(type) > -1;\r\n      if (!matches) {\r\n        return false;\r\n      }\r\n    }\r\n    return matches;\r\n  }\r\n\r\n  public contain(type: string) {\r\n    return this.types.indexOf(type) > -1;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Query } from './Query';\r\nimport { Component } from './Component';\r\nimport { World } from './World';\r\n\r\n/**\r\n * The query manager is responsible for updating all queries when entities/components change\r\n */\r\nexport class QueryManager {\r\n  private _queries: { [entityComponentKey: string]: Query<any> } = {};\r\n\r\n  constructor(private _world: World<any>) {}\r\n\r\n  /**\r\n   * Adds a query to the manager and populates with any entities that match\r\n   * @param query\r\n   */\r\n  private _addQuery(query: Query<any>) {\r\n    this._queries[buildTypeKey(query.types)] = query;\r\n    for (const entity of this._world.entityManager.entities) {\r\n      query.addEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the query if there are no observers left\r\n   * @param query\r\n   */\r\n  public maybeRemoveQuery(query: Query): void {\r\n    if (query.observers.length === 0) {\r\n      query.clear();\r\n      delete this._queries[buildTypeKey(query.types)];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the entity to any matching query in the query manage\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      if (this._queries[queryType]) {\r\n        this._queries[queryType].addEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from queries if the removed component disqualifies it\r\n   * @param entity\r\n   * @param component\r\n   */\r\n  public removeComponent(entity: Entity, component: Component) {\r\n    for (const queryType in this._queries) {\r\n      // If the component being removed from an entity is a part of a query,\r\n      // it is now disqualified from that query, remove it\r\n      if (this._queries[queryType].contain(component.type)) {\r\n        this._queries[queryType].removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from all queries it is currently a part of\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      this._queries[queryType].removeEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance\r\n   * @param types\r\n   */\r\n  public createQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const maybeExistingQuery = this.getQuery<T>(types);\r\n    if (maybeExistingQuery) {\r\n      return maybeExistingQuery;\r\n    }\r\n    const query = new Query<T>(types);\r\n    this._addQuery(query);\r\n    return query;\r\n  }\r\n\r\n  /**\r\n   * Retrieves an existing query by types if it exists otherwise returns null\r\n   * @param types\r\n   */\r\n  public getQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const key = buildTypeKey(types);\r\n    if (this._queries[key]) {\r\n      return this._queries[key] as Query<T>;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","import { System, SystemType } from './System';\r\nimport { Scene, Util } from '..';\r\nimport { World } from './World';\r\n\r\nexport interface SystemCtor<T extends System> {\r\n  new (): T;\r\n}\r\n\r\n/**\r\n * The SystemManager is responsible for keeping track of all systems in a scene.\r\n * Systems are scene specific\r\n */\r\nexport class SystemManager<ContextType> {\r\n  /**\r\n   * List of systems, to add a new system call [[SystemManager.addSystem]]\r\n   */\r\n  public systems: System<any, ContextType>[] = [];\r\n  public _keyToSystem: { [key: string]: System<any, ContextType> };\r\n  public initialized = false;\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Get a system registered in the manager by type\r\n   * @param systemType\r\n   */\r\n  public get<T extends System>(systemType: SystemCtor<T>): T | null {\r\n    return this.systems.find((s) => s instanceof systemType) as unknown as T;\r\n  }\r\n\r\n  /**\r\n   * Adds a system to the manager, it will now be updated every frame\r\n   * @param system\r\n   */\r\n  public addSystem(system: System<any, ContextType>): void {\r\n    // validate system has types\r\n    if (!system.types || system.types.length === 0) {\r\n      throw new Error(`Attempted to add a System without any types`);\r\n    }\r\n\r\n    const query = this._world.queryManager.createQuery(system.types);\r\n    this.systems.push(system);\r\n    this.systems.sort((a, b) => a.priority - b.priority);\r\n    query.register(system);\r\n    if (this.initialized && system.initialize) {\r\n      system.initialize(this._world.context);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a system from the manager, it will no longer be updated\r\n   * @param system\r\n   */\r\n  public removeSystem(system: System<any, ContextType>) {\r\n    Util.removeItemFromArray(system, this.systems);\r\n    const query = this._world.queryManager.getQuery(system.types);\r\n    if (query) {\r\n      query.unregister(system);\r\n      this._world.queryManager.maybeRemoveQuery(query);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize all systems in the manager\r\n   *\r\n   * Systems added after initialize() will be initialized on add\r\n   */\r\n  public initialize() {\r\n    if (!this.initialized) {\r\n      this.initialized = true;\r\n      for (const s of this.systems) {\r\n        if (s.initialize) {\r\n          s.initialize(this._world.context);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates all systems\r\n   * @param type whether this is an update or draw system\r\n   * @param context context reference\r\n   * @param delta time in milliseconds\r\n   */\r\n  public updateSystems(type: SystemType, context: ContextType, delta: number) {\r\n    const systems = this.systems.filter((s) => s.systemType === type);\r\n    for (const s of systems) {\r\n      if (s.preupdate) {\r\n        s.preupdate(context, delta);\r\n      }\r\n    }\r\n\r\n    for (const s of systems) {\r\n      // Get entities that match the system types, pre-sort\r\n      const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);\r\n      // Initialize entities if needed\r\n      if (context instanceof Scene) {\r\n        for (const entity of entities) {\r\n          entity._initialize(context?.engine);\r\n        }\r\n      }\r\n      s.update(entities, delta);\r\n    }\r\n\r\n    for (const s of systems) {\r\n      if (s.postupdate) {\r\n        s.postupdate(context, delta);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const system of this.systems) {\r\n      this.removeSystem(system);\r\n    }\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { EntityManager } from './EntityManager';\r\nimport { QueryManager } from './QueryManager';\r\nimport { System, SystemType } from './System';\r\nimport { SystemManager } from './SystemManager';\r\n\r\n/**\r\n * The World is a self-contained entity component system for a particular context.\r\n */\r\nexport class World<ContextType> {\r\n  public queryManager: QueryManager = new QueryManager(this);\r\n  public entityManager: EntityManager<ContextType> = new EntityManager<ContextType>(this);\r\n  public systemManager: SystemManager<ContextType> = new SystemManager<ContextType>(this);\r\n\r\n  /**\r\n   * The context type is passed to the system updates\r\n   * @param context\r\n   */\r\n  constructor(public context: ContextType) {}\r\n\r\n  /**\r\n   * Update systems by type and time elapsed in milliseconds\r\n   */\r\n  update(type: SystemType, delta: number) {\r\n    if (type === SystemType.Update) {\r\n      this.entityManager.updateEntities(this.context, delta);\r\n    }\r\n    this.systemManager.updateSystems(type, this.context, delta);\r\n    this.entityManager.findEntitiesForRemoval();\r\n    this.entityManager.processComponentRemovals();\r\n    this.entityManager.processEntityRemovals();\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the ECS world\r\n   * @param entity\r\n   */\r\n  add(entity: Entity): void;\r\n  /**\r\n   * Add a system to the ECS world\r\n   * @param system\r\n   */\r\n  add(system: System<any, ContextType>): void;\r\n  add(entityOrSystem: Entity | System<any, ContextType>): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.addEntity(entityOrSystem);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.addSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from the ECS world\r\n   * @param entity\r\n   */\r\n  remove(entity: Entity, deferred?: boolean): void;\r\n  /**\r\n   * Remove a system from the ECS world\r\n   * @param system\r\n   */\r\n  remove(system: System<any, ContextType>): void;\r\n  remove(entityOrSystem: Entity | System<any, ContextType>, deferred = true): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.removeEntity(entityOrSystem, deferred);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.removeSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  clearEntities(): void {\r\n    this.entityManager.clear();\r\n  }\r\n\r\n  clearSystems(): void {\r\n    this.systemManager.clear();\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\n\r\nexport class EulerIntegrator {\r\n  // Scratch vectors to avoid allocation\r\n  private static _POS = new Vector(0, 0);\r\n  private static _SCALE = new Vector(1, 1);\r\n\r\n  private static _ACC = new Vector(0, 0);\r\n  private static _VEL = new Vector(0, 0);\r\n  private static _VEL_ACC = new Vector(0, 0);\r\n  private static _SCALE_FACTOR = new Vector(0, 0);\r\n\r\n  static integrate(transform: TransformComponent, motion: MotionComponent, totalAcc: Vector, elapsedMs: number): void {\r\n    const seconds = elapsedMs / 1000;\r\n    // This code looks a little wild, but it's to avoid creating any new Vector instances\r\n    // integration is done in a tight loop so this is key to avoid GC'ing\r\n    motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));\r\n    transform.pos\r\n      .add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS)\r\n      .addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));\r\n\r\n    motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;\r\n    const rotation = transform.rotation + motion.angularVelocity * seconds;\r\n\r\n    transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);\r\n    const tx = transform.get();\r\n    tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Physics } from './Physics';\r\nimport { BodyComponent } from './BodyComponent';\r\nimport { CollisionType } from './CollisionType';\r\nimport { EulerIntegrator } from './Integrator';\r\n\r\nexport class MotionSystem extends System<TransformComponent | MotionComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  update(entities: Entity[], elapsedMs: number): void {\r\n    let transform: TransformComponent;\r\n    let motion: MotionComponent;\r\n    for (let i = 0; i < entities.length; i++) {\r\n      transform = entities[i].get(TransformComponent);\r\n      motion = entities[i].get(MotionComponent);\r\n\r\n      const optionalBody = entities[i].get(BodyComponent);\r\n      if (optionalBody?.sleeping) {\r\n        continue;\r\n      }\r\n\r\n      const totalAcc = motion.acc.clone();\r\n      if (optionalBody?.collisionType === CollisionType.Active && optionalBody?.useGravity) {\r\n        totalAcc.addEqual(Physics.gravity);\r\n      }\r\n      optionalBody?.captureOldTransform();\r\n\r\n      // Update transform and motion based on Euler linear algebra\r\n      EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);\r\n    }\r\n  }\r\n}\r\n","import { PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Side } from '../Side';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,\r\n * and negates velocity along the collision normal.\r\n *\r\n * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.\r\n *\r\n */\r\nexport class ArcadeSolver implements CollisionSolver {\r\n  directionMap = new Map<string, string>();\r\n  distanceMap = new Map<string, number>();\r\n\r\n  public solve(contacts: CollisionContact[]): CollisionContact[] {\r\n    // Events and init\r\n    this.preSolve(contacts);\r\n\r\n    // Remove any canceled contacts\r\n    contacts = contacts.filter(c => !c.isCanceled());\r\n\r\n    // Sort contacts by distance to avoid artifacts with seams\r\n    // It's important to solve in a specific order\r\n    contacts.sort((a, b) => {\r\n      const aDist = this.distanceMap.get(a.id);\r\n      const bDist = this.distanceMap.get(b.id);\r\n      return aDist - bDist;\r\n    });\r\n\r\n    for (const contact of contacts) {\r\n      // Solve position first in arcade\r\n      this.solvePosition(contact);\r\n\r\n      // Solve velocity second in arcade\r\n      this.solveVelocity(contact);\r\n    }\r\n\r\n    // Events and any contact house-keeping the solver needs\r\n    this.postSolve(contacts);\r\n\r\n    return contacts;\r\n  }\r\n\r\n  public preSolve(contacts: CollisionContact[]) {\r\n\r\n    for (const contact of contacts) {\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n\r\n      const distance = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);\r\n      this.distanceMap.set(contact.id, distance);\r\n\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      if (contact.isCanceled()) {\r\n        continue;\r\n      }\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public solvePosition(contact: CollisionContact) {\r\n    const epsilon = .0001;\r\n    // if bounds no longer intersect skip to the next\r\n    // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles\r\n    if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {\r\n      // Cancel the contact to prevent and solving\r\n      contact.cancel();\r\n      return;\r\n    }\r\n\r\n    if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {\r\n      // Cancel near 0 mtv collisions\r\n      contact.cancel();\r\n      return;\r\n    }\r\n\r\n    let mtv = contact.mtv;\r\n    const colliderA = contact.colliderA;\r\n    const colliderB = contact.colliderB;\r\n    const bodyA = colliderA.owner?.get(BodyComponent);\r\n    const bodyB = colliderB.owner?.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n        return;\r\n      }\r\n\r\n      if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {\r\n        // split overlaps if both are Active\r\n        mtv = mtv.scale(0.5);\r\n      }\r\n\r\n      // Resolve overlaps\r\n      if (bodyA.collisionType === CollisionType.Active) {\r\n        bodyA.globalPos.x -= mtv.x;\r\n        bodyA.globalPos.y -= mtv.y;\r\n        colliderA.update(bodyA.transform.get());\r\n      }\r\n\r\n      if (bodyB.collisionType === CollisionType.Active) {\r\n        bodyB.globalPos.x += mtv.x;\r\n        bodyB.globalPos.y += mtv.y;\r\n        colliderB.update(bodyB.transform.get());\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  public solveVelocity(contact: CollisionContact) {\r\n    if (contact.isCanceled()) {\r\n      return;\r\n    }\r\n\r\n    const colliderA = contact.colliderA;\r\n    const colliderB = contact.colliderB;\r\n    const bodyA = colliderA.owner?.get(BodyComponent);\r\n    const bodyB = colliderB.owner?.get(BodyComponent);\r\n\r\n    if (bodyA && bodyB) {\r\n\r\n      if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n        return;\r\n      }\r\n\r\n      const normal = contact.normal;\r\n      const opposite = normal.negate();\r\n\r\n      if (bodyA.collisionType === CollisionType.Active) {\r\n        // only adjust velocity if the contact normal is opposite to the current velocity\r\n        // this avoids catching edges on a platform when sliding off\r\n        if (bodyA.vel.normalize().dot(opposite) < 0) {\r\n          // Cancel out velocity opposite direction of collision normal\r\n          const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));\r\n          bodyA.vel = bodyA.vel.add(velAdj);\r\n        }\r\n      }\r\n\r\n      if (bodyB.collisionType === CollisionType.Active) {\r\n        // only adjust velocity if the contact normal is opposite to the current velocity\r\n        // this avoids catching edges on a platform\r\n        if (bodyB.vel.normalize().dot(normal) < 0) {\r\n          const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));\r\n          bodyB.vel = bodyB.vel.add(velAdj);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\n\r\n/**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */\r\nexport class ContactConstraintPoint {\r\n  constructor(public point: Vector, public local: Vector, public contact: CollisionContact) {\r\n    this.update();\r\n  }\r\n\r\n  /**\r\n   * Updates the contact information\r\n   */\r\n  update() {\r\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\r\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\r\n\r\n    if (bodyA && bodyB) {\r\n      const normal = this.contact.normal;\r\n      const tangent = this.contact.tangent;\r\n\r\n      this.aToContact = this.point.sub(bodyA.globalPos);\r\n      this.bToContact = this.point.sub(bodyB.globalPos);\r\n\r\n      const aToContactNormal = this.aToContact.cross(normal);\r\n      const bToContactNormal = this.bToContact.cross(normal);\r\n\r\n      this.normalMass =\r\n        bodyA.inverseMass +\r\n        bodyB.inverseMass +\r\n        bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n        bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n      const aToContactTangent = this.aToContact.cross(tangent);\r\n      const bToContactTangent = this.bToContact.cross(tangent);\r\n\r\n      this.tangentMass =\r\n        bodyA.inverseMass +\r\n        bodyB.inverseMass +\r\n        bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n        bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns the relative velocity between bodyA and bodyB\r\n   */\r\n  public getRelativeVelocity() {\r\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\r\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      // Relative velocity in linear terms\r\n      // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\r\n      const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));\r\n      const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));\r\n      return velB.sub(velA);\r\n    }\r\n    return Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Impulse accumulated over time in normal direction\r\n   */\r\n  public normalImpulse: number = 0;\r\n\r\n  /**\r\n   * Impulse accumulated over time in the tangent direction\r\n   */\r\n  public tangentImpulse: number = 0;\r\n\r\n  /**\r\n   * Effective mass seen in the normal direction\r\n   */\r\n  public normalMass: number = 0;\r\n\r\n  /**\r\n   * Effective mass seen in the tangent direction\r\n   */\r\n  public tangentMass: number = 0;\r\n\r\n  /**\r\n   * Direction from center of mass of bodyA to contact point\r\n   */\r\n  public aToContact: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Direction from center of mass of bodyB to contact point\r\n   */\r\n  public bToContact: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Original contact velocity combined with bounciness\r\n   */\r\n  public originalVelocityAndRestitution: number = 0;\r\n}\r\n","import { CollisionPostSolveEvent, CollisionPreSolveEvent, PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { clamp } from '../../Math/util';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { ContactConstraintPoint } from './ContactConstraintPoint';\r\nimport { Side } from '../Side';\r\nimport { Physics } from '../Physics';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent, DegreeOfFreedom } from '../BodyComponent';\r\nimport { CollisionJumpTable } from '../Colliders/CollisionJumpTable';\r\n\r\nexport class RealisticSolver implements CollisionSolver {\r\n  lastFrameContacts: Map<string, CollisionContact> = new Map();\r\n\r\n  // map contact id to contact points\r\n  idToContactConstraint: Map<string, ContactConstraintPoint[]> = new Map();\r\n\r\n  getContactConstraints(id: string) {\r\n    return this.idToContactConstraint.get(id) ?? [];\r\n  }\r\n\r\n  public solve(contacts: CollisionContact[]): CollisionContact[] {\r\n    // Events and init\r\n    this.preSolve(contacts);\r\n\r\n    // Remove any canceled contacts\r\n    contacts = contacts.filter(c => !c.isCanceled());\r\n\r\n    // Solve velocity first\r\n    this.solveVelocity(contacts);\r\n\r\n    // Solve position last because non-overlap is the most important\r\n    this.solvePosition(contacts);\r\n\r\n    // Events and any contact house-keeping the solver needs\r\n    this.postSolve(contacts);\r\n\r\n    return contacts;\r\n  }\r\n\r\n  preSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n\r\n      // Match awake state for sleeping\r\n      contact.matchAwake();\r\n    }\r\n\r\n    // Keep track of contacts that done\r\n    const finishedContactIds = Array.from(this.idToContactConstraint.keys());\r\n    for (const contact of contacts) {\r\n      // Remove all current contacts that are not done\r\n      const index = finishedContactIds.indexOf(contact.id);\r\n      if (index > -1) {\r\n        finishedContactIds.splice(index, 1);\r\n      }\r\n      const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n      let pointIndex = 0;\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        for (const point of contact.points) {\r\n          const normal = contact.normal;\r\n          const tangent = contact.tangent;\r\n\r\n          const aToContact = point.sub(bodyA.globalPos);\r\n          const bToContact = point.sub(bodyB.globalPos);\r\n\r\n          const aToContactNormal = aToContact.cross(normal);\r\n          const bToContactNormal = bToContact.cross(normal);\r\n\r\n          const normalMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n            bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n          const aToContactTangent = aToContact.cross(tangent);\r\n          const bToContactTangent = bToContact.cross(tangent);\r\n\r\n          const tangentMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n            bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n\r\n          // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n          if (contactPoints[pointIndex] && contactPoints[pointIndex]?.point?.squareDistance(point) < 4) {\r\n            contactPoints[pointIndex].point = point;\r\n            contactPoints[pointIndex].local = contact.localPoints[pointIndex];\r\n          } else {\r\n            // new contact if it's not close or doesn't exist\r\n            contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);\r\n          }\r\n\r\n          // Update contact point calculations\r\n          contactPoints[pointIndex].aToContact = aToContact;\r\n          contactPoints[pointIndex].bToContact = bToContact;\r\n          contactPoints[pointIndex].normalMass = 1.0 / normalMass;\r\n          contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;\r\n\r\n          // Calculate relative velocity before solving to accurately do restitution\r\n          const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;\r\n          const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());\r\n          contactPoints[pointIndex].originalVelocityAndRestitution = 0;\r\n          if (relativeVelocity < -0.1) { // TODO what's a good threshold here?\r\n            contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;\r\n          }\r\n          pointIndex++;\r\n        }\r\n      }\r\n      this.idToContactConstraint.set(contact.id, contactPoints);\r\n    }\r\n\r\n    // Clean up any contacts that did not occur last frame\r\n    for (const id of finishedContactIds) {\r\n      this.idToContactConstraint.delete(id);\r\n    }\r\n\r\n    // Warm contacts with accumulated impulse\r\n    // Useful for tall stacks\r\n    if (Physics.warmStart) {\r\n      this.warmStart(contacts);\r\n    } else {\r\n      for (const contact of contacts) {\r\n        const contactPoints = this.getContactConstraints(contact.id);\r\n        for (const point of contactPoints) {\r\n          point.normalImpulse = 0;\r\n          point.tangentImpulse = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n\r\n      if (bodyA && bodyB) {\r\n        // Skip post solve for active+passive collisions\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        // Update motion values for sleeping\r\n        bodyA.updateMotion();\r\n        bodyB.updateMotion();\r\n      }\r\n\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n    }\r\n\r\n    // Store contacts\r\n    this.lastFrameContacts.clear();\r\n    for (const c of contacts) {\r\n      this.lastFrameContacts.set(c.id, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warm up body's based on previous frame contact points\r\n   * @param contacts\r\n   */\r\n  warmStart(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n        for (const point of contactPoints) {\r\n          if (Physics.warmStart) {\r\n            const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n            const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\r\n            const impulse = normalImpulse.add(tangentImpulse);\r\n\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          } else {\r\n            point.normalImpulse = 0;\r\n            point.tangentImpulse = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iteratively solve the position overlap constraint\r\n   * @param contacts\r\n   */\r\n  solvePosition(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.positionIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n          for (const point of constraints) {\r\n            const normal = contact.normal;\r\n            const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);\r\n\r\n            const steeringConstant = Physics.steeringFactor; //0.2;\r\n            const maxCorrection = -5;\r\n            const slop = Physics.slop; //1;\r\n\r\n            // Clamp to avoid over-correction\r\n            // Remember that we are shooting for 0 overlap in the end\r\n            const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n            const impulse = normal.scale(-steeringForce * point.normalMass);\r\n\r\n            // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n            // We adjust position and rotation instead of doing the velocity\r\n            if (bodyA.collisionType === CollisionType.Active) {\r\n              // TODO make applyPseudoImpulse function?\r\n              const impulseForce = impulse.negate().scale(bodyA.inverseMass);\r\n              if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n                impulseForce.x = 0;\r\n              }\r\n              if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n                impulseForce.y = 0;\r\n              }\r\n\r\n              bodyA.globalPos = bodyA.globalPos.add(impulseForce);\r\n              if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n                bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n              }\r\n            }\r\n\r\n            if (bodyB.collisionType === CollisionType.Active) {\r\n              const impulseForce = impulse.scale(bodyB.inverseMass);\r\n              if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n                impulseForce.x = 0;\r\n              }\r\n              if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n                impulseForce.y = 0;\r\n              }\r\n\r\n              bodyB.globalPos = bodyB.globalPos.add(impulseForce);\r\n              if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n                bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  solveVelocity(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.velocityIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const friction = Math.min(bodyA.friction, bodyB.friction);\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n          // Friction constraint\r\n          for (const point of constraints) {\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Negate velocity in tangent direction to simulate friction\r\n            const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n            let impulseDelta = tangentVelocity * point.tangentMass;\r\n\r\n            // Clamping based in Erin Catto's GDC 2006 talk\r\n            // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n            // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n            // But deltas can vary\r\n            const maxFriction = friction * point.normalImpulse;\r\n            const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n            impulseDelta = newImpulse - point.tangentImpulse;\r\n            point.tangentImpulse = newImpulse;\r\n\r\n            const impulse = contact.tangent.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n\r\n          // Bounce constraint\r\n          for (const point of constraints) {\r\n            // Need to recalc relative velocity because the previous step could have changed vel\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Compute impulse in normal direction\r\n            const normalVelocity = relativeVelocity.dot(contact.normal);\r\n\r\n            // Per Erin it is a mistake to apply the restitution inside the iteration\r\n            // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses\r\n            let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);\r\n\r\n            // Clamping based in Erin Catto's GDC 2014 talk\r\n            // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n            // But deltas can be negative\r\n            const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n            impulseDelta = newImpulse - point.normalImpulse;\r\n            point.normalImpulse = newImpulse;\r\n\r\n            const impulse = contact.normal.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { CollisionEndEvent, CollisionStartEvent, ContactEndEvent, ContactStartEvent } from '../Events';\r\nimport { CollisionResolutionStrategy, Physics } from './Physics';\r\nimport { ArcadeSolver } from './Solver/ArcadeSolver';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { DynamicTreeCollisionProcessor } from './Detection/DynamicTreeCollisionProcessor';\r\nimport { RealisticSolver } from './Solver/RealisticSolver';\r\nimport { CollisionSolver } from './Solver/Solver';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { Engine, ExcaliburGraphicsContext, Scene } from '..';\r\n\r\nexport class CollisionSystem extends System<TransformComponent | MotionComponent | ColliderComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion', 'ex.collider'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _realisticSolver = new RealisticSolver();\r\n  private _arcadeSolver = new ArcadeSolver();\r\n  private _processor = new DynamicTreeCollisionProcessor();\r\n  private _lastFrameContacts = new Map<string, CollisionContact>();\r\n  private _currentFrameContacts = new Map<string, CollisionContact>();\r\n\r\n  private _trackCollider = (c: Collider) => this._processor.track(c);\r\n  private _untrackCollider = (c: Collider) => this._processor.untrack(c);\r\n\r\n  notify(message: AddedEntity | RemovedEntity) {\r\n    if (isAddedSystemEntity(message)) {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      colliderComponent.$colliderAdded.subscribe(this._trackCollider);\r\n      colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);\r\n      const collider = colliderComponent.get();\r\n      if (collider) {\r\n        this._processor.track(collider);\r\n      }\r\n    } else {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      const collider = colliderComponent.get();\r\n      if (colliderComponent && collider) {\r\n        this._processor.untrack(collider);\r\n      }\r\n    }\r\n  }\r\n\r\n  initialize(scene: Scene) {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  update(entities: Entity[], elapsedMs: number): void {\r\n    if (!Physics.enabled) {\r\n      return;\r\n    }\r\n\r\n    // Collect up all the colliders and update them\r\n    let colliders: Collider[] = [];\r\n    for (const entity of entities) {\r\n      const colliderComp = entity.get(ColliderComponent);\r\n      const collider = colliderComp?.get();\r\n      if (colliderComp && colliderComp.owner?.active && collider) {\r\n        colliderComp.update();\r\n        if (collider instanceof CompositeCollider) {\r\n          const compositeColliders = collider.getColliders();\r\n          colliders = colliders.concat(compositeColliders);\r\n        } else {\r\n          colliders.push(collider);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update the spatial partitioning data structures\r\n    // TODO if collider invalid it will break the processor\r\n    // TODO rename \"update\" to something more specific\r\n    this._processor.update(colliders);\r\n\r\n    // Run broadphase on all colliders and locates potential collisions\r\n    const pairs = this._processor.broadphase(colliders, elapsedMs);\r\n\r\n    this._currentFrameContacts.clear();\r\n\r\n    // Given possible pairs find actual contacts\r\n    let contacts = this._processor.narrowphase(pairs, this._engine?.debug?.stats?.currFrame);\r\n\r\n    const solver: CollisionSolver = this.getSolver();\r\n\r\n    // Solve, this resolves the position/velocity so entities aren't overlapping\r\n    contacts = solver.solve(contacts);\r\n\r\n    // Record contacts for start/end\r\n    for (const contact of contacts) {\r\n      // Process composite ids, things with the same composite id are treated as the same collider for start/end\r\n      const index = contact.id.indexOf('|');\r\n      if (index > 0) {\r\n        const compositeId = contact.id.substring(index + 1);\r\n        this._currentFrameContacts.set(compositeId, contact);\r\n      } else {\r\n        this._currentFrameContacts.set(contact.id, contact);\r\n      }\r\n    }\r\n\r\n    // Emit contact start/end events\r\n    this.runContactStartEnd();\r\n\r\n    // reset the last frame cache\r\n    this._lastFrameContacts.clear();\r\n\r\n    // Keep track of collisions contacts that have started or ended\r\n    this._lastFrameContacts = new Map(this._currentFrameContacts);\r\n  }\r\n\r\n  getSolver(): CollisionSolver {\r\n    return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;\r\n  }\r\n\r\n  debug(ex: ExcaliburGraphicsContext) {\r\n    this._processor.debug(ex);\r\n  }\r\n\r\n  public runContactStartEnd() {\r\n    // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end\r\n    for (const [id, c] of this._currentFrameContacts) {\r\n      // find all new contacts\r\n      if (!this._lastFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));\r\n        colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c) as any);\r\n        colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));\r\n        colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c) as any);\r\n      }\r\n    }\r\n\r\n    // find all contacts that have ceased\r\n    for (const [id, c] of this._lastFrameContacts) {\r\n      if (!this._currentFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));\r\n        colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB) as any);\r\n        colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));\r\n        colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA) as any);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { Logger } from '../Util/Log';\r\nimport { clamp } from '../Math/util';\r\n\r\nexport interface HasTick {\r\n  /**\r\n   *\r\n   * @param elapsedMilliseconds The amount of real world time in milliseconds that has elapsed that must be updated in the animation\r\n   * @param idempotencyToken Optional idempotencyToken prevents a ticking animation from updating twice per frame\r\n   */\r\n  tick(elapsedMilliseconds: number, idempotencyToken?: number): void;\r\n}\r\n\r\nexport enum AnimationDirection {\r\n  /**\r\n   * Animation is playing forwards\r\n   */\r\n  Forward = 'forward',\r\n  /**\r\n   * Animation is play backwards\r\n   */\r\n  Backward = 'backward'\r\n}\r\n\r\nexport enum AnimationStrategy {\r\n  /**\r\n   * Animation ends without displaying anything\r\n   */\r\n  End = 'end',\r\n  /**\r\n   * Animation loops to the first frame after the last frame\r\n   */\r\n  Loop = 'loop',\r\n  /**\r\n   * Animation plays to the last frame, then backwards to the first frame, then repeats\r\n   */\r\n  PingPong = 'pingpong',\r\n  /**\r\n   * Animation ends stopping on the last frame\r\n   */\r\n  Freeze = 'freeze'\r\n}\r\n\r\n/**\r\n * Frame of animation\r\n */\r\nexport interface Frame {\r\n  /**\r\n   * Optionally specify a graphic to show, no graphic shows an empty frame\r\n   */\r\n  graphic?: Graphic;\r\n  /**\r\n   * Optionally specify the number of ms the frame should be visible, overrides the animation duration (default 100 ms)\r\n   */\r\n  duration?: number;\r\n}\r\n\r\n/**\r\n * Animation options for building an animation via constructor.\r\n */\r\nexport interface AnimationOptions {\r\n  /**\r\n   * List of frames in the order you wish to play them\r\n   */\r\n  frames: Frame[];\r\n  /**\r\n   * Optionally reverse the direction of play\r\n   */\r\n  reverse?: boolean;\r\n  /**\r\n   * Optionally specify a default frame duration in ms (Default is 1000)\r\n   */\r\n  frameDuration?: number;\r\n  /**\r\n   * Optionally specify a total duration of the animation in ms to calculate each frame's duration\r\n   */\r\n  totalDuration?: number;\r\n  /**\r\n   * Optionally specify the [[AnimationStrategy]] for the Animation\r\n   */\r\n  strategy?: AnimationStrategy;\r\n}\r\n\r\n// TODO wire up to new Emitter\r\nexport type AnimationEvents = {\r\n  frame: Frame;\r\n  loop: Animation;\r\n  ended: Animation;\r\n};\r\n\r\n/**\r\n * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]\r\n *\r\n * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]\r\n */\r\nexport class Animation extends Graphic implements HasTick {\r\n  private static _LOGGER = Logger.getInstance();\r\n  public events = new EventDispatcher<any>(); // TODO replace with new Emitter\r\n  public frames: Frame[] = [];\r\n  public strategy: AnimationStrategy = AnimationStrategy.Loop;\r\n  public frameDuration: number = 100;\r\n  public timeScale: number = 1;\r\n\r\n  private _idempotencyToken = -1;\r\n\r\n  private _firstTick = true;\r\n  private _currentFrame = 0;\r\n  private _timeLeftInFrame = 0;\r\n  private _direction = 1; // TODO only used in ping-pong\r\n  private _done = false;\r\n  private _playing = true;\r\n\r\n  constructor(options: GraphicOptions & AnimationOptions) {\r\n    super(options);\r\n    this.frames = options.frames;\r\n    this.strategy = options.strategy ?? this.strategy;\r\n    this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : options.frameDuration ?? this.frameDuration;\r\n    if (options.reverse) {\r\n      this.reverse();\r\n    }\r\n    this.goToFrame(0);\r\n  }\r\n\r\n  public clone(): Animation {\r\n    return new Animation({\r\n      frames: this.frames.map((f) => ({ ...f })),\r\n      frameDuration: this.frameDuration,\r\n      reverse: this._reversed,\r\n      strategy: this.strategy,\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  public override get width(): number {\r\n    const maybeFrame = this.currentFrame;\r\n    if (maybeFrame) {\r\n      return Math.abs(maybeFrame.graphic.width * this.scale.x);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  public override get height(): number {\r\n    const maybeFrame = this.currentFrame;\r\n    if (maybeFrame) {\r\n      return Math.abs(maybeFrame.graphic.height * this.scale.y);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n\r\n  /**\r\n   * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame\r\n   * and optional [[AnimationStrategy]]\r\n   *\r\n   * Example:\r\n   * ```typescript\r\n   * const spriteSheet = SpriteSheet.fromImageSource({...});\r\n   *\r\n   * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);\r\n   * ```\r\n   *\r\n   * @param spriteSheet\r\n   * @param frameIndices\r\n   * @param durationPerFrameMs\r\n   * @param strategy\r\n   */\r\n  public static fromSpriteSheet(\r\n    spriteSheet: SpriteSheet,\r\n    frameIndices: number[],\r\n    durationPerFrameMs: number,\r\n    strategy: AnimationStrategy = AnimationStrategy.Loop\r\n  ): Animation {\r\n    const maxIndex = spriteSheet.sprites.length - 1;\r\n    const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);\r\n    if (invalidIndices.length) {\r\n      Animation._LOGGER.warn(\r\n        `Indices into SpriteSheet were provided that don\\'t exist: ${invalidIndices.join(',')} no frame will be shown`\r\n      );\r\n    }\r\n    return new Animation({\r\n      frames: spriteSheet.sprites\r\n        .filter((_, index) => frameIndices.indexOf(index) > -1)\r\n        .map((f) => ({\r\n          graphic: f,\r\n          duration: durationPerFrameMs\r\n        })),\r\n      strategy: strategy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the current Frame of the animation\r\n   */\r\n  public get currentFrame(): Frame | null {\r\n    if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {\r\n      return this.frames[this._currentFrame];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the current frame index of the animation\r\n   */\r\n  public get currentFrameIndex(): number {\r\n    return this._currentFrame;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is playing\r\n   */\r\n  public get isPlaying(): boolean {\r\n    return this._playing;\r\n  }\r\n\r\n  private _reversed = false;\r\n  /**\r\n   * Reverses the play direction of the Animation, this preserves the current frame\r\n   */\r\n  public reverse(): void {\r\n    // Don't mutate with the original frame list, create a copy\r\n    this.frames = this.frames.slice().reverse();\r\n    this._reversed = !this._reversed;\r\n  }\r\n\r\n  /**\r\n   * Returns the current play direction of the animation\r\n   */\r\n  public get direction(): AnimationDirection {\r\n    // Keep logically consistent with ping-pong direction\r\n    // If ping-pong is forward = 1 and reversed is true then we are logically reversed\r\n    const reversed = (this._reversed && this._direction === 1) ? true : false;\r\n    return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;\r\n  }\r\n\r\n  /**\r\n   * Plays or resumes the animation from the current frame\r\n   */\r\n  public play(): void {\r\n    this._playing = true;\r\n  }\r\n\r\n  /**\r\n   * Pauses the animation on the current frame\r\n   */\r\n  public pause(): void {\r\n    this._playing = false;\r\n    this._firstTick = true; // firstTick must be set to emit the proper frame event\r\n  }\r\n\r\n  /**\r\n   * Reset the animation back to the beginning, including if the animation were done\r\n   */\r\n  public reset(): void {\r\n    this._done = false;\r\n    this._firstTick = true;\r\n    this._currentFrame = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation can end\r\n   */\r\n  public get canFinish(): boolean {\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.End:\r\n      case AnimationStrategy.Freeze: {\r\n        return true;\r\n      }\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is done, for looping type animations\r\n   * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`\r\n   *\r\n   * See the `ex.Animation.canFinish()` method to know if an animation type can end\r\n   */\r\n  public get done(): boolean {\r\n    return this._done;\r\n  }\r\n\r\n  /**\r\n   * Jump the animation immediately to a specific frame if it exists\r\n   * @param frameNumber\r\n   */\r\n  public goToFrame(frameNumber: number) {\r\n    this._currentFrame = frameNumber;\r\n    this._timeLeftInFrame = this.frameDuration;\r\n    const maybeFrame = this.frames[this._currentFrame];\r\n    if (maybeFrame && !this._done) {\r\n      this._timeLeftInFrame = maybeFrame?.duration || this.frameDuration;\r\n      this.events.emit('frame', maybeFrame as any);\r\n    }\r\n  }\r\n\r\n  private _nextFrame(): number {\r\n    const currentFrame = this._currentFrame;\r\n    if (this._done) {\r\n      return currentFrame;\r\n    }\r\n    let next = -1;\r\n\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.Loop: {\r\n        next = (currentFrame + 1) % this.frames.length;\r\n        if (next === 0) {\r\n          this.events.emit('loop', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.End: {\r\n        next = currentFrame + 1;\r\n        if (next >= this.frames.length) {\r\n          this._done = true;\r\n          this._currentFrame = this.frames.length;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.Freeze: {\r\n        next = clamp(currentFrame + 1, 0, this.frames.length - 1);\r\n        if (next >= this.frames.length - 1) {\r\n          this._done = true;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.PingPong: {\r\n        if (currentFrame + this._direction >= this.frames.length) {\r\n          this._direction = -1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        if (currentFrame + this._direction < 0) {\r\n          this._direction = 1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        next = currentFrame + (this._direction % this.frames.length);\r\n        break;\r\n      }\r\n    }\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * Called internally by Excalibur to update the state of the animation potential update the current frame\r\n   * @param elapsedMilliseconds Milliseconds elapsed\r\n   * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame\r\n   */\r\n  public tick(elapsedMilliseconds: number, idempotencyToken: number = 0): void {\r\n    if (this._idempotencyToken === idempotencyToken) {\r\n      return;\r\n    }\r\n    this._idempotencyToken = idempotencyToken;\r\n    if (!this._playing) {\r\n      return;\r\n    }\r\n\r\n    // if it's the first frame emit frame event\r\n    if (this._firstTick) {\r\n      this._firstTick = false;\r\n      this.events.emit('frame', this.currentFrame as any);\r\n    }\r\n\r\n    this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;\r\n    if (this._timeLeftInFrame <= 0) {\r\n      this.goToFrame(this._nextFrame());\r\n    }\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this.currentFrame) {\r\n      this.currentFrame.graphic.draw(ctx, x, y);\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Animation, HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/Index';\r\n\r\nexport interface GraphicsGroupingOptions {\r\n  members: GraphicsGrouping[];\r\n}\r\n\r\nexport interface GraphicsGrouping {\r\n  pos: Vector;\r\n  graphic: Graphic;\r\n}\r\n\r\nexport class GraphicsGroup extends Graphic implements HasTick {\r\n  public members: GraphicsGrouping[] = [];\r\n\r\n  constructor(options: GraphicsGroupingOptions & GraphicOptions) {\r\n    super(options);\r\n    this.members = options.members;\r\n    this._updateDimensions();\r\n  }\r\n\r\n  public clone(): GraphicsGroup {\r\n    return new GraphicsGroup({\r\n      members: [...this.members],\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  private _updateDimensions(): BoundingBox {\r\n    let bb = new BoundingBox();\r\n    for (const { graphic, pos } of this.members) {\r\n      bb = graphic.localBounds.translate(pos).combine(bb);\r\n    }\r\n\r\n    this.width = bb.width;\r\n    this.height = bb.height;\r\n\r\n    return bb;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    let bb = new BoundingBox();\r\n    for (const { graphic, pos } of this.members) {\r\n      bb = graphic.localBounds.translate(pos).combine(bb);\r\n    }\r\n    return bb;\r\n  }\r\n\r\n  private _isAnimationOrGroup(graphic: Graphic): graphic is Animation | GraphicsGroup {\r\n    return graphic instanceof Animation || graphic instanceof GraphicsGroup;\r\n  }\r\n\r\n  public tick(elapsedMilliseconds: number, idempotencyToken?: number) {\r\n    for (const member of this.members) {\r\n      const maybeAnimation = member.graphic;\r\n      if (this._isAnimationOrGroup(maybeAnimation)) {\r\n        maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);\r\n      }\r\n    }\r\n  }\r\n\r\n  public reset() {\r\n    for (const member of this.members) {\r\n      const maybeAnimation = member.graphic;\r\n      if (this._isAnimationOrGroup(maybeAnimation)) {\r\n        maybeAnimation.reset();\r\n      }\r\n    }\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    this._updateDimensions();\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    for (const member of this.members) {\r\n      ex.save();\r\n      ex.translate(x, y);\r\n      member.graphic.draw(ex, member.pos.x, member.pos.y);\r\n      if (this.showDebug) {\r\n        /* istanbul ignore next */\r\n        ex.debug.drawRect(0, 0, this.width, this.height);\r\n      }\r\n      ex.restore();\r\n    }\r\n  }\r\n}\r\n","export type Constructor<T> = {\r\n  new (...args: any[]): T;\r\n};\r\n/**\r\n * Configurable helper extends base type and makes all properties available as option bag arguments\r\n * @internal\r\n * @param base\r\n */\r\nexport function Configurable<T extends Constructor<{}>>(base: T): T {\r\n  return class extends base {\r\n    public assign(props: Partial<T>) {\r\n      //set the value of every property that was passed in,\r\n      //if the constructor previously set this value, it will be overridden here\r\n      for (const k in props) {\r\n        // eslint-disable-next-line\r\n        if (typeof (<any>this)[k] !== 'function') {\r\n          // eslint-disable-next-line\r\n          (<any>this)[k] = (<any>props)[k];\r\n        }\r\n      }\r\n    }\r\n\r\n    constructor(...args: any[]) {\r\n      super(...args);\r\n      //get the number of arguments that aren't undefined. TS passes a value to all parameters\r\n      //of whatever ctor is the implementation, so args.length doesn't work here.\r\n      const size = args.filter(function(value) {\r\n        return value !== undefined;\r\n      }).length;\r\n      if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {\r\n        this.assign(args[0]);\r\n      }\r\n    }\r\n  };\r\n}\r\n","import { Engine } from './Engine';\r\nimport { Actor } from './Actor';\r\nimport { Color } from './Color';\r\nimport { Vector, vec } from './Math/vector';\r\nimport * as Util from './Util/Util';\r\nimport { Configurable } from './Configurable';\r\nimport { Random } from './Math/Random';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { Sprite } from './Graphics/Sprite';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { clamp, randomInRange } from './Math/util';\r\n\r\n/**\r\n * An enum that represents the types of emitter nozzles\r\n */\r\nexport enum EmitterType {\r\n  /**\r\n   * Constant for the circular emitter type\r\n   */\r\n  Circle,\r\n  /**\r\n   * Constant for the rectangular emitter type\r\n   */\r\n  Rectangle\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ParticleImpl extends Entity {\r\n  public position: Vector = new Vector(0, 0);\r\n  public velocity: Vector = new Vector(0, 0);\r\n  public acceleration: Vector = new Vector(0, 0);\r\n  public particleRotationalVelocity: number = 0;\r\n  public currentRotation: number = 0;\r\n\r\n  public focus: Vector = null;\r\n  public focusAccel: number = 0;\r\n  public opacity: number = 1;\r\n  public beginColor: Color = Color.White;\r\n  public endColor: Color = Color.White;\r\n\r\n  // Life is counted in ms\r\n  public life: number = 300;\r\n  public fadeFlag: boolean = false;\r\n\r\n  // Color transitions\r\n  private _rRate: number = 1;\r\n  private _gRate: number = 1;\r\n  private _bRate: number = 1;\r\n  private _aRate: number = 0;\r\n  private _currentColor: Color = Color.White;\r\n\r\n  public emitter: ParticleEmitter = null;\r\n  public particleSize: number = 5;\r\n  public particleSprite: Sprite = null;\r\n\r\n  public startSize: number;\r\n  public endSize: number;\r\n  public sizeRate: number = 0;\r\n  public elapsedMultiplier: number = 0;\r\n\r\n  public visible = true;\r\n  public isOffscreen = false;\r\n\r\n  public transform: TransformComponent;\r\n  public graphics: GraphicsComponent;\r\n\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super();\r\n    let emitter = emitterOrConfig;\r\n    if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {\r\n      const config = emitterOrConfig;\r\n      emitter = config.emitter;\r\n      life = config.life;\r\n      opacity = config.opacity;\r\n      endColor = config.endColor;\r\n      beginColor = config.beginColor;\r\n      position = config.position;\r\n      velocity = config.velocity;\r\n      acceleration = config.acceleration;\r\n      startSize = config.startSize;\r\n      endSize = config.endSize;\r\n    }\r\n    this.emitter = <ParticleEmitter>emitter;\r\n    this.life = life || this.life;\r\n    this.opacity = opacity || this.opacity;\r\n    this.endColor = endColor || this.endColor.clone();\r\n    this.beginColor = beginColor || this.beginColor.clone();\r\n    this._currentColor = this.beginColor.clone();\r\n    this.position = (position || this.position).add(this.emitter.pos);\r\n    this.velocity = velocity || this.velocity;\r\n    this.acceleration = acceleration || this.acceleration;\r\n    this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\r\n    this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\r\n    this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\r\n    this._aRate = this.opacity / this.life;\r\n\r\n    this.startSize = startSize || 0;\r\n    this.endSize = endSize || 0;\r\n\r\n    if (this.endSize > 0 && this.startSize > 0) {\r\n      this.sizeRate = (this.endSize - this.startSize) / this.life;\r\n      this.particleSize = this.startSize;\r\n    }\r\n\r\n    this.addComponent((this.transform = new TransformComponent()));\r\n    this.addComponent((this.graphics = new GraphicsComponent()));\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // TODO wut\r\n    if (this.particleSprite) {\r\n      this.graphics.opacity = this.opacity;\r\n      this.graphics.use(this.particleSprite);\r\n    } else {\r\n      this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);\r\n      this.graphics.onPostDraw = (ctx) => {\r\n        ctx.save();\r\n        this.graphics.opacity = this.opacity;\r\n        const tmpColor = this._currentColor.clone();\r\n        tmpColor.a = 1;\r\n        ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });\r\n        ctx.restore();\r\n      };\r\n    }\r\n  }\r\n\r\n  public kill() {\r\n    this.emitter.removeParticle(this);\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this.life = this.life - delta;\r\n    this.elapsedMultiplier = this.elapsedMultiplier + delta;\r\n\r\n    if (this.life < 0) {\r\n      this.kill();\r\n    }\r\n\r\n    if (this.fadeFlag) {\r\n      this.opacity = clamp(this._aRate * this.life, 0.0001, 1);\r\n    }\r\n\r\n    if (this.startSize > 0 && this.endSize > 0) {\r\n      this.particleSize = clamp(\r\n        this.sizeRate * delta + this.particleSize,\r\n        Math.min(this.startSize, this.endSize),\r\n        Math.max(this.startSize, this.endSize)\r\n      );\r\n    }\r\n\r\n    this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);\r\n    this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);\r\n    this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);\r\n    this._currentColor.a = clamp(this.opacity, 0.0001, 1);\r\n\r\n    if (this.focus) {\r\n      const accel = this.focus\r\n        .sub(this.position)\r\n        .normalize()\r\n        .scale(this.focusAccel)\r\n        .scale(delta / 1000);\r\n      this.velocity = this.velocity.add(accel);\r\n    } else {\r\n      this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\r\n    }\r\n    this.position = this.position.add(this.velocity.scale(delta / 1000));\r\n\r\n    if (this.particleRotationalVelocity) {\r\n      this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);\r\n    }\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // todo wut\r\n    this.graphics.opacity = this.opacity;\r\n  }\r\n}\r\n\r\nexport interface ParticleArgs extends Partial<ParticleImpl> {\r\n  emitter: ParticleEmitter;\r\n  position?: Vector;\r\n  velocity?: Vector;\r\n  acceleration?: Vector;\r\n  particleRotationalVelocity?: number;\r\n  currentRotation?: number;\r\n  particleSize?: number;\r\n  particleSprite?: Sprite;\r\n}\r\n\r\n/**\r\n * Particle is used in a [[ParticleEmitter]]\r\n */\r\nexport class Particle extends Configurable(ParticleImpl) {\r\n  constructor(config: ParticleArgs);\r\n  constructor(\r\n    emitter: ParticleEmitter,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  );\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);\r\n  }\r\n}\r\n\r\nexport interface ParticleEmitterArgs {\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  width?: number;\r\n  height?: number;\r\n  isEmitting?: boolean;\r\n  minVel?: number;\r\n  maxVel?: number;\r\n  acceleration?: Vector;\r\n  minAngle?: number;\r\n  maxAngle?: number;\r\n  emitRate?: number;\r\n  particleLife?: number;\r\n  opacity?: number;\r\n  fadeFlag?: boolean;\r\n  focus?: Vector;\r\n  focusAccel?: number;\r\n  startSize?: number;\r\n  endSize?: number;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  beginColor?: Color;\r\n  endColor?: Color;\r\n  particleSprite?: Sprite;\r\n  emitterType?: EmitterType;\r\n  radius?: number;\r\n  particleRotationalVelocity?: number;\r\n  randomRotation?: boolean;\r\n  random?: Random;\r\n}\r\n\r\n/**\r\n * Using a particle emitter is a great way to create interesting effects\r\n * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n * extend [[Actor]] allowing you to use all of the features that come with.\r\n */\r\nexport class ParticleEmitter extends Actor {\r\n  private _particlesToEmit: number = 0;\r\n\r\n  public numParticles: number = 0;\r\n\r\n  /**\r\n   * Random number generator\r\n   */\r\n  public random: Random;\r\n\r\n  /**\r\n   * Gets or sets the isEmitting flag\r\n   */\r\n  public isEmitting: boolean = true;\r\n  /**\r\n   * Gets or sets the backing particle collection\r\n   */\r\n  public particles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the backing deadParticle collection\r\n   */\r\n  public deadParticles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the minimum particle velocity\r\n   */\r\n  public minVel: number = 0;\r\n  /**\r\n   * Gets or sets the maximum particle velocity\r\n   */\r\n  public maxVel: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the acceleration vector for all particles\r\n   */\r\n  public acceleration: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Gets or sets the minimum angle in radians\r\n   */\r\n  public minAngle: number = 0;\r\n  /**\r\n   * Gets or sets the maximum angle in radians\r\n   */\r\n  public maxAngle: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the emission rate for particles (particles/sec)\r\n   */\r\n  public emitRate: number = 1; //particles/sec\r\n  /**\r\n   * Gets or sets the life of each particle in milliseconds\r\n   */\r\n  public particleLife: number = 2000;\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public get opacity(): number {\r\n    return super.graphics.opacity;\r\n  }\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public set opacity(opacity: number) {\r\n    super.graphics.opacity = opacity;\r\n  }\r\n  /**\r\n   * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n   */\r\n  public fadeFlag: boolean = false;\r\n\r\n  /**\r\n   * Gets or sets the optional focus where all particles should accelerate towards\r\n   */\r\n  public focus: Vector = null;\r\n  /**\r\n   * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n   */\r\n  public focusAccel: number = null;\r\n  /**\r\n   * Gets or sets the optional starting size for the particles\r\n   */\r\n  public startSize: number = null;\r\n  /**\r\n   * Gets or sets the optional ending size for the particles\r\n   */\r\n  public endSize: number = null;\r\n\r\n  /**\r\n   * Gets or sets the minimum size of all particles\r\n   */\r\n  public minSize: number = 5;\r\n  /**\r\n   * Gets or sets the maximum size of all particles\r\n   */\r\n  public maxSize: number = 5;\r\n\r\n  /**\r\n   * Gets or sets the beginning color of all particles\r\n   */\r\n  public beginColor: Color = Color.White;\r\n  /**\r\n   * Gets or sets the ending color of all particles\r\n   */\r\n  public endColor: Color = Color.White;\r\n\r\n  private _sprite: Sprite = null;\r\n  /**\r\n   * Gets or sets the sprite that a particle should use\r\n   */\r\n  public get particleSprite(): Sprite {\r\n    return this._sprite;\r\n  }\r\n\r\n  public set particleSprite(val: Sprite) {\r\n    if (val) {\r\n      this._sprite = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the emitter type for the particle emitter\r\n   */\r\n  public emitterType: EmitterType = EmitterType.Rectangle;\r\n\r\n  /**\r\n   * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n   */\r\n  public radius: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the particle rotational speed velocity\r\n   */\r\n  public particleRotationalVelocity: number = 0;\r\n\r\n  /**\r\n   * Indicates whether particles should start with a random rotation\r\n   */\r\n  public randomRotation: boolean = false;\r\n\r\n  /**\r\n   * @param config particle emitter options bag\r\n   */\r\n  constructor(config: ParticleEmitterArgs) {\r\n    super({ width: config.width ?? 0, height: config.height ?? 0 });\r\n\r\n    const {\r\n      x,\r\n      y,\r\n      pos,\r\n      isEmitting,\r\n      minVel,\r\n      maxVel,\r\n      acceleration,\r\n      minAngle,\r\n      maxAngle,\r\n      emitRate,\r\n      particleLife,\r\n      opacity,\r\n      fadeFlag,\r\n      focus,\r\n      focusAccel,\r\n      startSize,\r\n      endSize,\r\n      minSize,\r\n      maxSize,\r\n      beginColor,\r\n      endColor,\r\n      particleSprite,\r\n      emitterType,\r\n      radius,\r\n      particleRotationalVelocity,\r\n      randomRotation,\r\n      random\r\n    } = { ...config };\r\n\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.isEmitting = isEmitting ?? this.isEmitting;\r\n    this.minVel = minVel ?? this.minVel;\r\n    this.maxVel = maxVel ?? this.maxVel;\r\n    this.acceleration = acceleration ?? this.acceleration;\r\n    this.minAngle = minAngle ?? this.minAngle;\r\n    this.maxAngle = maxAngle ?? this.maxAngle;\r\n    this.emitRate = emitRate ?? this.emitRate;\r\n    this.particleLife = particleLife ?? this.particleLife;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.fadeFlag = fadeFlag ?? this.fadeFlag;\r\n    this.focus = focus ?? this.focus;\r\n    this.focusAccel = focusAccel ?? this.focusAccel;\r\n    this.startSize = startSize ?? this.startSize;\r\n    this.endSize = endSize ?? this.endSize;\r\n    this.minSize = minSize ?? this.minSize;\r\n    this.maxSize = maxSize ?? this.maxSize;\r\n    this.beginColor = beginColor ?? this.beginColor;\r\n    this.endColor = endColor ?? this.endColor;\r\n    this.particleSprite = particleSprite ?? this.particleSprite;\r\n    this.emitterType = emitterType ?? this.emitterType;\r\n    this.radius = radius ?? this.radius;\r\n    this.particleRotationalVelocity = particleRotationalVelocity ?? this.particleRotationalVelocity;\r\n    this.randomRotation = randomRotation ?? this.randomRotation;\r\n\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n\r\n    this.random = random ?? new Random();\r\n  }\r\n\r\n  public removeParticle(particle: Particle) {\r\n    this.deadParticles.push(particle);\r\n  }\r\n\r\n  /**\r\n   * Causes the emitter to emit particles\r\n   * @param particleCount  Number of particles to emit right now\r\n   */\r\n  public emitParticles(particleCount: number) {\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const p = this._createParticle();\r\n      this.particles.push(p);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.add(p);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clearParticles() {\r\n    this.particles.length = 0;\r\n  }\r\n\r\n  // Creates a new particle given the constraints of the emitter\r\n  private _createParticle(): Particle {\r\n    // todo implement emitter constraints;\r\n    let ranX = 0;\r\n    let ranY = 0;\r\n\r\n    const angle = randomInRange(this.minAngle, this.maxAngle, this.random);\r\n    const vel = randomInRange(this.minVel, this.maxVel, this.random);\r\n    const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);\r\n    const dx = vel * Math.cos(angle);\r\n    const dy = vel * Math.sin(angle);\r\n\r\n    if (this.emitterType === EmitterType.Rectangle) {\r\n      ranX = randomInRange(0, this.width, this.random);\r\n      ranY = randomInRange(0, this.height, this.random);\r\n    } else if (this.emitterType === EmitterType.Circle) {\r\n      const radius = randomInRange(0, this.radius, this.random);\r\n      ranX = radius * Math.cos(angle);\r\n      ranY = radius * Math.sin(angle);\r\n    }\r\n\r\n    const p = new Particle(\r\n      this,\r\n      this.particleLife,\r\n      this.opacity,\r\n      this.beginColor,\r\n      this.endColor,\r\n      new Vector(ranX, ranY),\r\n      new Vector(dx, dy),\r\n      this.acceleration,\r\n      this.startSize,\r\n      this.endSize\r\n    );\r\n    p.fadeFlag = this.fadeFlag;\r\n    p.particleSize = size;\r\n    if (this.particleSprite) {\r\n      p.particleSprite = this.particleSprite;\r\n      p.graphics.opacity = this.opacity;\r\n      p.graphics.use(this._sprite);\r\n    }\r\n    p.particleRotationalVelocity = this.particleRotationalVelocity;\r\n    if (this.randomRotation) {\r\n      p.currentRotation = randomInRange(0, Math.PI * 2, this.random);\r\n    }\r\n    if (this.focus) {\r\n      p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));\r\n      p.focusAccel = this.focusAccel;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    super.update(engine, delta);\r\n\r\n    if (this.isEmitting) {\r\n      this._particlesToEmit += this.emitRate * (delta / 1000);\r\n      if (this._particlesToEmit > 1.0) {\r\n        this.emitParticles(Math.floor(this._particlesToEmit));\r\n        this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\r\n      }\r\n    }\r\n\r\n    // deferred removal\r\n    for (let i = 0; i < this.deadParticles.length; i++) {\r\n      Util.removeItemFromArray(this.deadParticles[i], this.particles);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.remove(this.deadParticles[i], false);\r\n      }\r\n    }\r\n    this.deadParticles.length = 0;\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Scene } from '../Scene';\r\nimport { GraphicsComponent } from './GraphicsComponent';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Camera } from '../Camera';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem';\r\nimport { Engine } from '../Engine';\r\nimport { GraphicsGroup } from '.';\r\nimport { Particle } from '../Particles';\r\nimport { ParallaxComponent } from './ParallaxComponent';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\nimport { BodyComponent } from '../Collision/BodyComponent';\r\n\r\nexport class GraphicsSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 0;\r\n  private _token = 0;\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  private _sortedTransforms: TransformComponent[] = [];\r\n  public get sortedTransforms() {\r\n    return this._sortedTransforms;\r\n  }\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  private _zHasChanged = false;\r\n  private _zIndexUpdate = () => {\r\n    this._zHasChanged = true;\r\n  };\r\n\r\n  public preupdate(): void {\r\n    // Graphics context could be switched to fallback in a new frame\r\n    this._graphicsContext = this._engine.graphicsContext;\r\n    if (this._zHasChanged) {\r\n      this._sortedTransforms.sort((a, b) => {\r\n        return a.z - b.z;\r\n      });\r\n      this._zHasChanged = false;\r\n    }\r\n  }\r\n\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      this._sortedTransforms.push(tx);\r\n      tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n      this._zHasChanged = true;\r\n    } else {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n      const index = this._sortedTransforms.indexOf(tx);\r\n      if (index > -1) {\r\n        this._sortedTransforms.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(_entities: Entity[], delta: number): void {\r\n    this._token++;\r\n    let graphics: GraphicsComponent;\r\n\r\n    // This is a performance enhancement, most things are in world space\r\n    // so if we can only do this once saves a ton of transform updates\r\n    this._graphicsContext.save();\r\n    if (this._camera) {\r\n      this._camera.draw(this._graphicsContext);\r\n    }\r\n    for (const transform of this._sortedTransforms) {\r\n      const entity = transform.owner as Entity;\r\n\r\n      // If the entity is offscreen skip\r\n      if (entity.hasTag('ex.offscreen')) {\r\n        continue;\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      // Exit if graphics set to not visible\r\n      if (!graphics.visible) {\r\n        continue;\r\n      }\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      if (transform.coordPlane === CoordPlane.Screen) {\r\n        this._graphicsContext.restore();\r\n      }\r\n\r\n      this._graphicsContext.save();\r\n\r\n      // Tick any graphics state (but only once) for animations and graphics groups\r\n      graphics.update(delta, this._token);\r\n\r\n      // Apply parallax\r\n      const parallax = entity.get(ParallaxComponent);\r\n      if (parallax) {\r\n        // We use the Tiled formula\r\n        // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n        // cameraPos * (1 - parallaxFactor)\r\n        const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);\r\n        const parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n        this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);\r\n      }\r\n\r\n      // Position the entity + estimate lag\r\n      this._applyTransform(entity);\r\n\r\n      // Optionally run the onPreDraw graphics lifecycle draw\r\n      if (graphics.onPreDraw) {\r\n        graphics.onPreDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      // TODO remove this hack on the particle redo\r\n      const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;\r\n      this._graphicsContext.opacity = graphics.opacity * particleOpacity;\r\n\r\n      // Draw the graphics component\r\n      this._drawGraphicsComponent(graphics);\r\n\r\n      // Optionally run the onPostDraw graphics lifecycle draw\r\n      if (graphics.onPostDraw) {\r\n        graphics.onPostDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      // Reset the transform back to the original world space\r\n      if (transform.coordPlane === CoordPlane.Screen) {\r\n        this._graphicsContext.save();\r\n        if (this._camera) {\r\n          this._camera.draw(this._graphicsContext);\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n  }\r\n\r\n  private _drawGraphicsComponent(graphicsComponent: GraphicsComponent) {\r\n    if (graphicsComponent.visible) {\r\n      // this should be moved to the graphics system\r\n      for (const layer of graphicsComponent.layers.get()) {\r\n        for (const { graphic, options } of layer.graphics) {\r\n          let anchor = graphicsComponent.anchor;\r\n          let offset = graphicsComponent.offset;\r\n          if (options?.anchor) {\r\n            anchor = options.anchor;\r\n          }\r\n          if (options?.offset) {\r\n            offset = options.offset;\r\n          }\r\n          // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\r\n          const offsetX = -graphic.width * anchor.x + offset.x;\r\n          const offsetY = -graphic.height * anchor.y + offset.y;\r\n\r\n          graphic?.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n\r\n          if (this._engine?.isDebug && this._engine.debug.graphics.showBounds) {\r\n            const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n            if (graphic instanceof GraphicsGroup) {\r\n              for (const g of graphic.members) {\r\n                g.graphic?.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n              }\r\n            } else {\r\n              /* istanbul ignore next */\r\n              graphic?.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      const optionalBody = ancestor?.get(BodyComponent);\r\n      let interpolatedPos = transform.pos;\r\n      let interpolatedScale = transform.scale;\r\n      let interpolatedRotation = transform.rotation;\r\n      if (optionalBody) {\r\n        if (this._engine.fixedUpdateFps &&\r\n            optionalBody.__oldTransformCaptured &&\r\n            optionalBody.enableFixedUpdateInterpolate) {\r\n\r\n          // Interpolate graphics if needed\r\n          const blend = this._engine.currentFrameLagMs / (1000 / this._engine.fixedUpdateFps);\r\n          interpolatedPos = transform.pos.scale(blend).add(\r\n            optionalBody.oldPos.scale(1.0 - blend)\r\n          );\r\n          interpolatedScale = transform.scale.scale(blend).add(\r\n            optionalBody.oldScale.scale(1.0 - blend)\r\n          );\r\n          // Rotational lerp https://stackoverflow.com/a/30129248\r\n          const cosine = (1.0 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);\r\n          const sine = (1.0 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);\r\n          interpolatedRotation = Math.atan2(sine, cosine);\r\n        }\r\n      }\r\n\r\n      if (transform) {\r\n        this._graphicsContext.z = transform.z;\r\n        this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);\r\n        this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);\r\n        this._graphicsContext.rotate(interpolatedRotation);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Scene } from '../Scene';\r\nimport { Camera } from '../Camera';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { Entity, TransformComponent } from '../EntityComponentSystem';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { toDegrees } from '../Math/util';\r\nimport { BodyComponent, CollisionSystem, CompositeCollider, GraphicsComponent, Particle } from '..';\r\nimport { DebugGraphicsComponent } from '../Graphics/DebugGraphicsComponent';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\n\r\nexport class DebugSystem extends System<TransformComponent> {\r\n  public readonly types = ['ex.transform'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 999; // lowest priority\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _collisionSystem: CollisionSystem;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._graphicsContext = scene.engine.graphicsContext;\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n    this._collisionSystem = scene.world.systemManager.get(CollisionSystem);\r\n  }\r\n\r\n  update(entities: Entity[], _delta: number): void {\r\n    if (!this._engine.isDebug) {\r\n      return;\r\n    }\r\n\r\n    const filterSettings = this._engine.debug.filter;\r\n\r\n    let id: number;\r\n    let name: string;\r\n    const entitySettings = this._engine.debug.entity;\r\n\r\n    let tx: TransformComponent;\r\n    const txSettings = this._engine.debug.transform;\r\n\r\n    let motion: MotionComponent;\r\n    const motionSettings = this._engine.debug.motion;\r\n\r\n    let colliderComp: ColliderComponent;\r\n    const colliderSettings = this._engine.debug.collider;\r\n\r\n    const physicsSettings = this._engine.debug.physics;\r\n\r\n    let graphics: GraphicsComponent;\r\n    const graphicsSettings = this._engine.debug.graphics;\r\n\r\n    let debugDraw: DebugGraphicsComponent;\r\n\r\n    let body: BodyComponent;\r\n    const bodySettings = this._engine.debug.body;\r\n\r\n    const cameraSettings = this._engine.debug.camera;\r\n    for (const entity of entities) {\r\n      if (entity.hasTag('offscreen')) {\r\n        // skip offscreen entities\r\n        continue;\r\n      }\r\n      if (entity instanceof Particle) {\r\n        // Particles crush the renderer :(\r\n        continue;\r\n      }\r\n      if (filterSettings.useFilter) {\r\n        const allIds = filterSettings.ids.length === 0;\r\n        const idMatch = allIds || filterSettings.ids.includes(entity.id);\r\n        if (!idMatch) {\r\n          continue;\r\n        }\r\n        const allNames = filterSettings.nameQuery === '';\r\n        const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);\r\n        if (!nameMatch) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      let cursor = Vector.Zero;\r\n      const lineHeight = vec(0, 16);\r\n      id = entity.id;\r\n      name = entity.name;\r\n      tx = entity.get(TransformComponent);\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      this._pushCameraTransform(tx);\r\n\r\n      this._graphicsContext.save();\r\n\r\n      this._applyTransform(entity);\r\n      if (tx) {\r\n        if (txSettings.showAll || txSettings.showPosition) {\r\n          this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });\r\n        }\r\n        if (txSettings.showAll || txSettings.showPositionLabel) {\r\n          this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n        if (txSettings.showAll || txSettings.showZIndex) {\r\n          this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showId) {\r\n          this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? 'child of id(' + entity.parent?.id + ')' : ''}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showName) {\r\n          this._graphicsContext.debug.drawText(`name(${name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showRotation) {\r\n          this._graphicsContext.drawLine(\r\n            Vector.Zero,\r\n            Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero),\r\n            txSettings.rotationColor,\r\n            2\r\n          );\r\n          this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showScale) {\r\n          this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);\r\n        }\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics) {\r\n        if (graphicsSettings.showAll || graphicsSettings.showBounds) {\r\n          const bounds = graphics.localBounds;\r\n          bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);\r\n        }\r\n      }\r\n\r\n      debugDraw = entity.get(DebugGraphicsComponent);\r\n      if (debugDraw) {\r\n        if (!debugDraw.useTransform) {\r\n          this._graphicsContext.restore();\r\n        }\r\n        debugDraw.draw(this._graphicsContext);\r\n        if (!debugDraw.useTransform) {\r\n          this._graphicsContext.save();\r\n          this._applyTransform(entity);\r\n        }\r\n      }\r\n\r\n      body = entity.get(BodyComponent);\r\n      if (body) {\r\n        if (bodySettings.showAll || bodySettings.showCollisionGroup) {\r\n          this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showCollisionType) {\r\n          this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMass) {\r\n          this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMotion) {\r\n          this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showSleeping) {\r\n          this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping: 'cant sleep'})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      motion = entity.get(MotionComponent);\r\n      if (motion) {\r\n        if (motionSettings.showAll || motionSettings.showVelocity) {\r\n          this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (motionSettings.showAll || motionSettings.showAcceleration) {\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);\r\n        }\r\n      }\r\n\r\n      // Colliders live in world space already so after the restore()\r\n      colliderComp = entity.get(ColliderComponent);\r\n      if (colliderComp) {\r\n        const collider = colliderComp.get();\r\n        if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {\r\n          collider.debug(this._graphicsContext, colliderSettings.geometryColor);\r\n        }\r\n        if (colliderSettings.showAll || colliderSettings.showBounds) {\r\n          if (collider instanceof CompositeCollider) {\r\n            const colliders = collider.getColliders();\r\n            for (const collider of colliders) {\r\n              const bounds = collider.bounds;\r\n              const pos = vec(bounds.left, bounds.top);\r\n              this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n              if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);\r\n              }\r\n            }\r\n            colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);\r\n          } else if (collider) {\r\n            const bounds = colliderComp.bounds;\r\n            const pos = vec(bounds.left, bounds.top);\r\n            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n            if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n              this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      this._popCameraTransform(tx);\r\n    }\r\n\r\n    this._graphicsContext.save();\r\n    this._camera.draw(this._graphicsContext);\r\n    if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {\r\n      this._collisionSystem.debug(this._graphicsContext);\r\n    }\r\n    if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {\r\n      for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });\r\n          }\r\n        }\r\n\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {\r\n              color: physicsSettings.collisionNormalColor\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n\r\n    if (cameraSettings) {\r\n      this._graphicsContext.save();\r\n      this._camera.draw(this._graphicsContext);\r\n      if (cameraSettings.showAll || cameraSettings.showFocus) {\r\n        this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);\r\n      }\r\n      if (cameraSettings.showAll || cameraSettings.showZoom) {\r\n        this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);\r\n      }\r\n      this._graphicsContext.restore();\r\n    }\r\n\r\n    this._graphicsContext.flush();\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n        this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n        this._graphicsContext.rotate(transform.rotation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _pushCameraTransform(transform: TransformComponent) {\r\n    // Establish camera offset per entity\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      this._graphicsContext.save();\r\n      if (this._camera) {\r\n        this._camera.draw(this._graphicsContext);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _popCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Apply camera world offset\r\n      this._graphicsContext.restore();\r\n    }\r\n  }\r\n}\r\n","import { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { Engine } from '../Engine';\r\nimport {\r\n  System,\r\n  TransformComponent,\r\n  SystemType,\r\n  Entity,\r\n  AddedEntity,\r\n  RemovedEntity,\r\n  isAddedSystemEntity\r\n} from '../EntityComponentSystem';\r\nimport { GraphicsComponent } from '../Graphics/GraphicsComponent';\r\nimport { Scene } from '../Scene';\r\nimport { PointerComponent } from './PointerComponent';\r\nimport { PointerEventReceiver } from './PointerEventReceiver';\r\nimport { PointerEvent } from './PointerEvent';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\n\r\n/**\r\n * The PointerSystem is responsible for dispatching pointer events to entities\r\n * that need them.\r\n *\r\n * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use\r\n * the [[Collider]]'s shape for pointer events.\r\n */\r\nexport class PointerSystem extends System<TransformComponent | PointerComponent> {\r\n  public readonly types = ['ex.transform', 'ex.pointer'] as const;\r\n  public readonly systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _receiver: PointerEventReceiver;\r\n\r\n  /**\r\n   * Optionally override component configuration for all entities\r\n   */\r\n  public overrideUseColliderShape = false;\r\n  /**\r\n   * Optionally override component configuration for all entities\r\n   */\r\n  public overrideUseGraphicsBounds = false;\r\n\r\n  public lastFrameEntityToPointers = new Map<number, number[]>();\r\n  public currentFrameEntityToPointers = new Map<number, number[]>();\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  private _sortedTransforms: TransformComponent[] = [];\r\n  private _sortedEntities: Entity[] = [];\r\n\r\n  private _zHasChanged = false;\r\n  private _zIndexUpdate = () => {\r\n    this._zHasChanged = true;\r\n  };\r\n\r\n  public preupdate(): void {\r\n    // event receiver might change per frame\r\n    this._receiver = this._engine.input.pointers;\r\n    if (this._zHasChanged) {\r\n      this._sortedTransforms.sort((a, b) => {\r\n        return b.z - a.z;\r\n      });\r\n      this._sortedEntities = this._sortedTransforms.map(t => t.owner);\r\n      this._zHasChanged = false;\r\n    }\r\n  }\r\n\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      this._sortedTransforms.push(tx);\r\n      this._sortedEntities.push(tx.owner);\r\n      tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n      this._zHasChanged = true;\r\n    } else {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n      const index = this._sortedTransforms.indexOf(tx);\r\n      if (index > -1) {\r\n        this._sortedTransforms.splice(index, 1);\r\n        this._sortedEntities.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public entityCurrentlyUnderPointer(entity: Entity, pointerId: number) {\r\n    return this.currentFrameEntityToPointers.has(entity.id) &&\r\n           this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n  }\r\n\r\n  public entityWasUnderPointer(entity: Entity, pointerId: number) {\r\n    return this.lastFrameEntityToPointers.has(entity.id) &&\r\n           this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n  }\r\n\r\n  public entered(entity: Entity, pointerId: number) {\r\n    return this.entityCurrentlyUnderPointer(entity, pointerId) &&\r\n           !this.lastFrameEntityToPointers.has(entity.id);\r\n  }\r\n\r\n  public left(entity: Entity, pointerId: number) {\r\n    return !this.currentFrameEntityToPointers.has(entity.id) &&\r\n            this.entityWasUnderPointer(entity, pointerId);\r\n  }\r\n\r\n  public addPointerToEntity(entity: Entity, pointerId: number) {\r\n    if (!this.currentFrameEntityToPointers.has(entity.id)) {\r\n      this.currentFrameEntityToPointers.set(entity.id, [pointerId]);\r\n      return;\r\n    }\r\n    const pointers = this.currentFrameEntityToPointers.get(entity.id);\r\n    this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));\r\n  }\r\n\r\n  public update(_entities: Entity[]): void {\r\n    // Locate all the pointer/entity mappings\r\n    this._processPointerToEntity(this._sortedEntities);\r\n\r\n    // Dispatch pointer events on entities\r\n    this._dispatchEvents(this._sortedEntities);\r\n\r\n    // Clear last frame's events\r\n    this._receiver.update();\r\n    this.lastFrameEntityToPointers.clear();\r\n    this.lastFrameEntityToPointers = new Map<number, number[]>(this.currentFrameEntityToPointers);\r\n    this.currentFrameEntityToPointers.clear();\r\n    this._receiver.clear();\r\n  }\r\n\r\n  private _processPointerToEntity(entities: Entity[]) {\r\n    let transform: TransformComponent;\r\n    let collider: ColliderComponent;\r\n    let graphics: GraphicsComponent;\r\n    let pointer: PointerComponent;\r\n\r\n    // TODO probably a spatial partition optimization here to quickly query bounds for pointer\r\n    // doesn't seem to cause issues tho for perf\r\n\r\n    // Pre-process find entities under pointers\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      pointer = entity.get(PointerComponent) ?? new PointerComponent;\r\n      // Check collider contains pointer\r\n      collider = entity.get(ColliderComponent);\r\n      if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {\r\n        collider.update();\r\n        const geom = collider.get();\r\n        if (geom) {\r\n          for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n            if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n              this.addPointerToEntity(entity, pointerId);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check graphics contains pointer\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {\r\n        const graphicBounds = graphics.localBounds.transform(transform.get().matrix);\r\n        for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n          if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n            this.addPointerToEntity(entity, pointerId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processDownAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastDownPerPointer = new Map<number, PointerEvent>();\r\n    // Loop through down and dispatch to entities\r\n    for (const event of this._receiver.currentFrameDown) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        entity.events.emit('pointerdown', event as any);\r\n        if (this._receiver.isDragStart(event.pointerId)) {\r\n          entity.events.emit('pointerdragstart', event as any);\r\n        }\r\n      }\r\n      lastDownPerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastDownPerPointer;\r\n  }\r\n\r\n  private _processUpAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastUpPerPointer = new Map<number, PointerEvent>();\r\n    // Loop through up and dispatch to entities\r\n    for (const event of this._receiver.currentFrameUp) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        entity.events.emit('pointerup', event as any);\r\n        if (this._receiver.isDragEnd(event.pointerId)) {\r\n          entity.events.emit('pointerdragend', event as any);\r\n        }\r\n      }\r\n      lastUpPerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastUpPerPointer;\r\n  }\r\n\r\n  private _processMoveAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastMovePerPointer = new Map<number, PointerEvent>();\r\n    // Loop through move and dispatch to entities\r\n    for (const event of this._receiver.currentFrameMove) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        // move\r\n        entity.events.emit('pointermove', event as any);\r\n\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragmove', event as any);\r\n        }\r\n      }\r\n      lastMovePerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastMovePerPointer;\r\n  }\r\n\r\n  private _processEnterLeaveAndEmit(entity: Entity, lastUpDownMoveEvents: PointerEvent[]) {\r\n    // up, down, and move are considered for enter and leave\r\n    for (const event of lastUpDownMoveEvents) {\r\n      // enter\r\n      if (event.active && entity.active && this.entered(entity, event.pointerId)) {\r\n        entity.events.emit('pointerenter', event as any);\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragenter', event as any);\r\n        }\r\n        break;\r\n      }\r\n      if (event.active && entity.active &&\r\n          // leave can happen on move\r\n          (this.left(entity, event.pointerId) ||\r\n          // or leave can happen on pointer up\r\n          (this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === 'up'))) {\r\n        entity.events.emit('pointerleave', event as any);\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragleave', event as any);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processCancelAndEmit(entity: Entity) {\r\n    // cancel\r\n    for (const event of this._receiver.currentFrameCancel) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)){\r\n        entity.events.emit('pointercancel', event as any);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processWheelAndEmit(entity: Entity) {\r\n    // wheel\r\n    for (const event of this._receiver.currentFrameWheel) {\r\n      // Currently the wheel only fires under the primary pointer '0'\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {\r\n        entity.events.emit('pointerwheel', event as any);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _dispatchEvents(entities: Entity[]) {\r\n    const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());\r\n    const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());\r\n    // Filter preserves z order\r\n    const entitiesWithEvents = entities.filter(e => lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));\r\n    let lastMovePerPointer: Map<number, PointerEvent>;\r\n    let lastUpPerPointer: Map<number, PointerEvent>;\r\n    let lastDownPerPointer: Map<number, PointerEvent>;\r\n    // Dispatch events in entity z order\r\n    for (const entity of entitiesWithEvents) {\r\n      lastDownPerPointer = this._processDownAndEmit(entity);\r\n\r\n      lastUpPerPointer = this._processUpAndEmit(entity);\r\n\r\n      lastMovePerPointer = this._processMoveAndEmit(entity);\r\n\r\n      const lastUpDownMoveEvents = [\r\n        ...lastMovePerPointer.values(),\r\n        ...lastDownPerPointer.values(),\r\n        ...lastUpPerPointer.values()\r\n      ];\r\n      this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);\r\n\r\n      this._processCancelAndEmit(entity);\r\n\r\n      this._processWheelAndEmit(entity);\r\n    }\r\n  }\r\n}","import { Entity } from '../EntityComponentSystem';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ActionsComponent } from './ActionsComponent';\r\n\r\n\r\nexport class ActionsSystem extends System<ActionsComponent> {\r\n  public readonly types = ['ex.actions'] as const;\r\n  systemType = SystemType.Update;\r\n  priority = -1;\r\n\r\n  private _actions: ActionsComponent[] = [];\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n      this._actions.push(action);\r\n    } else {\r\n      const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n      const index = this._actions.indexOf(action);\r\n      if (index > -1) {\r\n        this._actions.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  update(_entities: Entity[], delta: number): void {\r\n    for (const actions of this._actions) {\r\n      actions.update(delta);\r\n    }\r\n  }\r\n}","import { Component } from '../EntityComponentSystem/Component';\r\nimport { IsometricMap } from './IsometricMap';\r\n\r\nexport class IsometricEntityComponent extends Component<'ex.isometricentity'> {\r\n  public readonly type = 'ex.isometricentity';\r\n  /**\r\n   * Vertical \"height\" in the isometric world\r\n   */\r\n  public elevation: number = 0;\r\n\r\n  public map: IsometricMap;\r\n\r\n  /**\r\n   * Specify the isometric map to use to position this entity's z-index\r\n   * @param map\r\n   */\r\n  constructor(map: IsometricMap) {\r\n    super();\r\n    this.map = map;\r\n  }\r\n}","import { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { IsometricEntityComponent } from './IsometricEntityComponent';\r\n\r\n\r\nexport class IsometricEntitySystem extends System<TransformComponent | IsometricEntityComponent> {\r\n  public readonly types = ['ex.transform', 'ex.isometricentity'] as const;\r\n  public readonly systemType = SystemType.Update;\r\n  priority: number = 99;\r\n  update(entities: Entity[], _delta: number): void {\r\n    let transform: TransformComponent;\r\n    let iso: IsometricEntityComponent;\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      iso = entity.get(IsometricEntityComponent);\r\n\r\n      const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);\r\n\r\n      const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;\r\n      transform.z = newZ;\r\n    }\r\n  }\r\n}","import { GraphicsComponent } from './GraphicsComponent';\r\nimport { EnterViewPortEvent, ExitViewPortEvent } from '../Events';\r\nimport { Scene } from '../Scene';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Camera } from '../Camera';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ParallaxComponent } from './ParallaxComponent';\r\nimport { Vector } from '../Math/vector';\r\nimport { CoordPlane } from '../Math/coord-plane';\r\n\r\nexport class OffscreenSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public systemType = SystemType.Draw;\r\n  priority: number = -1;\r\n  private _camera: Camera;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._camera = scene.camera;\r\n  }\r\n\r\n  update(entities: Entity[]): void {\r\n    let transform: TransformComponent;\r\n    let graphics: GraphicsComponent;\r\n    let maybeParallax: ParallaxComponent;\r\n\r\n    for (const entity of entities) {\r\n      graphics = entity.get(GraphicsComponent);\r\n      transform = entity.get(TransformComponent);\r\n      maybeParallax = entity.get(ParallaxComponent);\r\n\r\n      let parallaxOffset: Vector;\r\n      if (maybeParallax) {\r\n        // We use the Tiled formula\r\n        // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n        // cameraPos * (1 - parallaxFactor)\r\n        const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n        parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n      }\r\n\r\n      // Figure out if entities are offscreen\r\n      const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);\r\n      if (entityOffscreen && !entity.hasTag('ex.offscreen')) {\r\n        entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));\r\n        entity.addTag('ex.offscreen');\r\n      }\r\n\r\n      if (!entityOffscreen && entity.hasTag('ex.offscreen')) {\r\n        entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));\r\n        entity.removeTag('ex.offscreen');\r\n      }\r\n    }\r\n  }\r\n\r\n  private _isOffscreen(transform: TransformComponent, graphics: GraphicsComponent, parallaxOffset: Vector) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      let bounds = graphics.localBounds;\r\n      if (parallaxOffset) {\r\n        bounds = bounds.translate(parallaxOffset);\r\n      }\r\n      const transformedBounds = bounds.transform(transform.get().matrix);\r\n      const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);\r\n      return graphicsOffscreen;\r\n    } else {\r\n      // TODO screen coordinates\r\n      return false;\r\n    }\r\n  }\r\n\r\n}","import { isScreenElement, ScreenElement } from './ScreenElement';\r\nimport {\r\n  InitializeEvent,\r\n  ActivateEvent,\r\n  DeactivateEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  PreDebugDrawEvent,\r\n  PostDebugDrawEvent,\r\n  GameEvent\r\n} from './Events';\r\nimport { Logger } from './Util/Log';\r\nimport { Timer } from './Timer';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Camera } from './Camera';\r\nimport { Actor } from './Actor';\r\nimport { Class } from './Class';\r\nimport { CanInitialize, CanActivate, CanDeactivate, CanUpdate, CanDraw, SceneActivationContext } from './Interfaces/LifecycleEvents';\r\nimport * as Util from './Util/Util';\r\nimport * as Events from './Events';\r\nimport { Trigger } from './Trigger';\r\nimport { SystemType } from './EntityComponentSystem/System';\r\nimport { World } from './EntityComponentSystem/World';\r\nimport { MotionSystem } from './Collision/MotionSystem';\r\nimport { CollisionSystem } from './Collision/CollisionSystem';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { GraphicsSystem } from './Graphics/GraphicsSystem';\r\nimport { DebugSystem } from './Debug/DebugSystem';\r\nimport { PointerSystem } from './Input/PointerSystem';\r\nimport { ActionsSystem } from './Actions/ActionsSystem';\r\nimport { IsometricEntitySystem } from './TileMap/IsometricEntitySystem';\r\nimport { OffscreenSystem } from './Graphics/OffscreenSystem';\r\nimport { ExcaliburGraphicsContext } from './Graphics';\r\n/**\r\n * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n * Excalibur. The metaphor models the same idea behind real world\r\n * actors in a scene. Only actors in scenes will be updated and drawn.\r\n *\r\n * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n */\r\nexport class Scene<TActivationData = unknown>\r\n  extends Class\r\n  implements CanInitialize, CanActivate<TActivationData>, CanDeactivate, CanUpdate, CanDraw {\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Gets or sets the current camera for the scene\r\n   */\r\n  public camera: Camera = new Camera();\r\n\r\n  /**\r\n   * The ECS world for the scene\r\n   */\r\n  public world = new World(this);\r\n\r\n  /**\r\n   * The actors in the current scene\r\n   */\r\n  public get actors(): readonly Actor[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Actor;\r\n    }) as Actor[];\r\n  }\r\n\r\n  /**\r\n   * The entities in the current scene\r\n   */\r\n  public get entities(): readonly Entity[] {\r\n    return this.world.entityManager.entities;\r\n  }\r\n\r\n  /**\r\n   * The triggers in the current scene\r\n   */\r\n  public get triggers(): readonly Trigger[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Trigger;\r\n    }) as Trigger[];\r\n  }\r\n\r\n  /**\r\n   * The [[TileMap]]s in the scene, if any\r\n   */\r\n  public get tileMaps(): readonly TileMap[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof TileMap;\r\n    }) as TileMap[];\r\n  }\r\n\r\n  /**\r\n   * Access to the Excalibur engine\r\n   */\r\n  public engine: Engine;\r\n\r\n  private _isInitialized: boolean = false;\r\n  private _timers: Timer[] = [];\r\n  public get timers(): readonly Timer[] {\r\n    return this._timers;\r\n  }\r\n  private _cancelQueue: Timer[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n    // Initialize systems\r\n\r\n    // Update\r\n    this.world.add(new ActionsSystem());\r\n    this.world.add(new MotionSystem());\r\n    this.world.add(new CollisionSystem());\r\n    this.world.add(new PointerSystem());\r\n    this.world.add(new IsometricEntitySystem());\r\n    // Draw\r\n    this.world.add(new OffscreenSystem());\r\n    this.world.add(new GraphicsSystem());\r\n    this.world.add(new DebugSystem());\r\n  }\r\n\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public on(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public on(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public on(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public once(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public once(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public once(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.initialize, handler?: (event: InitializeEvent<Scene>) => void): void;\r\n  public off(eventName: Events.activate, handler?: (event: ActivateEvent) => void): void;\r\n  public off(eventName: Events.deactivate, handler?: (event: DeactivateEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: Events.predebugdraw, handler?: (event: PreDebugDrawEvent) => void): void;\r\n  public off(eventName: Events.postdebugdraw, handler?: (event: PostDebugDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made active and started. It is meant to be overridden,\r\n   * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onActivate(_context: SceneActivationContext<TActivationData>): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,\r\n   * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onDeactivate(_context: SceneActivationContext): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreDraw` is called directly before a scene is drawn.\r\n   *\r\n   */\r\n  public onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostDraw` is called directly after a scene is drawn.\r\n   *\r\n   */\r\n  public onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Initializes actors in the scene\r\n   */\r\n  private _initializeChildren(): void {\r\n    for (const child of this.entities) {\r\n      child._initialize(this.engine);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the [[Scene]] has been initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Initializes the scene before the first update, meant to be called by engine not by users of\r\n   * Excalibur\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.engine = engine;\r\n      // Initialize camera first\r\n      this.camera._initialize(engine);\r\n\r\n      this.world.systemManager.initialize();\r\n\r\n      // This order is important! we want to be sure any custom init that add actors\r\n      // fire before the actor init\r\n      this.onInitialize.call(this, engine);\r\n      this._initializeChildren();\r\n\r\n      this._logger.debug('Scene.onInitialize', this, engine);\r\n      this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.\r\n   * @internal\r\n   */\r\n  public _activate(context: SceneActivationContext<TActivationData>): void {\r\n    this._logger.debug('Scene.onActivate', this);\r\n    this.onActivate(context);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.\r\n   * @internal\r\n   */\r\n  public _deactivate(context: SceneActivationContext<never>): void {\r\n    this._logger.debug('Scene.onDeactivate', this);\r\n    this.onDeactivate(context);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(_engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));\r\n    this.onPreUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(_engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));\r\n    this.onPostUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));\r\n    this.onPreDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));\r\n    this.onPostDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n   * @param engine  Reference to the current Engine\r\n   * @param delta   The number of milliseconds since the last update\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._preupdate(engine, delta);\r\n\r\n    // TODO differed entity removal for timers\r\n    let i: number, len: number;\r\n    // Remove timers in the cancel queue before updating them\r\n    for (i = 0, len = this._cancelQueue.length; i < len; i++) {\r\n      this.removeTimer(this._cancelQueue[i]);\r\n    }\r\n    this._cancelQueue.length = 0;\r\n\r\n    // Cycle through timers updating timers\r\n    for (const timer of this._timers) {\r\n      timer.update(delta);\r\n    }\r\n\r\n    this.world.update(SystemType.Update, delta);\r\n\r\n    // Camera last keeps renders smooth that are based on entity/actor\r\n    if (this.camera) {\r\n      this.camera.update(engine, delta);\r\n    }\r\n\r\n    this._collectActorStats(engine);\r\n\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors in the Scene. Called by the [[Engine]].\r\n   *\r\n   * @param ctx    The current rendering context\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this._predraw(ctx, delta);\r\n\r\n    this.world.update(SystemType.Draw, delta);\r\n\r\n    if (this.engine?.isDebug) {\r\n      this.debugDraw(ctx);\r\n    }\r\n    this._postdraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors' debug information in the Scene. Called by the [[Engine]].\r\n   * @param ctx  The current rendering context\r\n   */\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: ExcaliburGraphicsContext) {\r\n    this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));\r\n    // pass\r\n    this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));\r\n  }\r\n\r\n  /**\r\n   * Checks whether an actor is contained in this scene or not\r\n   */\r\n  public contains(actor: Actor): boolean {\r\n    return this.actors.indexOf(actor) > -1;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the current [[Scene]].\r\n   * @param timer  The timer to add to the current [[Scene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n\r\n  /**\r\n   * Adds a [[TileMap]] to the [[Scene]], once this is done the [[TileMap]] will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Adds a [[Trigger]] to the [[Scene]], once this is done the [[Trigger]] will listen for interactions with other actors.\r\n   * @param trigger\r\n   */\r\n  public add(trigger: Trigger): void;\r\n\r\n  /**\r\n   * Adds an actor to the scene, once this is done the [[Actor]] will be drawn and updated.\r\n   * @param actor  The actor to add to the current scene\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the scene.\r\n   * @param screenElement  The ScreenElement to add to the current scene\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    this.emit('entityadded', { target: entity } as any);\r\n    this.world.add(entity);\r\n    entity.scene = this;\r\n    if (entity instanceof Timer) {\r\n      if (!Util.contains(this._timers, entity)) {\r\n        this.addTimer(entity);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the current scene, it will no longer be updated.\r\n   * @param timer  The timer to remove to the current scene.\r\n   */\r\n  public remove(timer: Timer): void;\r\n\r\n  /**\r\n   * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.\r\n   * @param tileMap {TileMap}\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Removes an actor from the scene, it will no longer be drawn or updated.\r\n   * @param actor  The actor to remove from the current scene.\r\n   */\r\n  public remove(actor: Actor): void;\r\n\r\n  public remove(entity: Entity): void;\r\n\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the current scene\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.emit('entityremoved', { target: entity } as any);\r\n      this.world.remove(entity);\r\n    }\r\n    if (entity instanceof Timer) {\r\n      this.removeTimer(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.\r\n   *\r\n   * By default entities use deferred removal\r\n   * @param deferred\r\n   */\r\n  public clear(deferred: boolean = true): void {\r\n    for (const entity of this.entities) {\r\n      this.world.remove(entity, deferred);\r\n    }\r\n    for (const timer of this.timers) {\r\n      this.removeTimer(timer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the scene\r\n   * @param timer  The timer to add\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    this._timers.push(timer);\r\n    timer.scene = this;\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the scene.\r\n   * @warning Can be dangerous, use [[cancelTimer]] instead\r\n   * @param timer  The timer to remove\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    const i = this._timers.indexOf(timer);\r\n    if (i !== -1) {\r\n      this._timers.splice(i, 1);\r\n    }\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Cancels a [[Timer]], removing it from the scene nicely\r\n   * @param timer  The timer to cancel\r\n   */\r\n  public cancelTimer(timer: Timer): Timer {\r\n    this._cancelQueue.push(timer);\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a [[Timer]] is active in the scene\r\n   */\r\n  public isTimerActive(timer: Timer): boolean {\r\n    return this._timers.indexOf(timer) > -1 && !timer.complete;\r\n  }\r\n\r\n  public isCurrentScene(): boolean {\r\n    if (this.engine) {\r\n      return this.engine.currentScene === this;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _collectActorStats(engine: Engine) {\r\n    const screenElements = this.actors.filter((a) => a instanceof ScreenElement) as ScreenElement[];\r\n    for (const _ui of screenElements) {\r\n      engine.stats.currFrame.actors.ui++;\r\n    }\r\n\r\n    for (const actor of this.actors) {\r\n      engine.stats.currFrame.actors.alive++;\r\n      for (const child of actor.children) {\r\n        if (isScreenElement(child as Actor)) {\r\n          // TODO not true\r\n          engine.stats.currFrame.actors.ui++;\r\n        } else {\r\n          engine.stats.currFrame.actors.alive++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","\r\n\r\nexport enum ColorBlindnessMode {\r\n  Protanope = 'Protanope',\r\n  Deuteranope = 'Deuteranope',\r\n  Tritanope = 'Tritanope'\r\n}\r\n","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n// our texture\\r\\nuniform sampler2D u_image;\\r\\n// the texCoords passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// color blind type\\r\\nuniform int u_type;\\r\\n\\r\\n// simulation?\\r\\nuniform bool u_simulate;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  vec4 o =  texture(u_image, v_texcoord);\\r\\n  // RGB to LMS matrix conversion\\r\\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\\r\\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\\r\\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\\r\\n  // Simulate color blindness\\r\\n  float l;\\r\\n  float m;\\r\\n  float s;\\r\\n  //MODE CODE//\\r\\n  if (u_type == 0) {\\r\\n    // Protanope\\r\\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\\r\\n  } else if (u_type == 1) {\\r\\n    // Deuteranope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\\r\\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\\r\\n  } else if (u_type == 2) {\\r\\n    // Tritanope\\r\\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\\r\\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\\r\\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\\r\\n  }\\r\\n\\r\\n  // LMS to RGB matrix conversion\\r\\n  vec4 error; // simulate the colors\\r\\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\\r\\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\\r\\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\\r\\n  error.a = 1.0;\\r\\n  vec4 diff = o - error;\\r\\n  vec4 correction; // correct the colors\\r\\n  correction.r = 0.0;\\r\\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\\r\\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\\r\\n  correction = o + correction;\\r\\n  correction.a = o.a;\\r\\n  //SIMULATE//\\r\\n\\r\\n  // sim \\r\\n  if (u_simulate) {\\r\\n    fragColor = error.rgba;\\r\\n  } else {\\r\\n    fragColor = correction.rgba;\\r\\n  }\\r\\n}\";","import { Shader } from '../Context/shader';\r\nimport { VertexBuffer } from '../Context/vertex-buffer';\r\nimport { VertexLayout } from '../Context/vertex-layout';\r\n\r\n/**\r\n * Helper that defines a whole screen renderer, just provide a fragment source!\r\n *\r\n * Currently supports 1 varying\r\n * - vec2 a_texcoord between 0-1 which corresponds to screen position\r\n */\r\nexport class ScreenShader {\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  constructor(fragmentSource: string) {\r\n    this._shader = new Shader({\r\n      vertexSource: `#version 300 es\r\n      in vec2 a_position;\r\n      in vec2 a_texcoord;\r\n      out vec2 v_texcoord;\r\n\r\n      void main() {\r\n        gl_Position = vec4(a_position, 0.0, 1.0);\r\n        // Pass the texcoord to the fragment shader.\r\n        v_texcoord = a_texcoord;\r\n      }`,\r\n      fragmentSource: fragmentSource\r\n    });\r\n    this._shader.compile();\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      type: 'static',\r\n      // clip space quad + uv since we don't need a camera\r\n      data: new Float32Array([\r\n        -1, -1,          0, 0,\r\n        -1, 1,           0, 1,\r\n        1, -1,           1, 0,\r\n\r\n        1, -1,            1, 0,\r\n        -1, 1,           0, 1,\r\n        1, 1,            1, 1\r\n      ])\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_texcoord', 2]\r\n      ]\r\n    });\r\n    this._buffer.upload();\r\n  }\r\n\r\n  public getShader() {\r\n    return this._shader;\r\n  }\r\n  public getLayout() {\r\n    return this._layout;\r\n  }\r\n}","import colorBlindCorrectSource from './color-blind-fragment.glsl';\r\nimport { PostProcessor } from './PostProcessor';\r\nimport { ColorBlindnessMode } from './ColorBlindnessMode';\r\nimport { Shader } from '../Context/shader';\r\nimport { VertexLayout } from '../Context/vertex-layout';\r\nimport { ScreenShader } from './ScreenShader';\r\n\r\nexport class ColorBlindnessPostProcessor implements PostProcessor {\r\n  private _shader: ScreenShader;\r\n  private _simulate = false;\r\n  constructor(private _colorBlindnessMode: ColorBlindnessMode, simulate = false) {\r\n    this._simulate = simulate;\r\n  }\r\n\r\n  initialize(_gl: WebGLRenderingContext): void {\r\n    this._shader = new ScreenShader(colorBlindCorrectSource);\r\n    this.simulate = this._simulate;\r\n    this.colorBlindnessMode = this._colorBlindnessMode;\r\n  }\r\n\r\n  getShader(): Shader {\r\n    return this._shader.getShader();\r\n  }\r\n\r\n  getLayout(): VertexLayout {\r\n    return this._shader.getLayout();\r\n  }\r\n\r\n  set colorBlindnessMode(colorBlindMode: ColorBlindnessMode) {\r\n    this._colorBlindnessMode = colorBlindMode;\r\n    if (this._shader) {\r\n      const shader = this._shader.getShader();\r\n      shader.use();\r\n      if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {\r\n        shader.setUniformInt('u_type', 0);\r\n      } else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {\r\n        shader.setUniformInt('u_type', 1);\r\n      } else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {\r\n        shader.setUniformInt('u_type', 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  get colorBlindnessMode(): ColorBlindnessMode {\r\n    return this._colorBlindnessMode;\r\n  }\r\n\r\n  set simulate(value: boolean) {\r\n    this._simulate = value;\r\n    if (this._shader) {\r\n\r\n      const shader = this._shader.getShader();\r\n      shader.use();\r\n      shader.setUniformBoolean('u_simulate', value);\r\n    }\r\n  }\r\n\r\n  get simulate(): boolean {\r\n    return this._simulate;\r\n  }\r\n}\r\n","import { ColorBlindnessMode } from '../Graphics/PostProcessor/ColorBlindnessMode';\r\nimport { ColorBlindnessPostProcessor } from '../Graphics/PostProcessor/ColorBlindnessPostProcessor';\r\nimport { Engine } from '../Engine';\r\nimport { ExcaliburGraphicsContextWebGL } from '..';\r\n\r\nexport interface DebugFlags {\r\n  colorBlindMode: ColorBlindFlags;\r\n}\r\n\r\nexport class ColorBlindFlags {\r\n  private _engine: Engine;\r\n  private _colorBlindPostProcessor: ColorBlindnessPostProcessor;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n    this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);\r\n  }\r\n\r\n  /**\r\n   * Correct colors for a specified color blindness\r\n   * @param colorBlindness\r\n   */\r\n  public correct(colorBlindness: ColorBlindnessMode) {\r\n    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      this.clear();\r\n      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n      this._colorBlindPostProcessor.simulate = false;\r\n      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simulate colors for a specified color blindness\r\n   * @param colorBlindness\r\n   */\r\n  public simulate(colorBlindness: ColorBlindnessMode) {\r\n    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      this.clear();\r\n      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n      this._colorBlindPostProcessor.simulate = true;\r\n      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove color blindness post processor\r\n   */\r\n  public clear() {\r\n    this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);\r\n  }\r\n}\r\n","import { DebugFlags, ColorBlindFlags } from './DebugFlags';\r\nimport { Engine } from '../Engine';\r\nimport { Color } from '../Color';\r\nimport { CollisionContact } from '../Collision/Detection/CollisionContact';\r\nimport { StandardClock, TestClock } from '..';\r\n\r\n/**\r\n * Debug stats containing current and previous frame statistics\r\n */\r\nexport interface DebugStats {\r\n  currFrame: FrameStats;\r\n  prevFrame: FrameStats;\r\n}\r\n\r\n/**\r\n * Represents a frame's individual statistics\r\n */\r\nexport interface FrameStatistics {\r\n  /**\r\n   * The number of the frame\r\n   */\r\n  id: number;\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame scaled by [[Engine.timescale]]) (in ms)\r\n   */\r\n  delta: number;\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  fps: number;\r\n\r\n  /**\r\n   * Duration statistics (in ms)\r\n   */\r\n  duration: FrameDurationStats;\r\n\r\n  /**\r\n   * Actor statistics\r\n   */\r\n  actors: FrameActorStats;\r\n\r\n  /**\r\n   * Physics statistics\r\n   */\r\n  physics: PhysicsStatistics;\r\n\r\n  /**\r\n   * Graphics statistics\r\n   */\r\n  graphics: GraphicsStatistics;\r\n}\r\n\r\n/**\r\n * Represents actor stats for a frame\r\n */\r\nexport interface FrameActorStats {\r\n  /**\r\n   * Gets the frame's number of actors (alive)\r\n   */\r\n  alive: number;\r\n\r\n  /**\r\n   * Gets the frame's number of actors (killed)\r\n   */\r\n  killed: number;\r\n\r\n  /**\r\n   * Gets the frame's number of remaining actors (alive - killed)\r\n   */\r\n  remaining: number;\r\n\r\n  /**\r\n   * Gets the frame's number of UI actors\r\n   */\r\n  ui: number;\r\n\r\n  /**\r\n   * Gets the frame's number of total actors (remaining + UI)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents duration stats for a frame\r\n */\r\nexport interface FrameDurationStats {\r\n  /**\r\n   * Gets the frame's total time to run the update function (in ms)\r\n   */\r\n  update: number;\r\n\r\n  /**\r\n   * Gets the frame's total time to run the draw function (in ms)\r\n   */\r\n  draw: number;\r\n\r\n  /**\r\n   * Gets the frame's total render duration (update + draw duration) (in ms)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents physics stats for the current frame\r\n */\r\nexport interface PhysicsStatistics {\r\n  /**\r\n   * Gets the number of broadphase collision pairs which\r\n   */\r\n  pairs: number;\r\n\r\n  /**\r\n   * Gets the number of actual collisions\r\n   */\r\n  collisions: number;\r\n\r\n  /**\r\n   * Copy of the current frame contacts (only updated if debug is toggled on)\r\n   */\r\n  contacts: Map<string, CollisionContact>;\r\n\r\n  /**\r\n   * Gets the number of fast moving bodies using raycast continuous collisions in the scene\r\n   */\r\n  fastBodies: number;\r\n\r\n  /**\r\n   * Gets the number of bodies that had a fast body collision resolution\r\n   */\r\n  fastBodyCollisions: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the broadphase pairs\r\n   */\r\n  broadphase: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the narrowphase\r\n   */\r\n  narrowphase: number;\r\n}\r\n\r\nexport interface GraphicsStatistics {\r\n  drawCalls: number;\r\n  drawnImages: number;\r\n}\r\n\r\n/**\r\n * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n * updated during a frame.\r\n */\r\nexport class Debug implements DebugFlags {\r\n  private _engine: Engine;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n\r\n    this.colorBlindMode = new ColorBlindFlags(this._engine);\r\n  }\r\n\r\n  /**\r\n   * Switch the current excalibur clock with the [[TestClock]] and return\r\n   * it in the same running state.\r\n   *\r\n   * This is useful when you need to debug frame by frame.\r\n   */\r\n  public useTestClock(): TestClock {\r\n    const clock = this._engine.clock;\r\n    const wasRunning = clock.isRunning();\r\n    clock.stop();\r\n\r\n    const testClock = clock.toTestClock();\r\n    if (wasRunning) {\r\n      testClock.start();\r\n    }\r\n    this._engine.clock = testClock;\r\n    return testClock;\r\n  }\r\n\r\n  /**\r\n   * Switch the current excalibur clock with the [[StandardClock]] and\r\n   * return it in the same running state.\r\n   *\r\n   * This is useful when you need to switch back to normal mode after\r\n   * debugging.\r\n   */\r\n  public useStandardClock(): StandardClock {\r\n    const currentClock = this._engine.clock;\r\n    const wasRunning = currentClock.isRunning();\r\n    currentClock.stop();\r\n\r\n    const standardClock = currentClock.toStandardClock();\r\n    if (wasRunning) {\r\n      standardClock.start();\r\n    }\r\n    this._engine.clock = standardClock;\r\n    return standardClock;\r\n  }\r\n\r\n  /**\r\n   * Performance statistics\r\n   */\r\n  public stats: DebugStats = {\r\n    /**\r\n     * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[postframe]] event. See [[FrameStats]]\r\n     */\r\n    currFrame: new FrameStats(),\r\n\r\n    /**\r\n     * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]\r\n     */\r\n    prevFrame: new FrameStats()\r\n  };\r\n\r\n  /**\r\n   * Correct or simulate color blindness using [[ColorBlindnessPostProcessor]].\r\n   * @warning Will reduce FPS.\r\n   */\r\n  public colorBlindMode: ColorBlindFlags;\r\n\r\n  /**\r\n   * Filter debug context to named entities or entity ids\r\n   */\r\n  public filter: { useFilter: boolean; nameQuery: string; ids: number[] } = {\r\n    /**\r\n     * Toggle filter on or off (default off) must be on for DebugDraw to use filters\r\n     */\r\n    useFilter: false,\r\n    /**\r\n     * Query for entities by name, if the entity name contains `nameQuery` it will be included\r\n     */\r\n    nameQuery: '',\r\n    /**\r\n     * Query for Entity ids, if the id matches it will be included\r\n     */\r\n    ids: []\r\n  };\r\n\r\n  /**\r\n   * Entity debug settings\r\n   */\r\n  public entity = {\r\n    showAll: false,\r\n    showId: true,\r\n    showName: false\r\n  };\r\n\r\n  /**\r\n   * Transform component debug settings\r\n   */\r\n  public transform = {\r\n    showAll: false,\r\n\r\n    showPosition: false,\r\n    showPositionLabel: false,\r\n    positionColor: Color.Yellow,\r\n\r\n    showZIndex: false,\r\n\r\n    showScale: false,\r\n    scaleColor: Color.Green,\r\n\r\n    showRotation: false,\r\n    rotationColor: Color.Blue\r\n  };\r\n\r\n  /**\r\n   * Graphics component debug settings\r\n   */\r\n  public graphics = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Yellow\r\n  };\r\n\r\n  /**\r\n   * Collider component debug settings\r\n   */\r\n  public collider = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Blue,\r\n\r\n    showOwner: false,\r\n\r\n    showGeometry: true,\r\n    geometryColor: Color.Green\r\n  };\r\n\r\n  /**\r\n   * Physics simulation debug settings\r\n   */\r\n  public physics = {\r\n    showAll: false,\r\n\r\n    showBroadphaseSpacePartitionDebug: false,\r\n\r\n    showCollisionNormals: false,\r\n    collisionNormalColor: Color.Cyan,\r\n\r\n    showCollisionContacts: true,\r\n    collisionContactColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Motion component debug settings\r\n   */\r\n  public motion = {\r\n    showAll: false,\r\n\r\n    showVelocity: false,\r\n    velocityColor: Color.Yellow,\r\n\r\n    showAcceleration: false,\r\n    accelerationColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Body component debug settings\r\n   */\r\n  public body = {\r\n    showAll: false,\r\n\r\n    showCollisionGroup: false,\r\n    showCollisionType: false,\r\n    showSleeping: false,\r\n    showMotion: false,\r\n    showMass: false\r\n  };\r\n\r\n  /**\r\n   * Camera debug settings\r\n   */\r\n  public camera = {\r\n    showAll: false,\r\n\r\n    showFocus: false,\r\n    focusColor: Color.Red,\r\n\r\n    showZoom: false\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n * creating instances of this every frame.\r\n */\r\nexport class FrameStats implements FrameStatistics {\r\n  private _id: number = 0;\r\n  private _delta: number = 0;\r\n  private _fps: number = 0;\r\n  private _actorStats: FrameActorStats = {\r\n    alive: 0,\r\n    killed: 0,\r\n    ui: 0,\r\n    get remaining() {\r\n      return this.alive - this.killed;\r\n    },\r\n    get total() {\r\n      return this.remaining + this.ui;\r\n    }\r\n  };\r\n  private _durationStats: FrameDurationStats = {\r\n    update: 0,\r\n    draw: 0,\r\n    get total() {\r\n      return this.update + this.draw;\r\n    }\r\n  };\r\n\r\n  private _physicsStats: PhysicsStats = new PhysicsStats();\r\n\r\n  private _graphicsStats: GraphicsStatistics = {\r\n    drawCalls: 0,\r\n    drawnImages: 0\r\n  };\r\n\r\n  /**\r\n   * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: FrameStatistics) {\r\n    if (otherStats) {\r\n      this.id = otherStats.id;\r\n      this.delta = otherStats.delta;\r\n      this.fps = otherStats.fps;\r\n      this.actors.alive = otherStats.actors.alive;\r\n      this.actors.killed = otherStats.actors.killed;\r\n      this.actors.ui = otherStats.actors.ui;\r\n      this.duration.update = otherStats.duration.update;\r\n      this.duration.draw = otherStats.duration.draw;\r\n      this._physicsStats.reset(otherStats.physics);\r\n      this.graphics.drawCalls = otherStats.graphics.drawCalls;\r\n      this.graphics.drawnImages = otherStats.graphics.drawnImages;\r\n    } else {\r\n      this.id = this.delta = this.fps = 0;\r\n      this.actors.alive = this.actors.killed = this.actors.ui = 0;\r\n      this.duration.update = this.duration.draw = 0;\r\n      this._physicsStats.reset();\r\n      this.graphics.drawnImages = this.graphics.drawCalls = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): FrameStats {\r\n    const fs = new FrameStats();\r\n\r\n    fs.reset(this);\r\n\r\n    return fs;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's id\r\n   */\r\n  public get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's id\r\n   */\r\n  public set id(value: number) {\r\n    this._id = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame)\r\n   */\r\n  public get delta() {\r\n    return this._delta;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's delta (time since last frame). Internal use only.\r\n   * @internal\r\n   */\r\n  public set delta(value: number) {\r\n    this._delta = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  public get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's frames-per-second (FPS). Internal use only.\r\n   * @internal\r\n   */\r\n  public set fps(value: number) {\r\n    this._fps = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's actor statistics\r\n   */\r\n  public get actors() {\r\n    return this._actorStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's duration statistics\r\n   */\r\n  public get duration() {\r\n    return this._durationStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's physics statistics\r\n   */\r\n  public get physics() {\r\n    return this._physicsStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's graphics statistics\r\n   */\r\n  public get graphics() {\r\n    return this._graphicsStats;\r\n  }\r\n}\r\n\r\nexport class PhysicsStats implements PhysicsStatistics {\r\n  private _pairs: number = 0;\r\n  private _collisions: number = 0;\r\n  private _contacts: Map<string, CollisionContact> = new Map();\r\n  private _fastBodies: number = 0;\r\n  private _fastBodyCollisions: number = 0;\r\n  private _broadphase: number = 0;\r\n  private _narrowphase: number = 0;\r\n\r\n  /**\r\n   * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: PhysicsStatistics) {\r\n    if (otherStats) {\r\n      this.pairs = otherStats.pairs;\r\n      this.collisions = otherStats.collisions;\r\n      this.contacts = otherStats.contacts;\r\n      this.fastBodies = otherStats.fastBodies;\r\n      this.fastBodyCollisions = otherStats.fastBodyCollisions;\r\n      this.broadphase = otherStats.broadphase;\r\n      this.narrowphase = otherStats.narrowphase;\r\n    } else {\r\n      this.pairs = this.collisions = this.fastBodies = 0;\r\n      this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\r\n      this.contacts.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): PhysicsStatistics {\r\n    const ps = new PhysicsStats();\r\n\r\n    ps.reset(this);\r\n\r\n    return ps;\r\n  }\r\n\r\n  public get pairs(): number {\r\n    return this._pairs;\r\n  }\r\n\r\n  public set pairs(value: number) {\r\n    this._pairs = value;\r\n  }\r\n\r\n  public get collisions(): number {\r\n    return this._collisions;\r\n  }\r\n\r\n  public set collisions(value: number) {\r\n    this._collisions = value;\r\n  }\r\n\r\n  public get contacts(): Map<string, CollisionContact> {\r\n    return this._contacts;\r\n  }\r\n\r\n  public set contacts(contacts: Map<string, CollisionContact>) {\r\n    this._contacts = contacts;\r\n  }\r\n\r\n  public get fastBodies(): number {\r\n    return this._fastBodies;\r\n  }\r\n\r\n  public set fastBodies(value: number) {\r\n    this._fastBodies = value;\r\n  }\r\n\r\n  public get fastBodyCollisions(): number {\r\n    return this._fastBodyCollisions;\r\n  }\r\n\r\n  public set fastBodyCollisions(value: number) {\r\n    this._fastBodyCollisions = value;\r\n  }\r\n\r\n  public get broadphase(): number {\r\n    return this._broadphase;\r\n  }\r\n\r\n  public set broadphase(value: number) {\r\n    this._broadphase = value;\r\n  }\r\n\r\n  public get narrowphase(): number {\r\n    return this._narrowphase;\r\n  }\r\n\r\n  public set narrowphase(value: number) {\r\n    this._narrowphase = value;\r\n  }\r\n}\r\n","/**\r\n * Determines the scope of handling mouse/touch events.\r\n */\r\n\r\nexport enum PointerScope {\r\n  /**\r\n   * Handle events on the `canvas` element only. Events originating outside the\r\n   * `canvas` will not be handled.\r\n   */\r\n  Canvas = 'Canvas',\r\n\r\n  /**\r\n   * Handles events on the entire document. All events will be handled by Excalibur.\r\n   */\r\n  Document = 'Document'\r\n}\r\n","import { Logger } from '../Util/Log';\r\nimport { Class } from '../Class';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Enum representing physical input key codes\r\n */\r\nexport enum Keys {\r\n  // NUMPAD\r\n  Num0 = 'Numpad0',\r\n  Num1 = 'Numpad1',\r\n  Num2 = 'Numpad2',\r\n  Num3 = 'Numpad3',\r\n  Num4 = 'Numpad4',\r\n  Num5 = 'Numpad5',\r\n  Num6 = 'Numpad6',\r\n  Num7 = 'Numpad7',\r\n  Num8 = 'Numpad8',\r\n  Num9 = 'Numpad9',\r\n  NumAdd = 'NumpadAdd',\r\n  NumSubtract = 'NumpadSubtract',\r\n  NumMultiply = 'NumpadMultiply',\r\n  NumDivide = 'NumpadDivide',\r\n  // NumComma = 'NumpadComma', // not x-browser\r\n  NumDecimal = 'NumpadDecimal',\r\n  Numpad0 = 'Numpad0',\r\n  Numpad1 = 'Numpad1',\r\n  Numpad2 = 'Numpad2',\r\n  Numpad3 = 'Numpad3',\r\n  Numpad4 = 'Numpad4',\r\n  Numpad5 = 'Numpad5',\r\n  Numpad6 = 'Numpad6',\r\n  Numpad7 = 'Numpad7',\r\n  Numpad8 = 'Numpad8',\r\n  Numpad9 = 'Numpad9',\r\n  NumpadAdd = 'NumpadAdd',\r\n  NumpadSubtract = 'NumpadSubtract',\r\n  NumpadMultiply = 'NumpadMultiply',\r\n  NumpadDivide = 'NumpadDivide',\r\n  // NumpadComma = 'NumpadComma', // not x-browser\r\n  NumpadDecimal = 'NumpadDecimal',\r\n\r\n  // MODIFIERS\r\n  NumLock = 'NumLock',\r\n  ShiftLeft = 'ShiftLeft',\r\n  ShiftRight = 'ShiftRight',\r\n  AltLeft = 'AltLeft',\r\n  AltRight = 'AltRight',\r\n  ControlLeft = 'ControlLeft',\r\n  ControlRight = 'ControlRight',\r\n  MetaLeft = 'MetaLeft',\r\n  MetaRight = 'MetaRight',\r\n\r\n  // NUMBERS\r\n  Key0 = 'Digit0',\r\n  Key1 = 'Digit1',\r\n  Key2 = 'Digit2',\r\n  Key3 = 'Digit3',\r\n  Key4 = 'Digit4',\r\n  Key5 = 'Digit5',\r\n  Key6 = 'Digit6',\r\n  Key7 = 'Digit7',\r\n  Key8 = 'Digit8',\r\n  Key9 = 'Digit9',\r\n  Digit0 = 'Digit0',\r\n  Digit1 = 'Digit1',\r\n  Digit2 = 'Digit2',\r\n  Digit3 = 'Digit3',\r\n  Digit4 = 'Digit4',\r\n  Digit5 = 'Digit5',\r\n  Digit6 = 'Digit6',\r\n  Digit7 = 'Digit7',\r\n  Digit8 = 'Digit8',\r\n  Digit9 = 'Digit9',\r\n\r\n  // FUNCTION KEYS\r\n  F1 = 'F1',\r\n  F2 = 'F2',\r\n  F3 = 'F3',\r\n  F4 = 'F4',\r\n  F5 = 'F5',\r\n  F6 = 'F6',\r\n  F7 = 'F7',\r\n  F8 = 'F8',\r\n  F9 = 'F9',\r\n  F10 = 'F10',\r\n  F11 = 'F11',\r\n  F12 = 'F12',\r\n\r\n  // LETTERS\r\n  A = 'KeyA',\r\n  B = 'KeyB',\r\n  C = 'KeyC',\r\n  D = 'KeyD',\r\n  E = 'KeyE',\r\n  F = 'KeyF',\r\n  G = 'KeyG',\r\n  H = 'KeyH',\r\n  I = 'KeyI',\r\n  J = 'KeyJ',\r\n  K = 'KeyK',\r\n  L = 'KeyL',\r\n  M = 'KeyM',\r\n  N = 'KeyN',\r\n  O = 'KeyO',\r\n  P = 'KeyP',\r\n  Q = 'KeyQ',\r\n  R = 'KeyR',\r\n  S = 'KeyS',\r\n  T = 'KeyT',\r\n  U = 'KeyU',\r\n  V = 'KeyV',\r\n  W = 'KeyW',\r\n  X = 'KeyX',\r\n  Y = 'KeyY',\r\n  Z = 'KeyZ',\r\n  KeyA = 'KeyA',\r\n  KeyB = 'KeyB',\r\n  KeyC = 'KeyC',\r\n  KeyD = 'KeyD',\r\n  KeyE = 'KeyE',\r\n  KeyF = 'KeyF',\r\n  KeyG = 'KeyG',\r\n  KeyH = 'KeyH',\r\n  KeyI = 'KeyI',\r\n  KeyJ = 'KeyJ',\r\n  KeyK = 'KeyK',\r\n  KeyL = 'KeyL',\r\n  KeyM = 'KeyM',\r\n  KeyN = 'KeyN',\r\n  KeyO = 'KeyO',\r\n  KeyP = 'KeyP',\r\n  KeyQ = 'KeyQ',\r\n  KeyR = 'KeyR',\r\n  KeyS = 'KeyS',\r\n  KeyT = 'KeyT',\r\n  KeyU = 'KeyU',\r\n  KeyV = 'KeyV',\r\n  KeyW = 'KeyW',\r\n  KeyX = 'KeyX',\r\n  KeyY = 'KeyY',\r\n  KeyZ = 'KeyZ',\r\n\r\n  // SYMBOLS\r\n  Semicolon = 'Semicolon',\r\n  Quote = 'Quote',\r\n  Comma = 'Comma',\r\n  Minus = 'Minus',\r\n  Period = 'Period',\r\n  Slash = 'Slash',\r\n  Equal = 'Equal',\r\n  BracketLeft = 'BracketLeft',\r\n  Backslash = 'Backslash',\r\n  BracketRight = 'BracketRight',\r\n  Backquote = 'Backquote',\r\n\r\n  // DIRECTIONS\r\n  Up = 'ArrowUp',\r\n  Down = 'ArrowDown',\r\n  Left = 'ArrowLeft',\r\n  Right = 'ArrowRight',\r\n  ArrowUp = 'ArrowUp',\r\n  ArrowDown = 'ArrowDown',\r\n  ArrowLeft = 'ArrowLeft',\r\n  ArrowRight = 'ArrowRight',\r\n\r\n  // OTHER\r\n  Space = 'Space',\r\n  Backspace = 'Backspace',\r\n  Delete = 'Delete',\r\n  Esc = 'Escape',\r\n  Escape = 'Escape',\r\n  Enter = 'Enter',\r\n  NumpadEnter = 'NumpadEnter',\r\n  ContextMenu = 'ContextMenu'\r\n}\r\n\r\n/**\r\n * Event thrown on a game object for a key event\r\n */\r\nexport class KeyEvent extends Events.GameEvent<any> {\r\n  /**\r\n   * @param key  The key responsible for throwing the event\r\n   * @param value The key's typed value the browser detected\r\n   * @param originalEvent The original keyboard event that Excalibur handled\r\n   */\r\n  constructor(public key: Keys, public value?: string, public originalEvent?: KeyboardEvent) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Provides keyboard support for Excalibur.\r\n */\r\nexport class Keyboard extends Class {\r\n  private _keys: Keys[] = [];\r\n  private _keysUp: Keys[] = [];\r\n  private _keysDown: Keys[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public on(eventName: Events.press, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.release, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.hold, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Initialize Keyboard event listeners\r\n   */\r\n  init(global?: GlobalEventHandlers): void {\r\n    if (!global) {\r\n      try {\r\n        // Try and listen to events on top window frame if within an iframe.\r\n        //\r\n        // See https://github.com/excaliburjs/Excalibur/issues/1294\r\n        //\r\n        // Attempt to add an event listener, which triggers a DOMException on\r\n        // cross-origin iframes\r\n        const noop = () => {\r\n          return;\r\n        };\r\n        window.top.addEventListener('blur', noop);\r\n        window.top.removeEventListener('blur', noop);\r\n\r\n        // this will be the same as window if not embedded within an iframe\r\n        global = window.top;\r\n      } catch {\r\n        // fallback to current frame\r\n        global = window;\r\n\r\n        Logger.getInstance().warn(\r\n          'Failed to bind to keyboard events to top frame. ' +\r\n            'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.'\r\n        );\r\n      }\r\n    }\r\n\r\n    global.addEventListener('blur', () => {\r\n      this._keys.length = 0; // empties array efficiently\r\n    });\r\n\r\n    // key up is on window because canvas cannot have focus\r\n    global.addEventListener('keyup', this._handleKeyUp);\r\n\r\n    // key down is on window because canvas cannot have focus\r\n    global.addEventListener('keydown', this._handleKeyDown);\r\n  }\r\n\r\n  private _handleKeyDown = (ev: KeyboardEvent) => {\r\n    const code = ev.code as Keys;\r\n    if (this._keys.indexOf(code) === -1) {\r\n      this._keys.push(code);\r\n      this._keysDown.push(code);\r\n      const keyEvent = new KeyEvent(code, ev.key, ev);\r\n      this.eventDispatcher.emit('down', keyEvent);\r\n      this.eventDispatcher.emit('press', keyEvent);\r\n    }\r\n  };\r\n\r\n  private _handleKeyUp = (ev: KeyboardEvent) => {\r\n    const code = ev.code as Keys;\r\n    const key = this._keys.indexOf(code);\r\n    this._keys.splice(key, 1);\r\n    this._keysUp.push(code);\r\n    const keyEvent = new KeyEvent(code, ev.key, ev);\r\n\r\n    // alias the old api, we may want to deprecate this in the future\r\n    this.eventDispatcher.emit('up', keyEvent);\r\n    this.eventDispatcher.emit('release', keyEvent);\r\n  };\r\n\r\n  public update() {\r\n    // Reset keysDown and keysUp after update is complete\r\n    this._keysDown.length = 0;\r\n    this._keysUp.length = 0;\r\n\r\n    // Emit synthetic \"hold\" event\r\n    for (let i = 0; i < this._keys.length; i++) {\r\n      this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets list of keys being pressed down\r\n   */\r\n  public getKeys(): Keys[] {\r\n    return this._keys;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n   * @param key Test whether a key was just pressed\r\n   */\r\n  public wasPressed(key: Keys): boolean {\r\n    return this._keysDown.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key is held down. This is persisted between frames.\r\n   * @param key  Test whether a key is held down\r\n   */\r\n  public isHeld(key: Keys): boolean {\r\n    return this._keys.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n   * @param key  Test whether a key was just released\r\n   */\r\n  public wasReleased(key: Keys): boolean {\r\n    return this._keysUp.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Trigger a manual key event\r\n   * @param type\r\n   * @param key\r\n   * @param character\r\n   */\r\n  public triggerEvent(type: 'down' | 'up', key: Keys, character?: string) {\r\n    if (type === 'down') {\r\n      this._handleKeyDown(new KeyboardEvent('keydown', {\r\n        code: key,\r\n        key: character ?? null\r\n      }));\r\n    }\r\n    if (type === 'up') {\r\n      this._handleKeyUp(new KeyboardEvent('keyup', {\r\n        code: key,\r\n        key: character ?? null\r\n      }));\r\n    }\r\n  }\r\n}\r\n","import { Class } from './../Class';\r\nimport { GameEvent, GamepadConnectEvent, GamepadDisconnectEvent, GamepadButtonEvent, GamepadAxisEvent } from '../Events';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n * to provide controller support for your games.\r\n */\r\nexport class Gamepads extends Class {\r\n  /**\r\n   * Whether or not to poll for Gamepad input (default: `false`)\r\n   */\r\n  public enabled = false;\r\n\r\n  /**\r\n   * Whether or not Gamepad API is supported\r\n   */\r\n  public supported = !!(<any>navigator).getGamepads;\r\n\r\n  /**\r\n   * The minimum value an axis has to move before considering it a change\r\n   */\r\n  public static MinAxisMoveThreshold = 0.05;\r\n\r\n  private _gamePadTimeStamps = [0, 0, 0, 0];\r\n  private _oldPads: Gamepad[] = [];\r\n  private _pads: Gamepad[] = [];\r\n  private _initSuccess: boolean = false;\r\n  private _navigator: NavigatorGamepads = <any>navigator;\r\n  private _minimumConfiguration: GamepadConfiguration = null;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public init() {\r\n    if (!this.supported) {\r\n      return;\r\n    }\r\n    if (this._initSuccess) {\r\n      return;\r\n    }\r\n\r\n    // In Chrome, this will return 4 undefined items until a button is pressed\r\n    // In FF, this will not return any items until a button is pressed\r\n    this._oldPads = this._clonePads(this._navigator.getGamepads());\r\n    if (this._oldPads.length && this._oldPads[0]) {\r\n      this._initSuccess = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n   * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n   * all other controllers with more axis or buttons are valid as well. If no minimum\r\n   * configuration is set all pads are valid.\r\n   */\r\n  public setMinimumGamepadConfiguration(config: GamepadConfiguration): void {\r\n    this._enableAndUpdate(); // if config is used, implicitly enable\r\n    this._minimumConfiguration = config;\r\n  }\r\n\r\n  /**\r\n   * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n   */\r\n  private _enableAndUpdate() {\r\n    if (!this.enabled) {\r\n      this.enabled = true;\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks a navigator gamepad against the minimum configuration if present.\r\n   */\r\n  private _isGamepadValid(pad: NavigatorGamepad): boolean {\r\n    if (!this._minimumConfiguration) {\r\n      return true;\r\n    }\r\n    if (!pad) {\r\n      return false;\r\n    }\r\n    const axesLength = pad.axes.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n\r\n    const buttonLength = pad.buttons.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n    return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;\r\n  }\r\n\r\n  public on(eventName: Events.connect, handler: (event: GamepadConnectEvent) => void): void;\r\n  public on(eventName: Events.disconnect, handler: (event: GamepadDisconnectEvent) => void): void;\r\n  public on(eventName: Events.button, handler: (event: GamepadButtonEvent) => void): void;\r\n  public on(eventName: Events.axis, handler: (event: GamepadAxisEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void) {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Updates Gamepad state and publishes Gamepad events\r\n   */\r\n  public update() {\r\n    if (!this.enabled || !this.supported) {\r\n      return;\r\n    }\r\n    this.init();\r\n\r\n    const gamepads = this._navigator.getGamepads();\r\n\r\n    for (let i = 0; i < gamepads.length; i++) {\r\n      if (!gamepads[i]) {\r\n        const gamepad = this.at(i);\r\n        // If was connected, but now isn't emit the disconnect event\r\n        if (gamepad.connected) {\r\n          this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));\r\n        }\r\n        // Reset connection status\r\n        gamepad.connected = false;\r\n        continue;\r\n      } else {\r\n        if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {\r\n          this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));\r\n        }\r\n        // Set connection status\r\n        this.at(i).connected = true;\r\n      }\r\n\r\n      // Only supported in Chrome\r\n      if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {\r\n        continue;\r\n      }\r\n\r\n      this._gamePadTimeStamps[i] = gamepads[i].timestamp;\r\n\r\n      // Add reference to navigator gamepad\r\n      this.at(i).navigatorGamepad = gamepads[i];\r\n\r\n      // Buttons\r\n      let b: string, bi: number, a: string, ai: number, value: number;\r\n\r\n      for (b in Buttons) {\r\n        bi = <any>Buttons[b];\r\n        if (typeof bi === 'number') {\r\n          if (gamepads[i].buttons[bi]) {\r\n            value = gamepads[i].buttons[bi].value;\r\n            if (value !== this._oldPads[i].getButton(bi)) {\r\n              if (gamepads[i].buttons[bi].pressed) {\r\n                this.at(i).updateButton(bi, value);\r\n                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));\r\n              } else {\r\n                this.at(i).updateButton(bi, 0);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Axes\r\n      for (a in Axes) {\r\n        ai = <any>Axes[a];\r\n        if (typeof ai === 'number') {\r\n          value = gamepads[i].axes[ai];\r\n          if (value !== this._oldPads[i].getAxes(ai)) {\r\n            this.at(i).updateAxes(ai, value);\r\n            this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));\r\n          }\r\n        }\r\n      }\r\n\r\n      this._oldPads[i] = this._clonePad(gamepads[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist\r\n   */\r\n  public at(index: number): Gamepad {\r\n    this._enableAndUpdate(); // implicitly enable gamepads when at() is called\r\n    if (index >= this._pads.length) {\r\n      // Ensure there is a pad to retrieve\r\n      for (let i = this._pads.length - 1, max = index; i < max; i++) {\r\n        this._pads.push(new Gamepad());\r\n        this._oldPads.push(new Gamepad());\r\n      }\r\n    }\r\n\r\n    return this._pads[index];\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n   */\r\n  public getValidGamepads(): Gamepad[] {\r\n    this._enableAndUpdate();\r\n    const result: Gamepad[] = [];\r\n    for (let i = 0; i < this._pads.length; i++) {\r\n      if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {\r\n        result.push(this.at(i));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of connected gamepads\r\n   */\r\n  public count() {\r\n    return this._pads.filter((p) => p.connected).length;\r\n  }\r\n\r\n  private _clonePads(pads: NavigatorGamepad[]): Gamepad[] {\r\n    const arr = [];\r\n    for (let i = 0, len = pads.length; i < len; i++) {\r\n      arr.push(this._clonePad(pads[i]));\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Fastest way to clone a known object is to do it yourself\r\n   */\r\n  private _clonePad(pad: NavigatorGamepad): Gamepad {\r\n    let i, len;\r\n    const clonedPad = new Gamepad();\r\n\r\n    if (!pad) {\r\n      return clonedPad;\r\n    }\r\n\r\n    for (i = 0, len = pad.buttons.length; i < len; i++) {\r\n      if (pad.buttons[i]) {\r\n        clonedPad.updateButton(i, pad.buttons[i].value);\r\n      }\r\n    }\r\n    for (i = 0, len = pad.axes.length; i < len; i++) {\r\n      clonedPad.updateAxes(i, pad.axes[i]);\r\n    }\r\n\r\n    return clonedPad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n * for more information on handling controller input.\r\n */\r\nexport class Gamepad extends Class {\r\n  public connected = false;\r\n  public navigatorGamepad: NavigatorGamepad;\r\n  private _buttons: number[] = new Array(16);\r\n  private _axes: number[] = new Array(4);\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    for (let i = 0; i < this._buttons.length; i++) {\r\n      this._buttons[i] = 0;\r\n    }\r\n    for (let i = 0; i < this._axes.length; i++) {\r\n      this._axes[i] = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given button is pressed\r\n   * @param button     The button to query\r\n   * @param threshold  The threshold over which the button is considered to be pressed\r\n   */\r\n  public isButtonPressed(button: Buttons, threshold: number = 1) {\r\n    return this._buttons[button] >= threshold;\r\n  }\r\n\r\n  /**\r\n   * Gets the given button value between 0 and 1\r\n   */\r\n  public getButton(button: Buttons) {\r\n    return this._buttons[button];\r\n  }\r\n\r\n  /**\r\n   * Gets the given axis value between -1 and 1. Values below\r\n   * [[MinAxisMoveThreshold]] are considered 0.\r\n   */\r\n  public getAxes(axes: Axes) {\r\n    const value = this._axes[axes];\r\n\r\n    if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {\r\n      return 0;\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  public updateButton(buttonIndex: number, value: number) {\r\n    this._buttons[buttonIndex] = value;\r\n  }\r\n\r\n  public updateAxes(axesIndex: number, value: number) {\r\n    this._axes[axesIndex] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad Buttons enumeration\r\n */\r\nexport enum Buttons {\r\n  /**\r\n   * Face 1 button (e.g. A)\r\n   */\r\n  Face1 = 0,\r\n  /**\r\n   * Face 2 button (e.g. B)\r\n   */\r\n  Face2 = 1,\r\n  /**\r\n   * Face 3 button (e.g. X)\r\n   */\r\n  Face3 = 2,\r\n  /**\r\n   * Face 4 button (e.g. Y)\r\n   */\r\n  Face4 = 3,\r\n  /**\r\n   * Left bumper button\r\n   */\r\n  LeftBumper = 4,\r\n  /**\r\n   * Right bumper button\r\n   */\r\n  RightBumper = 5,\r\n  /**\r\n   * Left trigger button\r\n   */\r\n  LeftTrigger = 6,\r\n  /**\r\n   * Right trigger button\r\n   */\r\n  RightTrigger = 7,\r\n  /**\r\n   * Select button\r\n   */\r\n  Select = 8,\r\n  /**\r\n   * Start button\r\n   */\r\n  Start = 9,\r\n  /**\r\n   * Left analog stick press (e.g. L3)\r\n   */\r\n  LeftStick = 10,\r\n  /**\r\n   * Right analog stick press (e.g. R3)\r\n   */\r\n  RightStick = 11,\r\n  /**\r\n   * D-pad up\r\n   */\r\n  DpadUp = 12,\r\n  /**\r\n   * D-pad down\r\n   */\r\n  DpadDown = 13,\r\n  /**\r\n   * D-pad left\r\n   */\r\n  DpadLeft = 14,\r\n  /**\r\n   * D-pad right\r\n   */\r\n  DpadRight = 15\r\n}\r\n\r\n/**\r\n * Gamepad Axes enumeration\r\n */\r\nexport enum Axes {\r\n  /**\r\n   * Left analogue stick X direction\r\n   */\r\n  LeftStickX = 0,\r\n  /**\r\n   * Left analogue stick Y direction\r\n   */\r\n  LeftStickY = 1,\r\n  /**\r\n   * Right analogue stick X direction\r\n   */\r\n  RightStickX = 2,\r\n  /**\r\n   * Right analogue stick Y direction\r\n   */\r\n  RightStickY = 3\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepads {\r\n  getGamepads(): NavigatorGamepad[];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepad {\r\n  axes: number[];\r\n  buttons: NavigatorGamepadButton[];\r\n  connected: boolean;\r\n  id: string;\r\n  index: number;\r\n  mapping: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadButton {\r\n  pressed: boolean;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadEvent {\r\n  gamepad: NavigatorGamepad;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface GamepadConfiguration {\r\n  axis: number;\r\n  buttons: number;\r\n}\r\n","export interface NativeEventable {\r\n  addEventListener(name: string, handler: (...any: any[]) => any): any;\r\n  removeEventListener(name: string, handler: (...any: any[]) => any): any;\r\n}\r\n\r\nexport class BrowserComponent<T extends NativeEventable> {\r\n  private _paused = false;\r\n  private _nativeHandlers: { [key: string]: (handler: any) => void } = {};\r\n\r\n  on(eventName: string, handler: (evt: any) => void): void {\r\n    if (this._nativeHandlers[eventName]) {\r\n      this.off(eventName, this._nativeHandlers[eventName]);\r\n    }\r\n    this._nativeHandlers[eventName] = this._decorate(handler);\r\n    this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);\r\n  }\r\n  off(eventName: string, handler?: (event: any) => void): void {\r\n    if (!handler) {\r\n      handler = this._nativeHandlers[eventName];\r\n    }\r\n    this.nativeComponent.removeEventListener(eventName, handler);\r\n    this._nativeHandlers[eventName] = null;\r\n  }\r\n\r\n  private _decorate(handler: (evt: any) => void): (evt: any) => void {\r\n    return (evt: any) => {\r\n      if (!this._paused) {\r\n        handler(evt);\r\n      }\r\n    };\r\n  }\r\n\r\n  public pause() {\r\n    this._paused = true;\r\n  }\r\n\r\n  public resume() {\r\n    this._paused = false;\r\n  }\r\n\r\n  public clear() {\r\n    for (const event in this._nativeHandlers) {\r\n      this.off(event);\r\n    }\r\n  }\r\n\r\n  constructor(public nativeComponent: T) {}\r\n}\r\n\r\nexport class BrowserEvents {\r\n  private _windowComponent: BrowserComponent<Window>;\r\n  private _documentComponent: BrowserComponent<Document>;\r\n  constructor(private _windowGlobal: Window, private _documentGlobal: Document) {\r\n    this._windowComponent = new BrowserComponent(this._windowGlobal);\r\n    this._documentComponent = new BrowserComponent(this._documentGlobal);\r\n  }\r\n\r\n  public get window(): BrowserComponent<Window> {\r\n    return this._windowComponent;\r\n  }\r\n\r\n  public get document(): BrowserComponent<Document> {\r\n    return this._documentComponent;\r\n  }\r\n\r\n  public pause() {\r\n    this.window.pause();\r\n    this.document.pause();\r\n  }\r\n\r\n  public resume() {\r\n    this.window.resume();\r\n    this.document.resume();\r\n  }\r\n\r\n  public clear() {\r\n    this.window.clear();\r\n    this.document.clear();\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Vector } from './vector';\r\n\r\nexport class GlobalCoordinates {\r\n  public static fromPagePosition(x: number, y: number, engine: Engine): GlobalCoordinates;\r\n  public static fromPagePosition(pos: Vector, engine: Engine): GlobalCoordinates;\r\n  public static fromPagePosition(xOrPos: number | Vector, yOrEngine: number | Engine, engineOrUndefined?: Engine): GlobalCoordinates {\r\n    let pageX: number;\r\n    let pageY: number;\r\n    let pagePos: Vector;\r\n    let engine: Engine;\r\n\r\n    if (arguments.length === 3) {\r\n      pageX = <number>xOrPos;\r\n      pageY = <number>yOrEngine;\r\n      pagePos = new Vector(pageX, pageY);\r\n      engine = engineOrUndefined;\r\n    } else {\r\n      pagePos = <Vector>xOrPos;\r\n      pageX = pagePos.x;\r\n      pageY = pagePos.y;\r\n      engine = <Engine>yOrEngine;\r\n    }\r\n\r\n    const screenPos = engine.screen.pageToScreenCoordinates(pagePos);\r\n    const worldPos = engine.screen.screenToWorldCoordinates(screenPos);\r\n\r\n    return new GlobalCoordinates(worldPos, pagePos, screenPos);\r\n  }\r\n\r\n  constructor(public worldPos: Vector, public pagePos: Vector, public screenPos: Vector) {}\r\n}\r\n","import { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { Vector } from '../Math/vector';\r\nimport { PointerButton } from './PointerButton';\r\nimport { PointerType } from './PointerType';\r\n\r\nexport class PointerEvent {\r\n  public active = true;\r\n  public cancel() {\r\n    this.active = false;\r\n  }\r\n\r\n  get pagePos(): Vector {\r\n    return this.coordinates.pagePos;\r\n  }\r\n\r\n  get screenPos(): Vector {\r\n    return this.coordinates.screenPos;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    return this.coordinates.worldPos;\r\n  }\r\n\r\n  constructor(\r\n    public type: 'down' | 'up' | 'move' | 'cancel',\r\n    public pointerId: number,\r\n    public button: PointerButton,\r\n    public pointerType: PointerType,\r\n    public coordinates: GlobalCoordinates,\r\n    public nativeEvent: Event) { };\r\n}\r\n","import { WheelDeltaMode } from './WheelDeltaMode';\r\n\r\n\r\nexport class WheelEvent {\r\n  public active = true;\r\n  public cancel() {\r\n    this.active = false;\r\n  }\r\n  constructor(\r\n    public x: number,\r\n    public y: number,\r\n    public pageX: number,\r\n    public pageY: number,\r\n    public screenX: number,\r\n    public screenY: number,\r\n    public index: number,\r\n    public deltaX: number,\r\n    public deltaY: number,\r\n    public deltaZ: number,\r\n    public deltaMode: WheelDeltaMode,\r\n    public ev: Event\r\n  ) { }\r\n}\r\n","import { Class } from '../Class';\r\nimport { Vector } from '../Math/vector';\r\nimport { WheelEvent } from './WheelEvent';\r\nimport { PointerEvent } from './PointerEvent';\r\n\r\nexport class PointerAbstraction extends Class {\r\n\r\n  /**\r\n   * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastPagePos: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastScreenPos: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastWorldPos: Vector = Vector.Zero;\r\n\r\n  constructor() {\r\n    super();\r\n    this.on('move', this._onPointerMove);\r\n    this.on('down', this._onPointerDown);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  private _onPointerMove = (ev: PointerEvent): void => {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  };\r\n\r\n  private _onPointerDown = (ev: PointerEvent): void => {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  };\r\n}\r\n","\r\nexport enum WheelDeltaMode {\r\n  Pixel = 'Pixel',\r\n  Line = 'Line',\r\n  Page = 'Page'\r\n}\r\n","/**\r\n * Native browser button enumeration\r\n */\r\nexport enum NativePointerButton {\r\n  NoButton = -1,\r\n  Left = 0,\r\n  Middle = 1,\r\n  Right = 2,\r\n  Unknown = 3\r\n}\r\n","/**\r\n * The mouse button being pressed.\r\n */\r\nexport enum PointerButton {\r\n  Left = 'Left',\r\n  Middle = 'Middle',\r\n  Right = 'Right',\r\n  Unknown = 'Unknown',\r\n  NoButton = 'NoButton'\r\n}\r\n","/**\r\n * The type of pointer for a [[PointerEvent]].\r\n */\r\nexport enum PointerType {\r\n  Touch = 'Touch',\r\n  Mouse = 'Mouse',\r\n  Pen = 'Pen',\r\n  Unknown = 'Unknown'\r\n}\r\n","import { Class } from '../Class';\r\nimport { Engine, ScrollPreventionMode } from '../Engine';\r\nimport { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { PointerEvent } from './PointerEvent';\r\nimport { WheelEvent } from './WheelEvent';\r\nimport { PointerAbstraction } from './PointerAbstraction';\r\n\r\nimport { WheelDeltaMode } from './WheelDeltaMode';\r\nimport { PointerSystem } from './PointerSystem';\r\nimport { NativePointerButton } from './NativePointerButton';\r\nimport { PointerButton } from './PointerButton';\r\nimport { fail } from '../Util/Util';\r\nimport { PointerType } from './PointerType';\r\n\r\n\r\nexport type NativePointerEvent = globalThis.PointerEvent;\r\nexport type NativeMouseEvent = globalThis.MouseEvent;\r\nexport type NativeTouchEvent = globalThis.TouchEvent;\r\nexport type NativeWheelEvent = globalThis.WheelEvent;\r\n\r\n/**\r\n * Is this event a native touch event?\r\n */\r\nfunction isTouchEvent(value: any): value is NativeTouchEvent {\r\n  // Guard for Safari <= 13.1\r\n  return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;\r\n}\r\n\r\n/**\r\n * Is this event a native pointer event\r\n */\r\nfunction isPointerEvent(value: any): value is NativePointerEvent {\r\n  // Guard for Safari <= 13.1\r\n  return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;\r\n}\r\n\r\n/**\r\n * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates\r\n */\r\nexport class PointerEventReceiver extends Class {\r\n  public primary: PointerAbstraction = new PointerAbstraction();\r\n\r\n  private _activeNativePointerIdsToNormalized = new Map<number, number>();\r\n  public lastFramePointerCoords = new Map<number, GlobalCoordinates>();\r\n  public currentFramePointerCoords = new Map<number, GlobalCoordinates>();\r\n\r\n  public currentFramePointerDown = new Map<number, boolean>();\r\n  public lastFramePointerDown = new Map<number, boolean>();\r\n\r\n  public currentFrameDown: PointerEvent[] = [];\r\n  public currentFrameUp: PointerEvent[] = [];\r\n  public currentFrameMove: PointerEvent[] = [];\r\n  public currentFrameCancel: PointerEvent[] = [];\r\n  public currentFrameWheel: WheelEvent[] = [];\r\n\r\n  constructor(public readonly target: GlobalEventHandlers & EventTarget, public engine: Engine) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event\r\n   * handlers.\r\n   * @param target\r\n   * @param engine\r\n   */\r\n  public recreate(target: GlobalEventHandlers & EventTarget, engine: Engine) {\r\n    const eventReceiver = new PointerEventReceiver(target, engine);\r\n    eventReceiver.primary = this.primary;\r\n    eventReceiver._pointers = this._pointers;\r\n    return eventReceiver;\r\n  }\r\n\r\n  private _pointers: PointerAbstraction[] = [this.primary];\r\n  /**\r\n   * Locates a specific pointer by id, creates it if it doesn't exist\r\n   * @param index\r\n   */\r\n  public at(index: number): PointerAbstraction {\r\n    if (index >= this._pointers.length) {\r\n      // Ensure there is a pointer to retrieve\r\n      for (let i = this._pointers.length - 1, max = index; i < max; i++) {\r\n        this._pointers.push(new PointerAbstraction());\r\n      }\r\n    }\r\n    return this._pointers[index];\r\n  }\r\n\r\n  /**\r\n   * The number of pointers currently being tracked by excalibur\r\n   */\r\n  public count(): number {\r\n    return this._pointers.length;\r\n  }\r\n\r\n  /**\r\n   * Is the specified pointer id down this frame\r\n   * @param pointerId\r\n   */\r\n  public isDown(pointerId: number) {\r\n    return this.currentFramePointerDown.get(pointerId) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Was the specified pointer id down last frame\r\n   * @param pointerId\r\n   */\r\n  public wasDown(pointerId: number) {\r\n    return this.lastFramePointerDown.get(pointerId) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer is currently dragging.\r\n   */\r\n  public isDragging(pointerId: number): boolean {\r\n    return this.isDown(pointerId);\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just started dragging.\r\n   */\r\n  public isDragStart(pointerId: number): boolean {\r\n    return this.isDown(pointerId) && !this.wasDown(pointerId);\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just ended dragging.\r\n   */\r\n  public isDragEnd(pointerId: number): boolean {\r\n    return !this.isDown(pointerId) && this.wasDown(pointerId);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  /**\r\n   * Called internally by excalibur\r\n   *\r\n   * Updates the current frame pointer info and emits raw pointer events\r\n   *\r\n   * This does not emit events to entities, see PointerSystem\r\n   */\r\n  public update() {\r\n    this.lastFramePointerDown = new Map(this.currentFramePointerDown);\r\n    this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);\r\n\r\n    for (const event of this.currentFrameDown) {\r\n      this.emit('down', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('down', event);\r\n      this.primary.emit('pointerdown', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameUp) {\r\n      this.emit('up', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('up', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameMove) {\r\n      this.emit('move', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('move', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameCancel) {\r\n      this.emit('cancel', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('cancel', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameWheel) {\r\n      this.emit('wheel', event);\r\n      this.primary.emit('pointerwheel', event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the current frame event and pointer data\r\n   */\r\n  public clear() {\r\n    for (const event of this.currentFrameUp) {\r\n      this.currentFramePointerCoords.delete(event.pointerId);\r\n      const ids = this._activeNativePointerIdsToNormalized.entries();\r\n      for (const [native, normalized] of ids) {\r\n        if (normalized === event.pointerId) {\r\n          this._activeNativePointerIdsToNormalized.delete(native);\r\n        }\r\n      }\r\n    }\r\n    this.currentFrameDown.length = 0;\r\n    this.currentFrameUp.length = 0;\r\n    this.currentFrameMove.length = 0;\r\n    this.currentFrameCancel.length = 0;\r\n    this.currentFrameWheel.length = 0;\r\n  }\r\n\r\n  private _boundHandle = this._handle.bind(this);\r\n  private _boundWheel = this._handleWheel.bind(this);\r\n  /**\r\n   * Initializes the pointer event receiver so that it can start listening to native\r\n   * browser events.\r\n   */\r\n  public init() {\r\n    // Disabling the touch action avoids browser/platform gestures from firing on the canvas\r\n    // It is important on mobile to have touch action 'none'\r\n    // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not\r\n    if (this.target === this.engine.canvas) {\r\n      this.engine.canvas.style.touchAction = 'none';\r\n    } else {\r\n      document.body.style.touchAction = 'none';\r\n    }\r\n    // Preferred pointer events\r\n    if (window.PointerEvent) {\r\n      this.target.addEventListener('pointerdown', this._boundHandle);\r\n      this.target.addEventListener('pointerup', this._boundHandle);\r\n      this.target.addEventListener('pointermove', this._boundHandle);\r\n      this.target.addEventListener('pointercancel', this._boundHandle);\r\n    } else {\r\n      // Touch Events\r\n      this.target.addEventListener('touchstart', this._boundHandle);\r\n      this.target.addEventListener('touchend', this._boundHandle);\r\n      this.target.addEventListener('touchmove', this._boundHandle);\r\n      this.target.addEventListener('touchcancel', this._boundHandle);\r\n\r\n      // Mouse Events\r\n      this.target.addEventListener('mousedown', this._boundHandle);\r\n      this.target.addEventListener('mouseup', this._boundHandle);\r\n      this.target.addEventListener('mousemove', this._boundHandle);\r\n    }\r\n\r\n    // MDN MouseWheelEvent\r\n    const wheelOptions = {\r\n      passive: !(\r\n        this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n        this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas\r\n      )\r\n    };\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      this.target.addEventListener('wheel', this._boundWheel, wheelOptions);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);\r\n    }\r\n  }\r\n\r\n  public detach() {\r\n    // Preferred pointer events\r\n    if (window.PointerEvent) {\r\n      this.target.removeEventListener('pointerdown', this._boundHandle);\r\n      this.target.removeEventListener('pointerup', this._boundHandle);\r\n      this.target.removeEventListener('pointermove', this._boundHandle);\r\n      this.target.removeEventListener('pointercancel', this._boundHandle);\r\n    } else {\r\n      // Touch Events\r\n      this.target.removeEventListener('touchstart', this._boundHandle);\r\n      this.target.removeEventListener('touchend', this._boundHandle);\r\n      this.target.removeEventListener('touchmove', this._boundHandle);\r\n      this.target.removeEventListener('touchcancel', this._boundHandle);\r\n\r\n      // Mouse Events\r\n      this.target.removeEventListener('mousedown', this._boundHandle);\r\n      this.target.removeEventListener('mouseup', this._boundHandle);\r\n      this.target.removeEventListener('mousemove', this._boundHandle);\r\n    }\r\n\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      this.target.removeEventListener('wheel', this._boundWheel);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      this.target.addEventListener('mousewheel', this._boundWheel);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      this.target.addEventListener('MozMousePixelScroll', this._boundWheel);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Take native pointer id and map it to index in active pointers\r\n   * @param nativePointerId\r\n   */\r\n  private _normalizePointerId(nativePointerId: number) {\r\n    // Add to the the native pointer set id\r\n    this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);\r\n\r\n    // Native pointer ids in ascending order\r\n    const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);\r\n\r\n    // The index into sorted ids will be the new id, will always have an id\r\n    const id = currentPointerIds.findIndex(p => p === nativePointerId);\r\n\r\n    // Save the mapping so we can reverse it later\r\n    this._activeNativePointerIdsToNormalized.set(nativePointerId, id);\r\n\r\n    // ignore pointer because game isn't watching\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Responsible for handling and parsing pointer events\r\n   */\r\n  private _handle(ev: NativeTouchEvent | NativePointerEvent | NativeMouseEvent) {\r\n    ev.preventDefault();\r\n    const eventCoords = new Map<number, GlobalCoordinates>();\r\n    let button: PointerButton;\r\n    let pointerType: PointerType;\r\n    if (isTouchEvent(ev)) {\r\n      button = PointerButton.Unknown;\r\n      pointerType = PointerType.Touch;\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\r\n      for (let i = 0; i < ev.changedTouches.length; i++) {\r\n        const touch = ev.changedTouches[i];\r\n        const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);\r\n        const nativePointerId = i + 1;\r\n        const pointerId = this._normalizePointerId(nativePointerId);\r\n        this.currentFramePointerCoords.set(pointerId, coordinates);\r\n        eventCoords.set(pointerId, coordinates);\r\n      }\r\n    } else {\r\n      button = this._nativeButtonToPointerButton(ev.button);\r\n      pointerType = PointerType.Mouse;\r\n      const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);\r\n      let nativePointerId = 1;\r\n      if (isPointerEvent(ev)) {\r\n        nativePointerId = ev.pointerId;\r\n        pointerType = this._stringToPointerType(ev.pointerType);\r\n      }\r\n      const pointerId = this._normalizePointerId(nativePointerId);\r\n      this.currentFramePointerCoords.set(pointerId, coordinates);\r\n      eventCoords.set(pointerId, coordinates);\r\n    }\r\n\r\n    for (const [pointerId, coord] of eventCoords.entries()) {\r\n      switch (ev.type) {\r\n        case 'mousedown':\r\n        case 'pointerdown':\r\n        case 'touchstart':\r\n          this.currentFrameDown.push(new PointerEvent('down', pointerId, button, pointerType, coord, ev));\r\n          this.currentFramePointerDown.set(pointerId, true);\r\n          break;\r\n        case 'mouseup':\r\n        case 'pointerup':\r\n        case 'touchend':\r\n          this.currentFrameUp.push(new PointerEvent('up', pointerId, button, pointerType, coord, ev));\r\n          this.currentFramePointerDown.set(pointerId, false);\r\n          break;\r\n        case 'mousemove':\r\n        case 'pointermove':\r\n        case 'touchmove':\r\n          this.currentFrameMove.push(new PointerEvent('move', pointerId, button, pointerType, coord, ev));\r\n          break;\r\n        case 'touchcancel':\r\n        case 'pointercancel':\r\n          this.currentFrameCancel.push(new PointerEvent('cancel', pointerId, button, pointerType, coord, ev));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _handleWheel(ev: NativeWheelEvent) {\r\n    // Should we prevent page scroll because of this event\r\n    if (\r\n      this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n      (this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)\r\n    ) {\r\n      ev.preventDefault();\r\n    }\r\n    const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));\r\n    const world = this.engine.screen.screenToWorldCoordinates(screen);\r\n\r\n    /**\r\n     * A constant used to normalize wheel events across different browsers\r\n     *\r\n     * This normalization factor is pulled from\r\n     * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n     */\r\n    const ScrollWheelNormalizationFactor = -1 / 40;\r\n\r\n    const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;\r\n    const deltaY =\r\n        ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;\r\n    const deltaZ = ev.deltaZ || 0;\r\n    let deltaMode = WheelDeltaMode.Pixel;\r\n\r\n    if (ev.deltaMode) {\r\n      if (ev.deltaMode === 1) {\r\n        deltaMode = WheelDeltaMode.Line;\r\n      } else if (ev.deltaMode === 2) {\r\n        deltaMode = WheelDeltaMode.Page;\r\n      }\r\n    }\r\n\r\n    const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);\r\n    this.currentFrameWheel.push(we);\r\n  }\r\n\r\n  /**\r\n   * Triggers an excalibur pointer event in a world space pos\r\n   *\r\n   * Useful for testing pointers in excalibur\r\n   * @param type\r\n   * @param pos\r\n   */\r\n  public triggerEvent(type: 'down' | 'up' | 'move' | 'cancel', pos: Vector) {\r\n    const page = this.engine.screen.worldToPageCoordinates(pos);\r\n    // Send an event to the event receiver\r\n    if (window.PointerEvent) {\r\n      this._handle(new window.PointerEvent('pointer' + type, {\r\n        pointerId: 0,\r\n        clientX: page.x,\r\n        clientY: page.y\r\n      }));\r\n    } else {\r\n      // Safari hack\r\n      this._handle(new window.MouseEvent('mouse' + type, {\r\n        clientX: page.x,\r\n        clientY: page.y\r\n      }));\r\n    }\r\n\r\n    // Force update pointer system\r\n    const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);\r\n    const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);\r\n    pointerSystem.preupdate();\r\n    pointerSystem.update(transformEntities.getEntities());\r\n  }\r\n\r\n  private _nativeButtonToPointerButton(s: NativePointerButton): PointerButton {\r\n    switch (s) {\r\n      case NativePointerButton.NoButton:\r\n        return PointerButton.NoButton;\r\n      case NativePointerButton.Left:\r\n        return PointerButton.Left;\r\n      case NativePointerButton.Middle:\r\n        return PointerButton.Middle;\r\n      case NativePointerButton.Right:\r\n        return PointerButton.Right;\r\n      case NativePointerButton.Unknown:\r\n        return PointerButton.Unknown;\r\n      default:\r\n        return fail(s);\r\n    }\r\n  }\r\n\r\n  private _stringToPointerType(s: string) {\r\n    switch (s) {\r\n      case 'touch':\r\n        return PointerType.Touch;\r\n      case 'mouse':\r\n        return PointerType.Mouse;\r\n      case 'pen':\r\n        return PointerType.Pen;\r\n      default:\r\n        return PointerType.Unknown;\r\n    }\r\n  }\r\n}","export interface FpsSamplerOptions {\r\n  /**\r\n   * Specify the sampling period in milliseconds (default 100)\r\n   */\r\n  samplePeriod?: number;\r\n  /**\r\n   * Specify the initial FPS\r\n   */\r\n  initialFps: number;\r\n\r\n  /**\r\n   * Specify the function used to return the current time (in milliseconds)\r\n   */\r\n  nowFn: () => number;\r\n}\r\n\r\nexport class FpsSampler {\r\n  private _fps: number;\r\n  private _samplePeriod: number = 100;\r\n  private _currentFrameTime: number = 0;\r\n  private _frames: number = 0;\r\n  private _previousSampleTime: number = 0;\r\n  private _beginFrameTime: number = 0;\r\n  private _nowFn: () => number;\r\n\r\n  constructor(options: FpsSamplerOptions) {\r\n    this._fps = options.initialFps;\r\n    this._samplePeriod = options.samplePeriod ?? this._samplePeriod;\r\n    this._currentFrameTime = 1000/options.initialFps;\r\n    this._nowFn = options.nowFn;\r\n    this._previousSampleTime = this._nowFn();\r\n  }\r\n\r\n  /**\r\n   * Start of code block to sample FPS for\r\n   */\r\n  start() {\r\n    this._beginFrameTime = this._nowFn();\r\n  }\r\n\r\n  /**\r\n   * End of code block to sample FPS for\r\n   */\r\n  end() {\r\n    this._frames++;\r\n    const time = this._nowFn();\r\n\r\n    this._currentFrameTime = time - this._beginFrameTime;\r\n\r\n    if (time >= this._previousSampleTime + this._samplePeriod) {\r\n      this._fps = (this._frames * 1000) / (time - this._previousSampleTime);\r\n      this._previousSampleTime = time;\r\n      this._frames = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the currently sampled fps over the last sample period, by default every 100ms\r\n   */\r\n  get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time\r\n   */\r\n  get instant() {\r\n    return 1000 / this._currentFrameTime;\r\n  }\r\n}","import { Logger } from '..';\r\nimport { FpsSampler } from './Fps';\r\n\r\nexport interface ClockOptions {\r\n  /**\r\n   * Define the function you'd like the clock to tick when it is started\r\n   */\r\n  tick: (elapsedMs: number) => any;\r\n  /**\r\n   * Optionally define the fatal exception handler, used if an error is thrown in tick\r\n   */\r\n  onFatalException?: (e: unknown) => any;\r\n  /**\r\n   * Optionally limit the maximum FPS of the clock\r\n   */\r\n  maxFps?: number;\r\n}\r\n\r\n\r\n/**\r\n * Abstract Clock is the base type of all Clocks\r\n *\r\n * It has a few opinions\r\n * 1. It manages the calculation of what \"elapsed\" time means and thus maximum fps\r\n * 2. The default timing api is implemented in now()\r\n *\r\n * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever\r\n * method is unique to your clock implementation.\r\n */\r\nexport abstract class Clock {\r\n  protected tick: (elapsedMs: number) => any;\r\n  private _onFatalException: (e: unknown) => any = () => { /* default nothing */ };\r\n  private _maxFps: number = Infinity;\r\n  private _lastTime: number = 0;\r\n  public fpsSampler: FpsSampler;\r\n  private _options: ClockOptions;\r\n  private _elapsed: number = 1;\r\n  private _scheduledCbs: [cb: () => any, scheduledTime: number][] = [];\r\n  private _totalElapsed: number = 0;\r\n  constructor(options: ClockOptions) {\r\n    this._options = options;\r\n    this.tick = options.tick;\r\n    this._lastTime = this.now() ?? 0;\r\n    this._maxFps = options.maxFps ?? this._maxFps;\r\n    this._onFatalException = options.onFatalException ?? this._onFatalException;\r\n    this.fpsSampler = new FpsSampler({\r\n      initialFps: 60,\r\n      nowFn: () => this.now()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the elapsed time for the last completed frame\r\n   */\r\n  public elapsed(): number {\r\n    return this._elapsed;\r\n  }\r\n\r\n  /**\r\n   * Get the current time in milliseconds\r\n   */\r\n  public now(): number {\r\n    return performance.now();\r\n  }\r\n\r\n  public toTestClock() {\r\n    const testClock = new TestClock({\r\n      ...this._options,\r\n      defaultUpdateMs: 16.6\r\n    });\r\n    return testClock;\r\n  }\r\n\r\n  public toStandardClock() {\r\n    const clock = new StandardClock({\r\n      ...this._options\r\n    });\r\n    return clock;\r\n  }\r\n\r\n  public setFatalExceptionHandler(handler: (e: unknown) => any) {\r\n    this._onFatalException = handler;\r\n  }\r\n\r\n  /**\r\n   * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]\r\n   *\r\n   * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the\r\n   * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is\r\n   * stopped or paused.\r\n   *\r\n   * @param cb callback to fire\r\n   * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick\r\n   */\r\n  public schedule(cb: () => any, timeoutMs: number = 0) {\r\n    // Scheduled based on internal elapsed time\r\n    const scheduledTime = this._totalElapsed + timeoutMs;\r\n    this._scheduledCbs.push([cb, scheduledTime]);\r\n  }\r\n\r\n  private _runScheduledCbs() {\r\n    // walk backwards to delete items as we loop\r\n    for (let i = this._scheduledCbs.length - 1; i > -1; i--) {\r\n      if (this._scheduledCbs[i][1] <= this._totalElapsed) {\r\n        this._scheduledCbs[i][0]();\r\n        this._scheduledCbs.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected update(overrideUpdateMs?: number): void {\r\n    try {\r\n      this.fpsSampler.start();\r\n      // Get the time to calculate time-elapsed\r\n      const now = this.now();\r\n      let elapsed = now - this._lastTime || 1; // first frame\r\n\r\n      // Constrain fps\r\n      const fpsInterval = (1000 / this._maxFps);\r\n\r\n      // only run frame if enough time has elapsed\r\n      if (elapsed >= fpsInterval) {\r\n        let leftover = 0;\r\n        if (fpsInterval !== 0) {\r\n          leftover = (elapsed % fpsInterval);\r\n          elapsed = elapsed - leftover; // shift elapsed to be \"in phase\" with the current loop fps\r\n        }\r\n\r\n        // Resolves issue #138 if the game has been paused, or blurred for\r\n        // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability\r\n        // and provides more expected behavior when the engine comes back\r\n        // into focus\r\n        if (elapsed > 200) {\r\n          elapsed = 1;\r\n        }\r\n\r\n        // tick the mainloop and run scheduled callbacks\r\n        this._elapsed = overrideUpdateMs || elapsed;\r\n        this._totalElapsed += this._elapsed;\r\n        this._runScheduledCbs();\r\n        this.tick(overrideUpdateMs || elapsed);\r\n\r\n        if (fpsInterval !== 0) {\r\n          this._lastTime = now - leftover;\r\n        } else {\r\n          this._lastTime = now;\r\n        }\r\n        this.fpsSampler.end();\r\n      }\r\n    } catch (e) {\r\n      this._onFatalException(e);\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns if the clock is currently running\r\n   */\r\n  public abstract isRunning(): boolean;\r\n\r\n  /**\r\n   * Start the clock, it will then periodically call the tick(elapsedMilliseconds) since the last tick\r\n   */\r\n  public abstract start(): void;\r\n\r\n  /**\r\n   * Stop the clock, tick() is no longer called\r\n   */\r\n  public abstract stop(): void;\r\n}\r\n\r\n\r\n/**\r\n * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()\r\n */\r\nexport class StandardClock extends Clock {\r\n\r\n  private _running = false;\r\n  private _requestId: number;\r\n  constructor(options: ClockOptions) {\r\n    super(options);\r\n  }\r\n\r\n  public isRunning(): boolean {\r\n    return this._running;\r\n  }\r\n\r\n  public start(): void {\r\n    if (this._running) {\r\n      return;\r\n    }\r\n    this._running = true;\r\n    const mainloop = () => {\r\n      // stop the loop\r\n      if (!this._running) {\r\n        return;\r\n      }\r\n      try {\r\n        // request next loop\r\n        this._requestId = window.requestAnimationFrame(mainloop);\r\n        this.update();\r\n      } catch (e) {\r\n        window.cancelAnimationFrame(this._requestId);\r\n        throw e;\r\n      }\r\n    };\r\n\r\n    // begin the first frame\r\n    mainloop();\r\n  }\r\n\r\n  public stop(): void {\r\n    this._running = false;\r\n  }\r\n}\r\n\r\nexport interface TestClockOptions {\r\n  /**\r\n   * Specify the update milliseconds to use for each manual step()\r\n   */\r\n  defaultUpdateMs: number;\r\n}\r\n\r\n/**\r\n * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test\r\n */\r\nexport class TestClock extends Clock {\r\n  private _logger = Logger.getInstance();\r\n  private _updateMs: number;\r\n  private _running: boolean = false;\r\n  private _currentTime = 0;\r\n  constructor(options: ClockOptions & TestClockOptions) {\r\n    super({\r\n      ...options\r\n    });\r\n    this._updateMs = options.defaultUpdateMs;\r\n  }\r\n\r\n  /**\r\n   * Get the current time in milliseconds\r\n   */\r\n  public override now() {\r\n    return this._currentTime ?? 0;\r\n  }\r\n\r\n  public isRunning(): boolean {\r\n    return this._running;\r\n  }\r\n  public start(): void {\r\n    this._running = true;\r\n  }\r\n  public stop(): void {\r\n    this._running = false;\r\n  }\r\n\r\n  /**\r\n   * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds\r\n   * @param overrideUpdateMs\r\n   */\r\n  step(overrideUpdateMs?: number): void {\r\n    const time = overrideUpdateMs ?? this._updateMs;\r\n\r\n    if (this._running) {\r\n      // to be comparable to RAF this needs to be a full blown Task\r\n      // For example, images cannot decode synchronously in a single step\r\n      this.update(time);\r\n      this._currentTime += time;\r\n    } else {\r\n      this._logger.warn('The clock is not running, no step will be performed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds\r\n   * @param numberOfSteps\r\n   * @param overrideUpdateMs\r\n   */\r\n  run(numberOfSteps: number, overrideUpdateMs?: number): void {\r\n    for (let i = 0; i < numberOfSteps; i++) {\r\n      this.step(overrideUpdateMs ?? this._updateMs);\r\n    }\r\n  }\r\n}","import toasterCss from './Toaster.css';\r\n\r\n/**\r\n * The Toaster is only meant to be called from inside Excalibur to display messages to players\r\n */\r\nexport class Toaster {\r\n  private _styleBlock: HTMLStyleElement;\r\n  private _container: HTMLDivElement;\r\n  private _toasterCss: string = toasterCss.toString();\r\n\r\n  private _isInitialized = false;\r\n  private _initialize() {\r\n    if (!this._isInitialized) {\r\n      this._container = document.createElement('div');\r\n      this._container.id = 'ex-toast-container';\r\n      document.body.appendChild(this._container);\r\n      this._isInitialized = true;\r\n\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._toasterCss;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n  }\r\n\r\n  public dispose() {\r\n    this._container.parentElement.removeChild(this._container);\r\n\r\n    this._styleBlock.parentElement.removeChild(this._styleBlock);\r\n\r\n    this._isInitialized = false;\r\n  }\r\n\r\n  private _createFragment(message: string) {\r\n    const toastMessage = document.createElement('span');\r\n    toastMessage.innerText = message;\r\n    return toastMessage;\r\n  }\r\n\r\n  /**\r\n   * Display a toast message to a player\r\n   * @param message Text of the message, messages may have a single \"[LINK]\" to influence placement\r\n   * @param linkTarget Optionally specify a link location\r\n   * @param linkName Optionally specify a name for that link location\r\n   */\r\n  public toast(message: string, linkTarget?: string, linkName?: string) {\r\n    this._initialize();\r\n    const toast = document.createElement('div');\r\n    toast.className = 'ex-toast-message';\r\n\r\n    const messageFragments: HTMLElement[] = message.split('[LINK]').map(message => this._createFragment(message));\r\n\r\n    if (linkTarget) {\r\n      const link = document.createElement('a');\r\n      link.href = linkTarget;\r\n      if (linkName) {\r\n        link.innerText = linkName;\r\n      } else {\r\n        link.innerText = linkTarget;\r\n      }\r\n      messageFragments.splice(1, 0, link);\r\n    }\r\n\r\n    // Assembly message\r\n    const finalMessage = document.createElement('div');\r\n    messageFragments.forEach(message => {\r\n      finalMessage.appendChild(message);\r\n    });\r\n    toast.appendChild(finalMessage);\r\n\r\n    // Dismiss button\r\n    const dismissBtn = document.createElement('button');\r\n    dismissBtn.innerText = 'x';\r\n    dismissBtn.addEventListener('click', () => {\r\n      this._container.removeChild(toast);\r\n    });\r\n    toast.appendChild(dismissBtn);\r\n\r\n    // Escape to dismiss\r\n    const keydownHandler = (evt: KeyboardEvent) => {\r\n      if (evt.key === 'Escape') {\r\n        try {\r\n          this._container.removeChild(toast);\r\n        } catch {\r\n          // pass\r\n        }\r\n      }\r\n      document.removeEventListener('keydown', keydownHandler);\r\n    };\r\n    document.addEventListener('keydown', keydownHandler);\r\n\r\n    // Insert into container\r\n    const first = this._container.firstChild;\r\n    this._container.insertBefore(toast, first);\r\n  }\r\n}","import { EX_VERSION } from './';\r\nimport { Flags } from './Flags';\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\nimport { CanUpdate, CanDraw, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Vector } from './Math/vector';\r\nimport { Screen, DisplayMode, ScreenDimension, Resolution } from './Screen';\r\nimport { ScreenElement } from './ScreenElement';\r\nimport { Actor } from './Actor';\r\nimport { Timer } from './Timer';\r\nimport { TileMap } from './TileMap';\r\nimport { Loader } from './Loader';\r\nimport { Detector } from './Util/Detector';\r\nimport {\r\n  VisibleEvent,\r\n  HiddenEvent,\r\n  GameStartEvent,\r\n  GameStopEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreFrameEvent,\r\n  PostFrameEvent,\r\n  GameEvent,\r\n  DeactivateEvent,\r\n  ActivateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  InitializeEvent\r\n} from './Events';\r\nimport { Logger, LogLevel } from './Util/Log';\r\nimport { Color } from './Color';\r\nimport { Scene } from './Scene';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { Debug, DebugStats } from './Debug/Debug';\r\nimport { Class } from './Class';\r\nimport * as Input from './Input/Index';\r\nimport * as Events from './Events';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { ExcaliburGraphicsContext, ExcaliburGraphicsContext2DCanvas, ExcaliburGraphicsContextWebGL, TextureLoader } from './Graphics';\r\nimport { PointerEventReceiver } from './Input/PointerEventReceiver';\r\nimport { Clock, StandardClock } from './Util/Clock';\r\nimport { ImageFiltering } from './Graphics/Filtering';\r\nimport { GraphicsDiagnostics } from './Graphics/GraphicsDiagnostics';\r\nimport { Toaster } from './Util/Toaster';\r\n\r\n/**\r\n * Enum representing the different mousewheel event bubble prevention\r\n */\r\nexport enum ScrollPreventionMode {\r\n  /**\r\n   * Do not prevent any page scrolling\r\n   */\r\n  None,\r\n  /**\r\n   * Prevent page scroll if mouse is over the game canvas\r\n   */\r\n  Canvas,\r\n  /**\r\n   * Prevent all page scrolling via mouse wheel\r\n   */\r\n  All\r\n}\r\n\r\n/**\r\n * Defines the available options to configure the Excalibur engine at constructor time.\r\n */\r\nexport interface EngineOptions {\r\n  /**\r\n   * Optionally configure the width of the viewport in css pixels\r\n   */\r\n  width?: number;\r\n\r\n  /**\r\n   * Optionally configure the height of the viewport in css pixels\r\n   */\r\n  height?: number;\r\n\r\n  /**\r\n   * Optionally configure the width & height of the viewport in css pixels.\r\n   * Use `viewport` instead of [[EngineOptions.width]] and [[EngineOptions.height]], or vice versa.\r\n   */\r\n  viewport?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify the size the logical pixel resolution, if not specified it will be width x height.\r\n   * See [[Resolution]] for common presets.\r\n   */\r\n  resolution?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify antialiasing (smoothing), by default true (smooth pixels)\r\n   *\r\n   *  * `true` - useful for high resolution art work you would like smoothed, this also hints excalibur to load images\r\n   * with [[ImageFiltering.Blended]]\r\n   *\r\n   *  * `false` - useful for pixel art style art work you would like sharp, this also hints excalibur to load images\r\n   * with [[ImageFiltering.Pixel]]\r\n   */\r\n  antialiasing?: boolean;\r\n\r\n  /**\r\n   * Optionally upscale the number of pixels in the canvas. Normally only useful if you need a smoother look to your assets, especially\r\n   * [[Text]].\r\n   *\r\n   * **WARNING** It is recommended you try using `antialiasing: true` before adjusting pixel ratio. Pixel ratio will consume more memory\r\n   * and on mobile may break if the internal size of the canvas exceeds 4k pixels in width or height.\r\n   *\r\n   * Default is based the display's pixel ratio, for example a HiDPI screen might have the value 2;\r\n   */\r\n  pixelRatio?: number;\r\n\r\n  /**\r\n   * Optionally configure the native canvas transparent backdrop\r\n   */\r\n  enableCanvasTransparency?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element to render the game in\r\n   */\r\n  canvasElementId?: string;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element directly\r\n   */\r\n  canvasElement?: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Optionally snap graphics to nearest pixel, default is false\r\n   */\r\n  snapToPixel?: boolean;\r\n\r\n  /**\r\n   * The [[DisplayMode]] of the game, by default [[DisplayMode.FitScreen]] with aspect ratio 4:3 (800x600).\r\n   * Depending on this value, [[width]] and [[height]] may be ignored.\r\n   */\r\n  displayMode?: DisplayMode;\r\n\r\n  /**\r\n   * Configures the pointer scope. Pointers scoped to the 'Canvas' can only fire events within the canvas viewport; whereas, 'Document'\r\n   * (default) scoped will fire anywhere on the page.\r\n   */\r\n  pointerScope?: Input.PointerScope;\r\n\r\n  /**\r\n   * Suppress boot up console message, which contains the \"powered by Excalibur message\"\r\n   */\r\n  suppressConsoleBootMessage?: boolean;\r\n\r\n  /**\r\n   * Suppress minimum browser feature detection, it is not recommended users of excalibur switch this off. This feature ensures that\r\n   * the currently running browser meets the minimum requirements for running excalibur. This can be useful if running on non-standard\r\n   * browsers or if there is a bug in excalibur preventing execution.\r\n   */\r\n  suppressMinimumBrowserFeatureDetection?: boolean;\r\n\r\n  /**\r\n   * Suppress HiDPI auto detection and scaling, it is not recommended users of excalibur switch off this feature. This feature detects\r\n   * and scales the drawing canvas appropriately to accommodate HiDPI screens.\r\n   */\r\n  suppressHiDPIScaling?: boolean;\r\n\r\n  /**\r\n   * Suppress play button, it is not recommended users of excalibur switch this feature. Some browsers require a user gesture (like a click)\r\n   * for certain browser features to work like web audio.\r\n   */\r\n  suppressPlayButton?: boolean;\r\n\r\n  /**\r\n   * Scroll prevention method.\r\n   */\r\n  scrollPreventionMode?: ScrollPreventionMode;\r\n\r\n  /**\r\n   * Optionally set the background color\r\n   */\r\n  backgroundColor?: Color;\r\n\r\n  /**\r\n   * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n   *\r\n   * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n   * one that bounces between 30fps and 60fps\r\n   */\r\n  maxFps?: number;\r\n\r\n  /**\r\n   * Optionally configure a fixed update fps, this can be desireable if you need the physics simulation to be very stable. When set\r\n   * the update step and physics will use the same elapsed time for each tick even if the graphical framerate drops. In order for the\r\n   * simulation to be correct, excalibur will run multiple updates in a row (at the configured update elapsed) to catch up, for example\r\n   * there could be X updates and 1 draw each clock step.\r\n   *\r\n   * **NOTE:** This does come at a potential perf cost because each catch-up update will need to be run if the fixed rate is greater than\r\n   * the current instantaneous framerate, or perf gain if the fixed rate is less than the current framerate.\r\n   *\r\n   * By default is unset and updates will use the current instantaneous framerate with 1 update and 1 draw each clock step.\r\n   */\r\n  fixedUpdateFps?: number\r\n\r\n  /**\r\n   * Default `true`, optionally configure excalibur to use optimal draw call sorting, to opt out set this to `false`.\r\n   *\r\n   * Excalibur will automatically sort draw calls by z and priority into renderer batches for maximal draw performance,\r\n   * this can disrupt a specific desired painter order.\r\n   */\r\n  useDrawSorting?: boolean;\r\n\r\n  /**\r\n   * Optionally configure how excalibur handles poor performance on a player's browser\r\n   */\r\n  configurePerformanceCanvas2DFallback?: {\r\n    /**\r\n     * By default `true`, this will switch the internal graphics context to Canvas2D which can improve performance on non hardware\r\n     * accelerated browsers.\r\n     */\r\n    allow: boolean;\r\n    /**\r\n     * By default `false`, if set to `true` a dialogue will be presented to the player about their browser and how to potentially\r\n     * address any issues.\r\n     */\r\n    showPlayerMessage?: boolean;\r\n    /**\r\n     * Default `{ numberOfFrames: 100, fps: 20 }`, optionally configure excalibur to fallback to the 2D Canvas renderer\r\n     * if bad performance is detected.\r\n     *\r\n     * In this example of the default if excalibur is running at 20fps or less for 100 frames it will trigger the fallback to the 2D\r\n     * Canvas renderer.\r\n     */\r\n    threshold?: { numberOfFrames: number, fps: number };\r\n  }\r\n}\r\n\r\n/**\r\n * The Excalibur Engine\r\n *\r\n * The [[Engine]] is the main driver for a game. It is responsible for\r\n * starting/stopping the game, maintaining state, transmitting events,\r\n * loading resources, and managing the scene.\r\n */\r\nexport class Engine extends Class implements CanInitialize, CanUpdate, CanDraw {\r\n  /**\r\n   * Excalibur browser events abstraction used for wiring to native browser events safely\r\n   */\r\n  public browser: BrowserEvents;\r\n\r\n  /**\r\n   * Screen abstraction\r\n   */\r\n  public screen: Screen;\r\n\r\n  /**\r\n   * Direct access to the engine's canvas element\r\n   */\r\n  public canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Direct access to the ExcaliburGraphicsContext used for drawing things to the screen\r\n   */\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Direct access to the canvas element ID, if an ID exists\r\n   */\r\n  public canvasElementId: string;\r\n\r\n  /**\r\n   * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n   *\r\n   * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n   * one that bounces between 30fps and 60fps\r\n   */\r\n  public maxFps: number = Number.POSITIVE_INFINITY;\r\n\r\n  /**\r\n   * Optionally configure a fixed update fps, this can be desireable if you need the physics simulation to be very stable. When set\r\n   * the update step and physics will use the same elapsed time for each tick even if the graphical framerate drops. In order for the\r\n   * simulation to be correct, excalibur will run multiple updates in a row (at the configured update elapsed) to catch up, for example\r\n   * there could be X updates and 1 draw each clock step.\r\n   *\r\n   * **NOTE:** This does come at a potential perf cost because each catch-up update will need to be run if the fixed rate is greater than\r\n   * the current instantaneous framerate, or perf gain if the fixed rate is less than the current framerate.\r\n   *\r\n   * By default is unset and updates will use the current instantaneous framerate with 1 update and 1 draw each clock step.\r\n   */\r\n  public fixedUpdateFps?: number;\r\n\r\n  /**\r\n   * Direct access to the excalibur clock\r\n   */\r\n  public clock: Clock;\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.screen.canvasWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.screen.halfCanvasWidth;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.screen.canvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.screen.halfCanvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    return this.screen.drawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.screen.halfDrawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    return this.screen.drawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.screen.halfDrawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns whether excalibur detects the current screen to be HiDPI\r\n   */\r\n  public get isHiDpi(): boolean {\r\n    return this.screen.isHiDpi;\r\n  }\r\n\r\n  /**\r\n   * Access engine input like pointer, keyboard, or gamepad\r\n   */\r\n  public input: Input.EngineInput;\r\n\r\n  /**\r\n   * Access Excalibur debugging functionality.\r\n   *\r\n   * Useful when you want to debug different aspects of built in engine features like\r\n   *   * Transform\r\n   *   * Graphics\r\n   *   * Colliders\r\n   */\r\n  public debug: Debug;\r\n\r\n  /**\r\n   * Access [[stats]] that holds frame statistics.\r\n   */\r\n  public get stats(): DebugStats {\r\n    return this.debug.stats;\r\n  }\r\n\r\n  /**\r\n   * The current [[Scene]] being drawn and updated on screen\r\n   */\r\n  public currentScene: Scene;\r\n\r\n  /**\r\n   * The default [[Scene]] of the game, use [[Engine.goToScene]] to transition to different scenes.\r\n   */\r\n  public readonly rootScene: Scene;\r\n\r\n  /**\r\n   * Contains all the scenes currently registered with Excalibur\r\n   */\r\n  public readonly scenes: { [key: string]: Scene } = {};\r\n\r\n  /**\r\n   * Indicates whether the engine is set to fullscreen or not\r\n   */\r\n  public get isFullscreen(): boolean {\r\n    return this.screen.isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Indicates the current [[DisplayMode]] of the engine.\r\n   */\r\n  public get displayMode(): DisplayMode {\r\n    return this.screen.displayMode;\r\n  }\r\n\r\n  private _suppressPlayButton: boolean = false;\r\n  /**\r\n   * Returns the calculated pixel ration for use in rendering\r\n   */\r\n  public get pixelRatio(): number {\r\n    return this.screen.pixelRatio;\r\n  }\r\n\r\n  /**\r\n   * Indicates whether audio should be paused when the game is no longer visible.\r\n   */\r\n  public pauseAudioWhenHidden: boolean = true;\r\n\r\n  /**\r\n   * Indicates whether the engine should draw with debug information\r\n   */\r\n  private _isDebug: boolean = false;\r\n  public get isDebug(): boolean {\r\n    return this._isDebug;\r\n  }\r\n\r\n  /**\r\n   * Sets the background color for the engine.\r\n   */\r\n  public backgroundColor: Color;\r\n\r\n  /**\r\n   * Sets the Transparency for the engine.\r\n   */\r\n  public enableCanvasTransparency: boolean = true;\r\n\r\n  /**\r\n   * Hints the graphics context to truncate fractional world space coordinates\r\n   */\r\n  public get snapToPixel(): boolean {\r\n    return this.graphicsContext.snapToPixel;\r\n  };\r\n\r\n  public set snapToPixel(shouldSnapToPixel: boolean) {\r\n    this.graphicsContext.snapToPixel = shouldSnapToPixel;\r\n  };\r\n\r\n  /**\r\n   * The action to take when a fatal exception is thrown\r\n   */\r\n  public onFatalException = (e: any) => {\r\n    Logger.getInstance().fatal(e);\r\n  };\r\n\r\n  /**\r\n   * The mouse wheel scroll prevention mode\r\n   */\r\n  public pageScrollPreventionMode: ScrollPreventionMode;\r\n\r\n  private _logger: Logger;\r\n\r\n  private _toaster: Toaster = new Toaster();\r\n\r\n  // this determines whether excalibur is compatible with your browser\r\n  private _compatible: boolean;\r\n\r\n  private _timescale: number = 1.0;\r\n\r\n  // loading\r\n  private _loader: Loader;\r\n\r\n  private _isInitialized: boolean = false;\r\n\r\n  private _deferredGoTo: string = null;\r\n\r\n  public on(eventName: 'fallbackgraphicscontext', handler: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public on(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public on(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public on(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public on(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public on(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'fallbackgraphicscontext', handler: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public once(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public once(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public once(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public once(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public once(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'fallbackgraphicscontext', handler?: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public off(eventName: Events.visible, handler?: (event: VisibleEvent) => void): void;\r\n  public off(eventName: Events.hidden, handler?: (event: HiddenEvent) => void): void;\r\n  public off(eventName: Events.start, handler?: (event: GameStartEvent) => void): void;\r\n  public off(eventName: Events.stop, handler?: (event: GameStopEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.preframe, handler?: (event: PreFrameEvent) => void): void;\r\n  public off(eventName: Events.postframe, handler?: (event: PostFrameEvent) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Default [[EngineOptions]]\r\n   */\r\n  private static _DEFAULT_ENGINE_OPTIONS: EngineOptions = {\r\n    width: 0,\r\n    height: 0,\r\n    enableCanvasTransparency: true,\r\n    useDrawSorting: true,\r\n    configurePerformanceCanvas2DFallback: {\r\n      allow: true,\r\n      showPlayerMessage: false,\r\n      threshold: { fps: 20, numberOfFrames: 100 }\r\n    },\r\n    canvasElementId: '',\r\n    canvasElement: undefined,\r\n    snapToPixel: false,\r\n    pointerScope: Input.PointerScope.Canvas,\r\n    suppressConsoleBootMessage: null,\r\n    suppressMinimumBrowserFeatureDetection: null,\r\n    suppressHiDPIScaling: null,\r\n    suppressPlayButton: null,\r\n    scrollPreventionMode: ScrollPreventionMode.Canvas,\r\n    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue\r\n  };\r\n\r\n  private _originalOptions: EngineOptions = {};\r\n  public readonly _originalDisplayMode: DisplayMode;\r\n\r\n  /**\r\n   * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,\r\n   * the game will be rendered full screen (taking up all available browser window space).\r\n   * You can customize the game rendering through [[EngineOptions]].\r\n   *\r\n   * Example:\r\n   *\r\n   * ```js\r\n   * var game = new ex.Engine({\r\n   *   width: 0, // the width of the canvas\r\n   *   height: 0, // the height of the canvas\r\n   *   enableCanvasTransparency: true, // the transparencySection of the canvas\r\n   *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own\r\n   *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n   *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n   *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine\r\n   * });\r\n   *\r\n   * // call game.start, which is a Promise\r\n   * game.start().then(function () {\r\n   *   // ready, set, go!\r\n   * });\r\n   * ```\r\n   */\r\n  constructor(options?: EngineOptions) {\r\n    super();\r\n\r\n    options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };\r\n    this._originalOptions = options;\r\n\r\n    Flags.freeze();\r\n\r\n    // Initialize browser events facade\r\n    this.browser = new BrowserEvents(window, document);\r\n\r\n    // Check compatibility\r\n    const detector = new Detector();\r\n    if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {\r\n      const message = document.createElement('div');\r\n      message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';\r\n      document.body.appendChild(message);\r\n\r\n      detector.failedTests.forEach(function (test) {\r\n        const testMessage = document.createElement('div');\r\n        testMessage.innerText = 'Browser feature missing ' + test;\r\n        document.body.appendChild(testMessage);\r\n      });\r\n\r\n      if (options.canvasElementId) {\r\n        const canvas = document.getElementById(options.canvasElementId);\r\n        if (canvas) {\r\n          canvas.parentElement.removeChild(canvas);\r\n        }\r\n      }\r\n\r\n      return;\r\n    } else {\r\n      this._compatible = true;\r\n    }\r\n\r\n    // Use native console API for color fun\r\n    // eslint-disable-next-line no-console\r\n    if (console.log && !options.suppressConsoleBootMessage) {\r\n      // eslint-disable-next-line no-console\r\n      console.log(\r\n        `%cPowered by Excalibur.js (v${EX_VERSION})`,\r\n        'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;'\r\n      );\r\n      // eslint-disable-next-line no-console\r\n      console.log('\\n\\\r\n      /| ________________\\n\\\r\nO|===|* >________________>\\n\\\r\n      \\\\|');\r\n      // eslint-disable-next-line no-console\r\n      console.log('Visit', 'http://excaliburjs.com', 'for more information');\r\n    }\r\n\r\n    // Suppress play button\r\n    if (options.suppressPlayButton) {\r\n      this._suppressPlayButton = true;\r\n    }\r\n\r\n    this._logger = Logger.getInstance();\r\n\r\n    // If debug is enabled, let's log browser features to the console.\r\n    if (this._logger.defaultLevel === LogLevel.Debug) {\r\n      detector.logBrowserFeatures();\r\n    }\r\n\r\n    this._logger.debug('Building engine...');\r\n\r\n    this.canvasElementId = options.canvasElementId;\r\n\r\n    if (options.canvasElementId) {\r\n      this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);\r\n      this.canvas = <HTMLCanvasElement>document.getElementById(options.canvasElementId);\r\n    } else if (options.canvasElement) {\r\n      this._logger.debug('Using Canvas element specified:', options.canvasElement);\r\n      this.canvas = options.canvasElement;\r\n    } else {\r\n      this._logger.debug('Using generated canvas element');\r\n      this.canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    }\r\n\r\n    let displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    if ((options.width && options.height) || options.viewport) {\r\n      if (options.displayMode === undefined) {\r\n        displayMode = DisplayMode.Fixed;\r\n      }\r\n      this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);\r\n    } else if (!options.displayMode) {\r\n      this._logger.debug('Engine viewport is fit');\r\n      displayMode = DisplayMode.FitScreen;\r\n    }\r\n\r\n    this._originalDisplayMode = displayMode;\r\n\r\n    // Canvas 2D fallback can be flagged on\r\n    let useCanvasGraphicsContext = Flags.isEnabled('use-canvas-context');\r\n    if (!useCanvasGraphicsContext) {\r\n      // Attempt webgl first\r\n      try {\r\n        this.graphicsContext = new ExcaliburGraphicsContextWebGL({\r\n          canvasElement: this.canvas,\r\n          enableTransparency: this.enableCanvasTransparency,\r\n          smoothing: options.antialiasing,\r\n          backgroundColor: options.backgroundColor,\r\n          snapToPixel: options.snapToPixel,\r\n          useDrawSorting: options.useDrawSorting\r\n        });\r\n      } catch (e) {\r\n        this._logger.warn(\r\n          `Excalibur could not load webgl for some reason (${(e as Error).message}) and loaded a Canvas 2D fallback. ` +\r\n          `Some features of Excalibur will not work in this mode. \\n\\n` +\r\n          'Read more about this issue at https://excaliburjs.com/docs/webgl'\r\n        );\r\n        // fallback to canvas in case of failure\r\n        useCanvasGraphicsContext = true;\r\n      }\r\n    }\r\n\r\n    if (useCanvasGraphicsContext) {\r\n      this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n        canvasElement: this.canvas,\r\n        enableTransparency: this.enableCanvasTransparency,\r\n        smoothing: options.antialiasing,\r\n        backgroundColor: options.backgroundColor,\r\n        snapToPixel: options.snapToPixel,\r\n        useDrawSorting: options.useDrawSorting\r\n      });\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : (options.pixelRatio ?? null)\r\n    });\r\n\r\n    // Set default filtering based on antialiasing\r\n    TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;\r\n\r\n    if (options.backgroundColor) {\r\n      this.backgroundColor = options.backgroundColor.clone();\r\n    }\r\n\r\n    this.maxFps = options.maxFps ?? this.maxFps;\r\n    this.fixedUpdateFps = options.fixedUpdateFps ?? this.fixedUpdateFps;\r\n\r\n    this.clock = new StandardClock({\r\n      maxFps: this.maxFps,\r\n      tick: this._mainloop.bind(this),\r\n      onFatalException: (e) => this.onFatalException(e)\r\n    });\r\n\r\n    this.enableCanvasTransparency = options.enableCanvasTransparency;\r\n\r\n    this._loader = new Loader();\r\n    this._loader.wireEngine(this);\r\n    this.debug = new Debug(this);\r\n\r\n    this._initialize(options);\r\n\r\n    this.rootScene = this.currentScene = new Scene();\r\n\r\n    this.addScene('root', this.rootScene);\r\n    (window as any).___EXCALIBUR_DEVTOOL = this;\r\n  }\r\n\r\n  private _performanceThresholdTriggered = false;\r\n  private _fpsSamples: number[] = [];\r\n  private _monitorPerformanceThresholdAndTriggerFallback() {\r\n    const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n    let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n    if (threshold === undefined) {\r\n      threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;\r\n    }\r\n    if (showPlayerMessage === undefined) {\r\n      showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;\r\n    }\r\n    if (!Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {\r\n      // Calculate Average fps for last X number of frames after start\r\n      if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n        this._fpsSamples.splice(0, 1);\r\n      }\r\n      this._fpsSamples.push(this.clock.fpsSampler.fps);\r\n      let total = 0;\r\n      for (let i = 0; i < this._fpsSamples.length; i++) {\r\n        total += this._fpsSamples[i];\r\n      }\r\n      const average = total / this._fpsSamples.length;\r\n\r\n      if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n        if (average <= threshold.fps) {\r\n          this._performanceThresholdTriggered = true;\r\n          this._logger.warn(\r\n            `Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\\n` +\r\n            'this might mean your browser doesn\\'t have webgl enabled or hardware acceleration is unavailable.\\n\\n' +\r\n            'If in Chrome:\\n' +\r\n            '  * Visit Settings > Advanced > System, and ensure \"Use Hardware Acceleration\" is checked.\\n'+\r\n            '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure \"Override software rendering list\" is \"enabled\"\\n' +\r\n            'If in Firefox, visit about:config\\n' +\r\n            '  * Ensure webgl.disabled = false\\n' +\r\n            '  * Ensure webgl.force-enabled = true\\n' +\r\n            '  * Ensure layers.acceleration.force-enabled = true\\n\\n' +\r\n            'Read more about this issue at https://excaliburjs.com/docs/performance'\r\n          );\r\n\r\n          if (showPlayerMessage) {\r\n            this._toaster.toast(\r\n              'Excalibur is encountering performance issues. '+\r\n              'It\\'s possible that your browser doesn\\'t have hardware acceleration enabled. ' +\r\n              'Visit [LINK] for more information and potential solutions.',\r\n              'https://excaliburjs.com/docs/performance'\r\n            );\r\n          }\r\n          this.useCanvas2DFallback();\r\n          this.emit('fallbackgraphicscontext', this.graphicsContext);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Switches the engine's graphics context to the 2D Canvas.\r\n   * @warning Some features of Excalibur will not work in this mode.\r\n   */\r\n  public useCanvas2DFallback() {\r\n    // Swap out the canvas\r\n    const newCanvas = this.canvas.cloneNode(false) as HTMLCanvasElement;\r\n    this.canvas.parentNode.replaceChild(newCanvas, this.canvas);\r\n    this.canvas = newCanvas;\r\n\r\n    const options = this._originalOptions;\r\n    const displayMode = this._originalDisplayMode;\r\n\r\n    // New graphics context\r\n    this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n      canvasElement: this.canvas,\r\n      enableTransparency: this.enableCanvasTransparency,\r\n      smoothing: options.antialiasing,\r\n      backgroundColor: options.backgroundColor,\r\n      snapToPixel: options.snapToPixel,\r\n      useDrawSorting: options.useDrawSorting\r\n    });\r\n\r\n    // Reset screen\r\n    if (this.screen) {\r\n      this.screen.dispose();\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : (options.pixelRatio ?? null)\r\n    });\r\n    this.screen.setCurrentCamera(this.currentScene.camera);\r\n\r\n    // Reset pointers\r\n    this.input.pointers.detach();\r\n    const pointerTarget = options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas;\r\n    this.input.pointers = this.input.pointers.recreate(pointerTarget, this);\r\n    this.input.pointers.init();\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   */\r\n  public getWorldBounds() {\r\n    return this.screen.getWorldBounds();\r\n  }\r\n\r\n  /**\r\n   * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n   */\r\n  public get timescale() {\r\n    return this._timescale;\r\n  }\r\n\r\n  /**\r\n   * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n   * when using time-based movement.\r\n   */\r\n  public set timescale(value: number) {\r\n    if (value <= 0) {\r\n      Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');\r\n      return;\r\n    }\r\n\r\n    this._timescale = value;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    return this.currentScene.addTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    return this.currentScene.removeTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   *\r\n   * @param key  The name of the scene, must be unique\r\n   * @param scene The scene to add to the engine\r\n   */\r\n  public addScene(key: string, scene: Scene) {\r\n    if (this.scenes[key]) {\r\n      this._logger.warn('Scene', key, 'already exists overwriting');\r\n    }\r\n    this.scenes[key] = scene;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Scene]] instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public removeScene(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param key  The scene key to remove\r\n   */\r\n  public removeScene(key: string): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  public removeScene(entity: any): void {\r\n    if (entity instanceof Scene) {\r\n      // remove scene\r\n      for (const key in this.scenes) {\r\n        if (this.scenes.hasOwnProperty(key)) {\r\n          if (this.scenes[key] === entity) {\r\n            delete this.scenes[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      // remove scene\r\n      delete this.scenes[entity];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   * @param sceneKey  The key of the scene, must be unique\r\n   * @param scene     The scene to add to the engine\r\n   */\r\n  public add(sceneKey: string, scene: Scene): void;\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n  /**\r\n   * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap\r\n   * will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n  /**\r\n   * Adds an actor to the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.add(actor)`.\r\n   *\r\n   * Actors can only be drawn if they are a member of a scene, and only\r\n   * the [[currentScene]] may be drawn or updated.\r\n   *\r\n   * @param actor  The actor to add to the [[currentScene]]\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the [[currentScene]] of the game,\r\n   * ScreenElements do not participate in collisions, instead the\r\n   * remain in the same place on the screen.\r\n   * @param screenElement  The ScreenElement to add to the [[currentScene]]\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    if (arguments.length === 2) {\r\n      this.addScene(<string>arguments[0], <Scene>arguments[1]);\r\n      return;\r\n    }\r\n    if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {\r\n      this.scenes[this._deferredGoTo].add(entity);\r\n    } else {\r\n      this.currentScene.add(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a scene instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public remove(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param sceneKey  The scene to remove\r\n   */\r\n  public remove(sceneKey: string): void;\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public remove(timer: Timer): void;\r\n  /**\r\n   * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n  /**\r\n   * Removes an actor from the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.removeChild(actor)`.\r\n   * Actors that are removed from a scene will no longer be drawn or updated.\r\n   *\r\n   * @param actor  The actor to remove from the [[currentScene]].\r\n   */\r\n  public remove(actor: Actor): void;\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the [[currentScene]]\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.currentScene.remove(entity);\r\n    }\r\n\r\n    if (entity instanceof Scene) {\r\n      this.removeScene(entity);\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      this.removeScene(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Changes the currently updating and drawing scene to a different,\r\n   * named scene. Calls the [[Scene]] lifecycle events.\r\n   * @param key  The key of the scene to transition to.\r\n   * @param data Optional data to send to the scene's onActivate method\r\n   */\r\n  public goToScene<TData = undefined>(key: string, data?: TData): void {\r\n    // if not yet initialized defer goToScene\r\n    if (!this.isInitialized) {\r\n      this._deferredGoTo = key;\r\n      return;\r\n    }\r\n\r\n    if (this.scenes[key]) {\r\n      const previousScene = this.currentScene;\r\n      const nextScene = this.scenes[key];\r\n\r\n      this._logger.debug('Going to scene:', key);\r\n\r\n      // only deactivate when initialized\r\n      if (this.currentScene.isInitialized) {\r\n        const context = { engine: this, previousScene, nextScene };\r\n        this.currentScene._deactivate.apply(this.currentScene, [context, nextScene]);\r\n        this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(context, this.currentScene));\r\n      }\r\n\r\n      // set current scene to new one\r\n      this.currentScene = nextScene;\r\n      this.screen.setCurrentCamera(nextScene.camera);\r\n\r\n      // initialize the current scene if has not been already\r\n      this.currentScene._initialize(this);\r\n\r\n      const context = { engine: this, previousScene, nextScene, data };\r\n      this.currentScene._activate.apply(this.currentScene, [context, nextScene]);\r\n      this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(context, this.currentScene));\r\n    } else {\r\n      this._logger.error('Scene', key, 'does not exist!');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms the current x, y from screen coordinates to world coordinates\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    return this.screen.screenToWorldCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Transforms a world coordinate, to a screen coordinate\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    return this.screen.worldToScreenCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Initializes the internal canvas, rendering context, display mode, and native event listeners\r\n   */\r\n  private _initialize(options?: EngineOptions) {\r\n    this.pageScrollPreventionMode = options.scrollPreventionMode;\r\n\r\n    // initialize inputs\r\n    const pointerTarget = options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas;\r\n    this.input = {\r\n      keyboard: new Input.Keyboard(),\r\n      pointers: new PointerEventReceiver(pointerTarget, this),\r\n      gamepads: new Input.Gamepads()\r\n    };\r\n    this.input.keyboard.init();\r\n    this.input.pointers.init();\r\n    this.input.gamepads.init();\r\n\r\n    // Issue #385 make use of the visibility api\r\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\r\n\r\n    let hidden: keyof HTMLDocument, visibilityChange: string;\r\n    if (typeof document.hidden !== 'undefined') {\r\n      // Opera 12.10 and Firefox 18 and later support\r\n      hidden = 'hidden';\r\n      visibilityChange = 'visibilitychange';\r\n    } else if ('msHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'msHidden';\r\n      visibilityChange = 'msvisibilitychange';\r\n    } else if ('webkitHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'webkitHidden';\r\n      visibilityChange = 'webkitvisibilitychange';\r\n    }\r\n\r\n    this.browser.document.on(visibilityChange, () => {\r\n      if (document[hidden]) {\r\n        this.eventDispatcher.emit('hidden', new HiddenEvent(this));\r\n        this._logger.debug('Window hidden');\r\n      } else {\r\n        this.eventDispatcher.emit('visible', new VisibleEvent(this));\r\n        this._logger.debug('Window visible');\r\n      }\r\n    });\r\n\r\n    if (!this.canvasElementId && !options.canvasElement) {\r\n      document.body.appendChild(this.canvas);\r\n    }\r\n  }\r\n\r\n  public onInitialize(_engine: Engine) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If supported by the browser, this will set the antialiasing flag on the\r\n   * canvas. Set this to `false` if you want a 'jagged' pixel art look to your\r\n   * image resources.\r\n   * @param isSmooth  Set smoothing to true or false\r\n   */\r\n  public setAntialiasing(isSmooth: boolean) {\r\n    this.screen.antialiasing = isSmooth;\r\n  }\r\n\r\n  /**\r\n   * Return the current smoothing status of the canvas\r\n   */\r\n  public getAntialiasing(): boolean {\r\n    return this.screen.antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  private _overrideInitialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n      if (this._deferredGoTo) {\r\n        const deferredScene = this._deferredGoTo;\r\n        this._deferredGoTo = null;\r\n        this.goToScene(deferredScene);\r\n      } else {\r\n        this.goToScene('root');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the entire state of the game\r\n   * @param delta  Number of milliseconds elapsed since the last update.\r\n   */\r\n  private _update(delta: number) {\r\n    if (!this.ready) {\r\n      // suspend updates until loading is finished\r\n      this._loader.update(this, delta);\r\n      // Update input listeners\r\n      this.input.keyboard.update();\r\n      this.input.gamepads.update();\r\n      return;\r\n    }\r\n\r\n\r\n    // Publish preupdate events\r\n    this._preupdate(delta);\r\n\r\n    // process engine level events\r\n    this.currentScene.update(this, delta);\r\n\r\n    // Publish update event\r\n    this._postupdate(delta);\r\n\r\n    // Update input listeners\r\n    this.input.keyboard.update();\r\n    this.input.gamepads.update();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _preupdate(delta: number) {\r\n    this.emit('preupdate', new PreUpdateEvent(this, delta, this));\r\n    this.onPreUpdate(this, delta);\r\n  }\r\n\r\n  public onPreUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postupdate(delta: number) {\r\n    this.emit('postupdate', new PostUpdateEvent(this, delta, this));\r\n    this.onPostUpdate(this, delta);\r\n  }\r\n\r\n  public onPostUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Draws the entire game\r\n   * @param delta  Number of milliseconds elapsed since the last draw.\r\n   */\r\n  private _draw(delta: number) {\r\n    this.graphicsContext.beginDrawLifecycle();\r\n    this.graphicsContext.clear();\r\n    this._predraw(this.graphicsContext, delta);\r\n\r\n    // Drawing nothing else while loading\r\n    if (!this._isReady) {\r\n      this._loader.canvas.draw(this.graphicsContext, 0, 0);\r\n      this.graphicsContext.flush();\r\n      return;\r\n    }\r\n\r\n    this.graphicsContext.backgroundColor = this.backgroundColor;\r\n\r\n    this.currentScene.draw(this.graphicsContext, delta);\r\n\r\n    this._postdraw(this.graphicsContext, delta);\r\n\r\n    // Flush any pending drawings\r\n    this.graphicsContext.flush();\r\n    this.graphicsContext.endDrawLifecycle();\r\n\r\n    this._checkForScreenShots();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, delta, this));\r\n    this.onPreDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));\r\n    this.onPostDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Enable or disable Excalibur debugging functionality.\r\n   * @param toggle a value that debug drawing will be changed to\r\n   */\r\n  public showDebug(toggle: boolean): void {\r\n    this._isDebug = toggle;\r\n  }\r\n\r\n  /**\r\n   * Toggle Excalibur debugging functionality.\r\n   */\r\n  public toggleDebug(): boolean {\r\n    this._isDebug = !this._isDebug;\r\n    return this._isDebug;\r\n  }\r\n\r\n  private _loadingComplete: boolean = false;\r\n\r\n  /**\r\n   * Returns true when loading is totally complete and the player has clicked start\r\n   */\r\n  public get loadingComplete() {\r\n    return this._loadingComplete;\r\n  }\r\n\r\n  private _isReady = false;\r\n  public get ready() {\r\n    return this._isReady;\r\n  }\r\n  private _isReadyResolve: () => any;\r\n  private _isReadyPromise = new Promise<void>(resolve => {\r\n    this._isReadyResolve = resolve;\r\n  });\r\n  public isReady(): Promise<void> {\r\n    return this._isReadyPromise;\r\n  }\r\n\r\n\r\n  /**\r\n   * Starts the internal game loop for Excalibur after loading\r\n   * any provided assets.\r\n   * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n   * custom loader.\r\n   *\r\n   * Note: start() only resolves AFTER the user has clicked the play button\r\n   */\r\n  public async start(loader?: Loader): Promise<void> {\r\n    if (!this._compatible) {\r\n      throw new Error('Excalibur is incompatible with your browser');\r\n    }\r\n\r\n    // Wire loader if we have it\r\n    if (loader) {\r\n      // Push the current user entered resolution/viewport\r\n      this.screen.pushResolutionAndViewport();\r\n\r\n      // Configure resolution for loader, it expects resolution === viewport\r\n      this.screen.resolution = this.screen.viewport;\r\n      this.screen.applyResolutionAndViewport();\r\n      this._loader = loader;\r\n      this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;\r\n      this._loader.wireEngine(this);\r\n    }\r\n\r\n    // Start the excalibur clock which drives the mainloop\r\n    // has started is a slight misnomer, it's really mainloop started\r\n    this._logger.debug('Starting game clock...');\r\n    this.browser.resume();\r\n    this.clock.start();\r\n    this._logger.debug('Game clock started');\r\n\r\n    if (loader) {\r\n      await this.load(this._loader);\r\n      this._loadingComplete = true;\r\n\r\n      // reset back to previous user resolution/viewport\r\n      this.screen.popResolutionAndViewport();\r\n      this.screen.applyResolutionAndViewport();\r\n    }\r\n\r\n    this._loadingComplete = true;\r\n\r\n    // Initialize before ready\r\n    this._overrideInitialize(this);\r\n\r\n    this._isReady = true;\r\n\r\n    this._isReadyResolve();\r\n    this.emit('start', new GameStartEvent(this));\r\n    return this._isReadyPromise;\r\n  }\r\n\r\n  /**\r\n   * Returns the current frames elapsed milliseconds\r\n   */\r\n  public currentFrameElapsedMs = 0;\r\n\r\n  /**\r\n   * Returns the current frame lag when in fixed update mode\r\n   */\r\n  public currentFrameLagMs = 0;\r\n\r\n  private _lagMs = 0;\r\n  private _mainloop(elapsed: number) {\r\n    this.emit('preframe', new PreFrameEvent(this, this.stats.prevFrame));\r\n    const delta = elapsed * this.timescale;\r\n    this.currentFrameElapsedMs = delta;\r\n\r\n    // reset frame stats (reuse existing instances)\r\n    const frameId = this.stats.prevFrame.id + 1;\r\n    this.stats.currFrame.reset();\r\n    this.stats.currFrame.id = frameId;\r\n    this.stats.currFrame.delta = delta;\r\n    this.stats.currFrame.fps = this.clock.fpsSampler.fps;\r\n    GraphicsDiagnostics.clear();\r\n\r\n    const beforeUpdate = this.clock.now();\r\n    const fixedTimestepMs = 1000 / this.fixedUpdateFps;\r\n    if (this.fixedUpdateFps) {\r\n      this._lagMs += delta;\r\n      while (this._lagMs >= fixedTimestepMs) {\r\n        this._update(fixedTimestepMs);\r\n        this._lagMs -= fixedTimestepMs;\r\n      }\r\n    } else {\r\n      this._update(delta);\r\n    }\r\n    const afterUpdate = this.clock.now();\r\n    this.currentFrameLagMs = this._lagMs;\r\n    this._draw(delta);\r\n    const afterDraw = this.clock.now();\r\n\r\n    this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\r\n    this.stats.currFrame.duration.draw = afterDraw - afterUpdate;\r\n    this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\r\n    this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\r\n\r\n    this.emit('postframe', new PostFrameEvent(this, this.stats.currFrame));\r\n    this.stats.prevFrame.reset(this.stats.currFrame);\r\n\r\n    this._monitorPerformanceThresholdAndTriggerFallback();\r\n  }\r\n\r\n  /**\r\n   * Stops Excalibur's main loop, useful for pausing the game.\r\n   */\r\n  public stop() {\r\n    if (this.clock.isRunning()) {\r\n      this.emit('stop', new GameStopEvent(this));\r\n      this.browser.pause();\r\n      this.clock.stop();\r\n      this._logger.debug('Game stopped');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the Engine's running status, Useful for checking whether engine is running or paused.\r\n   */\r\n  public isRunning() {\r\n    return this.clock.isRunning();\r\n  }\r\n\r\n\r\n  private _screenShotRequests: { preserveHiDPIResolution: boolean, resolve: (image: HTMLImageElement) => void }[] = [];\r\n  /**\r\n   * Takes a screen shot of the current viewport and returns it as an\r\n   * HTML Image Element.\r\n   * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false\r\n   */\r\n  public screenshot(preserveHiDPIResolution = false): Promise<HTMLImageElement> {\r\n    const screenShotPromise = new Promise<HTMLImageElement>((resolve) => {\r\n      this._screenShotRequests.push({preserveHiDPIResolution, resolve});\r\n    });\r\n    return screenShotPromise;\r\n  }\r\n\r\n  private _checkForScreenShots() {\r\n    // We must grab the draw buffer before we yield to the browser\r\n    // the draw buffer is cleared after compositing\r\n    // the reason for the asynchrony is setting `preserveDrawingBuffer: true`\r\n    // forces the browser to copy buffers which can have a mass perf impact on mobile\r\n    for (const request of this._screenShotRequests) {\r\n      const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;\r\n      const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;\r\n      const screenshot = document.createElement('canvas');\r\n      screenshot.width = finalWidth;\r\n      screenshot.height = finalHeight;\r\n      const ctx = screenshot.getContext('2d');\r\n      ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);\r\n\r\n      const result = new Image();\r\n      const raw = screenshot.toDataURL('image/png');\r\n      result.src = raw;\r\n      request.resolve(result);\r\n    }\r\n    // Reset state\r\n    this._screenShotRequests.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Another option available to you to load resources into the game.\r\n   * Immediately after calling this the game will pause and the loading screen\r\n   * will appear.\r\n   * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n   */\r\n  public async load(loader: Loadable<any>): Promise<void> {\r\n    try {\r\n      await loader.load();\r\n    } catch (e) {\r\n      this._logger.error('Error loading resources, things may not behave properly', e);\r\n      await Promise.resolve();\r\n    }\r\n  }\r\n}","export * from './vector';\r\nexport * from './vector-view';\r\nexport * from './matrix';\r\nexport * from './affine-matrix';\r\nexport * from './transform';\r\nexport * from './coord-plane';\r\nexport * from './Random';\r\nexport * from './global-coordinates';\r\nexport * from './line-segment';\r\nexport * from './projection';\r\nexport * from './ray';\r\nexport * from './util';","export * from './Debug';\r\nexport * from './DebugFlags';\r\nexport * from './DebugSystem';\r\n","import { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { vec, Vector } from './Math/vector';\r\nimport { Text } from './Graphics/Text';\r\nimport { GraphicsComponent, SpriteFont } from './Graphics';\r\nimport { Font } from './Graphics/Font';\r\nimport { Actor } from './Actor';\r\nimport { ActorArgs } from '.';\r\n\r\n/**\r\n * Option for creating a label\r\n */\r\nexport interface LabelOptions {\r\n  /**\r\n   * Specify the label text\r\n   */\r\n  text?: string;\r\n  /**\r\n   * Specify the color of the text (does not apply to SpriteFonts)\r\n   */\r\n  color?: Color;\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally specify a sprite font, will take precedence over any other [[Font]]\r\n   */\r\n  spriteFont?: SpriteFont;\r\n  /**\r\n   * Specify a custom font\r\n   */\r\n  font?: Font\r\n}\r\n\r\n/**\r\n * Labels are the way to draw small amounts of text to the screen. They are\r\n * actors and inherit all of the benefits and capabilities.\r\n */\r\nexport class Label extends Actor {\r\n  private _font: Font = new Font();\r\n  private _text: Text = new Text({ text: '', font: this._font });\r\n\r\n  public get font(): Font {\r\n    return this._font;\r\n  }\r\n\r\n  public set font(newFont: Font) {\r\n    this._font = newFont;\r\n    this._text.font = newFont;\r\n  }\r\n\r\n  /**\r\n   * The text to draw.\r\n   */\r\n  public get text(): string {\r\n    return this._text.text;\r\n  }\r\n\r\n  public set text(text: string) {\r\n    this._text.text = text;\r\n  }\r\n\r\n  public override get color(): Color {\r\n    return this._text.color;\r\n  }\r\n\r\n  public override set color(color: Color) {\r\n    if (this._text) {\r\n      this._text.color = color;\r\n    }\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._text.opacity;\r\n  }\r\n\r\n  public set opacity(opacity: number) {\r\n    this._text.opacity = opacity;\r\n  }\r\n\r\n  private _spriteFont: SpriteFont;\r\n  /**\r\n   * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.\r\n   */\r\n  public get spriteFont(): SpriteFont {\r\n    return this._spriteFont;\r\n  }\r\n\r\n  public set spriteFont(sf: SpriteFont) {\r\n    if (sf) {\r\n      this._spriteFont = sf;\r\n      this._text.font = this._spriteFont;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a new label\r\n   * @param options\r\n   */\r\n  constructor(options?: LabelOptions & ActorArgs) {\r\n    super(options);\r\n    const {text, pos, x, y, spriteFont, font, color} = options;\r\n\r\n    this.pos = pos ?? (x && y ? vec(x, y) : this.pos);\r\n    this.text = text ?? this.text;\r\n    this.font = font ?? this.font;\r\n    this.spriteFont = spriteFont ?? this.spriteFont;\r\n    this._text.color = color ?? this.color;\r\n    const gfx = this.get(GraphicsComponent);\r\n    gfx.anchor = Vector.Zero;\r\n    gfx.use(this._text);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the text in the label (in pixels);\r\n   */\r\n  public getTextWidth(): number {\r\n    return this._text.width;\r\n  }\r\n}\r\n","import { BodyComponent, BoundingBox, Collider, ColliderComponent, CollisionType, Color, CompositeCollider, vec, Vector } from '..';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { DebugGraphicsComponent, ExcaliburGraphicsContext, Graphic, GraphicsComponent } from '../Graphics';\r\nimport { IsometricEntityComponent } from './IsometricEntityComponent';\r\n\r\nexport class IsometricTile extends Entity {\r\n  /**\r\n   * Indicates whether this tile is solid\r\n   */\r\n  public solid: boolean = false;\r\n\r\n  private _gfx: GraphicsComponent;\r\n  private _tileBounds = new BoundingBox();\r\n  private _graphics: Graphic[] = [];\r\n  public getGraphics(): readonly Graphic[] {\r\n    return this._graphics;\r\n  }\r\n  /**\r\n   * Tile graphics\r\n   */\r\n  public addGraphic(graphic: Graphic) {\r\n    this._graphics.push(graphic);\r\n    this._gfx.visible = true;\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  private _recalculateBounds(): BoundingBox {\r\n    let bounds = this._tileBounds.clone();\r\n    for (const graphic of this._graphics) {\r\n      const offset = vec(\r\n        this.map.graphicsOffset.x - this.map.tileWidth / 2,\r\n        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n      bounds = bounds.combine(graphic.localBounds.translate(offset));\r\n    }\r\n    return bounds;\r\n  }\r\n\r\n  public removeGraphic(graphic: Graphic) {\r\n    const index = this._graphics.indexOf(graphic);\r\n    if (index > -1) {\r\n      this._graphics.splice(index, 1);\r\n    }\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  public clearGraphics() {\r\n    this._graphics.length = 0;\r\n    this._gfx.visible = false;\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  /**\r\n   * Tile colliders\r\n   */\r\n  private _colliders: Collider[] = [];\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Adds a collider to the IsometricTile\r\n   *\r\n   * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n   * @param collider\r\n   */\r\n  public addCollider(collider: Collider) {\r\n    this._colliders.push(collider);\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes a collider from the IsometricTile\r\n   * @param collider\r\n   */\r\n  public removeCollider(collider: Collider) {\r\n    const index = this._colliders.indexOf(collider);\r\n    if (index > -1) {\r\n      this._colliders.splice(index, 1);\r\n    }\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Clears all colliders from the IsometricTile\r\n   */\r\n  public clearColliders(): void {\r\n    this._colliders.length = 0;\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Integer tile x coordinate\r\n   */\r\n  public readonly x: number;\r\n  /**\r\n   * Integer tile y coordinate\r\n   */\r\n  public readonly y: number;\r\n  /**\r\n   * Reference to the [[IsometricMap]] this tile is part of\r\n   */\r\n  public readonly map: IsometricMap;\r\n\r\n  private _transform: TransformComponent;\r\n  private _isometricEntityComponent: IsometricEntityComponent;\r\n\r\n  /**\r\n   * Returns the top left corner of the [[IsometricTile]] in world space\r\n   */\r\n  public get pos(): Vector {\r\n    return this.map.tileToWorld(vec(this.x, this.y));\r\n  }\r\n\r\n  /**\r\n   * Returns the center of the [[IsometricTile]]\r\n   */\r\n  public get center(): Vector {\r\n    return this.pos.add(vec(0, this.map.tileHeight / 2));\r\n  }\r\n\r\n  /**\r\n   * Construct a new IsometricTile\r\n   * @param x tile coordinate in x (not world position)\r\n   * @param y tile coordinate in y (not world position)\r\n   * @param graphicsOffset offset that tile should be shifted by (default (0, 0))\r\n   * @param map reference to owning IsometricMap\r\n   */\r\n  constructor(x: number, y: number, graphicsOffset: Vector | null, map: IsometricMap) {\r\n    super([\r\n      new TransformComponent(),\r\n      new GraphicsComponent({\r\n        offset: graphicsOffset ?? Vector.Zero,\r\n        onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)\r\n      }),\r\n      new IsometricEntityComponent(map)\r\n    ]);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.map = map;\r\n    this._transform = this.get(TransformComponent);\r\n    this._isometricEntityComponent = this.get(IsometricEntityComponent);\r\n\r\n    const halfTileWidth = this.map.tileWidth / 2;\r\n    const halfTileHeight = this.map.tileHeight / 2;\r\n    // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n    // The x position shifts left with every y step\r\n    const xPos = (this.x - this.y) * halfTileWidth;\r\n    // The y position needs to go down with every x step\r\n    const yPos = (this.x + this.y) * halfTileHeight;\r\n    this._transform.pos = vec(xPos, yPos);\r\n    this._isometricEntityComponent.elevation = 0;\r\n\r\n    this._gfx = this.get(GraphicsComponent);\r\n    this._gfx.visible = false; // start not visible\r\n    const totalWidth = this.map.tileWidth;\r\n    const totalHeight = this.map.tileHeight;\r\n\r\n    // initial guess at gfx bounds based on the tile\r\n    const offset = vec(0, (this.map.renderFromTopOfGraphic ? totalHeight : 0));\r\n    this._gfx.localBounds = this._tileBounds = new BoundingBox({\r\n      left: -totalWidth / 2,\r\n      top: -totalHeight,\r\n      right: totalWidth / 2,\r\n      bottom: totalHeight\r\n    }).translate(offset);\r\n  }\r\n\r\n  draw(gfx: ExcaliburGraphicsContext, _elapsed: number) {\r\n    const halfTileWidth = this.map.tileWidth / 2;\r\n    gfx.save();\r\n    // shift left origin to corner of map, not the left corner of the first sprite\r\n    gfx.translate(-halfTileWidth, 0);\r\n    for (const graphic of this._graphics) {\r\n      graphic.draw(\r\n        gfx,\r\n        this.map.graphicsOffset.x,\r\n        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n    }\r\n    gfx.restore();\r\n  }\r\n}\r\n\r\nexport interface IsometricMapOptions {\r\n  /**\r\n   * Optionally name the isometric tile map\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally specify the position of the isometric tile map\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally render from the top of the graphic, by default tiles are rendered from the bottom\r\n   */\r\n  renderFromTopOfGraphic?: boolean;\r\n  /**\r\n   * Optionally present a graphics offset, this can be useful depending on your tile graphics\r\n   */\r\n  graphicsOffset?: Vector;\r\n  /**\r\n   * Width of an individual tile in pixels, this should be the width of the parallelogram of the base of the tile art asset.\r\n   */\r\n  tileWidth: number;\r\n  /**\r\n   * Height of an individual tile in pixels, this should be the height of the parallelogram of the base of the tile art asset.\r\n   */\r\n  tileHeight: number;\r\n  /**\r\n   * The number of tile columns, or the number of tiles wide\r\n   */\r\n  columns: number;\r\n  /**\r\n   * The number of tile  rows, or the number of tiles high\r\n   */\r\n  rows: number;\r\n}\r\n\r\n/**\r\n * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur\r\n *\r\n * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.\r\n * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.\r\n *\r\n * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given\r\n * your art assets.\r\n */\r\nexport class IsometricMap extends Entity {\r\n  /**\r\n   * Width of individual tile in pixels\r\n   */\r\n  public readonly tileWidth: number;\r\n  /**\r\n   * Height of individual tile in pixels\r\n   */\r\n  public readonly tileHeight: number;\r\n  /**\r\n   * Number of tiles wide\r\n   */\r\n  public readonly columns: number;\r\n  /**\r\n   * Number of tiles high\r\n   */\r\n  public readonly rows: number;\r\n  /**\r\n   * List containing all of the tiles in IsometricMap\r\n   */\r\n  public readonly tiles: IsometricTile[];\r\n\r\n  /**\r\n   * Render the tile graphic from the top instead of the bottom\r\n   *\r\n   * default is `false` meaning rendering from the bottom\r\n   */\r\n  public renderFromTopOfGraphic: boolean = false;\r\n  public graphicsOffset: Vector = vec(0, 0);\r\n\r\n  /**\r\n   * Isometric map [[TransformComponent]]\r\n   */\r\n  public transform: TransformComponent;\r\n\r\n  /**\r\n   * Isometric map [[ColliderComponent]]\r\n   */\r\n  public collider: ColliderComponent;\r\n\r\n  private _composite: CompositeCollider;\r\n\r\n  constructor(options: IsometricMapOptions) {\r\n    super([\r\n      new TransformComponent(),\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      }),\r\n      new ColliderComponent(),\r\n      new DebugGraphicsComponent((ctx) => this.debug(ctx), false)\r\n    ], options.name);\r\n    const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;\r\n\r\n    this.transform = this.get(TransformComponent);\r\n    if (pos) {\r\n      this.transform.pos = pos;\r\n    }\r\n\r\n    this.collider = this.get(ColliderComponent);\r\n    if (this.collider) {\r\n      this.collider.set(this._composite = new CompositeCollider([]));\r\n    }\r\n\r\n\r\n    this.renderFromTopOfGraphic = renderFromTopOfGraphic ?? this.renderFromTopOfGraphic;\r\n    this.graphicsOffset = graphicsOffset ?? this.graphicsOffset;\r\n\r\n    this.tileWidth = tileWidth;\r\n    this.tileHeight = tileHeight;\r\n    this.columns = width;\r\n    this.rows = height;\r\n\r\n    this.tiles = new Array(width * height);\r\n\r\n    // build up tile representation\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        const tile = new IsometricTile(x, y, this.graphicsOffset, this);\r\n        this.tiles[x + y * width] = tile;\r\n        this.addChild(tile);\r\n        // TODO row/columns helpers\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(): void {\r\n    if (this._collidersDirty) {\r\n      this.updateColliders();\r\n      this._collidersDirty = false;\r\n    }\r\n  }\r\n\r\n  private _collidersDirty = false;\r\n  public flagCollidersDirty() {\r\n    this._collidersDirty = true;\r\n  }\r\n\r\n  private _originalOffsets = new WeakMap<Collider, Vector>();\r\n  private _getOrSetColliderOriginalOffset(collider: Collider): Vector {\r\n    if (!this._originalOffsets.has(collider)) {\r\n      const originalOffset = collider.offset;\r\n      this._originalOffsets.set(collider, originalOffset);\r\n      return originalOffset;\r\n    } else {\r\n      return this._originalOffsets.get(collider);\r\n    }\r\n  }\r\n  public updateColliders() {\r\n    this._composite.clearColliders();\r\n    const pos = this.get(TransformComponent).pos;\r\n    for (const tile of this.tiles) {\r\n      if (tile.solid) {\r\n        for (const collider of tile.getColliders()) {\r\n          const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n          collider.offset = this.tileToWorld(vec(tile.x, tile.y))\r\n            .sub(pos)\r\n            .add(originalOffset)\r\n            .sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing\r\n          collider.owner = this;\r\n          this._composite.addCollider(collider);\r\n        }\r\n      }\r\n    }\r\n    this.collider.update();\r\n  }\r\n\r\n  /**\r\n   * Convert world space coordinates to the tile x, y coordinate\r\n   * @param worldCoordinate\r\n   */\r\n  public worldToTile(worldCoordinate: Vector): Vector {\r\n    worldCoordinate = worldCoordinate.sub(this.transform.globalPos);\r\n\r\n    const halfTileWidth = this.tileWidth / 2;\r\n    const halfTileHeight = this.tileHeight / 2;\r\n    // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n    return vec(\r\n      ~~((worldCoordinate.x / halfTileWidth + (worldCoordinate.y / halfTileHeight)) / 2),\r\n      ~~((worldCoordinate.y / halfTileHeight - (worldCoordinate.x / halfTileWidth)) / 2));\r\n  }\r\n\r\n  /**\r\n   * Given a tile coordinate, return the top left corner in world space\r\n   * @param tileCoordinate\r\n   */\r\n  public tileToWorld(tileCoordinate: Vector): Vector {\r\n    const halfTileWidth = this.tileWidth / 2;\r\n    const halfTileHeight = this.tileHeight / 2;\r\n    // The x position shifts left with every y step\r\n    const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;\r\n    // The y position needs to go down with every x step\r\n    const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;\r\n    return vec(xPos, yPos).add(this.transform.pos);\r\n  }\r\n\r\n  /**\r\n   * Returns the [[IsometricTile]] by its x and y coordinates\r\n   */\r\n  public getTile(x: number, y: number): IsometricTile | null {\r\n    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.tiles[x + y * this.columns];\r\n  }\r\n\r\n  /**\r\n   * Returns the [[IsometricTile]] by testing a point in world coordinates,\r\n   * returns `null` if no Tile was found.\r\n   */\r\n  public getTileByPoint(point: Vector): IsometricTile | null {\r\n    const tileCoord = this.worldToTile(point);\r\n    const tile = this.getTile(tileCoord.x, tileCoord.y);\r\n    return tile;\r\n  }\r\n\r\n  private _getMaxZIndex(): number {\r\n    let maxZ = Number.NEGATIVE_INFINITY;\r\n    for (const tile of this.tiles) {\r\n      const currentZ = tile.get(TransformComponent).z;\r\n      if (currentZ > maxZ) {\r\n        maxZ =  currentZ;\r\n      }\r\n    }\r\n    return maxZ;\r\n  }\r\n\r\n  /**\r\n   * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on\r\n   * @param gfx\r\n   */\r\n  public debug(gfx: ExcaliburGraphicsContext) {\r\n    gfx.save();\r\n    gfx.z = this._getMaxZIndex() + 0.5;\r\n    for (let y = 0; y < this.rows + 1; y++) {\r\n      const left = this.tileToWorld(vec(0, y));\r\n      const right = this.tileToWorld(vec(this.columns, y));\r\n      gfx.drawLine(left, right, Color.Red, 2);\r\n    }\r\n\r\n    for (let x = 0; x < this.columns + 1; x++) {\r\n      const top = this.tileToWorld(vec(x, 0));\r\n      const bottom = this.tileToWorld(vec(x, this.rows));\r\n      gfx.drawLine(top, bottom, Color.Red, 2);\r\n    }\r\n\r\n    for (const tile of this.tiles) {\r\n      gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);\r\n    }\r\n    gfx.restore();\r\n  }\r\n}","export * from './TileMap';\r\nexport * from './IsometricMap';\r\nexport * from './IsometricEntityComponent';\r\nexport * from './IsometricEntitySystem';","import { Entity } from '../../EntityComponentSystem';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\n/**\r\n * Action that can represent a sequence of actions, this can be useful in conjunction with\r\n * [[ParallelActions]] to run multiple sequences in parallel.\r\n */\r\nexport class ActionSequence implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _stopped: boolean = false;\r\n  private _sequenceContext: ActionContext;\r\n  private _sequenceBuilder: (actionContext: ActionContext) => any;\r\n  constructor(entity: Entity, actionBuilder: (actionContext: ActionContext) => any) {\r\n    this._sequenceBuilder = actionBuilder;\r\n    this._sequenceContext = new ActionContext(entity);\r\n    this._actionQueue = this._sequenceContext.getQueue();\r\n    this._sequenceBuilder(this._sequenceContext);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._actionQueue.isComplete();\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._stopped = false;\r\n    this._actionQueue.reset();\r\n  }\r\n\r\n  public clone(entity: Entity) {\r\n    return new ActionSequence(entity, this._sequenceBuilder);\r\n  }\r\n}","import { Entity } from '../../EntityComponentSystem';\r\nimport { Action } from '../Action';\r\n\r\n\r\n/**\r\n * Action that can run multiple [[Action]]s or [[ActionSequence]]s at the same time\r\n */\r\nexport class ParallelActions implements Action {\r\n  private _actions: Action[];\r\n\r\n  constructor(parallelActions: Action[]) {\r\n    this._actions = parallelActions;\r\n  }\r\n\r\n  update(delta: number): void {\r\n    for (let i = 0; i < this._actions.length; i++) {\r\n      this._actions[i].update(delta);\r\n    }\r\n  }\r\n  isComplete(entity: Entity): boolean {\r\n    return this._actions.every(a => a.isComplete(entity));\r\n  }\r\n  reset(): void {\r\n    this._actions.forEach(a => a.reset());\r\n  }\r\n  stop(): void {\r\n    this._actions.forEach(a => a.stop());\r\n  }\r\n}","export * from './ActionContext';\r\nexport * from './ActionQueue';\r\nexport * from './Actionable';\r\nexport * from './RotationType';\r\n\r\nexport * from './Action';\r\nexport * from './Action/ActionSequence';\r\nexport * from './Action/ParallelActions';\r\nexport * from './Action/Repeat';\r\nexport * from './Action/RepeatForever';\r\nexport * from './Action/Blink';\r\nexport * from './Action/Die';\r\nexport * from './Action/EaseTo';\r\nexport * from './Action/EaseBy';\r\nexport * from './Action/Fade';\r\nexport * from './Action/Follow';\r\nexport * from './Action/Meet';\r\nexport * from './Action/MoveBy';\r\nexport * from './Action/MoveTo';\r\nexport * from './Action/RotateBy';\r\nexport * from './Action/RotateTo';\r\nexport * from './Action/ScaleBy';\r\nexport * from './Action/ScaleTo';\r\nexport * from './Action/Delay';\r\n\r\nexport * from './ActionsComponent';\r\nexport * from './ActionsSystem';","import { CollisionGroup } from './CollisionGroup';\r\n\r\n/**\r\n * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur\r\n */\r\nexport class CollisionGroupManager {\r\n  // using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.\r\n  private static _STARTING_BIT = 0b1 | 0;\r\n  private static _MAX_GROUPS = 32;\r\n  private static _CURRENT_GROUP = 1;\r\n  private static _CURRENT_BIT = CollisionGroupManager._STARTING_BIT;\r\n  private static _GROUPS: Map<string, CollisionGroup> = new Map<string, CollisionGroup>();\r\n\r\n  /**\r\n   * Create a new named collision group up to a max of 32.\r\n   * @param name Name for the collision group\r\n   * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one\r\n   */\r\n  public static create(name: string, mask?: number) {\r\n    if (this._CURRENT_GROUP > this._MAX_GROUPS) {\r\n      throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);\r\n    }\r\n    if (this._GROUPS.get(name)) {\r\n      throw new Error(`Collision group ${name} already exists`);\r\n    }\r\n    const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);\r\n    this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;\r\n    this._CURRENT_GROUP++;\r\n    this._GROUPS.set(name, group);\r\n    return group;\r\n  }\r\n\r\n  /**\r\n   * Get all collision groups currently tracked by excalibur\r\n   */\r\n  public static get groups(): CollisionGroup[] {\r\n    return Array.from(this._GROUPS.values());\r\n  }\r\n\r\n  /**\r\n   * Get a collision group by it's name\r\n   * @param name\r\n   */\r\n  public static groupByName(name: string) {\r\n    return this._GROUPS.get(name);\r\n  }\r\n\r\n  /**\r\n   * Resets the managers internal group management state\r\n   */\r\n  public static reset() {\r\n    this._GROUPS = new Map<string, CollisionGroup>();\r\n    this._CURRENT_BIT = this._STARTING_BIT;\r\n    this._CURRENT_GROUP = 1;\r\n  }\r\n}\r\n","export * from './BodyComponent';\r\nexport * from './ColliderComponent';\r\nexport * from './CollisionType';\r\n\r\nexport * from './Colliders/Collider';\r\nexport * from './BoundingBox';\r\n\r\nexport * from './Colliders/Shape';\r\nexport * from './Colliders/Collider';\r\nexport * from './Colliders/CompositeCollider';\r\nexport * from './Colliders/CircleCollider';\r\nexport * from './Colliders/EdgeCollider';\r\nexport * from './Colliders/PolygonCollider';\r\nexport * from './Colliders/CollisionJumpTable';\r\nexport * from './Colliders/ClosestLineJumpTable';\r\n\r\nexport * from './Group/CollisionGroup';\r\nexport * from './Group/CollisionGroupManager';\r\n\r\nexport * from './Detection/Pair';\r\nexport * from './Detection/CollisionContact';\r\nexport * from './Detection/CollisionProcessor';\r\nexport * from './Detection/DynamicTree';\r\nexport * from './Detection/DynamicTreeCollisionProcessor';\r\n\r\nexport * from './Solver/ArcadeSolver';\r\nexport * from './Solver/ContactConstraintPoint';\r\nexport * from './Solver/RealisticSolver';\r\nexport * from './Solver/Solver';\r\n\r\nexport * from './CollisionSystem';\r\nexport * from './MotionSystem';\r\n\r\nexport * from './Physics';\r\nexport * from './Side';\r\n","import { Engine } from './../Engine';\r\nimport * as Events from './../Events';\r\nimport { Scene } from '../Scene';\r\nimport { ExcaliburGraphicsContext } from '../Graphics';\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _initialize {\r\n  _initialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n * Type guard checking for internal initialize method\r\n * @internal\r\n * @param a\r\n */\r\nexport function has_initialize(a: any): a is _initialize {\r\n  return !!a._initialize;\r\n}\r\n\r\nexport interface OnInitialize {\r\n  onInitialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnInitialize(a: any): a is OnInitialize {\r\n  return !!a.onInitialize;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _preupdate {\r\n  _preupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_preupdate(a: any): a is _preupdate {\r\n  return !!a._preupdate;\r\n}\r\n\r\nexport interface OnPreUpdate {\r\n  onPreUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPreUpdate(a: any): a is OnPreUpdate {\r\n  return !!a.onPreUpdate;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _postupdate {\r\n  _postupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_postupdate(a: any): a is _postupdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface OnPostUpdate {\r\n  onPostUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPostUpdate(a: any): a is OnPostUpdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface CanInitialize {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onInitialize(_engine: Engine): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<any>) => void): void;\r\n}\r\n\r\nexport interface SceneActivationContext<TData = undefined> {\r\n  data?: TData;\r\n  previousScene: Scene;\r\n  nextScene: Scene;\r\n  engine: Engine;\r\n}\r\n\r\nexport interface CanActivate<TData = undefined> {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onActivate(context: SceneActivationContext<TData>): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  once(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  off(eventName: Events.activate, handler?: (event: Events.ActivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanDeactivate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onDeactivate(context: SceneActivationContext<never>): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  once(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  off(eventName: Events.deactivate, handler?: (event: Events.DeactivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanUpdate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<any>) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<any>) => void): void;\r\n}\r\n\r\nexport interface OnPreDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n}\r\n\r\nexport interface OnPostDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\nexport interface CanDraw extends OnPreDraw, OnPostDraw {\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPreDraw(a: any): a is OnPreDraw {\r\n  return !!a.onPreDraw;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPostDraw(a: any): a is OnPostDraw {\r\n  return !!a.onPostDraw;\r\n}\r\n\r\nexport interface CanBeKilled {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  once(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  off(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  once(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  off(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n}\r\n","export * from './Clonable';\r\nexport * from './Audio';\r\nexport * from './AudioImplementation';\r\nexport * from './Evented';\r\nexport * from './Loadable';\r\nexport * from './LifecycleEvents';\r\nexport * from './PointerEventHandlers';\r\n","export * from './Sound';\r\nexport * from './AudioContext';\r\nexport * from './WebAudioInstance';\r\n","import { Resource } from './Resource';\r\nimport { Sprite } from '../Graphics/Sprite';\r\nimport { Color } from '../Color';\r\nimport { SpriteSheet } from '../Graphics/SpriteSheet';\r\nimport { Animation } from '../Graphics/Animation';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { ImageSource } from '../Graphics/ImageSource';\r\nimport { range } from '../Math/util';\r\n/**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n */\r\nexport class Gif implements Loadable<ImageSource[]> {\r\n  private _resource: Resource<ArrayBuffer>;\r\n\r\n  /**\r\n   * The width of the texture in pixels\r\n   */\r\n  public width: number;\r\n\r\n  /**\r\n   * The height of the texture in pixels\r\n   */\r\n  public height: number;\r\n\r\n\r\n  private _stream: Stream = null;\r\n  private _gif: ParseGif = null;\r\n  private _textures: ImageSource[] = [];\r\n  private _animation: Animation = null;\r\n  private _transparentColor: Color = null;\r\n\r\n  public data: ImageSource[];\r\n\r\n  /**\r\n   * @param path       Path to the image resource\r\n   * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]\r\n   * @param bustCache  Optionally load texture with cache busting\r\n   */\r\n  constructor(public path: string, public color: Color = Color.Magenta, public bustCache = true) {\r\n    this._resource = new Resource(path, 'arraybuffer', bustCache);\r\n    this._transparentColor = color;\r\n  }\r\n\r\n  /**\r\n   * Begins loading the texture and returns a promise to be resolved on completion\r\n   */\r\n  public async load(): Promise<ImageSource[]> {\r\n    const arraybuffer = await this._resource.load();\r\n    this._stream = new Stream(arraybuffer);\r\n    this._gif = new ParseGif(this._stream, this._transparentColor);\r\n    const images = this._gif.images.map(i => new ImageSource(i.src, false));\r\n\r\n    // Load all textures\r\n    await Promise.all(images.map(t => t.load()));\r\n    return this.data = this._textures = images;\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  /**\r\n   * Return a frame of the gif as a sprite by id\r\n   * @param id\r\n   */\r\n  public toSprite(id: number = 0): Sprite {\r\n    const sprite = this._textures[id].toSprite();\r\n    return sprite;\r\n  }\r\n\r\n  /**\r\n   * Return the gif as a spritesheet\r\n   */\r\n  public toSpriteSheet(): SpriteSheet {\r\n    const sprites: Sprite[] = this._textures.map((image) => {\r\n      return image.toSprite();\r\n    });\r\n    return new SpriteSheet({ sprites });\r\n  }\r\n\r\n  /**\r\n   * Transform the GIF into an animation with duration per frame\r\n   */\r\n  public toAnimation(durationPerFrameMs: number): Animation {\r\n    const spriteSheet: SpriteSheet = this.toSpriteSheet();\r\n    const length = spriteSheet.sprites.length;\r\n    this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);\r\n    return this._animation;\r\n  }\r\n\r\n  public get readCheckBytes(): number[] {\r\n    return this._gif.checkBytes;\r\n  }\r\n}\r\n\r\nexport interface GifFrame {\r\n  sentinel: number;\r\n  type: string;\r\n  leftPos: number;\r\n  topPos: number;\r\n  width: number;\r\n  height: number;\r\n  lctFlag: boolean;\r\n  interlaced: boolean;\r\n  sorted: boolean;\r\n  reserved: boolean[];\r\n  lctSize: number;\r\n  lzwMinCodeSize: number;\r\n  pixels: number[];\r\n}\r\n\r\nconst bitsToNum = (ba: any) => {\r\n  return ba.reduce(function (s: number, n: number) {\r\n    return s * 2 + n;\r\n  }, 0);\r\n};\r\n\r\nconst byteToBitArr = (bite: any) => {\r\n  const a = [];\r\n  for (let i = 7; i >= 0; i--) {\r\n    a.push(!!(bite & (1 << i)));\r\n  }\r\n  return a;\r\n};\r\n\r\nexport class Stream {\r\n  data: any = null;\r\n  len: number = 0;\r\n  position: number = 0;\r\n\r\n  constructor(dataArray: ArrayBuffer) {\r\n    this.data = new Uint8Array(dataArray);\r\n    this.len = this.data.byteLength;\r\n    if (this.len === 0) {\r\n      throw new Error('No data loaded from file');\r\n    }\r\n  }\r\n\r\n  public readByte = () => {\r\n    if (this.position >= this.data.byteLength) {\r\n      throw new Error('Attempted to read past end of stream.');\r\n    }\r\n    return this.data[this.position++];\r\n  };\r\n\r\n  public readBytes = (n: number) => {\r\n    const bytes = [];\r\n    for (let i = 0; i < n; i++) {\r\n      bytes.push(this.readByte());\r\n    }\r\n    return bytes;\r\n  };\r\n\r\n  public read = (n: number) => {\r\n    let s = '';\r\n    for (let i = 0; i < n; i++) {\r\n      s += String.fromCharCode(this.readByte());\r\n    }\r\n    return s;\r\n  };\r\n\r\n  public readUnsigned = () => {\r\n    // Little-endian.\r\n    const a = this.readBytes(2);\r\n    return (a[1] << 8) + a[0];\r\n  };\r\n}\r\n\r\nconst lzwDecode = function (minCodeSize: number, data: any) {\r\n  // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\r\n  let pos = 0; // Maybe this streaming thing should be merged with the Stream?\r\n\r\n  const readCode = function (size: number) {\r\n    let code = 0;\r\n    for (let i = 0; i < size; i++) {\r\n      if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\r\n        code |= 1 << i;\r\n      }\r\n      pos++;\r\n    }\r\n    return code;\r\n  };\r\n\r\n  const output: any[] = [];\r\n\r\n  const clearCode = 1 << minCodeSize;\r\n  const eoiCode = clearCode + 1;\r\n\r\n  let codeSize = minCodeSize + 1;\r\n\r\n  let dict: any[] = [];\r\n\r\n  const clear = function () {\r\n    dict = [];\r\n    codeSize = minCodeSize + 1;\r\n    for (let i = 0; i < clearCode; i++) {\r\n      dict[i] = [i];\r\n    }\r\n    dict[clearCode] = [];\r\n    dict[eoiCode] = null;\r\n  };\r\n\r\n  let code;\r\n  let last;\r\n\r\n  while (true) {\r\n    last = code;\r\n    code = readCode(codeSize);\r\n    if (code === clearCode) {\r\n      clear();\r\n      continue;\r\n    }\r\n    if (code === eoiCode) {\r\n      break;\r\n    }\r\n\r\n    if (code < dict.length) {\r\n      if (last !== clearCode) {\r\n        dict.push(dict[last].concat(dict[code][0]));\r\n      }\r\n    } else {\r\n      if (code !== dict.length) {\r\n        throw new Error('Invalid LZW code.');\r\n      }\r\n      dict.push(dict[last].concat(dict[last][0]));\r\n    }\r\n    output.push.apply(output, dict[code]);\r\n\r\n    if (dict.length === 1 << codeSize && codeSize < 12) {\r\n      // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\r\n      codeSize++;\r\n    }\r\n  }\r\n\r\n  // I don't know if this is technically an error, but some GIFs do it.\r\n  //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\r\n  return output;\r\n};\r\n\r\n// The actual parsing; returns an object with properties.\r\nexport class ParseGif {\r\n  private _st: Stream = null;\r\n  private _handler: any = {};\r\n  private _transparentColor: Color = null;\r\n  public frames: GifFrame[] = [];\r\n  public images: HTMLImageElement[] = [];\r\n  public globalColorTable: any[] = [];\r\n  public checkBytes: number[] = [];\r\n\r\n  constructor(stream: Stream, color: Color = Color.Magenta) {\r\n    this._st = stream;\r\n    this._handler = {};\r\n    this._transparentColor = color;\r\n    this.parseHeader();\r\n    this.parseBlock();\r\n  }\r\n\r\n  // LZW (GIF-specific)\r\n  parseColorTable = (entries: any) => {\r\n    // Each entry is 3 bytes, for RGB.\r\n    const ct = [];\r\n    for (let i = 0; i < entries; i++) {\r\n      const rgb: number[] = this._st.readBytes(3);\r\n      const rgba =\r\n        '#' +\r\n        rgb\r\n          .map((x: any) => {\r\n            const hex = x.toString(16);\r\n            return hex.length === 1 ? '0' + hex : hex;\r\n          })\r\n          .join('');\r\n      ct.push(rgba);\r\n    }\r\n    return ct;\r\n  };\r\n\r\n  readSubBlocks = () => {\r\n    let size, data;\r\n    data = '';\r\n    do {\r\n      size = this._st.readByte();\r\n      data += this._st.read(size);\r\n    } while (size !== 0);\r\n    return data;\r\n  };\r\n\r\n  parseHeader = () => {\r\n    const hdr: any = {\r\n      sig: null,\r\n      ver: null,\r\n      width: null,\r\n      height: null,\r\n      colorRes: null,\r\n      globalColorTableSize: null,\r\n      gctFlag: null,\r\n      sorted: null,\r\n      globalColorTable: [],\r\n      bgColor: null,\r\n      pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n    };\r\n\r\n    hdr.sig = this._st.read(3);\r\n    hdr.ver = this._st.read(3);\r\n    if (hdr.sig !== 'GIF') {\r\n      throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\r\n    }\r\n\r\n    hdr.width = this._st.readUnsigned();\r\n    hdr.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    hdr.gctFlag = bits.shift();\r\n    hdr.colorRes = bitsToNum(bits.splice(0, 3));\r\n    hdr.sorted = bits.shift();\r\n    hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    hdr.bgColor = this._st.readByte();\r\n    hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n\r\n    if (hdr.gctFlag) {\r\n      hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));\r\n      this.globalColorTable = hdr.globalColorTable;\r\n    }\r\n    if (this._handler.hdr && this._handler.hdr(hdr)) {\r\n      this.checkBytes.push(this._handler.hdr);\r\n    }\r\n  };\r\n\r\n  parseExt = (block: any) => {\r\n    const parseGCExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 4\r\n\r\n      const bits = byteToBitArr(this._st.readByte());\r\n      block.reserved = bits.splice(0, 3); // Reserved; should be 000.\r\n      block.disposalMethod = bitsToNum(bits.splice(0, 3));\r\n      block.userInput = bits.shift();\r\n      block.transparencyGiven = bits.shift();\r\n\r\n      block.delayTime = this._st.readUnsigned();\r\n\r\n      block.transparencyIndex = this._st.readByte();\r\n\r\n      block.terminator = this._st.readByte();\r\n\r\n      if (this._handler.gce && this._handler.gce(block)) {\r\n        this.checkBytes.push(this._handler.gce);\r\n      }\r\n    };\r\n\r\n    const parseComExt = (block: any) => {\r\n      block.comment = this.readSubBlocks();\r\n      if (this._handler.com && this._handler.com(block)) {\r\n        this.checkBytes.push(this._handler.com);\r\n      }\r\n    };\r\n\r\n    const parsePTExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 12\r\n      block.ptHeader = this._st.readBytes(12);\r\n      block.ptData = this.readSubBlocks();\r\n      if (this._handler.pte && this._handler.pte(block)) {\r\n        this.checkBytes.push(this._handler.pte);\r\n      }\r\n    };\r\n\r\n    const parseAppExt = (block: any) => {\r\n      const parseNetscapeExt = (block: any) => {\r\n        this.checkBytes.push(this._st.readByte()); // Always 3\r\n        block.unknown = this._st.readByte(); // Q: Always 1? What is this?\r\n        block.iterations = this._st.readUnsigned();\r\n        block.terminator = this._st.readByte();\r\n        if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {\r\n          this.checkBytes.push(this._handler.app);\r\n        }\r\n      };\r\n\r\n      const parseUnknownAppExt = (block: any) => {\r\n        block.appData = this.readSubBlocks();\r\n        // FIXME: This won't work if a handler wants to match on any identifier.\r\n        if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {\r\n          this.checkBytes.push(this._handler.app[block.identifier]);\r\n        }\r\n      };\r\n\r\n      this.checkBytes.push(this._st.readByte()); // Always 11\r\n      block.identifier = this._st.read(8);\r\n      block.authCode = this._st.read(3);\r\n      switch (block.identifier) {\r\n        case 'NETSCAPE':\r\n          parseNetscapeExt(block);\r\n          break;\r\n        default:\r\n          parseUnknownAppExt(block);\r\n          break;\r\n      }\r\n    };\r\n\r\n    const parseUnknownExt = (block: any) => {\r\n      block.data = this.readSubBlocks();\r\n      if (this._handler.unknown && this._handler.unknown(block)) {\r\n        this.checkBytes.push(this._handler.unknown);\r\n      }\r\n    };\r\n\r\n    block.label = this._st.readByte();\r\n    switch (block.label) {\r\n      case 0xf9:\r\n        block.extType = 'gce';\r\n        parseGCExt(block);\r\n        break;\r\n      case 0xfe:\r\n        block.extType = 'com';\r\n        parseComExt(block);\r\n        break;\r\n      case 0x01:\r\n        block.extType = 'pte';\r\n        parsePTExt(block);\r\n        break;\r\n      case 0xff:\r\n        block.extType = 'app';\r\n        parseAppExt(block);\r\n        break;\r\n      default:\r\n        block.extType = 'unknown';\r\n        parseUnknownExt(block);\r\n        break;\r\n    }\r\n  };\r\n\r\n  parseImg = (img: any) => {\r\n    const deinterlace = (pixels: any, width: any) => {\r\n      // Of course this defeats the purpose of interlacing. And it's *probably*\r\n      // the least efficient way it's ever been implemented. But nevertheless...\r\n\r\n      const newPixels = new Array(pixels.length);\r\n      const rows = pixels.length / width;\r\n      const cpRow = (toRow: any, fromRow: any) => {\r\n        const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\r\n        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\r\n      };\r\n\r\n      const offsets = [0, 4, 2, 1];\r\n      const steps = [8, 8, 4, 2];\r\n\r\n      let fromRow = 0;\r\n      for (let pass = 0; pass < 4; pass++) {\r\n        for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\r\n          cpRow(toRow, fromRow);\r\n          fromRow++;\r\n        }\r\n      }\r\n\r\n      return newPixels;\r\n    };\r\n\r\n    img.leftPos = this._st.readUnsigned();\r\n    img.topPos = this._st.readUnsigned();\r\n    img.width = this._st.readUnsigned();\r\n    img.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    img.lctFlag = bits.shift();\r\n    img.interlaced = bits.shift();\r\n    img.sorted = bits.shift();\r\n    img.reserved = bits.splice(0, 2);\r\n    img.lctSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    if (img.lctFlag) {\r\n      img.lct = this.parseColorTable(1 << (img.lctSize + 1));\r\n    }\r\n\r\n    img.lzwMinCodeSize = this._st.readByte();\r\n\r\n    const lzwData = this.readSubBlocks();\r\n\r\n    img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\r\n\r\n    if (img.interlaced) {\r\n      // Move\r\n      img.pixels = deinterlace(img.pixels, img.width);\r\n    }\r\n\r\n    this.frames.push(img);\r\n    this.arrayToImage(img);\r\n    if (this._handler.img && this._handler.img(img)) {\r\n      this.checkBytes.push(this._handler);\r\n    }\r\n  };\r\n\r\n  public parseBlock = () => {\r\n    const block = {\r\n      sentinel: this._st.readByte(),\r\n      type: ''\r\n    };\r\n    const blockChar = String.fromCharCode(block.sentinel);\r\n    switch (blockChar) {\r\n      case '!':\r\n        block.type = 'ext';\r\n        this.parseExt(block);\r\n        break;\r\n      case ',':\r\n        block.type = 'img';\r\n        this.parseImg(block);\r\n        break;\r\n      case ';':\r\n        block.type = 'eof';\r\n        if (this._handler.eof && this._handler.eof(block)) {\r\n          this.checkBytes.push(this._handler.eof);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Unknown block: 0x' + block.sentinel.toString(16));\r\n    }\r\n\r\n    if (block.type !== 'eof') {\r\n      this.parseBlock();\r\n    }\r\n  };\r\n\r\n  arrayToImage = (frame: GifFrame) => {\r\n    let count = 0;\r\n    const c = document.createElement('canvas');\r\n    c.id = count.toString();\r\n    c.width = frame.width;\r\n    c.height = frame.height;\r\n    count++;\r\n    const context = c.getContext('2d');\r\n    const pixSize = 1;\r\n    let y = 0;\r\n    let x = 0;\r\n    for (let i = 0; i < frame.pixels.length; i++) {\r\n      if (x % frame.width === 0) {\r\n        y++;\r\n        x = 0;\r\n      }\r\n      if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {\r\n        context.fillStyle = `rgba(0, 0, 0, 0)`;\r\n      } else {\r\n        context.fillStyle = this.globalColorTable[frame.pixels[i]];\r\n      }\r\n\r\n      context.fillRect(x, y, pixSize, pixSize);\r\n      x++;\r\n    }\r\n    const img = new Image();\r\n    img.src = c.toDataURL();\r\n    this.images.push(img);\r\n  };\r\n}\r\n","export * from './Resource';\r\nexport * from './Sound/Index';\r\nexport * from './Gif';\r\n","export * from './Component';\r\nexport * from './Entity';\r\nexport * from './EntityManager';\r\nexport * from './Query';\r\nexport * from './QueryManager';\r\nexport * from './System';\r\nexport * from './SystemManager';\r\nexport * from './World';\r\n\r\nexport * from './Components/TransformComponent';\r\nexport * from './Components/MotionComponent';\r\n","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Graphic } from './Graphic';\r\n\r\nexport interface LineOptions {\r\n  start: Vector;\r\n  end: Vector;\r\n  color?: Color;\r\n  thickness?: number;\r\n}\r\nexport class Line extends Graphic {\r\n  readonly start: Vector;\r\n  readonly end: Vector;\r\n  color: Color = Color.Black;\r\n  thickness: number = 1;\r\n  constructor(options: LineOptions) {\r\n    super();\r\n    const { start, end, color, thickness } = options;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.color = color ?? this.color;\r\n    this.thickness = thickness ?? this.thickness;\r\n    const { width, height } = BoundingBox.fromPoints([start, end]);\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, _x: number, _y: number): void {\r\n    ctx.drawLine(this.start, this.end, this.color, this.thickness);\r\n  }\r\n\r\n  clone(): Line {\r\n    return new Line({\r\n      start: this.start,\r\n      end: this.end,\r\n      color: this.color,\r\n      thickness: this.thickness\r\n    });\r\n  }\r\n}","import { ImageFiltering } from '.';\r\nimport { Vector, vec } from '../Math/vector';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface PolygonOptions {\r\n  points: Vector[];\r\n}\r\n\r\n/**\r\n * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Polygons default to [[ImageFiltering.Blended]]\r\n */\r\nexport class Polygon extends Raster {\r\n  private _points: Vector[];\r\n  public get points(): Vector[] {\r\n    return this._points;\r\n  }\r\n  public set points(points: Vector[]) {\r\n    this._points = points;\r\n    const min = this.minPoint;\r\n    this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;\r\n    this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;\r\n    this.flagDirty();\r\n  }\r\n\r\n  public get minPoint() {\r\n    const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);\r\n    const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);\r\n    return vec(minX, minY);\r\n  }\r\n\r\n  constructor(options: RasterOptions & PolygonOptions) {\r\n    super(options);\r\n    this.points = options.points;\r\n    this.filtering = ImageFiltering.Blended;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Polygon {\r\n    return new Polygon({\r\n      points: this.points.map((p) => p.clone()),\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.points && this.points.length) {\r\n      ctx.beginPath();\r\n      // Iterate through the supplied points and construct a 'polygon'\r\n      const min = this.minPoint.negate();\r\n      const firstPoint = this.points[0].add(min);\r\n      ctx.moveTo(firstPoint.x, firstPoint.y);\r\n      this.points.forEach((point) => {\r\n        ctx.lineTo(point.x + min.x, point.y + min.y);\r\n      });\r\n      ctx.lineTo(firstPoint.x, firstPoint.y);\r\n      ctx.closePath();\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","// Graphics\r\nexport * from './Graphic';\r\nexport * from './Sprite';\r\nexport * from './SpriteSheet';\r\nexport * from './GraphicsGroup';\r\nexport * from './ImageSource';\r\nexport * from './Animation';\r\nexport * from './Line';\r\n\r\n// Graphics ECS\r\nexport * from './GraphicsComponent';\r\nexport * from './DebugGraphicsComponent';\r\nexport * from './GraphicsSystem';\r\nexport * from './OffscreenSystem';\r\nexport * from './ParallaxComponent';\r\n\r\n// Raster graphics\r\nexport * from './Raster';\r\nexport * from './Circle';\r\nexport * from './Rectangle';\r\nexport * from './Polygon';\r\nexport * from './Text';\r\nexport * from './FontCommon';\r\nexport * from './Font';\r\nexport * from './SpriteFont';\r\nexport * from './Canvas';\r\n\r\nexport * from './Context/ExcaliburGraphicsContext';\r\nexport * from './Context/ExcaliburGraphicsContext2DCanvas';\r\nexport * from './Context/ExcaliburGraphicsContextWebGL';\r\n\r\nexport * from './Context/debug-text';\r\n\r\n// Post Processor\r\nexport * from './PostProcessor/PostProcessor';\r\nexport * from './PostProcessor/ScreenShader';\r\nexport * from './PostProcessor/ColorBlindnessMode';\r\nexport * from './PostProcessor/ColorBlindnessPostProcessor';\r\n\r\nexport * from './Context/texture-loader';\r\nexport * from './Filtering';\r\n\r\n\r\n// Rendering\r\nexport * from './Context/shader';\r\nexport * from './Context/vertex-buffer';\r\nexport * from './Context/vertex-layout';\r\nexport * from './Context/quad-index-buffer';\r\nexport * from './Context/webgl-adapter';\r\n\r\n// Util\r\n\r\nimport * as webgl from './Context/webgl-util';\r\nexport { webgl };","/**\r\n * @module\r\n * Provides support for mice, keyboards, and controllers.\r\n */\r\n\r\n/**\r\n * @typedoc\r\n */\r\nexport * from './Gamepad';\r\nexport * from './PointerScope';\r\nexport * from './PointerType';\r\nexport * from './PointerSystem';\r\nexport * from './PointerComponent';\r\nexport * from './PointerEventReceiver';\r\nexport * from './Keyboard';\r\nexport * from './EngineInput';\r\nexport * from './CapturePointerConfig';\r\n\r\nexport * from './NativePointerButton';\r\nexport * from './PointerButton';\r\nexport * from './WheelDeltaMode';\r\nexport * from './PointerEvent';\r\nexport * from './WheelEvent';\r\n","export * from './Util';\r\n\r\nexport * from './Log';\r\n\r\nexport * from './Observable';\r\n\r\nexport * from './EasingFunctions';\r\n\r\nimport * as drawUtil from './DrawUtil';\r\nexport { drawUtil as DrawUtil };\r\n","import { Future } from './Future';\r\n\r\nclass AsyncWaitQueue<T> {\r\n  // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e\r\n  private _queue: Future<T>[] = [];\r\n\r\n  public get length(): number {\r\n    return this._queue.length;\r\n  }\r\n\r\n  public enqueue(): Promise<T> {\r\n    const future = new Future<T>();\r\n    this._queue.push(future);\r\n    return future.promise;\r\n  }\r\n\r\n  public dequeue(value: T): void {\r\n    const future = this._queue.shift();\r\n    future.resolve(value);\r\n  }\r\n}\r\n\r\n/**\r\n * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`\r\n *\r\n * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work\r\n * around browser limitations like max Image.decode() calls in chromium being 256.\r\n */\r\nexport class Semaphore {\r\n  private _waitQueue = new AsyncWaitQueue();\r\n  constructor(private _count: number) { }\r\n\r\n  public get count() {\r\n    return this._count;\r\n  }\r\n\r\n  public get waiting() {\r\n    return this._waitQueue.length;\r\n  }\r\n\r\n  public async enter() {\r\n    if (this._count !== 0) {\r\n      this._count--;\r\n      return Promise.resolve();\r\n    }\r\n    return this._waitQueue.enqueue();\r\n  }\r\n\r\n  public exit(count: number = 1) {\r\n    if (count === 0) {\r\n      return;\r\n    }\r\n    while (count !== 0 && this._waitQueue.length !== 0) {\r\n      this._waitQueue.dequeue(null);\r\n      count--;\r\n    }\r\n    this._count += count;\r\n  }\r\n}","/**\r\n * The current Excalibur version string\r\n * @description `process.env.__EX_VERSION` gets replaced by Webpack on build\r\n */\r\nexport const EX_VERSION = process.env.__EX_VERSION;\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\n\r\n// This file is used as the bundle entry point and exports everything\r\n// that will be exposed as the `ex` global variable.\r\nexport * from './Flags';\r\nexport * from './Id';\r\nexport * from './Engine';\r\nexport * from './Screen';\r\nexport { Actor, ActorArgs } from './Actor';\r\nexport * from './Math/Index';\r\nexport * from './Camera';\r\nexport * from './Class';\r\nexport * from './Configurable';\r\nexport * from './Debug/index';\r\nexport * from './EventDispatcher';\r\nexport * from './Events/MediaEvents';\r\nexport * from './Events';\r\nexport * from './Label';\r\nexport { FontStyle, FontUnit, TextAlign, BaseAlign } from './Graphics/FontCommon';\r\nexport * from './Loader';\r\nexport { Particle, ParticleEmitter, ParticleArgs, ParticleEmitterArgs, EmitterType } from './Particles';\r\nexport * from './Collision/Physics';\r\nexport * from './Scene';\r\n\r\nexport * from './TileMap/index';\r\n\r\nexport * from './Timer';\r\nexport * from './Trigger';\r\nexport * from './ScreenElement';\r\n\r\nexport * from './Actions/Index';\r\nexport * from './Collision/Index';\r\n\r\nexport * from './Interfaces/Index';\r\nexport * from './Resources/Index';\r\n\r\nexport * from './EntityComponentSystem/index';\r\n\r\nexport * from './Color';\r\n\r\nexport * from './Graphics/index';\r\n\r\n// ex.Events namespace\r\nimport * as events from './Events';\r\nexport { events as Events };\r\n\r\n// ex.Input namespace\r\nimport * as input from './Input/Index';\r\nexport { input as Input };\r\nexport { PointerComponent } from './Input/Index';\r\nexport { PointerSystem } from './Input/PointerSystem';\r\n\r\n// ex.Util namespaces\r\nimport * as util from './Util/Index';\r\nexport { util as Util };\r\n\r\nexport * from './Util/Browser';\r\nexport * from './Util/Decorators';\r\nexport * from './Util/Detector';\r\nexport * from './Util/EasingFunctions';\r\nexport * from './Util/Observable';\r\nexport * from './Util/Log';\r\nexport * from './Util/Pool';\r\nexport * from './Util/Fps';\r\nexport * from './Util/Clock';\r\nexport * from './Util/WebAudio';\r\nexport * from './Util/Toaster';\r\nexport * from './Util/StateMachine';\r\nexport * from './Util/Future';\r\nexport * from './Util/Semaphore';\r\n\r\n// ex.Deprecated\r\n// import * as deprecated from './Deprecated';\r\n// export { deprecated as Deprecated };\r\n// export * from './Deprecated';\r\n"],"names":["$2c23f148d58cd887$var$__webpack_modules__","module","__unused_webpack_exports","__webpack_require__","entryUnbind","exports","path","Object","keys","isCallable","tryToString","$TypeError","TypeError","argument","isObject","$String","String","toIndexedObject","toAbsoluteIndex","lengthOfArrayLike","createMethod","IS_INCLUDES","$this","el","fromIndex","value","O","length","index","includes","indexOf","fails","METHOD_NAME","method","call","createProperty","$Array","Array","max","Math","start","end","k","fin","undefined","result","n","arraySlice","floor","mergeSort","array","comparefn","middle","insertionSort","merge","element","j","i","left","right","llength","rlength","lindex","rindex","uncurryThis","toString","stringSlice","slice","it","TO_STRING_TAG_SUPPORT","classofRaw","TO_STRING_TAG","wellKnownSymbol","$Object","CORRECT_ARGUMENTS","arguments","tryGet","key","error","tag","callee","hasOwn","ownKeys","getOwnPropertyDescriptorModule","definePropertyModule","target","source","exceptions","defineProperty","f","getOwnPropertyDescriptor","DESCRIPTORS","createPropertyDescriptor","object","bitmap","enumerable","configurable","writable","toPropertyKey","propertyKey","makeBuiltIn","defineGlobalProperty","options","simple","name","global","unsafe","nonConfigurable","nonWritable","P","get","document1","document","EXISTS","createElement","firefox","userAgent","match","UA","test","getBuiltIn","version","process","Deno","versions","v8","split","webkit","CONSTRUCTOR","METHOD","prototype","createNonEnumerableProperty","defineBuiltIn","copyConstructorProperties","isForced","targetProperty","sourceProperty","descriptor","TARGET","GLOBAL","STATIC","stat","dontCallGetSet","forced","sham","exec","bind","hasOwnProperty","NATIVE_BIND","Function","apply","FunctionPrototype","getDescriptor","CONFIGURABLE","PROPER","fn","namespace","aCallable","V","func","check","globalThis","window","self","g","toObject","a","classof","propertyIsEnumerable","store","functionToString","inspectSource","set","has","NATIVE_WEAK_MAP","shared","sharedKey","hiddenKeys","OBJECT_ALREADY_INITIALIZED","TypeError1","WeakMap1","WeakMap","state","wmget","wmhas","wmset","metadata","facade","STATE","enforce","getterFor","TYPE","type","replacement","feature","detection","data","normalize","POLYFILL","NATIVE","string","replace","toLowerCase","isPrototypeOf","USE_SYMBOL_AS_UID","$Symbol","toLength","obj","CONFIGURABLE_FUNCTION_NAME","InternalStateModule","enforceInternalState","getInternalState","CONFIGURABLE_LENGTH","TEMPLATE","getter","setter","arity","constructor","join","ceil","trunc","x","V8_VERSION","getOwnPropertySymbols","symbol","Symbol","__unused_webpack_module","IE8_DOM_DEFINE","V8_PROTOTYPE_DEFINE_BUG","anObject","$defineProperty","$getOwnPropertyDescriptor","ENUMERABLE","WRITABLE","Attributes","current","propertyIsEnumerableModule","internalObjectKeys","enumBugKeys","concat","getOwnPropertyNames","push","names","$propertyIsEnumerable","NASHORN_BUG","input","pref","val","valueOf","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","uid","SHARED","IS_PURE","mode","copyright","license","toIntegerOrInfinity","min","integer","IndexedObject","requireObjectCoercible","number","isSymbol","getMethod","ordinaryToPrimitive","TO_PRIMITIVE","exoticToPrim","toPrimitive","id","postfix","random","NATIVE_SYMBOL","iterator","WellKnownSymbolsStore","Symbol1","symbolFor","createWellKnownSymbol","withoutSetter","description","$","deletePropertyOrThrow","internalSort","arrayMethodIsStrict","FF","IE_OR_EDGE","V8","WEBKIT","un$Sort","sort","FAILS_ON_UNDEFINED","FAILS_ON_NULL","STRICT_METHOD","STABLE_SORT","code","chr","fromCharCode","v","b","charAt","proto","itemsLength","items","arrayLength","y","nativeKeys","__webpack_exports__","d","__WEBPACK_DEFAULT_EXPORT__","_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__","_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default","_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__","___CSS_LOADER_EXPORT___","_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default","cssWithMappingToString","list","map","item","content","needLayer","modules","media","dedupe","supports","layer","alreadyImportedModules","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","sources","sourceRoot","$2c23f148d58cd887$var$__webpack_module_cache__","$2c23f148d58cd887$var$__webpack_require__","moduleId","cachedModule","__esModule","definition","o","e","prop","r","toStringTag","$2c23f148d58cd887$var$__webpack_exports__","ActionContext","ActionQueue","ActionSequence","ActionsComponent","ActionsSystem","ActivateEvent","Actor","AddedComponent","AddedEntity","AffineMatrix","Animation","AnimationDirection","AnimationStrategy","ArcadeSolver","AudioContextFactory","Axis","BaseAlign","Blink","BodyComponent","BoundingBox","BroadphaseStrategy","BrowserComponent","BrowserEvents","Camera","Canvas","Circle","CircleCollider","Class","Clock","ClosestLine","ClosestLineJumpTable","Collider","ColliderComponent","CollisionContact","CollisionEndEvent","CollisionGroup","CollisionGroupManager","CollisionJumpTable","CollisionPostSolveEvent","CollisionPreSolveEvent","CollisionResolutionStrategy","CollisionStartEvent","CollisionSystem","CollisionType","Color","ColorBlindFlags","ColorBlindnessMode","ColorBlindnessPostProcessor","Component","CompositeCollider","Configurable","ConsoleAppender","ContactConstraintPoint","ContactEndEvent","ContactStartEvent","CoordPlane","DeactivateEvent","Debug","DebugGraphicsComponent","DebugSystem","DebugText","DegreeOfFreedom","Delay","Detector","Die","Direction","DisplayMode","DynamicTree","DynamicTreeCollisionProcessor","EX_VERSION","EaseBy","EaseTo","EasingFunctions","EdgeCollider","ElasticToActorStrategy","EmitterType","Engine","EnterTriggerEvent","EnterViewPortEvent","Entity","EntityManager","EventDispatcher","EventTypes","Events_namespaceObject","ExResponse","ExcaliburGraphicsContext2DCanvas","ExcaliburGraphicsContextWebGL","ExcaliburWebGLContextAccessor","ExitTriggerEvent","ExitViewPortEvent","Fade","Flags","Follow","Font","FontStyle","FontUnit","FpsSampler","FrameStats","Future","GameEvent","GameStartEvent","GameStopEvent","GamepadAxisEvent","GamepadButtonEvent","GamepadConnectEvent","GamepadDisconnectEvent","Gif","GlobalCoordinates","Graphic","GraphicsComponent","GraphicsGroup","GraphicsLayer","GraphicsLayers","GraphicsSystem","HiddenEvent","ImageFiltering","ImageSource","InitializeEvent","Input_Index_namespaceObject","Integrator","IsometricEntityComponent","IsometricEntitySystem","IsometricMap","IsometricTile","KillEvent","Label","LimitCameraBoundsStrategy","Line","LineSegment","Loader","LockCameraToActorAxisStrategy","LockCameraToActorStrategy","LogLevel","Logger","Matrix","MatrixLocations","MediaEvent","Meet","MotionComponent","MotionSystem","MoveBy","MoveTo","NativeSoundEvent","NativeSoundProcessedEvent","Observable","OffscreenSystem","Pair","ParallaxComponent","ParallelActions","ParseGif","Particle","ParticleEmitter","Physics","PhysicsStats","PointerComponent","PointerSystem","Polygon","PolygonCollider","Pool","PostCollisionEvent","PostDebugDrawEvent","PostDrawEvent","PostFrameEvent","PostKillEvent","PostUpdateEvent","PreCollisionEvent","PreDebugDrawEvent","PreDrawEvent","PreFrameEvent","PreKillEvent","PreUpdateEvent","Projection","QuadIndexBuffer","Query","QueryManager","RadiusAroundActorStrategy","Random","Raster","Ray","RealisticSolver","Rectangle","RemovedComponent","RemovedEntity","Repeat","RepeatForever","Resolution","Resource","RotateBy","RotateTo","RotationType","ScaleBy","ScaleTo","Scene","Screen","ScreenAppender","ScreenElement","ScreenShader","ScrollPreventionMode","Semaphore","Shader","Shape","Side","Sound","Sprite","SpriteFont","SpriteSheet","StandardClock","StateMachine","StrategyContainer","Stream","System","SystemManager","SystemType","TagComponent","TestClock","Text","TextAlign","TextureLoader","Tile","TileMap","Timer","Toaster","Transform","TransformComponent","TreeNode","Trigger","TwoPI","Util_Index_namespaceObject","Vector","VectorView","VertexBuffer","VertexLayout","VisibleEvent","WebAudio","WebAudioInstance","World","canonicalizeAngle","clamp","createId","frac","hasGraphicsTick","hasOnInitialize","hasOnPostUpdate","hasOnPreUpdate","hasPostDraw","hasPreDraw","has_initialize","has_postupdate","has_preupdate","isAddedComponent","isAddedSystemEntity","isRemoveSystemEntity","isRemovedComponent","isScreenElement","maxMessages","obsolete","pixelSnapEpsilon","randomInRange","randomIntInRange","range","resetObsoleteCounter","sign","toDegrees","toRadians","vec","webgl_util_namespaceObject","PointerScope","Keys","Buttons","Axes","WheelDeltaMode","NativePointerButton","PointerButton","PointerType","getAttributeComponentSize","getAttributePointerType","getGlTypeSizeBytes","DrawUtil_namespaceObject","circle","line","point","roundRect","vector","Gamepad","Gamepads","KeyEvent","Keyboard","PointerEvent","PointerEventReceiver","WheelEvent","polyfill","audioContext","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setInterval","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","AudioContext","webkitAudioContext","ctx","replaceMe","decodeAudioData","arrayBuffer","Promise","resolve","reject","mozAudioContext","msAudioContext","oAudioContext","devicePixelRatio","addItemToArray","contains","delay","fail","getPosition","removeItemFromArray","useCanvasGraphicsContext","enable","freeze","_FROZEN","_reset","_FLAGS","flagName","Error","disable","isEnabled","show","seed","_lowerMask","_upperMask","_w","_n","_m","_a","_u","_s","_b","_t","_c","_l","_f","_mt","Date","now","s","_index","_twist","mag01","nextInt","next","floating","bool","likelihood","pickOne","pickSet","numPicks","allowDuplicates","_pickSetWithDuplicates","_pickSetWithoutDuplicates","currentPick","tempArray","splice","shuffle","swap","randomIndex","d4","d6","d8","d10","d12","d20","PI","angle","tmpAngle","radians","degrees","from","to","_x","round","_y","Zero","One","Half","Up","Down","Left","Right","fromAngle","cos","sin","isValid","isNaN","Infinity","distance","vec1","vec2","sqrt","pow","setTo","equals","tolerance","abs","deltaX","deltaY","squareDistance","clampMagnitude","magnitude","size","newSize","newLength","scale","average","add","sizeOrScale","dest","sub","addEqual","subEqual","scaleEqual","dot","cross","num","perpendicular","normal","negate","toAngle","atan2","rotate","anchor","sinAngle","cosAngle","clone","fixed","toFixed","_appenders","defaultLevel","Info","_INSTANCE","addAppender","getInstance","appender","clearAppenders","_log","level","args","len","log","debug","info","warn","Warn","fatal","Fatal","console","consoleArgs","unshift","width","height","_messages","_canvas","innerWidth","innerHeight","style","position","_ctx","getContext","body","appendChild","message","clearRect","pos","opacity","fillStyle","fillText","fromRGB","fromRGBString","parseInt","parseFloat","fromHex","hex","fromHSL","h","l","temp","HSLColor","toRGBA","lighten","factor","fromRGBA","darken","saturate","desaturate","multiply","color","newR","newG","newB","newA","screen","color1","invert","color2","equal","format","toHSLA","toHex","_componentToHex","c","Black","White","Gray","LightGray","DarkGray","Yellow","Orange","Red","Vermilion","Rose","Magenta","Violet","Blue","Azure","Cyan","Viridian","Green","Chartreuse","Transparent","ExcaliburBlue","hue2rgb","p","q","t","getOpposite","side","Top","Bottom","None","fromDirection","direction","directions","directionEnum","Number","MAX_VALUE","maxIndex","leftOrOptions","top","bottom","getSideFromIntersection","intersection","fromPoints","points","minX","minY","maxX","maxY","fromDimension","hasZeroDimensions","center","translate","getPoints","shifted","transform","matrix","xa1","xa2","xb1","xb2","ya1","ya2","yb1","yb2","matrixPos","getPerimeter","wx","wy","results","rayCast","ray","farClipDistance","tmin","tmax","xinv","dir","yinv","tx1","tx2","ty1","ty2","rayCastTime","combine","other","compositeBB","dimensions","overlaps","epsilon","totalBoundingBox","intersect","overlapX","overlapY","intersectWithSide","bb","draw","ex","drawRect","_isCompleted","promise","_resolver","_rejecter","isCompleted","oLeft","oTop","calcOffsetLeft","parent","offsetLeft","offsetParent","calcOffsetTop","offsetTop","milliseconds","clock","future","schedule","setTimeout","Float32Array","_scaleX","_scaleSignX","_scaleY","_scaleSignY","ortho","near","far","mat","toDOMMatrix","DOMMatrix","fromFloat32Array","identity","reset","translation","sx","sy","rotation","angleRadians","vectorOrMatrix","resultX","resultY","a11","a21","a31","a41","a12","a22","a32","a42","a13","a23","a33","a43","a14","a24","a34","a44","b11","b21","b31","b41","b12","b22","b32","b42","b13","b23","b33","b43","b14","b24","b34","b44","getScale","setPosition","sine","cosine","setRotation","currentScale","getRotation","getScaleY","getScaleX","xscale","yscale","setScaleX","setScaleY","setScale","getBasisDeterminant","getAffineInverse","det","inverseDet","m","tx","ty","isIdentity","Float64Array","_scale","determinant","inverse","to4x4","TransformStack","_transforms","_currentTransform","save","restore","pop","StateStack","_states","_currentState","_getDefaultState","z","tint","_cloneState","_bubbles","bubbles","stopPropagation","delta","engine","prevStats","stats","gamepad","button","axis","actor","contact","context","_handlers","_wiredEventDispatchers","_deferedHandlerRemovals","clear","_processDeferredHandlerRemovals","eventHandler","_removeHandler","handler","emit","eventName","event","on","off","eventHandlers","once","metaHandler","ev","wire","eventDispatcher","unwire","responseType","bustCache","logger","events","isLoaded","_cacheBust","uri","query","load","request","XMLHttpRequest","open","addEventListener","status","response","statusText","send","watch","change","__isProxy","Proxy","watchAny","_d","_e","_ID","_transformStale","showDebug","_flipHorizontal","_flipVertical","_rotation","_origin","_width","_height","origin","flipHorizontal","flipVertical","isStale","cloneGraphicOptions","localBounds","_preDraw","_drawImage","_postDraw","_rotate","_flip","scaleDirX","scaleDirY","_logger","_dirty","_logNotLoadedWarning","image","sourceView","destSize","_updateSpriteDimensions","ready","then","newWidth","newHeight","nativeWidth","nativeHeight","drawImage","register","_GL","_MAX_TEXTURE_SIZE","getParameter","MAX_TEXTURE_SIZE","_TEXTURE_MAP","filtering","forceUpdate","gl","tex","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","createTexture","checkImageSizeSupportedAndLog","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","filterMode","TEXTURE_MIN_FILTER","Pixel","NEAREST","LINEAR","TEXTURE_MAG_FILTER","delete","deleteTexture","originalSrc","dataset","_LOGGER","Blended","Map","Image","_readyFuture","_resource","_filtering","endsWith","naturalWidth","naturalHeight","_src","src","url","blob","URL","createObjectURL","loadedFuture","onload","setAttribute","toSprite","unload","sprites","rows","columns","getSprite","spriteIndex","fromImageSourceWithSourceViews","sourceViews","fromImageSource","spacing","grid","cols","spriteWidth","spriteHeight","originOffset","margin","offsetDefaults","marginDefaults","_text","alphabet","shadow","caseInsensitive","_alreadyWarnedAlphabet","_alreadyWarnedSpriteSheet","spriteSheet","_getCharacterSprites","text","textToRender","toLocaleLowerCase","letterIndex","letter","letterSprite","measureText","lines","maxWidthLine","reduce","sprite","xCursor","yCursor","render","_color","bounds","offset","fontSheet","_imageSource","_spriteSheet","_spriteFont","write","RenderSource","_gl","_texture","use","activeTexture","TEXTURE0","RenderTarget","_setupFramebuffer","setResolution","_frameTexture","frameBuffer","_frameBuffer","frameTexture","attachmentPoint","COLOR_ATTACHMENT0","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","toRenderSource","viewport","FLOAT","SHORT","UNSIGNED_SHORT","BYTE","LOW_FLOAT","HIGH_FLOAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","uniforms","attributes","_compiled","vertexSource","fragmentSource","compiled","useProgram","program","_ACTIVE_SHADER_INSTANCE","isCurrentlyBound","compile","vertexShader","_compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","_createProgram","getAttributes","attribute","getUniforms","uniform","uniformCount","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","uniformLocation","getUniformLocation","glType","location","attributeCount","ACTIVE_ATTRIBUTES","getActiveAttrib","attributeLocation","getAttribLocation","normalized","setTexture","slotNumber","texture","setUniformInt","setUniform","setUniformIntArray","setUniformBoolean","setUniformFloat","setUniformFloatArray","setUniformFloatVector","setUniformMatrix","uniformType","createProgram","attachShader","linkProgram","success","LINK_STATUS","getProgramInfoLog","typeName","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","errorInfo","getShaderInfoLog","_processSourceForError","errorLineStart","search","errorLineEnd","_","error2","buffer","createBuffer","bufferData","bindBuffer","ARRAY_BUFFER","STATIC_DRAW","DYNAMIC_DRAW","upload","count","bufferSubData","_layout","_attributes","_vertexTotalSizeBytes","vertexBuffer","_vertexBuffer","_shader","initialize","totalVertexSizeBytes","shaderAttributes","attrib","componentsPerVertex","vertAttribute","typeSize","uploadBuffer","vert","vertexAttribPointer","enableVertexAttribArray","GraphicsDiagnostics","DrawCallCount","DrawnImagesCount","LineRenderer","priority","_maxLines","_vertexIndex","_lineCount","_context","_isFull","flush","getTransform","finalStart","finalEnd","hasPendingDraws","drawArrays","LINES","PointRenderer","_maxPoints","_pointCount","_buffer","snapToPixel","finalPoint","POINTS","ScreenPassPainter","renderWithPostProcessor","postprocessor","getShader","getLayout","TRIANGLES","renderToScreen","numberOfQuads","useUint16","ELEMENT_ARRAY_BUFFER","totalVertices","maxUint16Index","bufferGlType","Uint16Array","Uint32Array","currentQuad","ImageRenderer","_maxImages","_maxTextures","_imageCount","_textures","MAX_TEXTURE_IMAGE_UNITS","transformedFrag","_transformFragmentSource","_quads","maxTextures","newSource","texturePickerBuilder","_addImageAsTexture","_bindTextures","_getTextureIdForImage","swidth","sheight","dx","dy","dwidth","dheight","view","sw","sh","topLeft","topRight","bottomLeft","bottomRight","textureId","imageWidth","imageHeight","uvx0","uvy0","uvx1","uvy1","drawElements","RectangleRenderer","_maxRectangles","_rectangleCount","drawLine","drawRectangle","thickness","halfThick","startTop","startBottom","endTop","endBottom","stroke","strokeThickness","CircleRenderer","_maxCircles","_circleCount","radius","builder","recycler","maxObjects","totalAllocations","objects","disableWarnings","preallocate","using","done","borrow","poolIndex","DrawCall","ExcaliburGraphicsContextWebGLDebug","_webglCtx","_debugText","rectOptions","lineOptions","drawPoint","pointOptions","drawText","_renderers","_isDrawLifecycle","useDrawSorting","_drawCallPool","instance","renderer","_drawCalls","_postProcessTargets","_postprocessors","_transform","_state","smoothing","backgroundColor","_alreadyWarnedDrawLifecycle","canvasElement","enableTransparency","__gl","antialias","premultipliedAlpha","alpha","depth","powerPreference","_init","canvas","_ortho","checkIfResolutionSupported","dim","supported","clearColor","COLOR_BUFFER_BIT","BLEND","blendEquation","FUNC_ADD","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","blendEquationSeparate","blendFuncSeparate","_screenRenderer","_renderTarget","rendererName","_isCurrentRenderer","_currentRenderer","beginDrawLifecycle","endDrawLifecycle","drawCall","resetTransform","updateViewport","resolution","trace","drawCircle","addPostProcessor","removePostProcessor","clearPostProcessors","originalSort","firstIndex","findIndex","dc","zIndex","originalSortOrder","oldTransform","oldState","currentRendererName","currentRenderer","values","ExcaliburGraphicsContext2DCanvasDebug","_ex","__ctx","strokeStyle","strokeRect","beginPath","moveTo","lineTo","lineWidth","closePath","arc","fill","imageSmoothingEnabled","_resolution","globalAlpha","filter","fillRect","setTransform","_postprocessor","SVGA","Standard","Atari2600","GameBoy","GameBoyAdvance","NintendoDS","NES","SNES","_antialiasing","_resolutionStack","_viewportStack","_pixelRatioOverride","_isFullScreen","_isDisposed","_fullscreenChangeHandler","_pixelRatioChangeHandler","_listenForPixelRatio","_devicePixelRatio","_calculateDevicePixelRatio","applyResolutionAndViewport","_resizeHandler","_setResolutionAndViewportByDisplayMode","_alreadyWarned","_contentArea","_contentResolution","_displayMode","displayMode","Fixed","graphicsContext","antialiasing","_browser","browser","pixelRatio","_applyDisplayMode","_mediaQueryList","removeListener","nativeComponent","matchMedia","addListener","dispose","_resizeObserver","disconnect","removeEventListener","isHiDpi","FillContainer","FitContainer","FitContainerAndFill","FitContainerAndZoom","parentElement","_viewport","aspectRatio","scaledWidth","scaledHeight","setCurrentCamera","camera","_camera","pushResolutionAndViewport","peekViewport","peekResolution","popResolutionAndViewport","imageRendering","isSmooth","isFullScreen","goFullScreen","elementId","maybeElement","getElementById","requestFullscreen","exitFullScreen","exitFullscreen","pageToScreenCoordinates","newX","newY","screenHeight","screenMarginY","screenWidth","screenMarginX","screenToPageCoordinates","screenToWorldCoordinates","worldToScreenCoordinates","pageToWorldCoordinates","worldToPageCoordinates","getWorldBounds","drawWidth","drawHeight","canvasWidth","halfCanvasWidth","canvasHeight","halfCanvasHeight","zoom","halfDrawWidth","halfDrawHeight","contentArea","_computeFit","overflow","aspect","adjustedWidth","adjustedHeight","_computeFitScreenAndFill","vw","vh","_computeFitAndFill","_computeFitContainerAndFill","clientWidth","clientHeight","clip","_computeFitScreenAndZoom","_computeFitAndZoom","_computeFitContainerAndZoom","scaleX","scaleY","maxScaleFactor","zoomedWidth","zoomedHeight","_computeFitContainer","Window","ResizeObserver","observe","FillScreen","FitScreen","FitScreenAndFill","FitScreenAndZoom","create","unlock","_UNLOCKED","unlockTimeoutTimer","resume","createBufferSource","ended","connect","destination","onended","playbackState","PLAYING_STATE","FINISHED_STATE","currentTime","clearTimeout","isUnlocked","eventObject","x1","y1","x2","y2","cap","lineCap","br","tl","tr","bl","defaultRadius","quadraticCurveTo","Loader_0","_g","_h","_j","quality","_smoothing","flagDirty","_lineWidth","_lineDash","_padding","strokeColor","lineDash","padding","_bitmap","bitmapWidth","bitmapHeight","maybeCtx","cloneRasterOptions","dirty","_getTotalWidth","_originalWidth","_getTotalHeight","_originalHeight","_strokeColor","rasterize","_applyRasterProperties","execute","setLineDash","getLineDash","_options","cache","any","json","arraybuffer","states","currentState","machineDescription","machine","stateName","transitionState","transitions","startState","in","go","eventData","potentialNewState","onExit","canExit","onEnter","canEnter","onState","update","elapsedMs","onUpdate","saveKey","localStorage","setItem","parse","getItem","_audioContext","_volumeNode","createGain","_playingPromise","_playingResolve","_stateMachine","PLAYING","_createNewBufferSource","_handleEnd","_instance","pausedAt","_playbackRate","duration","startedAt","_playStarted","stop","SEEK","STOPPED","PAUSED","_volume","_loop","loop","playbackRate","volume","gain","setTargetAtTime","_duration","getTotalPlaybackDuration","isPlaying","isPaused","play","playStarted","pause","seek","getPlaybackPosition","_name","_value","_path","_val","action","propagate","layPath","_actor","track","_processedData","paths","_isStopped","_tracks","_wasPlayingOnHidden","canPlayFile","file","Audio","canPlayType","instances","audiobuffer","decodeAudio","wireEngine","_engine","pauseAudioWhenHidden","instanceCount","some","_resumePlayback","_startPlayback","forEach","trackId","_getTrackInstance","getTrackId","resumed","all","complete","newTrack","loadables","_resourceList","_playButtonShown","_resourceCount","_numLoaded","_progressCounts","_totalCounts","logo","logoWidth","logoHeight","loadingBarColor","suppressPlayButton","_playButtonStyles","Z","playButtonText","startButtonFactory","buttonElement","textContent","display","_loadingFuture","addResources","_image","_imageElement","playButtonRootElement","_playButtonRootElement","playButtonElement","_playButtonElement","_playButton","existingRoot","_styleBlock","head","addResource","loadable","showPlayButton","hidePlayButton","resizeHandler","_positionPlayButton","evt","click","playButtonClicked","startButtonHandler","removeChild","_delta","areResourcesLoaded","resource","decode","finally","markResourceComplete","progress","buttonWidth","buttonHeight","playButtonPosition","logoY","logoX","logoPosition","oldAntialias","getAntialiasing","setAntialiasing","loadingX","loadingY","loadingBarPosition","progressWidth","REPORTED_FEATURES","webgl","webaudio","gamepadapi","_features","failedTests","_criticalTests","canvasSupport","elem","arrayBufferSupport","xhr","dataUrlSupport","toDataURL","objectUrlSupport","rgbaSupport","cssText","_warningTest","webAudioSupport","webglSupport","_loadBrowserFeatures","getBrowserFeatures","logBrowserFeatures","msg","dataurl","objecturl","rgba","navigator","getGamepads","failedCritical","warning","obsoleteMessage","logMessage","suppressObsoleteMessages","showStackTrace","alternateMethod","property","SyntaxError","methodSignature","gravity","acc","useArcadePhysics","collisionResolutionStrategy","Arcade","useRealisticPhysics","Realistic","dynamicTreeVelocityMultiplyer","dynamicTreeVelocityMultiplier","enabled","broadphaseStrategy","DynamicAABBTree","defaultMass","integrator","Euler","boundsPadding","positionIterations","velocityIterations","slop","steeringFactor","warmStart","bodiesCanSleepByDefault","surfaceEpsilon","sleepEpsilon","wakeThreshold","sleepBias","checkForFastBodies","disableMinimumSpeedForFastBody","__decorate","decorators","desc","Reflect","decorate","_getX","getX","_getY","getY","_setX","setX","_setY","setY","WatchVector","original","_parent","_children","_pos","_isDirty","_isInverseDirty","_matrix","_inverse","children","globalPos","localPos","canonRotation","globalRotation","inverseRotation","globalScale","inverseScale","globalScaleX","globalScaleY","_calculateMatrix","applyInverse","owner","newComponent","hasClone","observers","subscriptions","observer","subscribe","unregister","unsubscribe","notifyAll","observersLength","notify","subscriptionsLength","_addChildTransform","child","childTxComponent","zIndexChanged$","_z","coordPlane","onAdd","childrenAdded$","childrenRemoved$","onRemove","_previousOwner","oldz","vel","scaleFactor","angularVelocity","torque","inertia","category","mask","_category","_mask","canCollide","collisionGroups","combinedName","combinedCategory","combinedMask","collidesWith","All","colliderA","colliderB","calculatePairHash","bodyA","bodyB","group","collisionType","PreventCollision","active","collide","hasCollider","collider","idA","idB","projection","getOverlap","isLeaf","worldBounds","root","nodes","_insert","leaf","leafAABB","currentRoot","oldArea","area","combinedAABB","combinedArea","cost","inheritanceCost","leftCost","leftCombined","newArea","rightCost","rightCombined","oldParent","newParent","currentNode","_balance","_remove","sibling","grandParent","trackCollider","node","updateCollider","untrackCollider","multdx","multdy","balance","getHeight","helper","rayCastQuery","getNodes","numerator","begin","getSlope","divisor","u","getLength","intersectPoint","time","getPoint","_dynamicCollisionTree","_pairs","Set","_collisionPairCache","_colliders","getColliders","colliders","untrack","_pairExists","hash","broadphase","targets","seconds","potentialColliders","pair","physics","pairs","Active","updateDistance","minDimension","minCollider","fastBodies","updateVec","oldPos","centerPoint","furthestPoint","getFurthestPoint","minTranslate","hitPoint","shift","fastBodyCollisions","narrowphase","contacts","newContacts","collisions","updated","__compositeColliderId","touching","_collisionProcessor","_dynamicAABBTree","addCollider","clearColliders","removeCollider","worldPos","axes","furthestPoints","bestPoint","maxDistance","getInertia","mass","totalInertia","otherColliders","potentialCollider","getClosestLineBetween","maybeLine","minLength","minLine","minPoint","minDistance","project","projs","proj","newProjection","slope","intercept","_normal","_dir","_slope","getEdge","_length","midpoint","flip","below","above2","sideVector","distanceToPoint","signed","x0","y0","findVectorToPoint","aMinusP","findPoint","hasPoint","currPoint","threshold","dxc","dyc","dx1","dy1","p0","q0","w0","denom","sDenom","tDenom","sClosest","tClosest","PolygonPolygonClosestLine","polygonA","polygonB","otherWorldPos","otherDirection","thisDirection","rayTowardsOther","rayTowardsThis","thisPoint","otherPoint","thisFace","getClosestFace","otherFace","face","PolygonEdgeClosestLine","polygon","edge","edgeLine","asLine","edgeStart","edgeVector","PolygonCircleClosestLine","circlex","circley","CircleCircleClosestLine","circleA","circleB","thisWorldPos","CircleEdgeClosestLine","circleWorlPos","EdgeEdgeClosestLine","edgeA","edgeB","edgeLineA","edgeStartA","edgeVectorA","edgeLineB","edgeStartB","edgeVectorB","_globalMatrix","_naturalRadius","orig","discriminant","toi","toi1","toi2","positiveToi","mintoi","shape","CollideCircleCircle","CollideCirclePolygon","CollideCircleEdge","getFurthestLocalPoint","globalMat","scalars","dotProduct","mtv","tangent","localPoints","_canceled","matchAwake","sleeping","sleepMotion","setSleeping","isCanceled","cancel","SeparatingAxis","findPolygonPolygonSeparation","polyA","polyB","bestSeparation","bestSide","bestAxis","bestSideIndex","bestOtherPoint","sides","getSides","localSides","getLocalSides","vertB","vertSeparation","separation","localSide","sideId","localPoint","findCirclePolygonSeparation","pc","polyDir","closestPointOnPoly","minOverlap","minAxis","minIndex","proj1","proj2","overlap","circleAPos","circleBPos","combinedRadius","mvt","local","samedir","xf","findSide","findLocalSide","cc","edgeWorld","asLocalLine","da","dda","db","ddb","den","pointOnEdge","dd","CollideEdgeEdge","CollidePolygonEdge","ec","linePoly","CollidePolygonPolygon","separationA","separationB","incident","reference","refDir","clipRight","clipLeft","FindContactSeparation","shapeA","txA","shapeB","txB","worldPoint","circlePoint","dist","_getTransformedBegin","_getTransformedEnd","transformedBegin","transformedEnd","_boundsFromBeginEnd","edgeNormal","_transformedPoints","_sides","_localSides","_transformedPointsDirty","_sidesDirty","_localSidesDirty","_localBoundsDirty","counterClockwise","_isCounterClockwiseWinding","reverse","isConvex","_calculateTransformation","_points","sum","oldPoint","newPoint","oldDirection","orientation","angleSum","entries","tessellate","polygons","triangulate","triangles","vertices","indices","va","vb","vc","leftArm","rightArm","isEar","vertIndex","isPointInTriangle","ab","bc","ca","ap","bp","cp","cross1","cross2","cross3","getTransformedPoints","currentSide","sideNormal","mostDirection","testRay","intersectCount","accum","pts","POSITIVE_INFINITY","faceIndex","_localBounds","_cachedMass","_cachedInertia","denominator","iplusone","crossTerm","minContactTime","contactIndex","contactTime","scalar","firstPoint","Box","Edge","Capsule","vertical","capsule","$colliderAdded","$colliderRemoved","_collider","flipped","entity","precollision","postcollision","useBoxCollider","usePolygonCollider","poly","useCircleCollider","useEdgeCollider","useCompositeCollider","dependencies","_oldTransform","__oldTransformCaptured","enableFixedUpdateInterpolate","_mass","canSleep","_sleeping","bounciness","friction","useGravity","limitDegreeOfFreedom","oldVel","oldAcc","newMass","_cachedInverseInertia","inverseMass","updateMotion","currentMotion","bias","maybeCollider","inverseInertia","motion","oldRotation","oldScale","applyImpulse","impulse","finalImpulse","X","Y","Rotation","distanceFromCenter","applyLinearImpulse","applyAngularImpulse","captureOldTransform","components","_componentsToRemove","_componentTypeToInstance","_componentStringToInstance","_tagsMemo","_typesMemo","componentAdded$","componentRemoved$","_isInitialized","_setName","component","addComponent","kill","isKilled","tags","hasTag","addTag","removeTag","force","removeComponent","types","_rebuildMemos","getComponents","_notifyAddComponent","added","_notifyRemoveComponent","removed","unparent","addChild","getAncestors","removeAllChildren","getDescendants","queue","curr","newEntity","addTemplate","templateEntity","ctor","constuctorType","componentOrType","_removeComponentByType","processComponentRemoval","isInitialized","_initialize","onInitialize","_preupdate","onPreUpdate","_postupdate","onPostUpdate","graphic","tick","_graphics","graphics","hide","nameOrGraphic","gfx","getGraphic","recalculateBounds","copyGraphics","getNames","order","currentKeys","_component","_layers","_layerMap","default","_maybeAddLayer","_getLayer","graphicsLayerKeys","visible","onPreDraw","onPostDraw","layers","graphicToSet","offsetX","offsetY","elapsed","idempotencyToken","_radius","useColliderShape","useGraphicsBounds","CreateReversibleEasingFunction","easing","CreateVectorEasingFunction","Linear","startValue","endValue","EaseInQuad","EaseOutQuad","EaseInOutQuad","EaseInCubic","EaseOutCubic","EaseInOutCubic","_actions","_completedActions","_entity","remove","clearActions","_currentAction","getActions","hasNext","isComplete","repeatBuilder","repeat","_stopped","_repeatBuilder","_repeatContext","_actionQueue","getQueue","_repeat","_originalRepeat","speed","_started","_tx","_motion","_speed","_offset","_start","_end","_distance","destx","desty","rotationType","_rotationType","ShortestPath","_currentNonCannonAngle","distance1","distance2","_shortDistance","_longDistance","_shortestPathIsPositive","_direction","LongestPath","Clockwise","CounterClockwise","distanceTraveled","angleRadiansOffset","speedX","speedY","_endX","_endY","_speedX","_speedY","_startX","_startY","_distanceX","_distanceY","directionX","directionY","scaleOffsetX","scaleOffsetY","_startScale","_endScale","_directionX","_directionY","CallMethod","_method","_hasBeenCalled","easingFcn","_currentLerpTime","_lerpDuration","_lerpStart","_lerpEnd","_initialized","timeVisible","timeNotVisible","numBlinks","_timeVisible","_timeNotVisible","_elapsedTime","_totalTime","endOpacity","_multiplier","_endOpacity","_ogspeed","_delay","entityToFollow","followDistance","_followTx","_followMotion","_current","_maximumDistance","_distanceBetween","actorToFollowSpeed","actorToMeet","_speedWasSpecified","_meetTx","_meetMotion","actorToMeetSpeed","_queue","runAction","easeTo","easeBy","xOrPos","yOrSpeed","speedOrUndefined","moveBy","xOffsetOrVector","yOffsetOrSpeed","xOffset","yOffset","rotateTo","rotateBy","scaleTo","sizeXOrVector","sizeYOrSpeed","speedXOrUndefined","speedYOrUndefined","sizeX","sizeY","scaleBy","sizeOffsetXOrVector","sizeOffsetYOrSpeed","sizeOffsetX","sizeOffsetY","blink","fade","die","callMethod","times","repeatForever","follow","meet","toPromise","_o","_p","_q","_r","family","Normal","bold","unit","Px","textAlign","baseAlign","Alphabetic","LeftToRight","_textBounds","_cachedTextMeasurement","_bitmapToTextMeasurement","_textToBitmap","_bitmapUsage","_textFragments","blur","fontString","measurementDirty","cached","rasterProps","_getRasterPropertiesHash","measurement","_getTextBitmap","_applyFont","metrics","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","lineAdjustedHeight","bottomBounds","actualBoundingBoxLeft","actualBoundingBoxRight","_setDimension","textBounds","textBaseline","font","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","_drawText","colorOverride","lineHeight","strokeText","textAndHash","_splitTextBitmap","textImages","currentX","currentY","clearCache","checkAndClearCache","isNewBitmap","frag","performance","cacheSize","_textWidth","_textHeight","_font","_calculateDimension","config","_anchor","_handleAnchorChange","scene","_draggable","_dragging","_pointerDragStartHandler","_pointerDragEndHandler","_pointerDragMoveHandler","pe","_pointerDragLeaveHandler","collisionGroup","defaults","Passive","pointer","actions","thePos","theVel","theAcc","theAngle","isOffScreen","draggable","isDraggable","defaultLayer","currentGraphic","_prekill","_scene","onPreKill","_postkill","onPostKill","unkill","newZ","getGlobalPos","localCenter","getGlobalScale","getGlobalRotation","recurse","geom","containment","within","otherCollider","me","useWorld","coords","fcn","interval","repeats","numberOfRepeats","randomRange","_totalTimeAlive","_running","_numberOfTicks","maxNumberOfRepeats","_baseInterval","_generateRandomInterval","_complete","_MAX_ID","_callbacks","newInterval","newNumberOfRepeats","timesRepeated","getTimeRunning","timeToNextAction","timeElapsedTowardNextAction","isRunning","cancelTimer","parallaxFactor","useTransform","_token","_onScreenXStart","_onScreenXEnd","_onScreenYStart","_onScreenYEnd","tiles","_rows","_cols","renderFromTopOfGraphic","_collidersDirty","_originalOffsets","_composite","_oldPos","tileWidth","tileHeight","currentCol","cd","flagCollidersDirty","_getOrSetColliderOriginalOffset","originalOffset","_updateColliders","tile","solid","prev","getTileByIndex","getTile","getTileByPoint","getRows","getColumns","worldCoordsUpperLeft","worldCoordsLowerRight","maybeParallax","parallaxOffset","oneMinusFactor","currentScene","graphicsIndex","graphicsLen","xEnd","yEnd","getGraphics","grayish","_posDirty","_solid","_recalculate","addGraphic","removeGraphic","clearGraphics","_bounds","lockToActor","addStrategy","lockToActorAxis","elasticToActor","cameraElasticity","cameraFriction","radiusAroundActor","limitCameraBounds","box","_cam","_eng","cam","currentFocus","getFocus","focus","cameraVel","stretch","boundSizeChecked","focusX","focusY","_cameraStrategies","strategy","dz","az","_angularVelocity","_posChanged","_cameraMoving","_isShaking","_shakeMagnitudeX","_shakeMagnitudeY","_shakeDuration","_elapsedShakeTime","_xShake","_yShake","_isZooming","_zoomStart","_zoomEnd","_currentZoomTime","_zoomDuration","_zoomEasing","_easing","_halfWidth","_halfHeight","_follow","ax","ay","move","easingFn","_lerpPromise","_lerpResolve","shake","magnitudeX","magnitudeY","zoomOverTime","_zoomPromise","_zoomResolve","cameraStrategy","removeStrategy","clearAllStrategies","_screen","currentRes","loadingComplete","res","updateTransform","runStrategies","zoomEasing","newZoom","moveEasing","lerpPoint","_isDoneShaking","newCanvasWidth","newCanvasHeight","cameraPos","triggerDefaults","opts","_dispatchAction","_target","_entityAddedOrRemoved","_world","entities","_entityIndex","_entitiesToRemove","updateEntities","removeEntity","findEntitiesForRemoval","queryManager","addEntity","idOrEntity","deferred","currFrame","actors","killed","processEntityRemovals","processComponentRemovals","getById","getByName","buildTypeKey","localeCompare","_entities","T","_key","getEntities","matches","typesOrEntity","contain","_queries","_addQuery","entityManager","maybeRemoveQuery","queryType","createQuery","maybeExistingQuery","getQuery","systems","initialized","systemType","find","addSystem","system","removeSystem","updateSystems","preupdate","postupdate","systemManager","Update","entityOrSystem","clearEntities","clearSystems","EulerIntegrator","integrate","totalAcc","_ACC","_VEL","_POS","_VEL_ACC","_SCALE_FACTOR","_SCALE","optionalBody","directionMap","distanceMap","solve","preSolve","aDist","bDist","solvePosition","solveVelocity","postSolve","opposite","velAdj","normalImpulse","tangentImpulse","normalMass","tangentMass","aToContact","bToContact","originalVelocityAndRestitution","aToContactNormal","bToContactNormal","aToContactTangent","bToContactTangent","getRelativeVelocity","velA","velB","lastFrameContacts","idToContactConstraint","getContactConstraints","finishedContactIds","contactPoints","pointIndex","restitution","relativeVelocity","constraints","steeringConstant","steeringForce","impulseForce","tangentVelocity","impulseDelta","maxFriction","newImpulse","normalVelocity","_realisticSolver","_arcadeSolver","_processor","_lastFrameContacts","_currentFrameContacts","_trackCollider","_untrackCollider","colliderComponent","colliderComp","compositeColliders","solver","getSolver","compositeId","substring","runContactStartEnd","frames","Loop","frameDuration","timeScale","_idempotencyToken","_firstTick","_currentFrame","_timeLeftInFrame","_done","_playing","_reversed","totalDuration","goToFrame","maybeFrame","currentFrame","fromSpriteSheet","frameIndices","durationPerFrameMs","invalidIndices","currentFrameIndex","reversed","Backward","Forward","canFinish","End","Freeze","frameNumber","_nextFrame","PingPong","elapsedMilliseconds","members","_updateDimensions","_isAnimationOrGroup","member","maybeAnimation","base","assign","props","ParticleImpl","emitterOrConfig","life","beginColor","endColor","velocity","acceleration","startSize","endSize","particleRotationalVelocity","currentRotation","focusAccel","fadeFlag","_rRate","_gRate","_bRate","_aRate","_currentColor","emitter","particleSize","particleSprite","sizeRate","elapsedMultiplier","isOffscreen","tmpColor","removeParticle","accel","_particlesToEmit","numParticles","isEmitting","particles","deadParticles","minVel","maxVel","minAngle","maxAngle","emitRate","particleLife","minSize","maxSize","_sprite","emitterType","randomRotation","particle","emitParticles","particleCount","_createParticle","world","clearParticles","ranX","ranY","Draw","_sortedTransforms","_zHasChanged","_zIndexUpdate","sortedTransforms","_graphicsContext","entityAddedOrRemoved","parallax","_applyTransform","particleOpacity","_drawGraphicsComponent","graphicsComponent","isDebug","showBounds","boundsColor","ancestors","ancestor","interpolatedPos","interpolatedScale","interpolatedRotation","fixedUpdateFps","blend","currentFrameLagMs","_collisionSystem","debugDraw","filterSettings","entitySettings","txSettings","motionSettings","colliderSettings","physicsSettings","graphicsSettings","bodySettings","cameraSettings","useFilter","allIds","ids","idMatch","allNames","nameQuery","nameMatch","cursor","_pushCameraTransform","showAll","showPosition","positionColor","showPositionLabel","showZIndex","showId","showName","showRotation","rotationColor","showScale","scaleColor","showCollisionGroup","showCollisionType","showMass","showMotion","showSleeping","showVelocity","velocityColor","showAcceleration","accelerationColor","showGeometry","geometryColor","showOwner","_popCameraTransform","showBroadphaseSpacePartitionDebug","showCollisionContacts","showCollisionNormals","collisionContactColor","collisionNormalColor","showFocus","focusColor","showZoom","overrideUseColliderShape","overrideUseGraphicsBounds","lastFrameEntityToPointers","currentFrameEntityToPointers","_sortedEntities","_receiver","pointers","entityCurrentlyUnderPointer","pointerId","entityWasUnderPointer","entered","addPointerToEntity","_processPointerToEntity","_dispatchEvents","currentFramePointerCoords","screenPos","graphicBounds","_processDownAndEmit","lastDownPerPointer","currentFrameDown","isDragStart","_processUpAndEmit","lastUpPerPointer","currentFrameUp","isDragEnd","_processMoveAndEmit","lastMovePerPointer","currentFrameMove","isDragging","_processEnterLeaveAndEmit","lastUpDownMoveEvents","_processCancelAndEmit","currentFrameCancel","_processWheelAndEmit","currentFrameWheel","lastFrameEntities","currentFrameEntities","entitiesWithEvents","elevation","iso","maxZindexPerElevation","entityOffscreen","_isOffscreen","transformedBounds","graphicsOffscreen","_timers","_cancelQueue","triggers","tileMaps","timers","onActivate","onDeactivate","_initializeChildren","_activate","_deactivate","_predraw","_postdraw","removeTimer","timer","_collectActorStats","addTimer","isTimerActive","isCurrentScene","screenElements","_ui","ui","alive","_colorBlindnessMode","simulate","_simulate","colorBlindnessMode","colorBlindMode","Protanope","Deuteranope","Tritanope","_colorBlindPostProcessor","correct","colorBlindness","prevFrame","useTestClock","wasRunning","testClock","toTestClock","useStandardClock","currentClock","standardClock","toStandardClock","_id","_fps","_actorStats","remaining","total","_durationStats","_physicsStats","_graphicsStats","drawCalls","drawnImages","otherStats","fps","fs","_collisions","_contacts","_fastBodies","_fastBodyCollisions","_broadphase","_narrowphase","ps","originalEvent","_keys","_keysUp","_keysDown","_handleKeyDown","keyEvent","_handleKeyUp","init","noop","getKeys","wasPressed","isHeld","wasReleased","triggerEvent","character","KeyboardEvent","_gamePadTimeStamps","_oldPads","_pads","_initSuccess","_navigator","_minimumConfiguration","_clonePads","setMinimumGamepadConfiguration","_enableAndUpdate","_isGamepadValid","pad","axesLength","buttonLength","buttons","connected","gamepads","bi","ai","at","timestamp","navigatorGamepad","getButton","pressed","updateButton","getAxes","updateAxes","_clonePad","getValidGamepads","pads","arr","clonedPad","MinAxisMoveThreshold","_buttons","_axes","isButtonPressed","buttonIndex","axesIndex","_paused","_nativeHandlers","_decorate","_windowGlobal","_documentGlobal","_windowComponent","_documentComponent","pagePos","fromPagePosition","yOrEngine","engineOrUndefined","pageX","pageY","pointerType","coordinates","nativeEvent","screenX","screenY","deltaZ","deltaMode","PointerAbstraction","lastPagePos","lastScreenPos","lastWorldPos","_onPointerMove","_onPointerDown","primary","_activeNativePointerIdsToNormalized","lastFramePointerCoords","currentFramePointerDown","lastFramePointerDown","_pointers","_boundHandle","_handle","_boundWheel","_handleWheel","recreate","eventReceiver","isDown","wasDown","native","touchAction","wheelOptions","passive","pageScrollPreventionMode","onmousewheel","detach","_normalizePointerId","nativePointerId","currentPointerIds","preventDefault","eventCoords","TouchEvent","Unknown","Touch","changedTouches","touch","_nativeButtonToPointerButton","Mouse","_stringToPointerType","coord","ScrollWheelNormalizationFactor","wheelDeltaX","wheelDeltaY","wheelDelta","detail","Page","we","page","clientX","clientY","MouseEvent","pointerSystem","transformEntities","NoButton","Middle","Pen","_samplePeriod","_currentFrameTime","_frames","_previousSampleTime","_beginFrameTime","initialFps","samplePeriod","_nowFn","nowFn","instant","_onFatalException","_maxFps","_lastTime","_elapsed","_scheduledCbs","_totalElapsed","maxFps","onFatalException","fpsSampler","defaultUpdateMs","setFatalExceptionHandler","cb","timeoutMs","scheduledTime","_runScheduledCbs","overrideUpdateMs","fpsInterval","leftover","mainloop","_requestId","_currentTime","_updateMs","step","run","numberOfSteps","Util_Toaster","_toasterCss","_container","_createFragment","toastMessage","innerText","toast","linkTarget","linkName","className","messageFragments","link","href","finalMessage","dismissBtn","keydownHandler","first","firstChild","insertBefore","scenes","_suppressPlayButton","_isDebug","enableCanvasTransparency","_toaster","_timescale","_deferredGoTo","_originalOptions","_performanceThresholdTriggered","_fpsSamples","_loadingComplete","_isReady","_isReadyPromise","_isReadyResolve","currentFrameElapsedMs","_lagMs","_screenShotRequests","_DEFAULT_ENGINE_OPTIONS","detector","suppressMinimumBrowserFeatureDetection","_compatible","testMessage","canvasElementId","suppressConsoleBootMessage","_originalDisplayMode","suppressHiDPIScaling","_mainloop","_loader","rootScene","addScene","___EXCALIBUR_DEVTOOL","isFullscreen","shouldSnapToPixel","_monitorPerformanceThresholdAndTriggerFallback","allow","configurePerformanceCanvas2DFallback","showPlayerMessage","numberOfFrames","useCanvas2DFallback","newCanvas","cloneNode","parentNode","replaceChild","pointerTarget","pointerScope","Document","timescale","removeScene","goToScene","previousScene","nextScene","hidden","visibilityChange","scrollPreventionMode","keyboard","_overrideInitialize","deferredScene","_update","_draw","_checkForScreenShots","toggle","toggleDebug","isReady","loader","frameId","beforeUpdate","fixedTimestepMs","afterUpdate","afterDraw","screenshot","preserveHiDPIResolution","screenShotPromise","finalWidth","finalHeight","raw","spriteFont","newFont","sf","getTextWidth","graphicsOffset","_tileBounds","_isometricEntityComponent","halfTileWidth","halfTileHeight","xPos","yPos","_gfx","totalWidth","totalHeight","_recalculateBounds","tileToWorld","updateColliders","worldToTile","worldCoordinate","tileCoordinate","tileCoord","_getMaxZIndex","maxZ","NEGATIVE_INFINITY","currentZ","actionBuilder","_sequenceBuilder","_sequenceContext","parallelActions","every","_CURRENT_GROUP","_MAX_GROUPS","_GROUPS","_CURRENT_BIT","groups","groupByName","_STARTING_BIT","_stream","_gif","_animation","_transparentColor","images","toSpriteSheet","toAnimation","readCheckBytes","checkBytes","bitsToNum","ba","byteToBitArr","bite","dataArray","readByte","byteLength","readBytes","bytes","read","readUnsigned","Uint8Array","lzwDecode","minCodeSize","last","output","clearCode","eoiCode","codeSize","dict","readCode","charCodeAt","stream","_st","_handler","globalColorTable","parseColorTable","ct","rgb","readSubBlocks","parseHeader","hdr","sig","ver","colorRes","globalColorTableSize","gctFlag","sorted","bgColor","pixelAspectRatio","bits","parseExt","block","label","extType","parseGCExt","reserved","disposalMethod","userInput","transparencyGiven","delayTime","transparencyIndex","terminator","gce","parseComExt","comment","com","parsePTExt","ptHeader","ptData","pte","parseAppExt","identifier","authCode","parseNetscapeExt","unknown","iterations","app","NETSCAPE","parseUnknownAppExt","appData","parseUnknownExt","parseImg","img","leftPos","topPos","lctFlag","interlaced","lctSize","lct","lzwMinCodeSize","lzwData","pixels","deinterlace","newPixels","cpRow","toRow","fromRow","fromPixels","offsets","steps","pass","arrayToImage","parseBlock","sentinel","blockChar","eof","frame","AsyncWaitQueue","enqueue","dequeue","_count","_waitQueue","waiting","enter","exit","fWn","Ia8","rqv","hLI","yyv","tX5","$2c23f148d58cd887$export$f73d3eb6fd876d80","vtX","r7K","lCh","cE4","fwF","sce","_c7","KUs","Ajp","RDh","_H9","mxs","OmD","kBf","C4F","NQt","JjN","V1s","Xz7","Cdc","FKn","wTW","SUY","ab2","GfZ","YMS","oyv","aUb","SdD","JUv","jEj","TFq","HDU","R_y","ydN","t50","s$$","$2c23f148d58cd887$export$ddb2ed749236e720","v2G","$2c23f148d58cd887$export$892596cec99bc70e","Ilk","s9i","dxL","LLX","wA2","R_p","IQ$","I5F","X8$","FR6","U8o","kbG","iS_","cGG","RPN","skb","SLU","RdJ","cNu","gU7","LSk","Nmp","d1Y","xrL","sRW","cmV","qWz","N0Q","q8b","ynB","jT9","wAz","$2c23f148d58cd887$export$2c3b404bf3a77a1f","D4V","N6H","W1A","JHW","v2K","pBf","GMl","zW2","B0K","Nv7","C_p","iqw","MUA","xqU","pTp","vUK","j9l","Zxw","Hdx","Z$d","iqV","o$7","olM","Zm$","$QH","i78","h6u","hts","j88","VME","nt","Ukr","zsu","oA6","TVh","TwZ","GTT","xxj","XdK","Jmb","cXo","Dm5","IIB","zI0","LYD","cEG","SEl","t9V","SKZ","__J","RI$","x12","ccz","aNw","xwn","dNK","ini","YdH","y3G","l57","xn0","t2V","uxB","cpd","fiy","$XZ","uqK","STE","y$z","mAD","sOq","hUw","_0G","Sqs","hpZ","Vol","wIZ","cBi","RFv","kfC","mgq","YVA","Kgp","HH$","M_d","rgh","Ra6","KhR","BS5","xhz","xOq","a9j","bHk","CgK","cuY","kvE","SBu","AE_","ctO","OLH","kky","nSF","zHn","zwx","AeJ","hLz","D9g","wA","jhr","GVs","_zO","w6$","mhV","MOD","kwd","Lmr","xsS","lLr","Z$r","IXb","SGH","SMj","L34","exe","bnF","MFA","$uU","jyi","E03","V6q","rg2","DVW","nVo","F6N","xP7","Odq","Zif","ZGJ","MJk","xvT","PHM","dpR","n9L","KwO","B7y","x7r","wx7","Uvn","OFT","xzN","M5Z","ZrN","OWs","dF9","oZy","rD2","VHo","ohE","R$E","q3I","Pab","uZ5","McK","F9c","k0b","hnT","RSJ","Mku","h90","rms","ErP","aVg","lPc","Z8E","_N2","yFn","lNv","cu9","MZQ","FUM","BxR","vdf","iaL","w6H","Q4c","Xxe","Uxb","Yr5","$2c23f148d58cd887$export$202e0172ed3c7be0","Bhw","yOA","$ad2bcec7a0192558$var$game","$ad2bcec7a0192558$var$paddle","$ad2bcec7a0192558$var$ball","$ad2bcec7a0192558$var$ballSpeed","$ad2bcec7a0192558$var$brickColor","$ad2bcec7a0192558$var$brickWidth","$ad2bcec7a0192558$var$padding","$ad2bcec7a0192558$var$bricks","$ad2bcec7a0192558$var$xoffset","$ad2bcec7a0192558$var$yoffset","$ad2bcec7a0192558$var$brickHeight","brick","$ad2bcec7a0192558$var$colliding","alert"],"version":3,"file":"index.dab76bea.js.map"}