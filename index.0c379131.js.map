{"mappings":"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","sources":["node_modules/excalibur/build/node_modules/core-js/es/array/sort.js","node_modules/excalibur/build/node_modules/core-js/es/object/keys.js","node_modules/excalibur/build/node_modules/core-js/internals/a-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/an-object.js","node_modules/excalibur/build/node_modules/core-js/internals/array-includes.js","node_modules/excalibur/build/node_modules/core-js/internals/array-method-is-strict.js","node_modules/excalibur/build/node_modules/core-js/internals/array-sort.js","node_modules/excalibur/build/node_modules/core-js/internals/classof-raw.js","node_modules/excalibur/build/node_modules/core-js/internals/classof.js","node_modules/excalibur/build/node_modules/core-js/internals/copy-constructor-properties.js","node_modules/excalibur/build/node_modules/core-js/internals/create-non-enumerable-property.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/descriptors.js","node_modules/excalibur/build/node_modules/core-js/internals/document-create-element.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-ff-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-is-ie-or-edge.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-user-agent.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-v8-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-webkit-version.js","node_modules/excalibur/build/node_modules/core-js/internals/entry-unbind.js","node_modules/excalibur/build/node_modules/core-js/internals/enum-bug-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/export.js","node_modules/excalibur/build/node_modules/core-js/internals/fails.js","node_modules/excalibur/build/node_modules/core-js/internals/function-bind-context.js","node_modules/excalibur/build/node_modules/core-js/internals/function-name.js","node_modules/excalibur/build/node_modules/core-js/internals/get-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/get-method.js","node_modules/excalibur/build/node_modules/core-js/internals/global.js","node_modules/excalibur/build/node_modules/core-js/internals/has.js","node_modules/excalibur/build/node_modules/core-js/internals/hidden-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/ie8-dom-define.js","node_modules/excalibur/build/node_modules/core-js/internals/indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/inspect-source.js","node_modules/excalibur/build/node_modules/core-js/internals/internal-state.js","node_modules/excalibur/build/node_modules/core-js/internals/is-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/is-forced.js","node_modules/excalibur/build/node_modules/core-js/internals/is-object.js","node_modules/excalibur/build/node_modules/core-js/internals/is-pure.js","node_modules/excalibur/build/node_modules/core-js/internals/is-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/native-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/native-weak-map.js","node_modules/excalibur/build/node_modules/core-js/internals/object-define-property.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-names.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-symbols.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys-internal.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/object-property-is-enumerable.js","node_modules/excalibur/build/node_modules/core-js/internals/ordinary-to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/own-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/path.js","node_modules/excalibur/build/node_modules/core-js/internals/redefine.js","node_modules/excalibur/build/node_modules/core-js/internals/require-object-coercible.js","node_modules/excalibur/build/node_modules/core-js/internals/set-global.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-key.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-store.js","node_modules/excalibur/build/node_modules/core-js/internals/shared.js","node_modules/excalibur/build/node_modules/core-js/internals/to-absolute-index.js","node_modules/excalibur/build/node_modules/core-js/internals/to-indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-integer.js","node_modules/excalibur/build/node_modules/core-js/internals/to-length.js","node_modules/excalibur/build/node_modules/core-js/internals/to-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/to-property-key.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string-tag-support.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/try-to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/uid.js","node_modules/excalibur/build/node_modules/core-js/internals/use-symbol-as-uid.js","node_modules/excalibur/build/node_modules/core-js/internals/well-known-symbol.js","node_modules/excalibur/build/node_modules/core-js/modules/es.array.sort.js","node_modules/excalibur/build/node_modules/core-js/modules/es.object.keys.js","node_modules/excalibur/build/esm/webpack:/Loader.css","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/api.js","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/sourceMaps.js","node_modules/excalibur/build/esm/webpack:/webpack/bootstrap","node_modules/excalibur/build/esm/webpack:/webpack/runtime/compat get default export","node_modules/excalibur/build/esm/webpack:/webpack/runtime/define property getters","node_modules/excalibur/build/esm/webpack:/webpack/runtime/global","node_modules/excalibur/build/esm/webpack:/webpack/runtime/hasOwnProperty shorthand","node_modules/excalibur/build/esm/webpack:/webpack/runtime/make namespace object","node_modules/excalibur/build/esm/webpack:/Flags.ts","node_modules/excalibur/build/esm/webpack:/Util/Log.ts","node_modules/excalibur/build/esm/webpack:/Polyfill.ts","node_modules/excalibur/build/esm/webpack:/Id.ts","node_modules/excalibur/build/esm/webpack:/Math/Random.ts","node_modules/excalibur/build/esm/webpack:/Collision/Side.ts","node_modules/excalibur/build/esm/webpack:/Util/Util.ts","node_modules/excalibur/build/esm/webpack:/Util/Decorators.ts","node_modules/excalibur/build/esm/webpack:/Math/vector.ts","node_modules/excalibur/build/esm/webpack:/Color.ts","node_modules/excalibur/build/esm/webpack:/Collision/BoundingBox.ts","node_modules/excalibur/build/esm/webpack:/Util/Pool.ts","node_modules/excalibur/build/esm/webpack:/Math/matrix.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/transform-stack.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/state-stack.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shaders/line-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/batch.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsDiagnostics.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shaders/image-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shaders/image-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/draw-image-command.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-util.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/texture-loader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/image-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shaders/point-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shaders/point-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Graphic.ts","node_modules/excalibur/build/esm/webpack:/Util/Watch.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Raster.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Canvas.ts","node_modules/excalibur/build/esm/webpack:/Events.ts","node_modules/excalibur/build/esm/webpack:/EventDispatcher.ts","node_modules/excalibur/build/esm/webpack:/Resources/Resource.ts","node_modules/excalibur/build/esm/webpack:/Drawing/SpriteEffects.ts","node_modules/excalibur/build/esm/webpack:/Drawing/Texture.ts","node_modules/excalibur/build/esm/webpack:/Configurable.ts","node_modules/excalibur/build/esm/webpack:/Drawing/Sprite.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Sprite.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ImageSource.ts","node_modules/excalibur/build/esm/webpack:/Drawing/Animation.ts","node_modules/excalibur/build/esm/webpack:/Graphics/FontCommon.ts","node_modules/excalibur/build/esm/webpack:/Drawing/SpriteSheet.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteSheet.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteFont.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-font.png","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-text.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContextWebGL.ts","node_modules/excalibur/build/esm/webpack:/Screen.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/AudioContext.ts","node_modules/excalibur/build/esm/webpack:/Util/WebAudio.ts","node_modules/excalibur/build/esm/webpack:/Util/DrawUtil.ts","node_modules/excalibur/build/esm/webpack:/Class.ts","node_modules/excalibur/build/esm/webpack:/Loader.logo.png","node_modules/excalibur/build/esm/webpack:/Loader.ts","node_modules/excalibur/build/esm/webpack:/Util/Detector.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionType.ts","node_modules/excalibur/build/esm/webpack:/Collision/Physics.ts","node_modules/excalibur/build/esm/webpack:/Math/vector-view.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Component.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/TransformComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/MotionComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroup.ts","node_modules/excalibur/build/esm/webpack:/Util/Observable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/Pair.ts","node_modules/excalibur/build/esm/webpack:/Math/projection.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTree.ts","node_modules/excalibur/build/esm/webpack:/Math/ray.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTreeCollisionProcessor.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Collider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CompositeCollider.ts","node_modules/excalibur/build/esm/webpack:/Math/line.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/ClosestLineJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CircleCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/CollisionContact.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/SeparatingAxis.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CollisionJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/EdgeCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/PolygonCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Shape.ts","node_modules/excalibur/build/esm/webpack:/Collision/ColliderComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/BodyComponent.ts","node_modules/excalibur/build/esm/webpack:/Util/CullingBox.ts","node_modules/excalibur/build/esm/webpack:/Traits/OffscreenCulling.ts","node_modules/excalibur/build/esm/webpack:/Traits/CapturePointer.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Entity.ts","node_modules/excalibur/build/esm/webpack:/Drawing/CanvasDrawComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Rectangle.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Circle.ts","node_modules/excalibur/build/esm/webpack:/Util/EasingFunctions.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionQueue.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Repeat.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RepeatForever.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/RotationType.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/CallMethod.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/EaseTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Blink.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Fade.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Delay.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Die.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Follow.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Meet.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionContext.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsComponent.ts","node_modules/excalibur/build/esm/webpack:/Actor.ts","node_modules/excalibur/build/esm/webpack:/ScreenElement.ts","node_modules/excalibur/build/esm/webpack:/Timer.ts","node_modules/excalibur/build/esm/webpack:/TileMap.ts","node_modules/excalibur/build/esm/webpack:/Camera.ts","node_modules/excalibur/build/esm/webpack:/Util/Actors.ts","node_modules/excalibur/build/esm/webpack:/Trigger.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/System.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/EntityManager.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ArcadeSolver.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Util.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Query.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/QueryManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/SystemManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/World.ts","node_modules/excalibur/build/esm/webpack:/Collision/Integrator.ts","node_modules/excalibur/build/esm/webpack:/Collision/MotionSystem.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/Solver.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ContactConstraintPoint.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/RealisticSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionSystem.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Animation.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsGroup.ts","node_modules/excalibur/build/esm/webpack:/Particles.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsSystem.ts","node_modules/excalibur/build/esm/webpack:/Drawing/CanvasDrawingSystem.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugSystem.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsSystem.ts","node_modules/excalibur/build/esm/webpack:/Scene.ts","node_modules/excalibur/build/esm/webpack:/PostProcessing/ColorBlindCorrector.ts","node_modules/excalibur/build/esm/webpack:/Debug/Debug.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugFlags.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEvents.ts","node_modules/excalibur/build/esm/webpack:/Input/Keyboard.ts","node_modules/excalibur/build/esm/webpack:/Input/Pointer.ts","node_modules/excalibur/build/esm/webpack:/Math/global-coordinates.ts","node_modules/excalibur/build/esm/webpack:/Input/Pointers.ts","node_modules/excalibur/build/esm/webpack:/Input/Gamepad.ts","node_modules/excalibur/build/esm/webpack:/Util/Browser.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts","node_modules/excalibur/build/esm/webpack:/Engine.ts","node_modules/excalibur/build/esm/webpack:/Events/MediaEvents.ts","node_modules/excalibur/build/esm/webpack:/Label.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Font.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Text.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroupManager.ts","node_modules/excalibur/build/esm/webpack:/Drawing/Polygon.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/AudioImplementation.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/LifecycleEvents.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/WebAudioInstance.ts","node_modules/excalibur/build/esm/webpack:/Util/Sound.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/Sound.ts","node_modules/excalibur/build/esm/webpack:/Resources/Gif.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Polygon.ts","node_modules/excalibur/build/esm/webpack:/Util/SortedList.ts","node_modules/excalibur/build/esm/webpack:/Promises.ts","node_modules/excalibur/build/esm/webpack:/index.ts","src/main.ts"],"sourcesContent":["require('../../modules/es.array.sort');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'sort');\n","require('../../modules/es.object.keys');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.keys;\n","var isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw TypeError(tryToString(argument) + ' is not a function');\n};\n","var isObject = require('../internals/is-object');\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw TypeError(String(argument) + ' is not an object');\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toLength = require('../internals/to-length');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n","// TODO: use something more complex like timsort?\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    mergeSort(array.slice(0, middle), comparefn),\n    mergeSort(array.slice(middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n  var result = [];\n\n  while (lindex < llength || rindex < rlength) {\n    if (lindex < llength && rindex < rlength) {\n      result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);\n    } else {\n      result.push(lindex < llength ? left[lindex++] : right[rindex++]);\n    }\n  } return result;\n};\n\nmodule.exports = mergeSort;\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n","var has = require('../internals/has');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var userAgent = require('../internals/engine-user-agent');\n\nvar firefox = userAgent.match(/firefox\\/(\\d+)/i);\n\nmodule.exports = !!firefox && +firefox[1];\n","var UA = require('../internals/engine-user-agent');\n\nmodule.exports = /MSIE|Trident/.test(UA);\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] < 4 ? 1 : match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n","var userAgent = require('../internals/engine-user-agent');\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nmodule.exports = !!webkit && +webkit[1];\n","var global = require('../internals/global');\nvar bind = require('../internals/function-bind-context');\n\nvar call = Function.call;\n\nmodule.exports = function (CONSTRUCTOR, METHOD, length) {\n  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var aCallable = require('../internals/a-callable');\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aCallable(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar has = require('../internals/has');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = has(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","var aCallable = require('../internals/a-callable');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n","var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","var toObject = require('../internals/to-object');\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty.call(toObject(it), key);\n};\n","module.exports = {};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n","var isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = Function.toString;\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar objectHas = require('../internals/has');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument === 'function';\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : isCallable(it);\n};\n","module.exports = false;\n","var isCallable = require('../internals/is-callable');\nvar getBuiltIn = require('../internals/get-built-in');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && Object(it) instanceof $Symbol;\n};\n","/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar has = require('../internals/has');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var has = require('../internals/has');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","var isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var getBuiltIn = require('../internals/get-built-in');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","var global = require('../internals/global');\n\nmodule.exports = global;\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar has = require('../internals/has');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar setGlobal = require('../internals/set-global');\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var name = options && options.name !== undefined ? options.name : key;\n  var state;\n  if (isCallable(value)) {\n    if (String(name).slice(0, 7) === 'Symbol(') {\n      name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n    }\n    if (!has(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n      createNonEnumerableProperty(value, 'name', name);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n});\n","// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","var global = require('../internals/global');\n\nmodule.exports = function (key, value) {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.18.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'\n});\n","var toInteger = require('../internals/to-integer');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.es/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n","var toInteger = require('../internals/to-integer');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n","var isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = exoticToPrim.call(input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","var toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : String(key);\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n","var classof = require('../internals/classof');\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return String(argument);\n};\n","module.exports = function (argument) {\n  try {\n    return String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n","/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar has = require('../internals/has');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar aCallable = require('../internals/a-callable');\nvar toObject = require('../internals/to-object');\nvar toLength = require('../internals/to-length');\nvar toString = require('../internals/to-string');\nvar fails = require('../internals/fails');\nvar internalSort = require('../internals/array-sort');\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar FF = require('../internals/engine-ff-version');\nvar IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');\nvar V8 = require('../internals/engine-v8-version');\nvar WEBKIT = require('../internals/engine-webkit-version');\n\nvar test = [];\nvar nativeSort = test.sort;\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD = arrayMethodIsStrict('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable(comparefn);\n\n    var array = toObject(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? nativeSort.call(array) : nativeSort.call(array, comparefn);\n\n    var items = [];\n    var arrayLength = toLength(array.length);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) items.push(array[index]);\n    }\n\n    items = internalSort(items, getSortCompare(comparefn));\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) delete array[index++];\n\n    return array;\n  }\n});\n","var $ = require('../internals/export');\nvar toObject = require('../internals/to-object');\nvar nativeKeys = require('../internals/object-keys');\nvar fails = require('../internals/fails');\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject(it));\n  }\n});\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./Loader.css\"],\"names\":[],\"mappings\":\"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF\",\"sourcesContent\":[\"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var _i = 0; _i < this.length; _i++) {\n        var id = this[_i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i2 = 0; _i2 < modules.length; _i2++) {\n      var item = [].concat(modules[_i2]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\r\n/**\r\n * Features in preview\r\n */\r\nexport enum Experiments {\r\n  WebGL = 'use-webgl'\r\n}\r\n\r\n/**\r\n * Legacy features that will go away\r\n */\r\nexport enum Legacy {\r\n  Canvas = 'use-canvas-context',\r\n  LegacyDrawing = 'use-legacy-drawing'\r\n}\r\n\r\n/**\r\n * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**\r\n * after which they are frozen and are read-only.\r\n *\r\n * Flags are used to enable experimental or preview features in Excalibur.\r\n */\r\nexport class Flags {\r\n  private static _FROZEN = false;\r\n  private static _FLAGS: Record<string, boolean> = {};\r\n\r\n  /**\r\n   * Freeze all flag modifications making them readonly\r\n   */\r\n  public static freeze() {\r\n    Flags._FROZEN = true;\r\n  }\r\n\r\n  /**\r\n   * Resets internal flag state, not meant to be called by users. Only used for testing.\r\n   *\r\n   * Calling this in your game is UNSUPPORTED\r\n   * @internal\r\n   */\r\n  public static _reset() {\r\n    Flags._FROZEN = false;\r\n    Flags._FLAGS = {};\r\n  }\r\n\r\n  /**\r\n   * Turn on webgl support\r\n   */\r\n  public static useWebGL() {\r\n    Flags.enable(Experiments.WebGL);\r\n  }\r\n\r\n  public static useCanvasGraphicsContext() {\r\n    Flags.enable(Legacy.Canvas);\r\n  }\r\n\r\n  /**\r\n   * @deprecated Recommended not to use legacy drawing, going away in v0.26.0\r\n   */\r\n  public static useLegacyDrawing() {\r\n    Flags.enable(Legacy.LegacyDrawing);\r\n  }\r\n\r\n  /**\r\n   * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static enable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be enabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = true;\r\n  }\r\n\r\n  /**\r\n   * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static disable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be disabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = false;\r\n  }\r\n\r\n  /**\r\n   * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned\r\n   * @param flagName\r\n   */\r\n  public static isEnabled(flagName: string): boolean {\r\n    return !!Flags._FLAGS[flagName];\r\n  }\r\n\r\n  /**\r\n   * Show a list of currently known flags\r\n   */\r\n  public static show(): string[] {\r\n    return Object.keys(Flags._FLAGS);\r\n  }\r\n}\r\n","/* eslint-disable no-console */\r\n/**\r\n * Logging level that Excalibur will tag\r\n */\r\nexport enum LogLevel {\r\n  Debug,\r\n  Info,\r\n  Warn,\r\n  Error,\r\n  Fatal\r\n}\r\n\r\n/**\r\n * Static singleton that represents the logging facility for Excalibur.\r\n * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n * Derive from [[Appender]] to create your own logging appenders.\r\n */\r\nexport class Logger {\r\n  private static _INSTANCE: Logger = null;\r\n  private _appenders: Appender[] = [];\r\n\r\n  constructor() {\r\n    if (Logger._INSTANCE) {\r\n      throw new Error('Logger is a singleton');\r\n    }\r\n    Logger._INSTANCE = this;\r\n    // Default console appender\r\n    Logger._INSTANCE.addAppender(new ConsoleAppender());\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the default logging level. Excalibur will only log\r\n   * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n   */\r\n  public defaultLevel: LogLevel = LogLevel.Info;\r\n\r\n  /**\r\n   * Gets the current static instance of Logger\r\n   */\r\n  public static getInstance(): Logger {\r\n    if (Logger._INSTANCE == null) {\r\n      Logger._INSTANCE = new Logger();\r\n    }\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Adds a new [[Appender]] to the list of appenders to write to\r\n   */\r\n  public addAppender(appender: Appender): void {\r\n    this._appenders.push(appender);\r\n  }\r\n\r\n  /**\r\n   * Clears all appenders from the logger\r\n   */\r\n  public clearAppenders(): void {\r\n    this._appenders.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Logs a message at a given LogLevel\r\n   * @param level  The LogLevel`to log the message at\r\n   * @param args   An array of arguments to write to an appender\r\n   */\r\n  private _log(level: LogLevel, args: any[]): void {\r\n    if (level == null) {\r\n      level = this.defaultLevel;\r\n    }\r\n\r\n    const len = this._appenders.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (level >= this.defaultLevel) {\r\n        this._appenders[i].log(level, args);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Debug]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public debug(...args: any[]): void {\r\n    this._log(LogLevel.Debug, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Info]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public info(...args: any[]): void {\r\n    this._log(LogLevel.Info, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Warn]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public warn(...args: any[]): void {\r\n    this._log(LogLevel.Warn, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Error]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public error(...args: any[]): void {\r\n    this._log(LogLevel.Error, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Fatal]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public fatal(...args: any[]): void {\r\n    this._log(LogLevel.Fatal, args);\r\n  }\r\n}\r\n\r\n/**\r\n * Contract for any log appender (such as console/screen)\r\n */\r\nexport interface Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  log(level: LogLevel, args: any[]): void;\r\n}\r\n\r\n/**\r\n * Console appender for browsers (i.e. `console.log`)\r\n */\r\nexport class ConsoleAppender implements Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    // Check for console support\r\n    if (!console && !console.log && console.warn && console.error) {\r\n      // todo maybe do something better than nothing\r\n      return;\r\n    }\r\n\r\n    // Create a new console args array\r\n    const consoleArgs: any[] = [];\r\n    consoleArgs.unshift.apply(consoleArgs, args);\r\n    consoleArgs.unshift('[' + LogLevel[level] + '] : ');\r\n\r\n    if (level < LogLevel.Warn) {\r\n      // Call .log for Debug/Info\r\n      if (console.log.apply) {\r\n        // this is required on some older browsers that don't support apply on console.log :(\r\n        console.log.apply(console, consoleArgs);\r\n      } else {\r\n        console.log(consoleArgs.join(' '));\r\n      }\r\n    } else if (level < LogLevel.Error) {\r\n      // Call .warn for Warn\r\n      if (console.warn.apply) {\r\n        console.warn.apply(console, consoleArgs);\r\n      } else {\r\n        console.warn(consoleArgs.join(' '));\r\n      }\r\n    } else {\r\n      // Call .error for Error/Fatal\r\n      if (console.error.apply) {\r\n        console.error.apply(console, consoleArgs);\r\n      } else {\r\n        console.error(consoleArgs.join(' '));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * On-screen (canvas) appender\r\n */\r\nexport class ScreenAppender implements Appender {\r\n  // @todo Clean this up\r\n\r\n  private _messages: string[] = [];\r\n  private _canvas: HTMLCanvasElement;\r\n  private _ctx: CanvasRenderingContext2D;\r\n\r\n  /**\r\n   * @param width   Width of the screen appender in pixels\r\n   * @param height  Height of the screen appender in pixels\r\n   */\r\n  constructor(width?: number, height?: number) {\r\n    this._canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    this._canvas.width = width || window.innerWidth;\r\n    this._canvas.height = height || window.innerHeight;\r\n    this._canvas.style.position = 'absolute';\r\n    // eslint-disable-next-line\r\n    this._ctx = <CanvasRenderingContext2D>this._canvas.getContext('2d'); // eslint-disable-line\r\n    document.body.appendChild(this._canvas);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    const message = args.join(',');\r\n\r\n    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n\r\n    this._messages.unshift('[' + LogLevel[level] + '] : ' + message);\r\n\r\n    let pos = 10;\r\n    let opacity = 1.0;\r\n    for (let i = 0; i < this._messages.length; i++) {\r\n      this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';\r\n      this._ctx.fillText(this._messages[i], 200, pos);\r\n      pos += 10;\r\n      opacity = opacity > 0 ? opacity - 0.05 : 0;\r\n    }\r\n  }\r\n}\r\n","import 'core-js/es/array/sort';\r\nimport 'core-js/es/object/keys';\r\n\r\n/**\r\n * Polyfill adding function\r\n */\r\nexport function polyfill() {\r\n  /* istanbul ignore next */\r\n  if (typeof window === 'undefined') {\r\n    window = <any>{\r\n      audioContext: function () {\r\n        return;\r\n      }\r\n    };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.requestAnimationFrame) {\r\n    (<any>window).requestAnimationFrame =\r\n      (<any>window).webkitRequestAnimationFrame ||\r\n      (<any>window).mozRequestAnimationFrame ||\r\n      function (callback: Function) {\r\n        window.setInterval(callback, 1000 / 60);\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {\r\n    (<any>window).cancelAnimationFrame =\r\n      (<any>window).webkitCancelAnimationFrame ||\r\n      (<any>window).mozCancelAnimationFrame ||\r\n      function () {\r\n        return;\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).AudioContext) {\r\n    if ((<any>window).webkitAudioContext) {\r\n      const ctx = (<any>window).webkitAudioContext;\r\n      const replaceMe = ctx.prototype.decodeAudioData;\r\n      (<any>window).webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer: ArrayBuffer) {\r\n        return new Promise((resolve, reject) => {\r\n          replaceMe.call(this, arrayBuffer, resolve, reject);\r\n        });\r\n      };\r\n    }\r\n\r\n    (<any>window).AudioContext =\r\n      (<any>window).AudioContext ||\r\n      (<any>window).webkitAudioContext ||\r\n      (<any>window).mozAudioContext ||\r\n      (<any>window).msAudioContext ||\r\n      (<any>window).oAudioContext;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).devicePixelRatio) {\r\n    (<any>window).devicePixelRatio = window.devicePixelRatio || 1;\r\n  }\r\n}\r\n","export type Id<T extends string> = {\r\n  type: T,\r\n  value: number\r\n};\r\n\r\n/**\r\n *\r\n */\r\nexport function createId<T extends string>(type: T, value: number): Id<T> {\r\n  return { type, value };\r\n};\r\n","/**\r\n * @module\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n */\r\n\r\n/**\r\n * 32-bit mask\r\n */\r\nconst BITMASK32: number = 0xffffffff;\r\n\r\n/**\r\n * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n * of numbers each time it is called.\r\n * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n *\r\n * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n */\r\nexport class Random {\r\n  // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\r\n  private _lowerMask: number = 0x7fffffff; // 31 bits same as _r\r\n  private _upperMask: number = 0x80000000; // 34 high bits\r\n\r\n  // Word size, 64 bits\r\n  private _w: number = 32;\r\n\r\n  // Degree of recurrence\r\n  private _n: number = 624;\r\n\r\n  // Middle word, an offset used in the recurrence defining the series x, 1<=m<n\r\n  private _m: number = 397;\r\n  // coefficients of teh rational normal form twist matrix\r\n  private _a: number = 0x9908b0df;\r\n\r\n  // tempering bit shifts and masks\r\n  private _u: number = 11;\r\n  private _s: number = 7;\r\n  private _b: number = 0x9d2c5680;\r\n  private _t: number = 15;\r\n  private _c: number = 0xefc60000;\r\n  private _l: number = 18;\r\n  private _f: number = 1812433253;\r\n\r\n  private _mt: number[];\r\n\r\n  private _index: number;\r\n\r\n  /**\r\n   * If no seed is specified, the Date.now() is used\r\n   */\r\n  constructor(public seed?: number) {\r\n    this._mt = new Array<number>(this._n);\r\n    // need to mask to support higher bit machines\r\n    this._mt[0] = (seed || Date.now()) >>> 0;\r\n\r\n    for (let i = 1; i < this._n; i++) {\r\n      const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));\r\n      // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits\r\n      this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;\r\n    }\r\n    this._index = this._n;\r\n  }\r\n\r\n  /**\r\n   * Apply the twist\r\n   */\r\n  private _twist(): void {\r\n    const mag01 = [0x0, this._a];\r\n    let y = 0,\r\n      i = 0;\r\n    for (; i < this._n - this._m; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    for (; i < this._n - 1; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);\r\n    this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n\r\n    this._index = 0;\r\n  }\r\n\r\n  /**\r\n   * Return next 32 bit integer number in sequence\r\n   */\r\n  public nextInt(): number {\r\n    if (this._index >= this._n) {\r\n      this._twist();\r\n    }\r\n\r\n    let y = this._mt[this._index++];\r\n\r\n    y ^= y >>> this._u;\r\n    y ^= (y << this._s) & this._b;\r\n    y ^= (y << this._t) & this._c;\r\n    y ^= y >>> this._l;\r\n\r\n    return y >>> 0;\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point number between [0, 1)\r\n   */\r\n  public next(): number {\r\n    return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point in range [min, max) min is included, max is not included\r\n   */\r\n  public floating(min: number, max: number): number {\r\n    return (max - min) * this.next() + min;\r\n  }\r\n\r\n  /**\r\n   * Return a random integer in range [min, max] min is included, max is included.\r\n   * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n   */\r\n  public integer(min: number, max: number): number {\r\n    return Math.floor((max - min + 1) * this.next() + min);\r\n  }\r\n\r\n  /**\r\n   * Returns true or false randomly with 50/50 odds by default.\r\n   * By default the likelihood of returning a true is .5 (50%).\r\n   * @param likelihood takes values between [0, 1]\r\n   */\r\n  public bool(likelihood: number = 0.5): boolean {\r\n    return this.next() <= likelihood;\r\n  }\r\n\r\n  /**\r\n   * Returns one element from an array at random\r\n   */\r\n  public pickOne<T>(array: Array<T>): T {\r\n    return array[this.integer(0, array.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original\r\n   * @param array Original array to pick from\r\n   * @param numPicks can be any positive number\r\n   * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n   * just that it is possible)\r\n   */\r\n  public pickSet<T>(array: Array<T>, numPicks: number, allowDuplicates: boolean = false): Array<T> {\r\n    if (allowDuplicates) {\r\n      return this._pickSetWithDuplicates(array, numPicks);\r\n    } else {\r\n      return this._pickSetWithoutDuplicates(array, numPicks);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new array randomly picking elements in the original (not reused)\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks must be less than or equal to the number of elements in the array.\r\n   */\r\n  private _pickSetWithoutDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    if (numPicks > array.length || numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');\r\n    }\r\n    if (numPicks === array.length) {\r\n      return array;\r\n    }\r\n\r\n    const result: Array<T> = new Array<T>(numPicks);\r\n    let currentPick = 0;\r\n    const tempArray = array.slice(0);\r\n    while (currentPick < numPicks) {\r\n      const index = this.integer(0, tempArray.length - 1);\r\n      result[currentPick++] = tempArray[index];\r\n      tempArray.splice(index, 1);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original allowing duplicates\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks can be any positive number\r\n   */\r\n  private _pickSetWithDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\r\n    if (numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');\r\n    }\r\n    const result = new Array<T>(numPicks);\r\n    for (let i = 0; i < numPicks; i++) {\r\n      result[i] = this.pickOne(array);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n   */\r\n  public shuffle<T>(array: Array<T>): Array<T> {\r\n    const tempArray = array.slice(0);\r\n    let swap: T = null;\r\n    for (let i = 0; i < tempArray.length - 2; i++) {\r\n      const randomIndex = this.integer(i, tempArray.length - 1);\r\n      swap = tempArray[i];\r\n      tempArray[i] = tempArray[randomIndex];\r\n      tempArray[randomIndex] = swap;\r\n    }\r\n\r\n    return tempArray;\r\n  }\r\n\r\n  /**\r\n   * Generate a list of random integer numbers\r\n   * @param length the length of the final array\r\n   * @param min the minimum integer number to generate inclusive\r\n   * @param max the maximum integer number to generate inclusive\r\n   */\r\n  public range(length: number, min: number, max: number): Array<number> {\r\n    const result: Array<number> = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      result[i] = this.integer(min, max);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d4 dice roll\r\n   */\r\n  public d4() {\r\n    return this.integer(1, 4);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d6 dice roll\r\n   */\r\n  public d6() {\r\n    return this.integer(1, 6);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d8 dice roll\r\n   */\r\n  public d8() {\r\n    return this.integer(1, 8);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d10 dice roll\r\n   */\r\n  public d10() {\r\n    return this.integer(1, 10);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d12 dice roll\r\n   */\r\n  public d12() {\r\n    return this.integer(1, 12);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d20 dice roll\r\n   */\r\n  public d20() {\r\n    return this.integer(1, 20);\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * An enum that describes the sides of an axis aligned box for collision\r\n */\r\nexport enum Side {\r\n  None = 'None',\r\n  Top = 'Top',\r\n  Bottom = 'Bottom',\r\n  Left = 'Left',\r\n  Right = 'Right'\r\n}\r\n\r\nexport module Side {\r\n  /**\r\n   * Returns the opposite side from the current\r\n   */\r\n  export function getOpposite(side: Side): Side {\r\n    if (side === Side.Top) {\r\n      return Side.Bottom;\r\n    }\r\n    if (side === Side.Bottom) {\r\n      return Side.Top;\r\n    }\r\n    if (side === Side.Left) {\r\n      return Side.Right;\r\n    }\r\n    if (side === Side.Right) {\r\n      return Side.Left;\r\n    }\r\n\r\n    return Side.None;\r\n  }\r\n\r\n  /**\r\n   * Given a vector, return the Side most in that direction (via dot product)\r\n   */\r\n  export function fromDirection(direction: Vector): Side {\r\n    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];\r\n    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];\r\n\r\n    let max = -Number.MAX_VALUE;\r\n    let maxIndex = -1;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      if (directions[i].dot(direction) > max) {\r\n        max = directions[i].dot(direction);\r\n        maxIndex = i;\r\n      }\r\n    }\r\n    return directionEnum[maxIndex];\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Random } from '../Math/Random';\r\nimport { Side } from '../Collision/Side';\r\n\r\n/**\r\n * Two PI constant\r\n */\r\nexport const TwoPI: number = Math.PI * 2;\r\n\r\n/**\r\n * Merges one or more objects into a single target object\r\n *\r\n * @param deep Whether or not to do a deep clone\r\n * @param target The target object to attach properties on\r\n * @param objects The objects whose properties to merge\r\n * @returns Merged object with properties from other objects\r\n */\r\nexport function extend(deep: boolean, target: any, ...objects: any[]): any;\r\n\r\n/**\r\n * Merges one or more objects into a single target object\r\n *\r\n * @param target The target object to attach properties on\r\n * @param object2 The second object whose properties to merge\r\n * @returns Merged object with properties from other objects\r\n */\r\nexport function extend<T1, T2>(target: T1, object2: T2): T1 & T2;\r\n\r\n/**\r\n * Merges one or more objects into a single target object\r\n *\r\n * @param target The target object to attach properties on\r\n * @param object2 The second object whose properties to merge\r\n * @param object3 The third object whose properties to merge\r\n * @returns Merged object with properties from other objects\r\n */\r\nexport function extend<T1, T2, T3>(target: T1, object2: T2, object3: T3): T1 & T2 & T3;\r\n\r\n/**\r\n * Merges one or more objects into a single target object\r\n *\r\n * @param target The target object to attach properties on\r\n * @param objects The objects whose properties to merge\r\n * @returns Merged object with properties from other objects\r\n */\r\nexport function extend(target: any, ...objects: any[]): any;\r\n\r\n/**\r\n * Merges one or more objects into a single target object\r\n *\r\n * @returns Merged object with properties from other objects\r\n * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/\r\n */\r\nexport function extend() {\r\n  const extended: { [key: string]: any } = {};\r\n  let deep = false;\r\n  let i = 0;\r\n  const length = arguments.length;\r\n\r\n  // Check if a deep merge\r\n  if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {\r\n    deep = arguments[0];\r\n    i++;\r\n  }\r\n\r\n  // Merge the object into the extended object\r\n  const assignExists = typeof (<any>Object).assign === 'function';\r\n  let merge = null;\r\n  if (!assignExists) {\r\n    merge = function (obj: any) {\r\n      for (const prop in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n          // If deep merge and property is an object, merge properties\r\n          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\r\n            extended[prop] = extend(true, extended[prop], obj[prop]);\r\n          } else {\r\n            extended[prop] = obj[prop];\r\n          }\r\n        }\r\n      }\r\n    };\r\n  } else {\r\n    merge = (<any>Object).assign;\r\n  }\r\n\r\n  // Loop through each object and conduct a merge\r\n  for (; i < length; i++) {\r\n    const obj = arguments[i];\r\n    if (!assignExists) {\r\n      merge(obj);\r\n    } else {\r\n      merge(extended, obj);\r\n    }\r\n  }\r\n\r\n  return extended;\r\n}\r\n\r\n/**\r\n * Encode a string in base64\r\n * @deprecated This will be removed in v0.26.0\r\n */\r\nexport function base64Encode(inputStr: string) {\r\n  const b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n  let outputStr = '';\r\n  let i = 0;\r\n\r\n  while (i < inputStr.length) {\r\n    //all three \"& 0xff\" added below are there to fix a known bug\r\n    //with bytes returned by xhr.responseText\r\n    const byte1 = inputStr.charCodeAt(i++) & 0xff;\r\n    const byte2 = inputStr.charCodeAt(i++) & 0xff;\r\n    const byte3 = inputStr.charCodeAt(i++) & 0xff;\r\n\r\n    const enc1 = byte1 >> 2;\r\n    const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);\r\n\r\n    let enc3, enc4;\r\n    if (isNaN(byte2)) {\r\n      enc3 = enc4 = 64;\r\n    } else {\r\n      enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);\r\n      if (isNaN(byte3)) {\r\n        enc4 = 64;\r\n      } else {\r\n        enc4 = byte3 & 63;\r\n      }\r\n    }\r\n\r\n    outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);\r\n  }\r\n\r\n  return outputStr;\r\n}\r\n\r\n/**\r\n * Sugar that will use `nullishVal` if it's not null or undefined. Simulates the `??` operator\r\n * @param nullishVal\r\n * @param defaultVal\r\n */\r\nexport function nullish<T>(nullishVal: T | undefined | null, defaultVal: T): T {\r\n  return nullishVal !== null && nullishVal !== undefined ? nullishVal : defaultVal;\r\n}\r\n\r\n/**\r\n * Clamps a value between a min and max inclusive\r\n */\r\nexport function clamp(val: number, min: number, max: number) {\r\n  return Math.min(Math.max(min, val), max);\r\n}\r\n\r\n/**\r\n * Find a random floating point number in range\r\n */\r\nexport function randomInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.floating(min, max) : min + Math.random() * (max - min);\r\n}\r\n\r\n/**\r\n * Find a random integer in a range\r\n */\r\nexport function randomIntInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.integer(min, max) : Math.round(randomInRange(min, max));\r\n}\r\n\r\n/**\r\n * Convert an angle to be the equivalent in the range [0, 2PI]\r\n */\r\nexport function canonicalizeAngle(angle: number): number {\r\n  let tmpAngle = angle;\r\n  if (angle > TwoPI) {\r\n    while (tmpAngle > TwoPI) {\r\n      tmpAngle -= TwoPI;\r\n    }\r\n  }\r\n\r\n  if (angle < 0) {\r\n    while (tmpAngle < 0) {\r\n      tmpAngle += TwoPI;\r\n    }\r\n  }\r\n  return tmpAngle;\r\n}\r\n\r\n/**\r\n * Convert radians to degrees\r\n */\r\nexport function toDegrees(radians: number): number {\r\n  return (180 / Math.PI) * radians;\r\n}\r\n\r\n/**\r\n * Convert degrees to radians\r\n */\r\nexport function toRadians(degrees: number): number {\r\n  return (degrees / 180) * Math.PI;\r\n}\r\n\r\n/**\r\n * Find the screen position of an HTML element\r\n */\r\nexport function getPosition(el: HTMLElement): Vector {\r\n  let oLeft: number = 0,\r\n    oTop: number = 0;\r\n\r\n  const calcOffsetLeft = (parent: HTMLElement) => {\r\n    oLeft += parent.offsetLeft;\r\n\r\n    if (parent.offsetParent) {\r\n      calcOffsetLeft(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n  const calcOffsetTop = (parent: HTMLElement) => {\r\n    oTop += parent.offsetTop;\r\n    if (parent.offsetParent) {\r\n      calcOffsetTop(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n\r\n  calcOffsetLeft(el);\r\n  calcOffsetTop(el);\r\n\r\n  return new Vector(oLeft, oTop);\r\n}\r\n\r\n/**\r\n * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function addItemToArray<T>(item: T, array: T[]): boolean {\r\n  if (array.indexOf(item) === -1) {\r\n    array.push(item);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Remove an item from an list\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function removeItemFromArray<T>(item: T, array: T[]): boolean {\r\n  let index = -1;\r\n  if ((index = array.indexOf(item)) > -1) {\r\n    array.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * See if an array contains something\r\n */\r\nexport function contains(array: Array<any>, obj: any): boolean {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (array[i] === obj) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get the opposit side\r\n * TODO: Move to Side type\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function getOppositeSide(side: Side) {\r\n  if (side === Side.Top) {\r\n    return Side.Bottom;\r\n  }\r\n  if (side === Side.Bottom) {\r\n    return Side.Top;\r\n  }\r\n  if (side === Side.Left) {\r\n    return Side.Right;\r\n  }\r\n  if (side === Side.Right) {\r\n    return Side.Left;\r\n  }\r\n\r\n  return Side.None;\r\n}\r\n\r\n/**\r\n * Returns the side in the direction of the vector supplied\r\n * @param direction Vector to check\r\n * @deprecated\r\n * TODO: Move to Side type\r\n */\r\nexport function getSideFromDirection(direction: Vector) {\r\n  const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];\r\n  const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];\r\n\r\n  let max = -Number.MAX_VALUE;\r\n  let maxIndex = -1;\r\n  for (let i = 0; i < directions.length; i++) {\r\n    if (directions[i].dot(direction) > max) {\r\n      max = directions[i].dot(direction);\r\n      maxIndex = i;\r\n    }\r\n  }\r\n  return directionEnum[maxIndex];\r\n}\r\n\r\n/**\r\n * Excalibur's dynamically resizing collection\r\n * @deprecated Will be removed v0.26.0\r\n */\r\nexport class Collection<T> {\r\n  /**\r\n   * Default collection size\r\n   */\r\n  public static DefaultSize = 200;\r\n  private _internalArray: T[] = null;\r\n  private _endPointer: number = 0;\r\n\r\n  /**\r\n   * @param initialSize  Initial size of the internal backing array\r\n   */\r\n  constructor(initialSize: number = Collection.DefaultSize) {\r\n    this._internalArray = new Array<T>(initialSize);\r\n  }\r\n\r\n  private _resize() {\r\n    const newSize = this._internalArray.length * 2;\r\n    const newArray = new Array<T>(newSize);\r\n    const count = this.count();\r\n    for (let i = 0; i < count; i++) {\r\n      newArray[i] = this._internalArray[i];\r\n    }\r\n\r\n    delete this._internalArray;\r\n    this._internalArray = newArray;\r\n  }\r\n\r\n  /**\r\n   * Push elements to the end of the collection\r\n   */\r\n  public push(element: T): T {\r\n    if (this._endPointer === this._internalArray.length) {\r\n      this._resize();\r\n    }\r\n    return (this._internalArray[this._endPointer++] = element);\r\n  }\r\n\r\n  /**\r\n   * Removes elements from the end of the collection\r\n   */\r\n  public pop(): T {\r\n    this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;\r\n    return this._internalArray[this._endPointer];\r\n  }\r\n\r\n  /**\r\n   * Returns the count of the collection\r\n   */\r\n  public count(): number {\r\n    return this._endPointer;\r\n  }\r\n\r\n  /**\r\n   * Empties the collection\r\n   */\r\n  public clear() {\r\n    this._endPointer = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the size of the internal backing array\r\n   */\r\n  public internalSize(): number {\r\n    return this._internalArray.length;\r\n  }\r\n\r\n  /**\r\n   * Returns an element at a specific index\r\n   * @param index  Index of element to retrieve\r\n   */\r\n  public elementAt(index: number): T {\r\n    if (index >= this.count()) {\r\n      //Logger.getInstance().error('Invalid parameter: ' + index);\r\n      throw new Error('Invalid index ' + index);\r\n    }\r\n    return this._internalArray[index];\r\n  }\r\n\r\n  /**\r\n   * Inserts an element at a specific index\r\n   * @param index  Index to insert the element\r\n   * @param value  Element to insert\r\n   */\r\n  public insert(index: number, value: T): T {\r\n    if (index >= this.count()) {\r\n      this._resize();\r\n    }\r\n    return (this._internalArray[index] = value);\r\n  }\r\n\r\n  /**\r\n   * Removes an element at a specific index\r\n   * @param index  Index of element to remove\r\n   */\r\n  public remove(index: number): T {\r\n    const count = this.count();\r\n    if (count === 0) {\r\n      //Logger.getInstance().error('Invalid parameter: ' + index);\r\n      throw new Error('Invalid parameter ' + index);\r\n    }\r\n    // O(n) Shift\r\n    const removed = this._internalArray[index];\r\n    for (let i = index; i < count; i++) {\r\n      this._internalArray[i] = this._internalArray[i + 1];\r\n    }\r\n    this._endPointer--;\r\n    return removed;\r\n  }\r\n\r\n  /**\r\n   * Removes an element by reference\r\n   * @param element  Element to retrieve\r\n   */\r\n  public removeElement(element: T) {\r\n    const index = this._internalArray.indexOf(element);\r\n    this.remove(index);\r\n  }\r\n\r\n  /**\r\n   * Returns a array representing the collection\r\n   */\r\n  public toArray(): T[] {\r\n    return this._internalArray.slice(0, this._endPointer);\r\n  }\r\n\r\n  /**\r\n   * Iterate over every element in the collection\r\n   * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored\r\n   */\r\n  public forEach(func: (element: T, index: number) => any) {\r\n    let i = 0;\r\n    const count = this.count();\r\n    for (i; i < count; i++) {\r\n      func.call(this, this._internalArray[i], i);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mutate every element in the collection\r\n   * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate\r\n   * the collection\r\n   */\r\n  public map(func: (element: T, index: number) => any) {\r\n    const count = this.count();\r\n    for (let i = 0; i < count; i++) {\r\n      this._internalArray[i] = func.call(this, this._internalArray[i], i);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Used for exhaustive checks at compile time\r\n */\r\nexport function fail(message: never): never {\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Generate a range of numbers\r\n * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]\r\n * @param from inclusive\r\n * @param to inclusive\r\n */\r\nexport const range = (from: number, to: number) => Array.from(new Array(to - from + 1), (_x, i) => i + from);\r\n\r\n/**\r\n * Create a promise that resolves after a certain number of milliseconds\r\n * @param milliseconds\r\n */\r\nexport function delay(milliseconds: number): Promise<void> {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve();\r\n    }, milliseconds);\r\n  });\r\n}\r\n","import { Flags } from '../Flags';\r\nimport { Logger } from './Log';\r\nimport { extend } from './Util';\r\n\r\n/**\r\n * Obsolete decorator options\r\n */\r\nexport interface ObsoleteOptions {\r\n  // Optionally specify a custom message\r\n  message?: string;\r\n  // Optionally indicate that an alternate method to the obsolete one exists\r\n  alternateMethod?: string;\r\n  // Optional show stack trace, by default off\r\n  showStackTrace?: boolean;\r\n}\r\n\r\nexport const maxMessages = 5;\r\nconst obsoleteMessage: { [messageCount: string]: number } = {};\r\nexport const resetObsoleteCounter = () => {\r\n  for (const message in obsoleteMessage) {\r\n    obsoleteMessage[message] = 0;\r\n  }\r\n};\r\n\r\nconst logMessage = (message: string, options: ObsoleteOptions) => {\r\n  const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');\r\n  if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {\r\n    Logger.getInstance().warn(message);\r\n\r\n    // tslint:disable-next-line: no-console\r\n    if (console.trace && options.showStackTrace) {\r\n      // tslint:disable-next-line: no-console\r\n      console.trace();\r\n    }\r\n  }\r\n  obsoleteMessage[message]++;\r\n};\r\n\r\n/**\r\n * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n */\r\nexport function obsolete(options?: ObsoleteOptions): any {\r\n  options = extend(\r\n    {},\r\n    {\r\n      message: 'This feature will be removed in future versions of Excalibur.',\r\n      alternateMethod: null,\r\n      showStackTrack: false\r\n    },\r\n    options\r\n  );\r\n\r\n  return function (target: any, property: string, descriptor: PropertyDescriptor): any {\r\n    if (\r\n      descriptor &&\r\n      !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\r\n    ) {\r\n      throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');\r\n    }\r\n    const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;\r\n\r\n    const message =\r\n      `${methodSignature} is marked obsolete: ${options.message}` +\r\n      (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');\r\n\r\n    if (!obsoleteMessage[message]) {\r\n      obsoleteMessage[message] = 0;\r\n    }\r\n\r\n    // If descriptor is null it is a class\r\n    const method = descriptor ? { ...descriptor } : target;\r\n    if (!descriptor) {\r\n      // with es2015 classes we need to change our decoration tactic\r\n      class DecoratedClass extends method {\r\n        constructor(...args: any) {\r\n          logMessage(message, options);\r\n          super(...args);\r\n        }\r\n      }\r\n      return DecoratedClass;\r\n    }\r\n\r\n    if (descriptor && descriptor.value) {\r\n      method.value = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.value.apply(this, arguments);\r\n      };\r\n      return method;\r\n    }\r\n\r\n    if (descriptor && descriptor.get) {\r\n      method.get = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.get.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    if (descriptor && descriptor.set) {\r\n      method.set = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.set.apply(this, arguments);\r\n      };\r\n    }\r\n    return method;\r\n  };\r\n}\r\n","import { Clonable } from '../Interfaces/Clonable';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n/**\r\n * A 2D vector on a plane.\r\n */\r\n\r\nexport class Vector implements Clonable<Vector> {\r\n  /**\r\n   * A (0, 0) vector\r\n   */\r\n  public static get Zero() {\r\n    return new Vector(0, 0);\r\n  }\r\n\r\n  /**\r\n   * A (1, 1) vector\r\n   */\r\n  public static get One() {\r\n    return new Vector(1, 1);\r\n  }\r\n\r\n  /**\r\n   * A (0.5, 0.5) vector\r\n   */\r\n  public static get Half() {\r\n    return new Vector(0.5, 0.5);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing up (0, -1)\r\n   */\r\n  public static get Up() {\r\n    return new Vector(0, -1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing down (0, 1)\r\n   */\r\n  public static get Down() {\r\n    return new Vector(0, 1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing left (-1, 0)\r\n   */\r\n  public static get Left() {\r\n    return new Vector(-1, 0);\r\n  }\r\n  /**\r\n   * A unit vector pointing right (1, 0)\r\n   */\r\n  public static get Right() {\r\n    return new Vector(1, 0);\r\n  }\r\n\r\n  /**\r\n   * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n   * @param angle The angle to generate the vector\r\n   */\r\n  public static fromAngle(angle: number) {\r\n    return new Vector(Math.cos(angle), Math.sin(angle));\r\n  }\r\n\r\n  /**\r\n   * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n   */\r\n  public static isValid(vec: Vector) {\r\n    if (vec === null || vec === undefined) {\r\n      return false;\r\n    }\r\n    if (isNaN(vec.x) || isNaN(vec.y)) {\r\n      return false;\r\n    }\r\n\r\n    if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculates distance between two Vectors\r\n   * @param vec1\r\n   * @param vec2\r\n   */\r\n  public static distance(vec1: Vector, vec2: Vector) {\r\n    return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\r\n  }\r\n\r\n  /**\r\n   * @param x  X component of the Vector\r\n   * @param y  Y component of the Vector\r\n   */\r\n  constructor(x: number, y: number) {\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  protected _x = 0;\r\n  /**\r\n   * Get the x component of the vector\r\n   */\r\n  public get x(): number {\r\n    return this._x;\r\n  }\r\n\r\n  /**\r\n   * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set x(val: number) {\r\n    this._x = val;\r\n  }\r\n\r\n  protected _y = 0;\r\n  /**\r\n   * Get the y component of the vector\r\n   */\r\n  public get y(): number {\r\n    return this._y;\r\n  }\r\n\r\n  /**\r\n   * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set y(val: number) {\r\n    this._y = val;\r\n  }\r\n\r\n  /**\r\n   * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   *\r\n   * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  setTo(x: number, y: number) {\r\n    (this.x as number) = x;\r\n    (this.y as number) = y;\r\n  }\r\n\r\n  /**\r\n   * Compares this point against another and tests for equality\r\n   * @param vector The other point to compare to\r\n   * @param tolerance Amount of euclidean distance off we are willing to tolerate\r\n   */\r\n  public equals(vector: Vector, tolerance: number = 0.001): boolean {\r\n    return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\r\n  }\r\n\r\n  /**\r\n   * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n   * @param v  The other vector. Leave blank to use origin vector.\r\n   */\r\n  public distance(v?: Vector): number {\r\n    if (!v) {\r\n      v = Vector.Zero;\r\n    }\r\n    return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\r\n  }\r\n\r\n  public squareDistance(v?: Vector): number {\r\n    if (!v) {\r\n      v = Vector.Zero;\r\n    }\r\n    return Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2);\r\n  }\r\n\r\n  /**\r\n   * The magnitude (size) of the Vector\r\n   * @deprecated magnitude will be removed in favour of '.size' in version 0.25.0\r\n   */\r\n  @obsolete({ message: 'will be removed in favour of `.size` in version 0.25.0' })\r\n  public magnitude(): number {\r\n    return this.distance();\r\n  }\r\n\r\n  /**\r\n   * The size (magnitude) of the Vector\r\n   */\r\n  public get size(): number {\r\n    return this.distance();\r\n  }\r\n\r\n  /**\r\n   * Setting the size mutates the current vector\r\n   *\r\n   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  public set size(newLength: number) {\r\n    const v = this.normalize().scale(newLength);\r\n    this.setTo(v.x, v.y);\r\n  }\r\n\r\n  /**\r\n   * Normalizes a vector to have a magnitude of 1.\r\n   */\r\n  public normalize(): Vector {\r\n    const d = this.distance();\r\n    if (d > 0) {\r\n      return new Vector(this.x / d, this.y / d);\r\n    } else {\r\n      return new Vector(0, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the average (midpoint) between the current point and the specified\r\n   */\r\n  public average(vec: Vector): Vector {\r\n    return this.add(vec).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Scales a vector's by a factor of size\r\n   * @param size  The factor to scale the magnitude by\r\n   */\r\n  public scale(scale: Vector): Vector;\r\n  public scale(size: number): Vector;\r\n  public scale(sizeOrScale: number | Vector): Vector {\r\n    if (sizeOrScale instanceof Vector) {\r\n      return new Vector(this.x * sizeOrScale.x, this.y * sizeOrScale.y);\r\n    } else {\r\n      return new Vector(this.x * sizeOrScale, this.y * sizeOrScale);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to another\r\n   * @param v The vector to add\r\n   */\r\n  public add(v: Vector): Vector {\r\n    return new Vector(this.x + v.x, this.y + v.y);\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B\r\n   * @param v The vector to subtract\r\n   */\r\n  public sub(v: Vector): Vector {\r\n    return new Vector(this.x - v.x, this.y - v.y);\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to this one modifying the original\r\n   * @param v The vector to add\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public addEqual(v: Vector): Vector {\r\n    this.setTo(this.x + v.x, this.y + v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from this one modifying the original\r\n   * @param v The vector to subtract\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public subEqual(v: Vector): Vector {\r\n    this.setTo(this.x - v.x, this.y - v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales this vector by a factor of size and modifies the original\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public scaleEqual(size: number): Vector {\r\n    this.setTo(this.x * size, this.y * size);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs a dot product with another vector\r\n   * @param v  The vector to dot\r\n   */\r\n  public dot(v: Vector): number {\r\n    return this.x * v.x + this.y * v.y;\r\n  }\r\n\r\n  /**\r\n   * Performs a 2D cross product with scalar. 2D cross products with a scalar return a vector.\r\n   * @param v  The scalar to cross\r\n   */\r\n  public cross(v: number): Vector;\r\n  /**\r\n   * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.\r\n   * @param v  The vector to cross\r\n   */\r\n  public cross(v: Vector): number;\r\n  public cross(v: any): any {\r\n    if (v instanceof Vector) {\r\n      return this.x * v.y - this.y * v.x;\r\n    } else if (typeof v === 'number') {\r\n      return new Vector(v * this.y, -v * this.x);\r\n    }\r\n  }\r\n\r\n  static cross(num: number, vec: Vector): Vector {\r\n    return new Vector(-num * vec.y, num * vec.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the perpendicular vector to this one\r\n   */\r\n  public perpendicular(): Vector {\r\n    return new Vector(this.y, -this.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the normal vector to this one, same as the perpendicular of length 1\r\n   */\r\n  public normal(): Vector {\r\n    return this.perpendicular().normalize();\r\n  }\r\n\r\n  /**\r\n   * Negate the current vector\r\n   */\r\n  public negate(): Vector {\r\n    return this.scale(-1);\r\n  }\r\n\r\n  /**\r\n   * Returns the angle of this vector.\r\n   */\r\n  public toAngle(): number {\r\n    return Math.atan2(this.y, this.x);\r\n  }\r\n\r\n  /**\r\n   * Rotates the current vector around a point by a certain number of\r\n   * degrees in radians\r\n   */\r\n  public rotate(angle: number, anchor?: Vector): Vector {\r\n    if (!anchor) {\r\n      anchor = new Vector(0, 0);\r\n    }\r\n    const sinAngle = Math.sin(angle);\r\n    const cosAngle = Math.cos(angle);\r\n    const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n    const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n    return new Vector(x, y);\r\n  }\r\n\r\n  /**\r\n   * Creates new vector that has the same values as the previous.\r\n   */\r\n  public clone(): Vector {\r\n    return new Vector(this.x, this.y);\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of the vector.\r\n   */\r\n  public toString(fixed?: number): string {\r\n    if (fixed) {\r\n      return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;\r\n    }\r\n    return `(${this.x}, ${this.y})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Shorthand for creating new Vectors - returns a new Vector instance with the\r\n * provided X and Y components.\r\n *\r\n * @param x  X component of the Vector\r\n * @param y  Y component of the Vector\r\n */\r\nexport function vec(x: number, y: number): Vector {\r\n  return new Vector(x, y);\r\n}\r\n","import { obsolete } from './Util/Decorators';\r\n\r\n/**\r\n * Provides standard colors (e.g. [[Color.Black]])\r\n * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n */\r\nexport class Color {\r\n  /**\r\n   * Red channel\r\n   */\r\n  public r: number;\r\n  /**\r\n   * Green channel\r\n   */\r\n  public g: number;\r\n  /**\r\n   * Blue channel\r\n   */\r\n  public b: number;\r\n  /**\r\n   * Alpha channel (between 0 and 1)\r\n   */\r\n  public a: number;\r\n\r\n  /**\r\n   * Hue\r\n   */\r\n  public h: number;\r\n  /**\r\n   * Saturation\r\n   */\r\n  public s: number;\r\n  /**\r\n   * Lightness\r\n   */\r\n  public l: number;\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  constructor(r: number, g: number, b: number, a?: number) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a != null ? a : 1;\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  public static fromRGB(r: number, g: number, b: number, a?: number): Color {\r\n    return new Color(r, g, b, a);\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a rgb string\r\n   *\r\n   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)\r\n   */\r\n  public static fromRGBString(string: string): Color {\r\n    const rgbaRegEx: RegExp = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/i;\r\n    let match = null;\r\n    if ((match = string.match(rgbaRegEx))) {\r\n      const r = parseInt(match[1], 10);\r\n      const g = parseInt(match[2], 10);\r\n      const b = parseInt(match[3], 10);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseFloat(match[4]);\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid rgb/a string: ' + string);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a hex string\r\n   *\r\n   * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n   */\r\n  public static fromHex(hex: string): Color {\r\n    const hexRegEx: RegExp = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\r\n    let match = null;\r\n    if ((match = hex.match(hexRegEx))) {\r\n      const r = parseInt(match[1], 16);\r\n      const g = parseInt(match[2], 16);\r\n      const b = parseInt(match[3], 16);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseInt(match[4], 16) / 255;\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid hex string: ' + hex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from hsla values\r\n   *\r\n   * @param h  Hue is represented [0-1]\r\n   * @param s  Saturation is represented [0-1]\r\n   * @param l  Luminance is represented [0-1]\r\n   * @param a  Alpha is represented [0-1]\r\n   */\r\n  public static fromHSL(h: number, s: number, l: number, a: number = 1.0): Color {\r\n    const temp = new HSLColor(h, s, l, a);\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Lightens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to lighten by [0-1]\r\n   */\r\n  public lighten(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l += (1 - temp.l) * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Darkens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to darken by [0-1]\r\n   */\r\n  public darken(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l -= temp.l * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Saturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to saturate by [0-1]\r\n   */\r\n  public saturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s += temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Desaturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to desaturate by [0-1]\r\n   */\r\n  public desaturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s -= temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Multiplies a color by another, results in a darker color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public multiply(color: Color): Color {\r\n    const newR = (((color.r / 255) * this.r) / 255) * 255;\r\n    const newG = (((color.g / 255) * this.g) / 255) * 255;\r\n    const newB = (((color.b / 255) * this.b) / 255) * 255;\r\n    const newA = color.a * this.a;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  /**\r\n   * Multiplies a color by another, results in a darker color\r\n   * @param color\r\n   * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0\r\n   */\r\n  @obsolete({ message: 'Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0' })\r\n  public mulitiply(color: Color): Color {\r\n    return this.multiply(color);\r\n  }\r\n\r\n  /**\r\n   * Screens a color by another, results in a lighter color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public screen(color: Color): Color {\r\n    const color1 = color.invert();\r\n    const color2 = color.invert();\r\n    return color1.multiply(color2).invert();\r\n  }\r\n\r\n  /**\r\n   * Inverts the current color\r\n   */\r\n  public invert(): Color {\r\n    return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\r\n  }\r\n\r\n  /**\r\n   * Averages the current color with another\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public average(color: Color): Color {\r\n    const newR = (color.r + this.r) / 2;\r\n    const newG = (color.g + this.g) / 2;\r\n    const newB = (color.b + this.b) / 2;\r\n    const newA = (color.a + this.a) / 2;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  public equal(color: Color): boolean {\r\n    return this.toString() === color.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   *\r\n   * @param format Color representation, accepts: rgb, hsl, or hex\r\n   */\r\n  public toString(format: 'rgb' | 'hsl' | 'hex' = 'rgb') {\r\n    switch (format) {\r\n      case 'rgb':\r\n        return this.toRGBA();\r\n      case 'hsl':\r\n        return this.toHSLA();\r\n      case 'hex':\r\n        return this.toHex();\r\n      default:\r\n        throw new Error('Invalid Color format');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Hex Value of a color component\r\n   * @param c color component\r\n   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n   */\r\n  private _componentToHex(c: number) {\r\n    const hex = c.toString(16);\r\n    return hex.length === 1 ? '0' + hex : hex;\r\n  }\r\n\r\n  /**\r\n   * Return Hex representation of a color.\r\n   */\r\n  public toHex() {\r\n    return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\r\n  }\r\n\r\n  /**\r\n   * Return RGBA representation of a color.\r\n   */\r\n  public toRGBA() {\r\n    const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));\r\n    if (this.a !== undefined || this.a !== null) {\r\n      return 'rgba(' + result + ', ' + String(this.a) + ')';\r\n    }\r\n    return 'rgb(' + result + ')';\r\n  }\r\n\r\n  /**\r\n   * Return HSLA representation of a color.\r\n   */\r\n  public toHSLA() {\r\n    return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   */\r\n  public fillStyle() {\r\n    return this.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of the current color.\r\n   */\r\n  public clone(): Color {\r\n    return new Color(this.r, this.g, this.b, this.a);\r\n  }\r\n\r\n  /**\r\n   * Black (#000000)\r\n   */\r\n  public static get Black(): Color {\r\n    return Color.fromHex('#000000');\r\n  }\r\n\r\n  /**\r\n   * White (#FFFFFF)\r\n   */\r\n  public static get White(): Color {\r\n    return Color.fromHex('#FFFFFF');\r\n  }\r\n\r\n  /**\r\n   * Gray (#808080)\r\n   */\r\n  public static get Gray(): Color {\r\n    return Color.fromHex('#808080');\r\n  }\r\n\r\n  /**\r\n   * Light gray (#D3D3D3)\r\n   */\r\n  public static get LightGray(): Color {\r\n    return Color.fromHex('#D3D3D3');\r\n  }\r\n\r\n  /**\r\n   * Dark gray (#A9A9A9)\r\n   */\r\n  public static get DarkGray(): Color {\r\n    return Color.fromHex('#A9A9A9');\r\n  }\r\n\r\n  /**\r\n   * Yellow (#FFFF00)\r\n   */\r\n  public static get Yellow(): Color {\r\n    return Color.fromHex('#FFFF00');\r\n  }\r\n\r\n  /**\r\n   * Orange (#FFA500)\r\n   */\r\n  public static get Orange(): Color {\r\n    return Color.fromHex('#FFA500');\r\n  }\r\n\r\n  /**\r\n   * Red (#FF0000)\r\n   */\r\n  public static get Red(): Color {\r\n    return Color.fromHex('#FF0000');\r\n  }\r\n\r\n  /**\r\n   * Vermilion (#FF5B31)\r\n   */\r\n  public static get Vermilion(): Color {\r\n    return Color.fromHex('#FF5B31');\r\n  }\r\n\r\n  /**\r\n   * Vermilion (#FF5B31)\r\n   * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0\r\n   */\r\n  @obsolete({\r\n    message: 'Alias for incorrect spelling used in older versions',\r\n    alternateMethod: 'Vermilion'\r\n  })\r\n  public static get Vermillion(): Color {\r\n    return Color.Vermilion;\r\n  }\r\n\r\n  /**\r\n   * Rose (#FF007F)\r\n   */\r\n  public static get Rose(): Color {\r\n    return Color.fromHex('#FF007F');\r\n  }\r\n\r\n  /**\r\n   * Magenta (#FF00FF)\r\n   */\r\n  public static get Magenta(): Color {\r\n    return Color.fromHex('#FF00FF');\r\n  }\r\n\r\n  /**\r\n   * Violet (#7F00FF)\r\n   */\r\n  public static get Violet(): Color {\r\n    return Color.fromHex('#7F00FF');\r\n  }\r\n\r\n  /**\r\n   * Blue (#0000FF)\r\n   */\r\n  public static get Blue(): Color {\r\n    return Color.fromHex('#0000FF');\r\n  }\r\n\r\n  /**\r\n   * Azure (#007FFF)\r\n   */\r\n  public static get Azure(): Color {\r\n    return Color.fromHex('#007FFF');\r\n  }\r\n\r\n  /**\r\n   * Cyan (#00FFFF)\r\n   */\r\n  public static get Cyan(): Color {\r\n    return Color.fromHex('#00FFFF');\r\n  }\r\n\r\n  /**\r\n   * Viridian (#59978F)\r\n   */\r\n  public static get Viridian(): Color {\r\n    return Color.fromHex('#59978F');\r\n  }\r\n\r\n  /**\r\n   * Green (#00FF00)\r\n   */\r\n  public static get Green(): Color {\r\n    return Color.fromHex('#00FF00');\r\n  }\r\n\r\n  /**\r\n   * Chartreuse (#7FFF00)\r\n   */\r\n  public static get Chartreuse(): Color {\r\n    return Color.fromHex('#7FFF00');\r\n  }\r\n\r\n  /**\r\n   * Transparent (#FFFFFF00)\r\n   */\r\n  public static get Transparent(): Color {\r\n    return Color.fromHex('#FFFFFF00');\r\n  }\r\n\r\n  /**\r\n   * ExcaliburBlue (#176BAA)\r\n   */\r\n  public static get ExcaliburBlue(): Color {\r\n    return Color.fromHex('#176BAA');\r\n  }\r\n}\r\n\r\n/**\r\n * Internal HSL Color representation\r\n *\r\n * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n */\r\nclass HSLColor {\r\n  constructor(public h: number, public s: number, public l: number, public a: number) {}\r\n\r\n  public static hue2rgb(p: number, q: number, t: number): number {\r\n    if (t < 0) {\r\n      t += 1;\r\n    }\r\n    if (t > 1) {\r\n      t -= 1;\r\n    }\r\n    if (t < 1 / 6) {\r\n      return p + (q - p) * 6 * t;\r\n    }\r\n    if (t < 1 / 2) {\r\n      return q;\r\n    }\r\n    if (t < 2 / 3) {\r\n      return p + (q - p) * (2 / 3 - t) * 6;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public static fromRGBA(r: number, g: number, b: number, a: number): HSLColor {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n    const max = Math.max(r, g, b),\r\n      min = Math.min(r, g, b);\r\n    let h, s;\r\n    const l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // achromatic\r\n    } else {\r\n      const d = max - min;\r\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      switch (max) {\r\n        case r:\r\n          h = (g - b) / d + (g < b ? 6 : 0);\r\n          break;\r\n        case g:\r\n          h = (b - r) / d + 2;\r\n          break;\r\n        case b:\r\n          h = (r - g) / d + 4;\r\n          break;\r\n      }\r\n      h /= 6;\r\n    }\r\n\r\n    return new HSLColor(h, s, l, a);\r\n  }\r\n\r\n  public toRGBA(): Color {\r\n    let r: number, g: number, b: number;\r\n\r\n    if (this.s === 0) {\r\n      r = g = b = this.l; // achromatic\r\n    } else {\r\n      const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\r\n      const p = 2 * this.l - q;\r\n      r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\r\n      g = HSLColor.hue2rgb(p, q, this.h);\r\n      b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\r\n    }\r\n\r\n    return new Color(r * 255, g * 255, b * 255, this.a);\r\n  }\r\n\r\n  public toString(): string {\r\n    const h = this.h.toFixed(0),\r\n      s = this.s.toFixed(0),\r\n      l = this.l.toFixed(0),\r\n      a = this.a.toFixed(0);\r\n    return `hsla(${h}, ${s}, ${l}, ${a})`;\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\nimport { Ray } from '../Math/ray';\nimport { Color } from '../Color';\nimport { Side } from './Side';\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\nimport { Matrix } from '../Math/matrix';\n\nexport interface BoundingBoxOptions {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\n\n/**\n * Axis Aligned collision primitive for Excalibur.\n */\nexport class BoundingBox {\n  public top: number;\n  public right: number;\n  public bottom: number;\n  public left: number;\n\n  /**\n   * Constructor allows passing of either an object with all coordinate components,\n   * or the coordinate components passed separately.\n   * @param leftOrOptions    Either x coordinate of the left edge or an options object\n   * containing the four coordinate components.\n   * @param top     y coordinate of the top edge\n   * @param right   x coordinate of the right edge\n   * @param bottom  y coordinate of the bottom edge\n   */\n  constructor(leftOrOptions: number | BoundingBoxOptions = 0, top: number = 0, right: number = 0, bottom: number = 0) {\n    if (typeof leftOrOptions === 'object') {\n      this.left = leftOrOptions.left;\n      this.top = leftOrOptions.top;\n      this.right = leftOrOptions.right;\n      this.bottom = leftOrOptions.bottom;\n    } else if (typeof leftOrOptions === 'number') {\n      this.left = leftOrOptions;\n      this.top = top;\n      this.right = right;\n      this.bottom = bottom;\n    }\n  }\n\n  /**\n   * Given bounding box A & B, returns the side relative to A when intersection is performed.\n   * @param intersection Intersection vector between 2 bounding boxes\n   */\n  public static getSideFromIntersection(intersection: Vector): Side {\n    if (!intersection) {\n      return Side.None;\n    }\n    if (intersection) {\n      if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\n        if (intersection.x < 0) {\n          return Side.Right;\n        }\n        return Side.Left;\n      } else {\n        if (intersection.y < 0) {\n          return Side.Bottom;\n        }\n        return Side.Top;\n      }\n    }\n    return Side.None;\n  }\n\n  public static fromPoints(points: Vector[]): BoundingBox {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < points.length; i++) {\n      if (points[i].x < minX) {\n        minX = points[i].x;\n      }\n      if (points[i].x > maxX) {\n        maxX = points[i].x;\n      }\n      if (points[i].y < minY) {\n        minY = points[i].y;\n      }\n      if (points[i].y > maxY) {\n        maxY = points[i].y;\n      }\n    }\n    return new BoundingBox(minX, minY, maxX, maxY);\n  }\n\n  public static fromDimension(width: number, height: number, anchor: Vector = Vector.Half, pos: Vector = Vector.Zero) {\n    return new BoundingBox(\n      -width * anchor.x + pos.x,\n      -height * anchor.y + pos.y,\n      width - width * anchor.x + pos.x,\n      height - height * anchor.y + pos.y\n    );\n  }\n\n  /**\n   * Returns the calculated width of the bounding box\n   */\n  public get width() {\n    return this.right - this.left;\n  }\n\n  /**\n   * Returns the calculated height of the bounding box\n   */\n  public get height() {\n    return this.bottom - this.top;\n  }\n\n  /**\n   * Return whether the bounding box has zero dimensions in height,width or both\n   */\n  public hasZeroDimensions() {\n    return this.width === 0 || this.height === 0;\n  }\n\n  /**\n   * Returns the center of the bounding box\n   */\n  public get center(): Vector {\n    return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);\n  }\n\n  public translate(pos: Vector): BoundingBox {\n    return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);\n  }\n\n  /**\n   * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding\n   * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.\n   */\n  public rotate(angle: number, point: Vector = Vector.Zero): BoundingBox {\n    const points = this.getPoints().map((p) => p.rotate(angle, point));\n    return BoundingBox.fromPoints(points);\n  }\n\n  public scale(scale: Vector, point: Vector = Vector.Zero): BoundingBox {\n    const shifted = this.translate(point);\n    return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);\n  }\n\n  public transform(matrix: Matrix) {\n    const points = this.getPoints().map((p) => matrix.multv(p));\n    return BoundingBox.fromPoints(points);\n  }\n\n  /**\n   * Returns the perimeter of the bounding box\n   */\n  public getPerimeter(): number {\n    const wx = this.width;\n    const wy = this.height;\n    return 2 * (wx + wy);\n  }\n\n  public getPoints(): Vector[] {\n    const results = [];\n    results.push(new Vector(this.left, this.top));\n    results.push(new Vector(this.right, this.top));\n    results.push(new Vector(this.right, this.bottom));\n    results.push(new Vector(this.left, this.bottom));\n    return results;\n  }\n\n  /**\n   * Determines whether a ray intersects with a bounding box\n   */\n  public rayCast(ray: Ray, farClipDistance = Infinity): boolean {\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\n    let tmin = -Infinity;\n    let tmax = +Infinity;\n\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\n\n    const tx1 = (this.left - ray.pos.x) * xinv;\n    const tx2 = (this.right - ray.pos.x) * xinv;\n    tmin = Math.min(tx1, tx2);\n    tmax = Math.max(tx1, tx2);\n\n    const ty1 = (this.top - ray.pos.y) * yinv;\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\n\n    return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\n  }\n\n  public rayCastTime(ray: Ray, farClipDistance = Infinity): number {\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\n    let tmin = -Infinity;\n    let tmax = +Infinity;\n\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\n\n    const tx1 = (this.left - ray.pos.x) * xinv;\n    const tx2 = (this.right - ray.pos.x) * xinv;\n    tmin = Math.min(tx1, tx2);\n    tmax = Math.max(tx1, tx2);\n\n    const ty1 = (this.top - ray.pos.y) * yinv;\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\n\n    if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {\n      return tmin;\n    }\n    return -1;\n  }\n\n  /**\n   * Tests whether a point is contained within the bounding box\n   * @param p  The point to test\n   */\n  public contains(p: Vector): boolean;\n\n  /**\n   * Tests whether another bounding box is totally contained in this one\n   * @param bb  The bounding box to test\n   */\n  public contains(bb: BoundingBox): boolean;\n  public contains(val: any): boolean {\n    if (val instanceof Vector) {\n      return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;\n    } else if (val instanceof BoundingBox) {\n      if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  /**\n   * Combines this bounding box and another together returning a new bounding box\n   * @param other  The bounding box to combine\n   */\n  public combine(other: BoundingBox): BoundingBox {\n    const compositeBB = new BoundingBox(\n      Math.min(this.left, other.left),\n      Math.min(this.top, other.top),\n      Math.max(this.right, other.right),\n      Math.max(this.bottom, other.bottom)\n    );\n    return compositeBB;\n  }\n\n  public get dimensions(): Vector {\n    return new Vector(this.width, this.height);\n  }\n\n  /**\n   * Test wether this bounding box intersects with another returning\n   * the intersection vector that can be used to resolve the collision. If there\n   * is no intersection null is returned.\n   *\n   * @param other  Other [[BoundingBox]] to test intersection with\n   * @returns A Vector in the direction of the current BoundingBox, this <- other\n   */\n  public intersect(other: BoundingBox): Vector {\n    const totalBoundingBox = this.combine(other);\n\n    // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision\n    if (\n      totalBoundingBox.width < other.width + this.width &&\n      totalBoundingBox.height < other.height + this.height &&\n      !totalBoundingBox.dimensions.equals(other.dimensions) &&\n      !totalBoundingBox.dimensions.equals(this.dimensions)\n    ) {\n      // collision\n      let overlapX = 0;\n      // right edge is between the other's left and right edge\n      /**\n       *     +-this-+\n       *     |      |\n       *     |    +-other-+\n       *     +----|-+     |\n       *          |       |\n       *          +-------+\n       *         <---\n       *          ^ overlap\n       */\n      if (this.right >= other.left && this.right <= other.right) {\n        overlapX = other.left - this.right;\n        // right edge is past the other's right edge\n        /**\n         *     +-other-+\n         *     |       |\n         *     |    +-this-+\n         *     +----|--+   |\n         *          |      |\n         *          +------+\n         *          --->\n         *          ^ overlap\n         */\n      } else {\n        overlapX = other.right - this.left;\n      }\n\n      let overlapY = 0;\n      // top edge is between the other's top and bottom edge\n      /**\n       *     +-other-+\n       *     |       |\n       *     |    +-this-+   | <- overlap\n       *     +----|--+   |   |\n       *          |      |  \\ /\n       *          +------+   '\n       */\n      if (this.top <= other.bottom && this.top >= other.top) {\n        overlapY = other.bottom - this.top;\n        // top edge is above the other top edge\n        /**\n         *     +-this-+         .\n         *     |      |        / \\\n         *     |    +-other-+   | <- overlap\n         *     +----|-+     |   |\n         *          |       |\n         *          +-------+\n         */\n      } else {\n        overlapY = other.top - this.bottom;\n      }\n\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\n        return new Vector(overlapX, 0);\n      } else {\n        return new Vector(0, overlapY);\n      }\n      // Case of total containment of one bounding box by another\n    } else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {\n      let overlapX = 0;\n      // this is wider than the other\n      if (this.width - other.width >= 0) {\n        // This right edge is closest to the others right edge\n        if (this.right - other.right <= other.left - this.left) {\n          overlapX = other.left - this.right;\n          // This left edge is closest to the others left edge\n        } else {\n          overlapX = other.right - this.left;\n        }\n        // other is wider than this\n      } else {\n        // This right edge is closest to the others right edge\n        if (other.right - this.right <= this.left - other.left) {\n          overlapX = this.left - other.right;\n          // This left edge is closest to the others left edge\n        } else {\n          overlapX = this.right - other.left;\n        }\n      }\n\n      let overlapY = 0;\n      // this is taller than other\n      if (this.height - other.height >= 0) {\n        // The bottom edge is closest to the others bottom edge\n        if (this.bottom - other.bottom <= other.top - this.top) {\n          overlapY = other.top - this.bottom;\n        } else {\n          overlapY = other.bottom - this.top;\n        }\n        // other is taller than this\n      } else {\n        // The bottom edge is closest to the others bottom edge\n        if (other.bottom - this.bottom <= this.top - other.top) {\n          overlapY = this.top - other.bottom;\n        } else {\n          overlapY = this.bottom - other.top;\n        }\n      }\n\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\n        return new Vector(overlapX, 0);\n      } else {\n        return new Vector(0, overlapY);\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.\n   * @param bb The other actor to test\n   */\n  public intersectWithSide(bb: BoundingBox): Side {\n    const intersect = this.intersect(bb);\n    return BoundingBox.getSideFromIntersection(intersect);\n  }\n\n  /* istanbul ignore next */\n  public debugDraw(ctx: CanvasRenderingContext2D, color: Color = Color.Yellow) {\n    ctx.strokeStyle = color.toString();\n    ctx.strokeRect(this.left, this.top, this.width, this.height);\n  }\n\n  /**\n   * Draw a debug bounding box\n   * @param ex\n   * @param color\n   */\n  public draw(ex: ExcaliburGraphicsContext, color: Color = Color.Yellow) {\n    ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });\n  }\n}\n","import { Logger } from '..';\r\n\r\nexport interface Poolable {\r\n  /**\r\n   * Any type that is a member of a an object pool will have a reference to teh pool\r\n   * @internal\r\n   */\r\n  _pool?: Pool<this>;\r\n  dispose(): this;\r\n}\r\n\r\nexport class Pool<Type extends Poolable> {\r\n  public totalAllocations = 0;\r\n  public index = 0;\r\n  public objects: Type[] = [];\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(\r\n    public builder: (...args: any[]) => Type,\r\n    public recycler: (instance: Type, ...args: any[]) => Type,\r\n    public maxObjects: number = 100\r\n  ) {}\r\n\r\n  /**\r\n   * Use many instances out of the in the context and return all to the pool.\r\n   *\r\n   * By returning values out of the contex they will be un-hooked from the pool and are free to be passed to consumers\r\n   * @param context\r\n   */\r\n  using(context: (pool: Pool<Type>) => Type[] | void) {\r\n    const result = context(this);\r\n    if (result) {\r\n      return this.done(...result);\r\n    }\r\n    return this.done();\r\n  }\r\n\r\n  /**\r\n   * Use a single instance out of th pool and immediately return it to the pool\r\n   * @param context\r\n   */\r\n  borrow(context: (object: Type) => void) {\r\n    const object = this.get();\r\n    context(object);\r\n    this.index--;\r\n  }\r\n\r\n  /**\r\n   * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool\r\n   * @param args\r\n   */\r\n  get(...args: any[]): Type {\r\n    if (this.index === this.maxObjects) {\r\n      // TODO implement hard or soft cap\r\n      this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');\r\n      this.maxObjects = this.maxObjects * 2;\r\n      // throw new Error('Max pooled objects reached, possible memory leak?');\r\n    }\r\n\r\n    if (this.objects[this.index]) {\r\n      // Pool has an available object already constructed\r\n      return this.recycler(this.objects[this.index++], ...args);\r\n    } else {\r\n      // New allocation\r\n      this.totalAllocations++;\r\n      const object = (this.objects[this.index++] = this.builder(...args));\r\n      object._pool = this;\r\n      return object;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Signals we are done with the pool objects for now, Reclaims all objects in the pool.\r\n   *\r\n   * If a list of pooled objects is passed to done they are un-hooked from the pool and are free\r\n   * to be passed to consumers\r\n   * @param objects A list of object to separate from the pool\r\n   */\r\n  done(...objects: Type[]): Type[];\r\n  done(): void;\r\n  done(...objects: Type[]): Type[] | void {\r\n    // All objects in pool now considered \"free\"\r\n    this.index = 0;\r\n    for (const object of objects) {\r\n      const poolIndex = this.objects.indexOf(object);\r\n      // Build a new object to take the pool place\r\n      this.objects[poolIndex] = (this as any).builder(); // TODO problematic 0-arg only support\r\n      this.objects[poolIndex]._pool = this;\r\n      this.totalAllocations++;\r\n      // Unhook object from the pool\r\n      object._pool = undefined;\r\n    }\r\n    return objects;\r\n  }\r\n}\r\n","import { vec } from '..';\nimport { Vector } from './vector';\nimport { canonicalizeAngle } from '../Util/Util';\n\nexport enum MatrixLocations {\n  X = 12,\n  Y = 13\n}\n\nconst sign = (val: number) => {\n  if (val === 0) {\n    return 0;\n  }\n  return val < 0 ? -1 : 1;\n};\n\n// const multMatch = (a: number, b: number) => {\n//   if (sign(a) < 0 && sign(b) < 0) {\n//     return -Math.abs(a * b);\n//   }\n//   return a * b;\n// }\n\n// const epsilon = (val: number) => {\n//   if (val * val < .0001) {\n//     return 0;\n//   }\n//   return val;\n// }\n\n/**\n * Excalibur Matrix helper for 4x4 matrices\n *\n * Useful for webgl 4x4 matrices\n */\nexport class Matrix {\n  /**\n   *  4x4 matrix in column major order\n   *\n   * |         |         |          |          |\n   * | ------- | ------- | -------- |          |\n   * | data[0] | data[4] | data[8]  | data[12] |\n   * | data[1] | data[5] | data[9]  | data[13] |\n   * | data[2] | data[6] | data[10] | data[14] |\n   * | data[3] | data[7] | data[11] | data[15] |\n   *\n   */\n  public data: Float32Array = new Float32Array(16);\n\n  /**\n   * Creates an orthographic (flat non-perspective) projection\n   * https://en.wikipedia.org/wiki/Orthographic_projection\n   * @param left\n   * @param right\n   * @param bottom\n   * @param top\n   * @param near\n   * @param far\n   */\n  public static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix {\n    const mat = new Matrix();\n    mat.data[0] = 2 / (right - left);\n    mat.data[1] = 0;\n    mat.data[2] = 0;\n    mat.data[3] = 0;\n\n    mat.data[4] = 0;\n    mat.data[5] = 2 / (top - bottom);\n    mat.data[6] = 0;\n    mat.data[7] = 0;\n\n    mat.data[8] = 0;\n    mat.data[9] = 0;\n    mat.data[10] = -2 / (far - near);\n    mat.data[11] = 0;\n\n    mat.data[12] = -(right + left) / (right - left);\n    mat.data[13] = -(top + bottom) / (top - bottom);\n    mat.data[14] = -(far + near) / (far - near);\n    mat.data[15] = 1;\n    return mat;\n  }\n\n  /**\n   * Creates a new Matrix with the same data as the current 4x4\n   */\n  public clone(): Matrix {\n    const mat = new Matrix();\n    mat.data[0] = this.data[0];\n    mat.data[1] = this.data[1];\n    mat.data[2] = this.data[2];\n    mat.data[3] = this.data[3];\n\n    mat.data[4] = this.data[4];\n    mat.data[5] = this.data[5];\n    mat.data[6] = this.data[6];\n    mat.data[7] = this.data[7];\n\n    mat.data[8] = this.data[8];\n    mat.data[9] = this.data[9];\n    mat.data[10] = this.data[10];\n    mat.data[11] = this.data[11];\n\n    mat.data[12] = this.data[12];\n    mat.data[13] = this.data[13];\n    mat.data[14] = this.data[14];\n    mat.data[15] = this.data[15];\n    return mat;\n  }\n\n  /**\n   * Creates a new identity matrix (a matrix that when applied does nothing)\n   */\n  public static identity(): Matrix {\n    const mat = new Matrix();\n    mat.data[0] = 1;\n    mat.data[1] = 0;\n    mat.data[2] = 0;\n    mat.data[3] = 0;\n\n    mat.data[4] = 0;\n    mat.data[5] = 1;\n    mat.data[6] = 0;\n    mat.data[7] = 0;\n\n    mat.data[8] = 0;\n    mat.data[9] = 0;\n    mat.data[10] = 1;\n    mat.data[11] = 0;\n\n    mat.data[12] = 0;\n    mat.data[13] = 0;\n    mat.data[14] = 0;\n    mat.data[15] = 1;\n    return mat;\n  }\n\n  /**\n   * Creates a brand new translation matrix at the specified 3d point\n   * @param x\n   * @param y\n   */\n  public static translation(x: number, y: number): Matrix {\n    const mat = Matrix.identity();\n    mat.data[12] = x;\n    mat.data[13] = y;\n    return mat;\n  }\n\n  /**\n   * Creates a brand new scaling matrix with the specified scaling factor\n   * @param sx\n   * @param sy\n   */\n  public static scale(sx: number, sy: number): Matrix {\n    const mat = Matrix.identity();\n    mat.data[0] = sx;\n    mat.data[5] = sy;\n    mat.data[10] = 1;\n    mat.data[15] = 1;\n    return mat;\n  }\n\n  /**\n   * Creates a brand new rotation matrix with the specified angle\n   * @param angleRadians\n   */\n  public static rotation(angleRadians: number): Matrix {\n    const mat = Matrix.identity();\n    mat.data[0] = Math.cos(angleRadians);\n    mat.data[4] = -Math.sin(angleRadians);\n    mat.data[1] = Math.sin(angleRadians);\n    mat.data[5] = Math.cos(angleRadians);\n    return mat;\n  }\n\n  /**\n   * Multiplies the current matrix by a vector and returns the resulting vector\n   * @param other\n   */\n  multv(other: [number, number]): [number, number];\n  multv(other: Vector): Vector;\n  multv(other: [number, number] | Vector): [number, number] | Vector {\n    const z = 0;\n    if (other instanceof Vector) {\n      return new Vector(\n        other.x * this.data[0] + other.y * this.data[4] + z * this.data[6] + 1 * this.data[12],\n        other.x * this.data[1] + other.y * this.data[5] + z * this.data[9] + 1 * this.data[13]\n      );\n    } else {\n      const dest: [number, number] = [\n        other[0] * this.data[0] + other[1] * this.data[4] + z * this.data[6] + 1 * this.data[12],\n\n        other[0] * this.data[1] + other[1] * this.data[5] + z * this.data[9] + 1 * this.data[13]\n      ];\n      return dest;\n    }\n  }\n\n  /**\n   * Multiplies the current matrix by another and returns the resulting matrix\n   * @param other\n   */\n  multm(other: Matrix): Matrix {\n    const dest = new Matrix();\n    const a11 = this.data[0];\n    const a21 = this.data[1];\n    const a31 = this.data[2];\n    const a41 = this.data[3];\n\n    const a12 = this.data[4];\n    const a22 = this.data[5];\n    const a32 = this.data[6];\n    const a42 = this.data[7];\n\n    const a13 = this.data[8];\n    const a23 = this.data[9];\n    const a33 = this.data[10];\n    const a43 = this.data[11];\n\n    const a14 = this.data[12];\n    const a24 = this.data[13];\n    const a34 = this.data[14];\n    const a44 = this.data[15];\n\n    const b11 = other.data[0];\n    const b21 = other.data[1];\n    const b31 = other.data[2];\n    const b41 = other.data[3];\n\n    const b12 = other.data[4];\n    const b22 = other.data[5];\n    const b32 = other.data[6];\n    const b42 = other.data[7];\n\n    const b13 = other.data[8];\n    const b23 = other.data[9];\n    const b33 = other.data[10];\n    const b43 = other.data[11];\n\n    const b14 = other.data[12];\n    const b24 = other.data[13];\n    const b34 = other.data[14];\n    const b44 = other.data[15];\n\n    dest.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    dest.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    dest.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    dest.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\n    dest.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    dest.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    dest.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    dest.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\n    dest.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    dest.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    dest.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    dest.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\n    dest.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    dest.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    dest.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    dest.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n    const s = this.getScale();\n    dest._scaleSignX = sign(s.x) * sign(dest._scaleSignX);\n    dest._scaleSignY = sign(s.y) * sign(dest._scaleSignY);\n\n    return dest;\n  }\n\n  /**\n   * Applies translation to the current matrix mutating it\n   * @param x\n   * @param y\n   */\n  translate(x: number, y: number) {\n    const a11 = this.data[0];\n    const a21 = this.data[1];\n    const a31 = this.data[2];\n    const a41 = this.data[3];\n\n    const a12 = this.data[4];\n    const a22 = this.data[5];\n    const a32 = this.data[6];\n    const a42 = this.data[7];\n\n    const a13 = this.data[8];\n    const a23 = this.data[9];\n    const a33 = this.data[10];\n    const a43 = this.data[11];\n\n    const a14 = this.data[12];\n    const a24 = this.data[13];\n    const a34 = this.data[14];\n    const a44 = this.data[15];\n\n    // Doesn't change z\n    const z = 0;\n    const w = 1;\n    this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;\n    this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;\n    this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;\n    this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;\n\n    return this;\n  }\n\n  public setPosition(x: number, y: number) {\n    this.data[12] = x;\n    this.data[13] = y;\n  }\n\n  public getPosition(): Vector {\n    return vec(this.data[12], this.data[13]);\n  }\n\n  /**\n   * Applies rotation to the current matrix mutating it\n   * @param angle in Radians\n   */\n  rotate(angle: number) {\n    const a11 = this.data[0];\n    const a21 = this.data[1];\n    const a31 = this.data[2];\n    const a41 = this.data[3];\n\n    const a12 = this.data[4];\n    const a22 = this.data[5];\n    const a32 = this.data[6];\n    const a42 = this.data[7];\n\n    const sine = Math.sin(angle);\n    const cosine = Math.cos(angle);\n\n    this.data[0] = cosine * a11 + sine * a12;\n    this.data[1] = cosine * a21 + sine * a22;\n    this.data[2] = cosine * a31 + sine * a32;\n    this.data[3] = cosine * a41 + sine * a42;\n\n    this.data[4] = cosine * a12 - sine * a11;\n    this.data[5] = cosine * a22 - sine * a21;\n    this.data[6] = cosine * a32 - sine * a31;\n    this.data[7] = cosine * a42 - sine * a41;\n\n    return this;\n  }\n\n  /**\n   * Applies scaling to the current matrix mutating it\n   * @param x\n   * @param y\n   */\n  scale(x: number, y: number) {\n    const a11 = this.data[0];\n    const a21 = this.data[1];\n    const a31 = this.data[2];\n    const a41 = this.data[3];\n\n    const a12 = this.data[4];\n    const a22 = this.data[5];\n    const a32 = this.data[6];\n    const a42 = this.data[7];\n\n    this.data[0] = a11 * x;\n    this.data[1] = a21 * x;\n    this.data[2] = a31 * x;\n    this.data[3] = a41 * x;\n\n    this.data[4] = a12 * y;\n    this.data[5] = a22 * y;\n    this.data[6] = a32 * y;\n    this.data[7] = a42 * y;\n\n    return this;\n  }\n\n  public setRotation(angle: number) {\n    const currentScale = this.getScale();\n    const sine = Math.sin(angle);\n    const cosine = Math.cos(angle);\n\n    this.data[0] = cosine * currentScale.x;\n    this.data[1] = sine * currentScale.y;\n    this.data[4] = -sine * currentScale.x;\n    this.data[5] = cosine * currentScale.y;\n  }\n\n  public getRotation(): number {\n    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\n    return canonicalizeAngle(angle);\n  }\n\n  public getScaleX(): number {\n    // absolute scale of the matrix (we lose sign so need to add it back)\n    const xscale = vec(this.data[0], this.data[4]).size;\n    return this._scaleSignX * xscale;\n  }\n\n  public getScaleY(): number {\n    // absolute scale of the matrix (we lose sign so need to add it back)\n    const yscale = vec(this.data[1], this.data[5]).size;\n    return this._scaleSignY * yscale;\n  }\n\n  /**\n   * Get the scale of the matrix\n   */\n  public getScale(): Vector {\n    return vec(this.getScaleX(), this.getScaleY());\n  }\n\n  private _scaleSignX = 1;\n  public setScaleX(val: number) {\n    this._scaleSignX = sign(val);\n    // negative scale acts like a 180 rotation, so flip\n    const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();\n    this.data[0] = xscale.x * val;\n    this.data[4] = xscale.y * val;\n  }\n\n  private _scaleSignY = 1;\n  public setScaleY(val: number) {\n    this._scaleSignY = sign(val);\n    // negative scale acts like a 180 rotation, so flip\n    const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();\n    this.data[1] = yscale.x * val;\n    this.data[5] = yscale.y * val;\n  }\n\n  public setScale(scale: Vector) {\n    this.setScaleX(scale.x);\n    this.setScaleY(scale.y);\n  }\n\n  /**\n   * Determinant of the upper left 2x2 matrix\n   */\n  public getBasisDeterminant() {\n    return this.data[0] * this.data[5] - this.data[1] * this.data[4];\n  }\n\n  public getAffineInverse(): Matrix {\n    // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\n    // See https://www.mathsisfun.com/algebra/matrix-inverse.html\n    // Since we are actually only doing 2D transformations we can use this hack\n    // We don't actually use the 3rd or 4th dimension\n\n    const det = this.getBasisDeterminant();\n    const inverseDet = 1 / det; // todo zero check\n    const a = this.data[0];\n    const b = this.data[4];\n    const c = this.data[1];\n    const d = this.data[5];\n\n    const m = Matrix.identity();\n    // inverts rotation and scale\n    m.data[0] = d * inverseDet;\n    m.data[1] = -c * inverseDet;\n    m.data[4] = -b * inverseDet;\n    m.data[5] = a * inverseDet;\n\n    const tx = this.data[12];\n    const ty = this.data[13];\n    // invert translation\n    // transform translation into the matrix basis created by rot/scale\n    m.data[12] = -(tx * m.data[0] + ty * m.data[4]);\n    m.data[13] = -(tx * m.data[1] + ty * m.data[5]);\n\n    return m;\n  }\n\n  public isIdentity(): boolean {\n    return (\n      this.data[0] === 1 &&\n      this.data[1] === 0 &&\n      this.data[2] === 0 &&\n      this.data[3] === 0 &&\n      this.data[4] === 0 &&\n      this.data[5] === 1 &&\n      this.data[6] === 0 &&\n      this.data[7] === 0 &&\n      this.data[8] === 0 &&\n      this.data[9] === 0 &&\n      this.data[10] === 1 &&\n      this.data[11] === 0 &&\n      this.data[12] === 0 &&\n      this.data[13] === 0 &&\n      this.data[14] === 0 &&\n      this.data[15] === 1\n    );\n  }\n\n  public toString() {\n    return `\n[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]\n[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]\n[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]\n[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]\n`;\n  }\n}\n","import { Matrix } from '../../Math/matrix';\r\n\r\nexport class TransformStack {\r\n  private _transforms: Matrix[] = [];\r\n  private _currentTransform: Matrix = Matrix.identity();\r\n\r\n  public save(): void {\r\n    this._transforms.push(this._currentTransform);\r\n    this._currentTransform = this._currentTransform.clone();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentTransform = this._transforms.pop();\r\n  }\r\n\r\n  public translate(x: number, y: number): Matrix {\r\n    return this._currentTransform.translate(x, y);\r\n  }\r\n\r\n  public rotate(angle: number): Matrix {\r\n    return this._currentTransform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): Matrix {\r\n    return this._currentTransform.scale(x, y);\r\n  }\r\n\r\n  public set current(matrix: Matrix) {\r\n    this._currentTransform = matrix;\r\n  }\r\n\r\n  public get current(): Matrix {\r\n    return this._currentTransform;\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class StateStack {\r\n  private _states: ExcaliburGraphicsContextState[] = [];\r\n  private _currentState: ExcaliburGraphicsContextState = this._getDefaultState();\r\n\r\n  private _getDefaultState() {\r\n    return {\r\n      opacity: 1\r\n    };\r\n  }\r\n\r\n  private _cloneState() {\r\n    return {\r\n      opacity: this._currentState.opacity\r\n    };\r\n  }\r\n\r\n  public save(): void {\r\n    this._states.push(this._currentState);\r\n    this._currentState = this._cloneState();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentState = this._states.pop();\r\n  }\r\n\r\n  public get current(): ExcaliburGraphicsContextState {\r\n    return this._currentState;\r\n  }\r\n}\r\n","export interface VertexAttributeDefinition {\r\n  name: string;\r\n  size: number;\r\n  glType: number;\r\n  normalized: boolean;\r\n  location: number;\r\n}\r\n\r\nexport interface UniformDefinition {\r\n  name: string;\r\n  location: WebGLUniformLocation;\r\n  type: string;\r\n  data: any;\r\n}\r\n\r\n/**\r\n * Create a shader program for the Excalibur WebGL Graphics Context\r\n */\r\nexport class Shader {\r\n  public program: WebGLProgram | null = null;\r\n\r\n  public uniforms: { [variableName: string]: UniformDefinition } = {};\r\n  public attributes: { [variableName: string]: VertexAttributeDefinition } = {};\r\n  public layout: VertexAttributeDefinition[] = [];\r\n\r\n  /**\r\n   * Create a shader program in excalibur\r\n   * @param _gl WebGL graphics context\r\n   * @param _vertexSource Vertex shader source as a string\r\n   * @param _fragmentSource Fragment shader source as a string\r\n   */\r\n  constructor(private _gl: WebGLRenderingContext, private _vertexSource: string, private _fragmentSource: string) {\r\n    this.compile(_gl);\r\n  }\r\n\r\n  private _createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\r\n    const program = gl.createProgram();\r\n    if (program === null) {\r\n      throw Error('Could not create graphics shader program');\r\n    }\r\n\r\n    // attach the shaders.\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n\r\n    // link the program.\r\n    gl.linkProgram(program);\r\n\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!success) {\r\n      throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  private _compileShader(gl: WebGLRenderingContext, source: string, type: number): WebGLShader {\r\n    const shader = gl.createShader(type);\r\n    if (shader === null) {\r\n      throw Error(`Could not build shader: [${source}]`);\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!success) {\r\n      throw Error(`Could not compile shader [${gl.getShaderInfoLog(shader)}]`);\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  /**\r\n   * Compile the current shader against a webgl context\r\n   * @param gl WebGL context\r\n   */\r\n  compile(gl: WebGLRenderingContext): WebGLProgram {\r\n    const vertexShader = this._compileShader(gl, this._vertexSource, gl.VERTEX_SHADER);\r\n    const fragmentShader = this._compileShader(gl, this._fragmentSource, gl.FRAGMENT_SHADER);\r\n    const program = this._createProgram(gl, vertexShader, fragmentShader);\r\n    return (this.program = program);\r\n  }\r\n\r\n  /**\r\n   * Add a uniform [[Matrix]] to the shader\r\n   * @param name Name of the uniform in the shader source\r\n   * @param data (4x4) matrix in column major order\r\n   */\r\n  public addUniformMatrix(name: string, data: Float32Array) {\r\n    if (!data) {\r\n      throw Error(`Shader Uniform Matrix '${name}' was set to null or undefined`);\r\n    }\r\n    const gl = this._gl;\r\n    this.uniforms[name] = {\r\n      name,\r\n      type: 'matrix',\r\n      location: gl.getUniformLocation(this.program, name),\r\n      data: data\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add a uniform array of numbers to the shader\r\n   * @param name Name of the uniform in the shader source\r\n   * @param data List of numbers\r\n   */\r\n  public addUniformIntegerArray(name: string, data: number[]) {\r\n    if (!data) {\r\n      throw Error(`Shader Uniform Integery Array '${name}' was set to null or undefined`);\r\n    }\r\n    const gl = this._gl;\r\n    this.uniforms[name] = {\r\n      name,\r\n      type: 'numbers',\r\n      location: gl.getUniformLocation(this.program, name),\r\n      data: data\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add attributes in the order they appear in the VBO\r\n   * @param name Name of the attribute in the shader source\r\n   * @param size The size of the attribute in gl.Type units, for example `vec2 a_pos` would be 2 gl.FLOAT\r\n   * @param glType The gl.Type of the attribute\r\n   */\r\n  public addAttribute(name: string, size: number, glType: number, normalized = false) {\r\n    const gl = this._gl;\r\n    // TODO needs to be compiled first\r\n    const location = gl.getAttribLocation(this.program, name);\r\n    this.attributes[name] = {\r\n      name,\r\n      size,\r\n      glType,\r\n      normalized,\r\n      location\r\n    };\r\n    this.layout.push(this.attributes[name]);\r\n  }\r\n\r\n  /**\r\n   * Number of javascript floats a vertex will take up\r\n   */\r\n  public get vertexAttributeSize(): number {\r\n    let vertexSize = 0;\r\n    for (const vert of this.layout) {\r\n      vertexSize += vert.size;\r\n    }\r\n    return vertexSize;\r\n  }\r\n\r\n  /**\r\n   * Total number of bytes that the vertex will take up\r\n   */\r\n  public get totalVertexSizeBytes(): number {\r\n    let vertexSize = 0;\r\n    for (const vert of this.layout) {\r\n      let typeSize = 1;\r\n      switch (vert.glType) {\r\n        case this._gl.FLOAT: {\r\n          typeSize = 4;\r\n          break;\r\n        }\r\n        default: {\r\n          typeSize = 1;\r\n        }\r\n      }\r\n      vertexSize += typeSize * vert.size;\r\n    }\r\n\r\n    return vertexSize;\r\n  }\r\n\r\n  /**\r\n   * Get a previously defined attribute size in bytes\r\n   * @param name\r\n   */\r\n  public getAttributeSize(name: string) {\r\n    let typeSize = 1;\r\n    switch (this.attributes[name].glType) {\r\n      case this._gl.FLOAT: {\r\n        typeSize = 4;\r\n        break;\r\n      }\r\n      default: {\r\n        typeSize = 1;\r\n      }\r\n    }\r\n    return typeSize * this.attributes[name].size;\r\n  }\r\n\r\n  /**\r\n   * Sets this shader program as the current in the underlying webgl context\r\n   *\r\n   * **Must** specify all attributes and uniforms before calling this\r\n   */\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.useProgram(this.program);\r\n    let offset = 0;\r\n    for (const vert of this.layout) {\r\n      gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);\r\n      gl.enableVertexAttribArray(vert.location);\r\n      offset += this.getAttributeSize(vert.name);\r\n    }\r\n\r\n    for (const key in this.uniforms) {\r\n      const uniform = this.uniforms[key];\r\n      switch (uniform.type) {\r\n        case 'matrix': {\r\n          gl.uniformMatrix4fv(uniform.location, false, uniform.data);\r\n          break;\r\n        }\r\n        case 'numbers': {\r\n          gl.uniform1iv(uniform.location, uniform.data);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","export default \"precision mediump float;\\r\\n\\r\\n// Color\\r\\nvarying lowp vec4 v_color;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n  gl_FragColor = v_color;\\r\\n}\";","import { Pool, Poolable } from '../../Util/Pool';\r\n\r\nexport class BatchCommand<T> implements Poolable {\r\n  _pool: Pool<this> = undefined;\r\n  public commands: T[] = [];\r\n  constructor(public max: number) {}\r\n\r\n  isFull() {\r\n    if (this.commands.length >= this.max) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  canAdd() {\r\n    return !this.isFull();\r\n  }\r\n\r\n  add(cmd: T) {\r\n    this.commands.push(cmd);\r\n  }\r\n\r\n  dispose() {\r\n    this.commands.length = 0;\r\n    return this;\r\n  }\r\n}\r\n","export class GraphicsDiagnostics {\r\n  public static DrawCallCount: number = 0;\r\n  public static DrawnImagesCount: number = 0;\r\n  public static clear(): void {\r\n    GraphicsDiagnostics.DrawCallCount = 0;\r\n    GraphicsDiagnostics.DrawnImagesCount = 0;\r\n  }\r\n}\r\n","import { BatchCommand } from './batch';\r\nimport { Shader } from './shader';\r\n// import { Pool, Poolable } from './pool';\r\nimport { GraphicsDiagnostics } from '../GraphicsDiagnostics';\r\nimport { Pool, Poolable } from '../../Util/Pool';\r\n\r\nexport interface Renderer {\r\n  render(): void;\r\n}\r\n\r\nexport interface Ctor<T> {\r\n  new (): T;\r\n}\r\n\r\nexport interface BatchRendererOptions<T extends Poolable> {\r\n  gl: WebGLRenderingContext;\r\n  /**\r\n   * Draw command constructor\r\n   */\r\n  command: Ctor<T>;\r\n  /**\r\n   * Number of vertices that are generated per draw command\r\n   */\r\n  verticesPerCommand?: number;\r\n  /**\r\n   * Maximum commands to batch before drawing\r\n   */\r\n  maxCommandsPerBatch?: number;\r\n  /**\r\n   * Override the built in command batching mechanism\r\n   */\r\n  batchFactory?: () => BatchCommand<T>;\r\n}\r\n\r\nexport abstract class BatchRenderer<T extends Poolable> implements Renderer {\r\n  priority = 0;\r\n  private _gl: WebGLRenderingContext;\r\n  private _vertices: Float32Array;\r\n  private _verticesPerCommand: number;\r\n  private _buffer: WebGLBuffer | null = null;\r\n  private _maxCommandsPerBatch: number = 2000;\r\n\r\n  public shader: Shader;\r\n\r\n  public commands: Pool<T>;\r\n  private _batchPool: Pool<BatchCommand<T>>;\r\n  private _batches: BatchCommand<T>[] = [];\r\n  constructor(options: BatchRendererOptions<T>) {\r\n    this._gl = options.gl;\r\n    const command = options.command;\r\n    this._verticesPerCommand = options?.verticesPerCommand ?? 1;\r\n    this._maxCommandsPerBatch = options?.maxCommandsPerBatch ?? this._maxCommandsPerBatch;\r\n    const batchFactory = options?.batchFactory ?? (() => new BatchCommand<T>(this._maxCommandsPerBatch));\r\n\r\n    this.commands = new Pool<T>(\r\n      () => new command(),\r\n      (c) => c.dispose(),\r\n      this._maxCommandsPerBatch\r\n    );\r\n    this._batchPool = new Pool<BatchCommand<T>>(batchFactory, (b) => b.dispose(), 100);\r\n  }\r\n\r\n  /**\r\n   * Initialize render, builds shader and initialized webgl buffers\r\n   */\r\n  public init() {\r\n    const gl = this._gl;\r\n    this.shader = this.buildShader(gl);\r\n    // Initialize VBO\r\n    // https://groups.google.com/forum/#!topic/webgl-dev-list/vMNXSNRAg8M\r\n    this._vertices = new Float32Array(this.shader.vertexAttributeSize * this._verticesPerCommand * this._maxCommandsPerBatch);\r\n    this._buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);\r\n  }\r\n\r\n  public get vertexSize(): number {\r\n    return this.shader.vertexAttributeSize;\r\n  }\r\n\r\n  public addCommand(cmd: T) {\r\n    if (this._batches.length === 0) {\r\n      this._batches.push(this._batchPool.get());\r\n    }\r\n\r\n    const lastBatch = this._batches[this._batches.length - 1];\r\n    if (lastBatch.canAdd()) {\r\n      lastBatch.add(cmd);\r\n    } else {\r\n      const newBatch = this._batchPool.get();\r\n      newBatch.add(cmd);\r\n      this._batches.push(newBatch);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Construct or return the Shader to be used in this batch renderer\r\n   * @param gl\r\n   */\r\n  abstract buildShader(gl: WebGLRenderingContext): Shader;\r\n\r\n  /**\r\n   * Implement populating the vertex buffer, return the number of vertices added to the buffer\r\n   * @param vertices\r\n   * @param batch\r\n   */\r\n  abstract buildBatchVertices(vertexBuffer: Float32Array, batch: BatchCommand<T>): number;\r\n\r\n  /**\r\n   * Implement gl draw call to render batch. The vertextBuffer from buildBatchVertices is already bound and the data has been updated.\r\n   */\r\n  abstract renderBatch(gl: WebGLRenderingContext, batch: BatchCommand<T>, vertexCount: number): void;\r\n\r\n  /**\r\n   * Build batch geometry, submit to the gpu, and issue draw command to underlying webgl\r\n   */\r\n  public render(): void {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);\r\n    this.shader.use();\r\n    let drawCallCount = 0;\r\n    let drawnImagesCount = 0;\r\n    for (const batch of this._batches) {\r\n      // Build all geometry and ship to GPU\r\n      // interleave VBOs https://goharsha.com/lwjgl-tutorial-series/interleaving-buffer-objects/\r\n      const vertexCount = this.buildBatchVertices(this._vertices, batch);\r\n      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);\r\n\r\n      this.renderBatch(gl, batch, vertexCount);\r\n      drawnImagesCount += batch.commands.length;\r\n      drawCallCount++;\r\n    }\r\n    this.commands.done();\r\n    this._batchPool.done();\r\n    this._batches.length = 0;\r\n    GraphicsDiagnostics.DrawCallCount += drawCallCount;\r\n    GraphicsDiagnostics.DrawnImagesCount += drawnImagesCount;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { Shader } from './shader';\r\nimport lineVertexSource from './shaders/line-vertex.glsl';\r\nimport lineFragmentSource from './shaders/line-fragment.glsl';\r\nimport { BatchRenderer } from './renderer';\r\nimport { BatchCommand } from './batch';\r\nimport { WebGLGraphicsContextInfo } from './ExcaliburGraphicsContextWebGL';\r\nimport { Pool, Poolable } from '../../Util/Pool';\r\n\r\nexport class DrawLine implements Poolable {\r\n  _pool?: Pool<this>;\r\n  public color: Color = Color.Black;\r\n  public start: Vector = Vector.Zero;\r\n  public end: Vector = Vector.Zero;\r\n  public dispose() {\r\n    this.color.r = 0;\r\n    this.color.g = 0;\r\n    this.color.b = 0;\r\n    this.color.a = 1;\r\n    this.start.setTo(0, 0);\r\n    this.end.setTo(0, 0);\r\n    return this;\r\n  }\r\n}\r\n\r\nexport class LineRenderer extends BatchRenderer<DrawLine> {\r\n  constructor(gl: WebGLRenderingContext, private _contextInfo: WebGLGraphicsContextInfo) {\r\n    super({ gl, command: DrawLine, verticesPerCommand: 2 });\r\n    this.init();\r\n  }\r\n\r\n  buildShader(gl: WebGLRenderingContext) {\r\n    const shader = new Shader(gl, lineVertexSource, lineFragmentSource);\r\n\r\n    shader.addAttribute('a_position', 2, gl.FLOAT);\r\n    shader.addAttribute('a_color', 4, gl.FLOAT);\r\n    shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);\r\n    return shader;\r\n  }\r\n\r\n  addLine(start: Vector, end: Vector, color: Color) {\r\n    const cmd = this.commands.get();\r\n    cmd.start = this._contextInfo.transform.current.multv(start);\r\n    cmd.end = this._contextInfo.transform.current.multv(end);\r\n    cmd.color.r = color.r;\r\n    cmd.color.g = color.g;\r\n    cmd.color.b = color.b;\r\n    cmd.color.a = cmd.color.a * this._contextInfo.state.current.opacity;\r\n    this.addCommand(cmd);\r\n  }\r\n\r\n  buildBatchVertices(vertexBuffer: Float32Array, batch: BatchCommand<DrawLine>): number {\r\n    let index = 0;\r\n    for (const command of batch.commands) {\r\n      // Start\r\n      vertexBuffer[index++] = command.start.x;\r\n      vertexBuffer[index++] = command.start.y;\r\n      vertexBuffer[index++] = command.color.r / 255;\r\n      vertexBuffer[index++] = command.color.g / 255;\r\n      vertexBuffer[index++] = command.color.b / 255;\r\n      vertexBuffer[index++] = command.color.a;\r\n\r\n      // End\r\n      vertexBuffer[index++] = command.end.x;\r\n      vertexBuffer[index++] = command.end.y;\r\n      vertexBuffer[index++] = command.color.r / 255;\r\n      vertexBuffer[index++] = command.color.g / 255;\r\n      vertexBuffer[index++] = command.color.b / 255;\r\n      vertexBuffer[index++] = command.color.a;\r\n    }\r\n    return index / this.vertexSize;\r\n  }\r\n\r\n  renderBatch(gl: WebGLRenderingContext, _batch: BatchCommand<DrawLine>, vertexCount: number) {\r\n    gl.drawArrays(gl.LINES, 0, vertexCount);\r\n  }\r\n}\r\n","export default \"attribute vec4 a_position;\\r\\n\\r\\n// Opacity \\r\\nattribute float a_opacity;\\r\\nvarying float v_opacity;\\r\\n\\r\\nattribute vec4 a_color;\\r\\nvarying vec4 v_color;\\r\\n\\r\\n// UV coordinate\\r\\nattribute vec2 a_texcoord;\\r\\nvarying vec2 v_texcoord;\\r\\n\\r\\n// Texture number\\r\\nattribute lowp float a_textureIndex;\\r\\nvarying lowp float v_textureIndex;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n   // Set the vertex position using the ortho transform matrix\\r\\n   gl_Position = u_matrix * a_position;\\r\\n\\r\\n   // Pass through the Opacity to the fragment shader\\r\\n   v_opacity = a_opacity;\\r\\n   // Pass through the UV coord to the fragment shader\\r\\n   v_texcoord = a_texcoord;\\r\\n   // Pass through the texture number to the fragment shader\\r\\n   v_textureIndex = a_textureIndex;\\r\\n   // Pass through the color to the fragment shader\\r\\n   v_color = a_color;\\r\\n}\";","export default \"#ifdef GL_OES_standard_derivatives\\r\\n#extension GL_OES_standard_derivatives : enable\\r\\n#endif\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nvarying vec2 v_texcoord;\\r\\n\\r\\n// Texture index\\r\\nvarying lowp float v_textureIndex;\\r\\n\\r\\n// Color coord to blend with image\\r\\nvarying lowp vec4 v_color;\\r\\n\\r\\n// Opacity\\r\\nvarying float v_opacity;\\r\\n\\r\\nuniform sampler2D u_textures[%%count%%];\\r\\n\\r\\nfloat circle(in vec2 st, in float radius) {\\r\\n  vec2 dist = st - vec2(0.5);\\r\\n  float r = dot(dist, dist) * 4.0;\\r\\n  float delta = fwidth(r);\\r\\n  return 1.0 - smoothstep(radius - delta, radius + delta, r);\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n  float r = 0.0, delta = 0.0, alpha = 1.0;\\r\\n   // In order to support the most efficient sprite batching, we have multiple\\r\\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\\r\\n   // that do not apply to a particular sprite.\\r\\n\\r\\n   vec4 color;\\r\\n   // -1 If there is no texture to sample we are drawing a solid geometry (rectangles)\\r\\n   if (v_textureIndex == -1.0) {\\r\\n     color = v_color;\\r\\n     color.w = color.w * v_opacity;\\r\\n   // -2 If there is no texture we are drawing a circle\\r\\n   } else if (v_textureIndex == -2.0) {\\r\\n     color = v_color;\\r\\n     color.a = color.a * circle(v_texcoord, .95);\\r\\n   } else {\\r\\n     // GLSL is templated out to pick the right texture and set the vec4 color\\r\\n      %%texture_picker%%\\r\\n   }\\r\\n   color.w = color.w * v_opacity;\\r\\n   gl_FragColor = color;\\r\\n}\";","import { Matrix } from '../../Math/matrix';\r\nimport { BoundingBox } from '../../Collision/Index';\r\nimport { Color } from '../../Color';\r\nimport { Pool, Poolable } from '../../Util/Pool';\r\nimport { HTMLImageSource } from './ExcaliburGraphicsContext';\r\nimport { vec, Vector } from '../../Math/vector';\r\n\r\nexport enum DrawCommandType {\r\n  Image = 'image',\r\n  Line = 'line',\r\n  Rectangle = 'rectangle',\r\n  Circle = 'circle'\r\n}\r\n\r\nexport class DrawImageCommand implements Poolable {\r\n  _pool: Pool<this> = undefined;\r\n\r\n  public snapToPixel: boolean = true;\r\n  public image: HTMLImageSource;\r\n  public color: Color;\r\n  public type = DrawCommandType.Image;\r\n  public opacity: number = 1;\r\n  public width: number = 0;\r\n  public height: number = 0;\r\n  public dest: [number, number] = [0, 0]; // x, y\r\n  public view: [number, number, number, number] = [0, 0, 0, 0]; // sx, sy, sw, sh\r\n  private _geom: [number, number][] = [\r\n    [0, 0],\r\n    [0, 0],\r\n    [0, 0],\r\n    [0, 0],\r\n    [0, 0],\r\n    [0, 0]\r\n  ];\r\n  constructor();\r\n  constructor(image: HTMLImageSource, x: number, y: number);\r\n  constructor(image: HTMLImageSource, x: number, y: number, width?: number, height?: number);\r\n  constructor(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  );\r\n  constructor(\r\n    image?: HTMLImageSource,\r\n    sx?: number,\r\n    sy?: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ) {\r\n    this.init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n  }\r\n\r\n  public init(\r\n    image?: HTMLImageSource,\r\n    sx?: number,\r\n    sy?: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ) {\r\n    this.type = DrawCommandType.Image;\r\n    this.image = image;\r\n    this.width = image?.width || swidth || 0;\r\n    this.height = image?.height || sheight || 0;\r\n    this.view = [0, 0, swidth ?? image?.width, sheight ?? image?.height];\r\n    this.dest = [sx, sy];\r\n    // If destination is specified, update view and dest\r\n    if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {\r\n      this.view = [sx, sy, swidth ?? image?.width, sheight ?? image?.height];\r\n      this.dest = [dx, dy];\r\n      this.width = dwidth;\r\n      this.height = dheight;\r\n    }\r\n\r\n    let index = 0;\r\n    this._geom[index++] = [this.dest[0], this.dest[1]];\r\n    this._geom[index++] = [this.dest[0], this.dest[1] + this.height];\r\n    this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];\r\n    this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];\r\n    this._geom[index++] = [this.dest[0], this.dest[1] + this.height];\r\n    this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];\r\n    if (this.snapToPixel) {\r\n      for (const point of this._geom) {\r\n        point[0] = ~~point[0];\r\n        point[1] = ~~point[1];\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public initRect(color: Color, start: Vector, width: number, height: number) {\r\n    this.type = DrawCommandType.Rectangle;\r\n    this.color = color;\r\n    this.width = width;\r\n    this.height = height;\r\n    let index = 0;\r\n    this._geom[index++] = [start.x, start.y];\r\n    this._geom[index++] = [start.x, start.y + this.height];\r\n    this._geom[index++] = [start.x + this.width, start.y];\r\n    this._geom[index++] = [start.x + this.width, start.y];\r\n    this._geom[index++] = [start.x, start.y + this.height];\r\n    this._geom[index++] = [start.x + this.width, start.y + this.height];\r\n\r\n    if (this.snapToPixel) {\r\n      for (const point of this._geom) {\r\n        point[0] = ~~point[0];\r\n        point[1] = ~~point[1];\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public initLine(color: Color, start: Vector, end: Vector, thickness: number) {\r\n    this.type = DrawCommandType.Line;\r\n    this.color = color;\r\n    const dir = end.sub(start).normalize();\r\n    const normal = dir.perpendicular();\r\n    const halfThick = thickness / 2;\r\n    const startTop = normal.scale(halfThick).add(start);\r\n    const startBottom = normal.scale(-halfThick).add(start);\r\n    const endTop = normal.scale(halfThick).add(end);\r\n    const endBottom = normal.scale(-halfThick).add(end);\r\n\r\n    /**\r\n     *    +---------------------^----------------------+\r\n     *    |                     | (normal)             |\r\n     *   (startx, starty)------------------>(endx, endy)\r\n     *    |                                            |\r\n     *    + -------------------------------------------+\r\n     */\r\n\r\n    let index = 0;\r\n    this._geom[index++] = [startTop.x, startTop.y];\r\n    this._geom[index++] = [endTop.x, endTop.y];\r\n    this._geom[index++] = [startBottom.x, startBottom.y];\r\n    this._geom[index++] = [startBottom.x, startBottom.y];\r\n    this._geom[index++] = [endTop.x, endTop.y];\r\n    this._geom[index++] = [endBottom.x, endBottom.y];\r\n\r\n    if (this.snapToPixel) {\r\n      for (const point of this._geom) {\r\n        point[0] = ~~point[0];\r\n        point[1] = ~~point[1];\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public initCircle(pos: Vector, radius: number, color: Color) {\r\n    this.type = DrawCommandType.Circle;\r\n    this.color = color;\r\n    const topLeft = pos.add(vec(-radius, -radius));\r\n    const topRight = pos.add(vec(radius, -radius));\r\n    const bottomRight = pos.add(vec(radius, radius));\r\n    const bottomLeft = pos.add(vec(-radius, radius));\r\n    let index = 0;\r\n    this._geom[index++] = [topLeft.x, topLeft.y];\r\n    this._geom[index++] = [topRight.x, topRight.y];\r\n    this._geom[index++] = [bottomLeft.x, bottomLeft.y];\r\n    this._geom[index++] = [bottomLeft.x, bottomLeft.y];\r\n    this._geom[index++] = [topRight.x, topRight.y];\r\n    this._geom[index++] = [bottomRight.x, bottomRight.y];\r\n\r\n    if (this.snapToPixel) {\r\n      for (const point of this._geom) {\r\n        point[0] = ~~point[0];\r\n        point[1] = ~~point[1];\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public dispose() {\r\n    this.image = null;\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.view = [0, 0, 0, 0];\r\n    this.dest = [0, 0];\r\n\r\n    let index = 0;\r\n    this._geom[index++] = [this.dest[0], this.dest[1]];\r\n    this._geom[index++] = [this.dest[0], this.dest[1] + this.height];\r\n    this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];\r\n    this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];\r\n    this._geom[index++] = [this.dest[0], this.dest[1] + this.height];\r\n    this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];\r\n    return this;\r\n  }\r\n\r\n  // todo weird\r\n  applyTransform(transform: Matrix, opacity: number): void {\r\n    if (transform) {\r\n      for (let i = 0; i < this._geom.length; i++) {\r\n        this._geom[i] = transform.multv(this._geom[i]);\r\n        if (this.snapToPixel) {\r\n          this._geom[i] = [~~this._geom[i][0], ~~this._geom[i][1]];\r\n        }\r\n      }\r\n    }\r\n    this.opacity = opacity;\r\n  }\r\n\r\n  public get geometry() {\r\n    return this._geom;\r\n  }\r\n}\r\n\r\nexport class DrawRectCommand {\r\n  public dest: [number, number] = [0, 0];\r\n  public width: number = 0;\r\n  public height: number = 0;\r\n  constructor(x: number, y: number, width: number, height: number) {\r\n    this.dest = [x, y];\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n}\r\n\r\nexport class DrawDebugRectCommand {\r\n  constructor(public bounds: BoundingBox, public color: Color) {}\r\n}\r\n","/**\r\n * Checks if the current number is a power of two\r\n */\r\nexport function isPowerOfTwo(x: number): boolean {\r\n  return (x & (x - 1)) === 0;\r\n}\r\n\r\n/**\r\n * Returns the next highest power of two\r\n */\r\nexport function nextHighestPowerOfTwo(x: number): number {\r\n  --x;\r\n  for (let i = 1; i < 32; i <<= 1) {\r\n    x = x | (x >> i);\r\n  }\r\n  return x + 1;\r\n}\r\n\r\n/**\r\n * Returns the input number if a power of two, otherwise the next highest power of two\r\n */\r\nexport function ensurePowerOfTwo(x: number): number {\r\n  if (!isPowerOfTwo(x)) {\r\n    return nextHighestPowerOfTwo(x);\r\n  }\r\n  return x;\r\n}\r\n","import { HTMLImageSource } from './ExcaliburGraphicsContext';\r\nimport { ensurePowerOfTwo, isPowerOfTwo } from './webgl-util';\r\n\r\n/**\r\n * Manages loading image sources into webgl textures, a unique id is associated with all sources\r\n */\r\nexport class TextureLoader {\r\n  private static _POT_CANVAS = document.createElement('canvas');\r\n  private static _POT_CTX = TextureLoader._POT_CANVAS.getContext('2d');\r\n\r\n  private static _GL: WebGLRenderingContext;\r\n\r\n  private static _TEXTURE_MAP = new Map<HTMLImageSource, WebGLTexture>();\r\n\r\n  public static registerContext(context: WebGLRenderingContext): void {\r\n    TextureLoader._GL = context;\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL Texture from a source image\r\n   * @param image\r\n   */\r\n  public static get(image: HTMLImageSource): WebGLTexture {\r\n    return TextureLoader._TEXTURE_MAP.get(image);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a source image has been loaded as a texture\r\n   * @param image\r\n   */\r\n  public static has(image: HTMLImageSource): boolean {\r\n    return TextureLoader._TEXTURE_MAP.has(image);\r\n  }\r\n\r\n  /**\r\n   * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered\r\n   * @param image Source graphic\r\n   * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed\r\n   */\r\n  public static load(image: HTMLImageSource, forceUpdate = false): WebGLTexture {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    // If reuse the texture if it's from the same source\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n    }\r\n\r\n    // Update existing webgl texture and return early\r\n    if (tex) {\r\n      if (forceUpdate) {\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        const source = TextureLoader.toPowerOfTwoImage(image);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n      }\r\n      return tex;\r\n    }\r\n\r\n    // No texture exists create a new one\r\n    tex = gl.createTexture();\r\n    const source = TextureLoader.toPowerOfTwoImage(image);\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    // NEAREST for pixels\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n\r\n    TextureLoader._TEXTURE_MAP.set(image, tex);\r\n    return tex;\r\n  }\r\n\r\n  /**\r\n   * Converts source images into power of two images, WebGL only supports POT images\r\n   * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\r\n   * @param image\r\n   */\r\n  public static toPowerOfTwoImage(image: HTMLImageSource): HTMLImageSource {\r\n    const potCanvas = TextureLoader._POT_CANVAS;\r\n    const potCtx = TextureLoader._POT_CTX;\r\n    if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {\r\n      // Scale up the texture to the next highest power of two dimensions.\r\n\r\n      potCanvas.width = ensurePowerOfTwo(image.width);\r\n      potCanvas.height = ensurePowerOfTwo(image.height);\r\n      potCtx.imageSmoothingEnabled = false;\r\n      potCtx.clearRect(0, 0, potCanvas.width, potCanvas.height);\r\n      potCtx.drawImage(image, 0, 0, image.width, image.height);\r\n      image = potCanvas;\r\n    }\r\n    return image;\r\n  }\r\n}\r\n","import { Shader } from './shader';\r\nimport imageVertexSource from './shaders/image-vertex.glsl';\r\nimport imageFragmentSource from './shaders/image-fragment.glsl';\r\nimport { BatchCommand } from './batch';\r\nimport { DrawCommandType, DrawImageCommand } from './draw-image-command';\r\nimport { Graphic } from '../Graphic';\r\nimport { ensurePowerOfTwo } from './webgl-util';\r\nimport { BatchRenderer } from './renderer';\r\nimport { WebGLGraphicsContextInfo } from './ExcaliburGraphicsContextWebGL';\r\nimport { TextureLoader } from './texture-loader';\r\nimport { HTMLImageSource } from './ExcaliburGraphicsContext';\r\nimport { Color } from '../../Color';\r\nimport { Vector } from '../..';\r\n\r\nexport class BatchImage extends BatchCommand<DrawImageCommand> {\r\n  public textures: WebGLTexture[] = [];\r\n  public commands: DrawImageCommand[] = [];\r\n  private _graphicMap: { [id: string]: Graphic } = {};\r\n\r\n  constructor(public maxDraws: number, public maxTextures: number) {\r\n    super(maxDraws);\r\n  }\r\n\r\n  isFull() {\r\n    if (this.commands.length >= this.maxDraws) {\r\n      return true;\r\n    }\r\n    if (this.textures.length >= this.maxTextures) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  canAdd() {\r\n    if (this.commands.length >= this.maxDraws) {\r\n      return false;\r\n    }\r\n\r\n    if (this.textures.length < this.maxTextures) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private _isCommandFull() {\r\n    return this.commands.length >= this.maxDraws;\r\n  }\r\n\r\n  private _isTextureFull() {\r\n    return this.textures.length >= this.maxTextures;\r\n  }\r\n\r\n  private _wouldAddTexture(command: DrawImageCommand) {\r\n    return !this._graphicMap[command.image.id];\r\n  }\r\n\r\n  maybeAdd(command: DrawImageCommand): boolean {\r\n    if ((this._isCommandFull() || this._isTextureFull()) && this._wouldAddTexture(command)) {\r\n      return false;\r\n    }\r\n\r\n    this.add(command);\r\n    return true;\r\n  }\r\n\r\n  add(command: DrawImageCommand) {\r\n    if (command.type === DrawCommandType.Image) {\r\n      const texture = TextureLoader.load(command.image);\r\n      if (this.textures.indexOf(texture) === -1) {\r\n        this.textures.push(texture);\r\n      }\r\n    }\r\n\r\n    this.commands.push(command);\r\n  }\r\n\r\n  bindTextures(gl: WebGLRenderingContext) {\r\n    // Bind textures in the correct order\r\n    for (let i = 0; i < this.maxTextures; i++) {\r\n      gl.activeTexture(gl.TEXTURE0 + i);\r\n      gl.bindTexture(gl.TEXTURE_2D, this.textures[i] || this.textures[0]);\r\n    }\r\n  }\r\n\r\n  getBatchTextureId(command: DrawImageCommand) {\r\n    if (command.image) {\r\n      return this.textures.indexOf(TextureLoader.get(command.image));\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  dispose() {\r\n    this.clear();\r\n    return this;\r\n  }\r\n\r\n  clear() {\r\n    this.commands.length = 0;\r\n    this.textures.length = 0;\r\n    this._graphicMap = {};\r\n  }\r\n}\r\n\r\nexport class ImageRenderer extends BatchRenderer<DrawImageCommand> {\r\n  constructor(gl: WebGLRenderingContext, private _contextInfo: WebGLGraphicsContextInfo) {\r\n    super({\r\n      gl,\r\n      command: DrawImageCommand,\r\n      // 6 verts per quad\r\n      verticesPerCommand: 6,\r\n      maxCommandsPerBatch: 2000,\r\n      batchFactory: () => new BatchImage(2000, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS))\r\n    });\r\n    TextureLoader.registerContext(gl);\r\n    this.init();\r\n  }\r\n\r\n  buildShader(gl: WebGLRenderingContext): Shader {\r\n    // Initialilze default batch rendering shader\r\n    const maxGPUTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n    const shader = new Shader(gl, imageVertexSource, this._transformFragmentSource(imageFragmentSource, maxGPUTextures));\r\n    shader.addAttribute('a_position', 3, gl.FLOAT);\r\n    shader.addAttribute('a_texcoord', 2, gl.FLOAT);\r\n    shader.addAttribute('a_textureIndex', 1, gl.FLOAT);\r\n    shader.addAttribute('a_opacity', 1, gl.FLOAT);\r\n    shader.addAttribute('a_color', 4, gl.FLOAT);\r\n    shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);\r\n    // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]\r\n    shader.addUniformIntegerArray(\r\n      'u_textures',\r\n      [...Array(maxGPUTextures)].map((_, i) => i)\r\n    );\r\n    return shader;\r\n  }\r\n\r\n  private _transformFragmentSource(source: string, maxTextures: number): string {\r\n    let newSource = source.replace('%%count%%', maxTextures.toString());\r\n    let texturePickerBuilder = '';\r\n    for (let i = 0; i < maxTextures; i++) {\r\n      if (i === 0) {\r\n        texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\\n`;\r\n      } else {\r\n        texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\\n`;\r\n      }\r\n      texturePickerBuilder += `      color = texture2D(u_textures[${i}], v_texcoord);\\n`;\r\n      texturePickerBuilder += `   }\\n`;\r\n    }\r\n    newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);\r\n    return newSource;\r\n  }\r\n\r\n  public addCircle(pos: Vector, radius: number, color: Color) {\r\n    const command = this.commands.get().initCircle(pos, radius, color);\r\n    command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);\r\n    this.addCommand(command);\r\n  }\r\n\r\n  public addRectangle(color: Color, pos: Vector, width: number, height: number) {\r\n    const command = this.commands.get().initRect(color, pos, width, height);\r\n    command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);\r\n    this.addCommand(command);\r\n  }\r\n\r\n  public addLine(color: Color, start: Vector, end: Vector, thickness = 1) {\r\n    const command = this.commands.get().initLine(color, start, end, thickness);\r\n    command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);\r\n    this.addCommand(command);\r\n  }\r\n\r\n  public addImage(\r\n    graphic: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ) {\r\n    const command = this.commands.get().init(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n    command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);\r\n    this.addCommand(command);\r\n  }\r\n\r\n  public renderBatch(gl: WebGLRenderingContext, batch: BatchImage, vertexCount: number) {\r\n    // Bind textures in the correct order\r\n    batch.bindTextures(gl);\r\n    // draw the quads\r\n    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\r\n  }\r\n\r\n  buildBatchVertices(vertexBuffer: Float32Array, batch: BatchImage): number {\r\n    let vertIndex = 0;\r\n    let sx: number = 0;\r\n    let sy: number = 0;\r\n    let sw: number = 0;\r\n    let sh: number = 0;\r\n    let potWidth: number = 1;\r\n    let potHeight: number = 1;\r\n    let textureId = 0;\r\n    let commandColor = Color.Transparent;\r\n    for (const command of batch.commands) {\r\n      sx = command.view[0];\r\n      sy = command.view[1];\r\n      sw = command.view[2];\r\n      sh = command.view[3];\r\n\r\n      potWidth = ensurePowerOfTwo(command.image?.width || command.width);\r\n      potHeight = ensurePowerOfTwo(command.image?.height || command.height);\r\n\r\n      textureId = batch.getBatchTextureId(command);\r\n      if (command.type === DrawCommandType.Line || command.type === DrawCommandType.Rectangle) {\r\n        textureId = -1; // sentinel for no image rect\r\n        commandColor = command.color;\r\n      }\r\n      if (command.type === DrawCommandType.Circle) {\r\n        textureId = -2; // sentinel for circle\r\n        commandColor = command.color;\r\n      }\r\n\r\n      // potential optimization when divding by 2 (bitshift)\r\n      // Modifying the images to poweroftwo images warp the UV coordinates\r\n      let uvx0 = sx / potWidth;\r\n      let uvy0 = sy / potHeight;\r\n      let uvx1 = (sx + sw) / potWidth;\r\n      let uvy1 = (sy + sh) / potHeight;\r\n      if (textureId === -2) {\r\n        uvx0 = 0;\r\n        uvy0 = 0;\r\n        uvx1 = 1;\r\n        uvy1 = 1;\r\n      }\r\n\r\n      // Quad update\r\n      // (0, 0, z) z-index doesn't work in batch rendering between batches\r\n      vertexBuffer[vertIndex++] = command.geometry[0][0]; // x + 0 * width;\r\n      vertexBuffer[vertIndex++] = command.geometry[0][1]; //y + 0 * height;\r\n      vertexBuffer[vertIndex++] = 0;\r\n\r\n      // UV coords\r\n      vertexBuffer[vertIndex++] = uvx0; // 0;\r\n      vertexBuffer[vertIndex++] = uvy0; // 0;\r\n      // texture id\r\n      vertexBuffer[vertIndex++] = textureId;\r\n      // opacity\r\n      vertexBuffer[vertIndex++] = command.opacity;\r\n      // color\r\n      vertexBuffer[vertIndex++] = commandColor.r / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.g / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.b / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.a;\r\n\r\n      // (0, 1)\r\n      vertexBuffer[vertIndex++] = command.geometry[1][0]; // x + 0 * width;\r\n      vertexBuffer[vertIndex++] = command.geometry[1][1]; // y + 1 * height;\r\n      vertexBuffer[vertIndex++] = 0;\r\n\r\n      // UV coords\r\n      vertexBuffer[vertIndex++] = uvx0; // 0;\r\n      vertexBuffer[vertIndex++] = uvy1; // 1;\r\n      // texture id\r\n      vertexBuffer[vertIndex++] = textureId;\r\n      // opacity\r\n      vertexBuffer[vertIndex++] = command.opacity;\r\n      // color\r\n      vertexBuffer[vertIndex++] = commandColor.r / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.g / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.b / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.a;\r\n\r\n      // (1, 0)\r\n      vertexBuffer[vertIndex++] = command.geometry[2][0]; // x + 1 * width;\r\n      vertexBuffer[vertIndex++] = command.geometry[2][1]; // y + 0 * height;\r\n      vertexBuffer[vertIndex++] = 0;\r\n\r\n      // UV coords\r\n      vertexBuffer[vertIndex++] = uvx1; //1;\r\n      vertexBuffer[vertIndex++] = uvy0; //0;\r\n      // texture id\r\n      vertexBuffer[vertIndex++] = textureId;\r\n      // opacity\r\n      vertexBuffer[vertIndex++] = command.opacity;\r\n      // color\r\n      vertexBuffer[vertIndex++] = commandColor.r / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.g / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.b / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.a;\r\n\r\n      // (1, 0)\r\n      vertexBuffer[vertIndex++] = command.geometry[3][0]; // x + 1 * width;\r\n      vertexBuffer[vertIndex++] = command.geometry[3][1]; // y + 0 * height;\r\n      vertexBuffer[vertIndex++] = 0;\r\n\r\n      // UV coords\r\n      vertexBuffer[vertIndex++] = uvx1; //1;\r\n      vertexBuffer[vertIndex++] = uvy0; //0;\r\n      // texture id\r\n      vertexBuffer[vertIndex++] = textureId;\r\n      // opacity\r\n      vertexBuffer[vertIndex++] = command.opacity;\r\n      // color\r\n      vertexBuffer[vertIndex++] = commandColor.r / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.g / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.b / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.a;\r\n\r\n      // (0, 1)\r\n      vertexBuffer[vertIndex++] = command.geometry[4][0]; // x + 0 * width;\r\n      vertexBuffer[vertIndex++] = command.geometry[4][1]; // y + 1 * height\r\n      vertexBuffer[vertIndex++] = 0;\r\n\r\n      // UV coords\r\n      vertexBuffer[vertIndex++] = uvx0; // 0;\r\n      vertexBuffer[vertIndex++] = uvy1; // 1;\r\n      // texture id\r\n      vertexBuffer[vertIndex++] = textureId;\r\n      // opacity\r\n      vertexBuffer[vertIndex++] = command.opacity;\r\n      // color\r\n      vertexBuffer[vertIndex++] = commandColor.r / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.g / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.b / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.a;\r\n\r\n      // (1, 1)\r\n      vertexBuffer[vertIndex++] = command.geometry[5][0]; // x + 1 * width;\r\n      vertexBuffer[vertIndex++] = command.geometry[5][1]; // y + 1 * height;\r\n      vertexBuffer[vertIndex++] = 0;\r\n\r\n      // UV coords\r\n      vertexBuffer[vertIndex++] = uvx1; // 1;\r\n      vertexBuffer[vertIndex++] = uvy1; // 1;\r\n      // texture id\r\n      vertexBuffer[vertIndex++] = textureId;\r\n      // opacity\r\n      vertexBuffer[vertIndex++] = command.opacity;\r\n      // color\r\n      vertexBuffer[vertIndex++] = commandColor.r / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.g / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.b / 255;\r\n      vertexBuffer[vertIndex++] = commandColor.a;\r\n    }\r\n\r\n    return vertIndex / this.vertexSize;\r\n  }\r\n}\r\n","export default \"attribute vec4 a_position;\\r\\nattribute vec4 a_color;\\r\\nattribute float a_size;\\r\\nvarying lowp vec4 v_color;\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * a_position;\\r\\n  gl_PointSize = a_size * 2.0;\\r\\n  v_color = a_color;\\r\\n}\";","export default \"#ifdef GL_OES_standard_derivatives\\r\\n#extension GL_OES_standard_derivatives : enable\\r\\n#endif\\r\\n\\r\\nprecision mediump float;\\r\\nvarying lowp vec4 v_color;\\r\\n\\r\\nvoid main() {\\r\\n  float r = 0.0, delta = 0.0, alpha = 1.0;\\r\\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\r\\n  r = dot(cxy, cxy);\\r\\n  \\r\\n#ifdef GL_OES_standard_derivatives\\r\\n  delta = fwidth(r);\\r\\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\r\\n#else\\r\\n  if (r > 1.0) {\\r\\n    discard;\\r\\n  }\\r\\n#endif\\r\\n  gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);\\r\\n}\";","import { Shader } from './shader';\r\nimport pointVertexSource from './shaders/point-vertex.glsl';\r\nimport pointFragmentSource from './shaders/point-fragment.glsl';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { BatchRenderer } from './renderer';\r\nimport { BatchCommand } from './batch';\r\nimport { WebGLGraphicsContextInfo } from './ExcaliburGraphicsContextWebGL';\r\nimport { Pool, Poolable } from '../../Util/Pool';\r\n// import { Random } from '../../Math/Index';\r\n\r\nexport class DrawPoint implements Poolable {\r\n  _pool?: Pool<this>;\r\n  public point: Vector = Vector.Zero;\r\n  public color: Color = Color.Black;\r\n  public size: number = 1;\r\n  public dispose() {\r\n    this.point.setTo(0, 0);\r\n    this.color.r = 0;\r\n    this.color.g = 0;\r\n    this.color.b = 0;\r\n    this.color.a = 1;\r\n    this.size = 1;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport class PointRenderer extends BatchRenderer<DrawPoint> {\r\n  constructor(gl: WebGLRenderingContext, private _contextInfo: WebGLGraphicsContextInfo) {\r\n    super({ gl, command: DrawPoint, verticesPerCommand: 1 });\r\n    this.init();\r\n  }\r\n\r\n  buildShader(gl: WebGLRenderingContext): Shader {\r\n    gl.getExtension('OES_standard_derivatives');\r\n    const shader = new Shader(gl, pointVertexSource, pointFragmentSource);\r\n    shader.addAttribute('a_position', 2, gl.FLOAT);\r\n    shader.addAttribute('a_color', 4, gl.FLOAT);\r\n    shader.addAttribute('a_size', 1, gl.FLOAT);\r\n    shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);\r\n    return shader;\r\n  }\r\n\r\n  addPoint(point: Vector, color: Color, size: number) {\r\n    const cmd = this.commands.get();\r\n    cmd.point = this._contextInfo.transform.current.multv(point);\r\n    cmd.color.r = color.r;\r\n    cmd.color.g = color.g;\r\n    cmd.color.b = color.b;\r\n    cmd.color.a = color.a * this._contextInfo.state.current.opacity;\r\n    cmd.size = size * Math.max(this._contextInfo.transform.current.getScaleX(), this._contextInfo.transform.current.getScaleY());\r\n    this.addCommand(cmd);\r\n  }\r\n\r\n  buildBatchVertices(vertexBuffer: Float32Array, batch: BatchCommand<DrawPoint>): number {\r\n    let index = 0;\r\n    for (const command of batch.commands) {\r\n      vertexBuffer[index++] = command.point.x;\r\n      vertexBuffer[index++] = command.point.y;\r\n      // normalize to [0, 1] for webgl\r\n      vertexBuffer[index++] = command.color.r / 255;\r\n      vertexBuffer[index++] = command.color.g / 255;\r\n      vertexBuffer[index++] = command.color.b / 255;\r\n      vertexBuffer[index++] = command.color.a;\r\n\r\n      vertexBuffer[index++] = command.size;\r\n    }\r\n    return index / this.vertexSize;\r\n  }\r\n\r\n  renderBatch(gl: WebGLRenderingContext, _batch: BatchCommand<DrawPoint>, vertexCount: number): void {\r\n    gl.drawArrays(gl.POINTS, 0, vertexCount);\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\nimport { BoundingBox } from '../Collision/BoundingBox';\n\nexport interface GraphicOptions {\n  /**\n   * The width of the graphic\n   */\n  width?: number;\n  /**\n   * The height of the graphic\n   */\n  height?: number;\n  /**\n   * SHould the graphic be flipped horizontally\n   */\n  flipHorizontal?: boolean;\n  /**\n   * Should the graphic be flipped vertically\n   */\n  flipVertical?: boolean;\n  /**\n   * The rotation of the graphic\n   */\n  rotation?: number;\n  /**\n   * The scale of the graphic\n   */\n  scale?: Vector;\n  /**\n   * The opacity of the graphic\n   */\n  opacity?: number;\n  /**\n   * The origin of the drawing in pixels to use when applying transforms, by default it will be the center of the image\n   */\n  origin?: Vector;\n}\n\n/**\n * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].\n * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the\n * [[Graphic]] abstract class.\n *\n * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic\n * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]\n */\nexport abstract class Graphic {\n  private static _ID: number = 0;\n  readonly id = Graphic._ID++;\n\n  /**\n   * Gets or sets wether to show debug information about the graphic\n   */\n  public showDebug: boolean = false;\n\n  /**\n   * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)\n   */\n  public flipHorizontal: boolean = false;\n\n  /**\n   * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)\n   */\n  public flipVertical: boolean = false;\n\n  /**\n   * Gets or sets the rotation of the graphic\n   */\n  public rotation: number = 0;\n\n  /**\n   * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).\n   */\n  public opacity: number = 1;\n\n  /**\n   * Gets or sets the scale of the graphic, this affects the width and\n   */\n  public scale = Vector.One;\n\n  /**\n   * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin\n   */\n  public origin: Vector | null = null;\n\n  constructor(options?: GraphicOptions) {\n    if (options) {\n      this.origin = options.origin ?? this.origin;\n      this.flipHorizontal = options.flipHorizontal ?? this.flipHorizontal;\n      this.flipVertical = options.flipVertical ?? this.flipVertical;\n      this.rotation = options.rotation ?? this.rotation;\n      this.opacity = options.opacity ?? this.opacity;\n      this.scale = options.scale ?? this.scale;\n    }\n  }\n\n  public cloneGraphicOptions(): GraphicOptions {\n    return {\n      origin: this.origin ? this.origin.clone() : null,\n      flipHorizontal: this.flipHorizontal,\n      flipVertical: this.flipVertical,\n      rotation: this.rotation,\n      opacity: this.opacity,\n      scale: this.scale ? this.scale.clone() : null\n    };\n  }\n\n  private _width: number = 0;\n\n  /**\n   * Gets or sets the width of the graphic (always positive)\n   */\n  public get width() {\n    return Math.abs(this._width * this.scale.x);\n  }\n\n  private _height: number = 0;\n\n  /**\n   * Gets or sets the height of the graphic (always positive)\n   */\n  public get height() {\n    return Math.abs(this._height * this.scale.y);\n  }\n\n  public set width(value: number) {\n    this._width = value;\n  }\n\n  public set height(value: number) {\n    this._height = value;\n  }\n\n  /**\n   * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.\n   */\n  public get localBounds(): BoundingBox {\n    return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);\n  }\n\n  /**\n   * Draw the whole graphic to the context including transform\n   * @param ex The excalibur graphics context\n   * @param x\n   * @param y\n   */\n  public draw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\n    this._preDraw(ex, x, y);\n    this._drawImage(ex, 0, 0);\n    this._postDraw(ex);\n  }\n\n  /**\n   * Meant to be overriden by the graphic implementation to draw the underlying image (HTMLCanvasElement or HTMLImageElement)\n   * to the graphics context without transform. Transformations like position, rotation, and scale are handled by [[Graphic._preDraw]]\n   * and [[Graphic._postDraw]]\n   * @param ex The excalibur graphics context\n   * @param x\n   * @param y\n   */\n  protected abstract _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void;\n\n  /**\n   * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]\n   * @param ex\n   * @param x\n   * @param y\n   */\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\n    ex.save();\n    ex.translate(x, y);\n    ex.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\n    this._rotate(ex);\n    this._flip(ex);\n    // it is important to multiply alphas so graphics respect the current context\n    ex.opacity = ex.opacity * this.opacity;\n  }\n\n  protected _rotate(ex: ExcaliburGraphicsContext) {\n    const scaleDirX = this.scale.x > 0 ? 1 : -1;\n    const scaleDirY = this.scale.y > 0 ? 1 : -1;\n    const origin = this.origin ?? vec(this.width / 2, this.height / 2);\n    ex.translate(origin.x, origin.y);\n    ex.rotate(this.rotation);\n    // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\n    ex.scale(scaleDirX, scaleDirY);\n    ex.translate(-origin.x, -origin.y);\n  }\n\n  protected _flip(ex: ExcaliburGraphicsContext) {\n    if (this.flipHorizontal) {\n      ex.translate(this.width / this.scale.x, 0);\n      ex.scale(-1, 1);\n    }\n\n    if (this.flipVertical) {\n      ex.translate(0, this.height / this.scale.y);\n      ex.scale(1, -1);\n    }\n  }\n\n  /**\n   * Apply any addtional work after [[Graphic._drawImage]] and restore the context state.\n   * @param ex\n   */\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\n    if (this.showDebug) {\n      ex.debug.drawRect(0, 0, this.width, this.height);\n    }\n    ex.restore();\n  }\n\n  /**\n   * Returns a new instance of the graphic that has the same properties\n   */\n  abstract clone(): Graphic;\n}\n","/**\r\n * Watch an object with a proxy, only fires if property value is different\r\n */\r\nexport function watch<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        if ((obj as any)[prop] !== value) {\r\n          (obj as any)[prop] = value;\r\n          // Avoid watching private junk\r\n          if (typeof prop === 'string') {\r\n            if (prop[0] !== '_') {\r\n              change(obj);\r\n            }\r\n          }\r\n        }\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n\r\n/**\r\n * Watch an object with a proxy, fires change on any property value change\r\n */\r\nexport function watchAny<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        (obj as any)[prop] = value;\r\n        // Avoid watching private junk\r\n        if (typeof prop === 'string') {\r\n          if (prop[0] !== '_') {\r\n            change(obj);\r\n          }\r\n        }\r\n\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\nimport { Color } from '../Color';\nimport { ensurePowerOfTwo } from './Context/webgl-util';\nimport { Vector } from '../Math/vector';\nimport { BoundingBox } from '../Collision/BoundingBox';\nimport { watch } from '../Util/Watch';\nimport { TextureLoader } from './Context/texture-loader';\n\nexport interface RasterOptions {\n  smoothing?: boolean;\n  color?: Color;\n  strokeColor?: Color;\n  lineWidth?: number;\n  lineDash?: number[];\n  padding?: number;\n}\n\n/**\n * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the\n * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.\n *\n * Implementors must implemenet the [[Raster.execute]] method to rasterize their drawing.\n */\nexport abstract class Raster extends Graphic {\n  public _bitmap: HTMLCanvasElement;\n  protected _ctx: CanvasRenderingContext2D;\n  private _dirty: boolean = true;\n\n  constructor(options?: GraphicOptions & RasterOptions) {\n    super(options);\n    if (options) {\n      this.color = options.color ?? Color.Black;\n      this.strokeColor = options?.strokeColor;\n      this.smoothing = options.smoothing ?? this.smoothing;\n      this.lineWidth = options.lineWidth ?? this.lineWidth;\n      this.lineDash = options.lineDash ?? this.lineDash;\n      this.padding = options.padding ?? this.padding;\n    }\n\n    this._bitmap = document.createElement('canvas');\n    // get the default canvas width/height as a fallback\n    const bitmapWidth = options?.width ?? this._bitmap.width;\n    const bitmapHeight = options?.height ?? this._bitmap.height;\n    // Rasters use power of two images as an optimization for webgl\n    this.width = ensurePowerOfTwo(bitmapWidth);\n    this.height = ensurePowerOfTwo(bitmapHeight);\n    const maybeCtx = this._bitmap.getContext('2d');\n    if (!maybeCtx) {\n      /* istanbul ignore next */\n      throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');\n    } else {\n      this._ctx = maybeCtx;\n    }\n  }\n\n  public cloneRasterOptions(): RasterOptions {\n    return {\n      color: this.color ? this.color.clone() : null,\n      strokeColor: this.strokeColor ? this.strokeColor.clone() : null,\n      smoothing: this.smoothing,\n      lineWidth: this.lineWidth,\n      lineDash: this.lineDash,\n      padding: this.padding\n    };\n  }\n\n  /**\n   * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized\n   */\n  public get dirty() {\n    return this._dirty;\n  }\n\n  /**\n   * Flags the graphic as dirty, meaning it must be re-rasterized before draw.\n   * This should be called any time the graphics state changes such that it affects the outputed drawing\n   */\n  public flagDirty() {\n    this._dirty = true;\n  }\n\n  private _originalWidth: number;\n  /**\n   * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster\n   * to be flagged dirty causing a re-raster on the next draw.\n   *\n   * Any `padding`s set will be factored into the width\n   */\n  public get width() {\n    return this._getTotalWidth();\n  }\n  public set width(value: number) {\n    this._bitmap.width = value;\n    this._originalWidth = value;\n    this.flagDirty();\n  }\n\n  private _originalHeight: number;\n  /**\n   * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster\n   * to be flagged dirty causing a re-raster on the next draw.\n   *\n   * Any `padding` set will be factored into the height\n   */\n  public get height() {\n    return this._getTotalHeight();\n  }\n\n  public set height(value: number) {\n    this._bitmap.height = value;\n    this._originalHeight = value;\n    this.flagDirty();\n  }\n\n  private _getTotalWidth() {\n    return (this._originalWidth ?? this._bitmap.width) + this.padding * 2;\n  }\n\n  private _getTotalHeight() {\n    return (this._originalHeight ?? this._bitmap.height) + this.padding * 2;\n  }\n\n  /**\n   * Returns the local bounds of the Raster including the padding\n   */\n  public get localBounds() {\n    return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);\n  }\n\n  private _smoothing: boolean = false;\n  /**\n   * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster\n   * to be flagged dirty causing a re-raster on the next draw.\n   */\n  public get smoothing() {\n    return this._smoothing;\n  }\n  public set smoothing(value: boolean) {\n    this._smoothing = value;\n    this.flagDirty();\n  }\n\n  private _color: Color = watch(Color.Black, () => this.flagDirty());\n  /**\n   * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be\n   * flagged dirty causing a re-raster on the next draw.\n   */\n  public get color() {\n    return this._color;\n  }\n  public set color(value) {\n    if (!this._color?.equal(value)) {\n      this.flagDirty();\n    }\n    this._color = watch(value, () => this.flagDirty());\n  }\n\n  private _strokeColor: Color;\n  /**\n   * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be\n   * flagged dirty causing a re-raster on the next draw.\n   */\n  public get strokeColor() {\n    return this._strokeColor;\n  }\n  public set strokeColor(value) {\n    if (!this._strokeColor?.equal(value)) {\n      this.flagDirty();\n    }\n    this._strokeColor = watch(value, () => this.flagDirty());\n  }\n\n  private _lineWidth: number = 1;\n  /**\n   * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be\n   * flagged dirty causing a re-raster on the next draw.\n   */\n  public get lineWidth() {\n    return this._lineWidth;\n  }\n  public set lineWidth(value) {\n    this._lineWidth = value;\n    this.flagDirty();\n  }\n\n  private _lineDash: number[] = [];\n  public get lineDash() {\n    return this._lineDash;\n  }\n\n  public set lineDash(value) {\n    this._lineDash = value;\n    this.flagDirty();\n  }\n\n  private _padding: number = 0;\n  public get padding() {\n    return this._padding;\n  }\n\n  public set padding(value: number) {\n    this._padding = value;\n    this.flagDirty();\n  }\n\n  /**\n   * Rasterize the graphic to a bitmap making it usuable as in excalibur. Rasterize is called automatically if\n   * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call\n   */\n  public rasterize(): void {\n    this._dirty = false;\n    this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());\n    this._ctx.save();\n    this._applyRasterProperites(this._ctx);\n    this.execute(this._ctx);\n    this._ctx.restore();\n    // The webgl texture needs to be updated if it exists after a raster cycle\n    TextureLoader.load(this._bitmap, true);\n  }\n\n  protected _applyRasterProperites(ctx: CanvasRenderingContext2D) {\n    this._bitmap.width = this._getTotalWidth();\n    this._bitmap.height = this._getTotalHeight();\n    ctx.translate(this.padding, this.padding);\n    ctx.imageSmoothingEnabled = this.smoothing;\n    ctx.lineWidth = this.lineWidth;\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\n    ctx.strokeStyle = this.strokeColor?.toString();\n    ctx.fillStyle = this.color?.toString();\n  }\n\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\n    if (this._dirty) {\n      this.rasterize();\n    }\n\n    ex.drawImage(this._bitmap, x, y);\n  }\n\n  /**\n   * Executes drawing implemenation of the graphic, this is where the specific drawing code for the graphic\n   * should be implemented. Once `rasterize()` the graphic can be drawn to the [[ExcaliburGraphicsContext]] via `draw(...)`\n   * @param ctx Canvas to draw the graphic to\n   */\n  abstract execute(ctx: CanvasRenderingContext2D): void;\n}\n","import { GraphicOptions } from './Graphic';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CanvasOptions {\r\n  draw?: (ctx: CanvasRenderingContext2D) => void;\r\n  cache?: boolean;\r\n}\r\n\r\n/**\r\n * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].\r\n *\r\n * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed\r\n * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.\r\n *\r\n * **Low performance API**\r\n */\r\nexport class Canvas extends Raster {\r\n  /**\r\n   * Return the 2D graphics context of this canvas\r\n   */\r\n  public get ctx() {\r\n    return this._ctx;\r\n  }\r\n\r\n  constructor(private _options: GraphicOptions & RasterOptions & CanvasOptions) {\r\n    super(_options);\r\n  }\r\n\r\n  public clone(): Canvas {\r\n    return new Canvas({\r\n      ...this._options,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this._options?.draw) {\r\n      this._options?.draw(ctx);\r\n    }\r\n    if (!this._options.cache) {\r\n      this.flagDirty();\r\n    }\r\n  }\r\n}\r\n","import { Scene } from './Scene';\nimport { Vector } from './Math/vector';\nimport { Actor } from './Actor';\nimport { Trigger } from './Trigger';\nimport { FrameStats } from './Debug';\nimport { Engine } from './Engine';\nimport { TileMap } from './TileMap';\nimport { Side } from './Collision/Side';\nimport * as Input from './Input/Index';\nimport { CollisionContact } from './Collision/Detection/CollisionContact';\nimport { Collider } from './Collision/Colliders/Collider';\nimport { Entity } from './EntityComponentSystem/Entity';\nimport { OnInitialize, OnPreUpdate, OnPostUpdate } from './Interfaces/LifecycleEvents';\nimport { BodyComponent } from './Collision/BodyComponent';\n\nexport enum EventTypes {\n  Kill = 'kill',\n  PreKill = 'prekill',\n  PostKill = 'postkill',\n\n  PreDraw = 'predraw',\n  PostDraw = 'postdraw',\n\n  PreDebugDraw = 'predebugdraw',\n  PostDebugDraw = 'postdebugdraw',\n\n  PreUpdate = 'preupdate',\n  PostUpdate = 'postupdate',\n\n  PreFrame = 'preframe',\n  PostFrame = 'postframe',\n\n  PreCollision = 'precollision',\n  CollisionStart = 'collisionstart',\n  CollisionEnd = 'collisionend',\n  PostCollision = 'postcollision',\n\n  Initialize = 'initialize',\n  Activate = 'activate',\n  Deactivate = 'deactivate',\n\n  ExitViewport = 'exitviewport',\n  EnterViewport = 'enterviewport',\n\n  ExitTrigger = 'exit',\n  EnterTrigger = 'enter',\n\n  Connect = 'connect',\n  Disconnect = 'disconnect',\n  Button = 'button',\n  Axis = 'axis',\n\n  Subscribe = 'subscribe',\n  Unsubscribe = 'unsubscribe',\n\n  Visible = 'visible',\n  Hidden = 'hidden',\n  Start = 'start',\n  Stop = 'stop',\n\n  PointerUp = 'pointerup',\n  PointerDown = 'pointerdown',\n  PointerMove = 'pointermove',\n  PointerEnter = 'pointerenter',\n  PointerLeave = 'pointerleave',\n  PointerCancel = 'pointercancel',\n  PointerWheel = 'pointerwheel',\n\n  Up = 'up',\n  Down = 'down',\n  Move = 'move',\n  Enter = 'enter',\n  Leave = 'leave',\n  Cancel = 'cancel',\n  Wheel = 'wheel',\n\n  Press = 'press',\n  Release = 'release',\n  Hold = 'hold',\n\n  PointerDragStart = 'pointerdragstart',\n  PointerDragEnd = 'pointerdragend',\n  PointerDragEnter = 'pointerdragenter',\n  PointerDragLeave = 'pointerdragleave',\n  PointerDragMove = 'pointerdragmove'\n}\n\n/* istanbul ignore next */\n/* compiler only: these are internal to lib */\nexport type kill = 'kill';\nexport type prekill = 'prekill';\nexport type postkill = 'postkill';\n\nexport type predraw = 'predraw';\nexport type postdraw = 'postdraw';\n\nexport type predebugdraw = 'predebugdraw';\nexport type postdebugdraw = 'postdebugdraw';\n\nexport type preupdate = 'preupdate';\nexport type postupdate = 'postupdate';\n\nexport type preframe = 'preframe';\nexport type postframe = 'postframe';\n\nexport type precollision = 'precollision';\nexport type collisionstart = 'collisionstart';\nexport type collisionend = 'collisionend';\nexport type postcollision = 'postcollision';\n\nexport type initialize = 'initialize';\nexport type activate = 'activate';\nexport type deactivate = 'deactivate';\n\nexport type exitviewport = 'exitviewport';\nexport type enterviewport = 'enterviewport';\n\nexport type exittrigger = 'exit';\nexport type entertrigger = 'enter';\n\nexport type connect = 'connect';\nexport type disconnect = 'disconnect';\nexport type button = 'button';\nexport type axis = 'axis';\n\nexport type subscribe = 'subscribe';\nexport type unsubscribe = 'unsubscribe';\n\nexport type visible = 'visible';\nexport type hidden = 'hidden';\nexport type start = 'start';\nexport type stop = 'stop';\n\nexport type pointerup = 'pointerup';\nexport type pointerdown = 'pointerdown';\nexport type pointermove = 'pointermove';\nexport type pointerenter = 'pointerenter';\nexport type pointerleave = 'pointerleave';\nexport type pointercancel = 'pointercancel';\nexport type pointerwheel = 'pointerwheel';\n\nexport type up = 'up';\nexport type down = 'down';\nexport type move = 'move';\nexport type enter = 'enter';\nexport type leave = 'leave';\nexport type cancel = 'cancel';\nexport type wheel = 'wheel';\n\nexport type press = 'press';\nexport type release = 'release';\nexport type hold = 'hold';\n\nexport type pointerdragstart = 'pointerdragstart';\nexport type pointerdragend = 'pointerdragend';\nexport type pointerdragenter = 'pointerdragenter';\nexport type pointerdragleave = 'pointerdragleave';\nexport type pointerdragmove = 'pointerdragmove';\n\n/**\n * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\n * some events are unique to a type, others are not.\n *\n */\nexport class GameEvent<T, U = T> {\n  /**\n   * Target object for this event.\n   */\n  public target: T;\n\n  /**\n   * Other target object for this event\n   */\n  public other: U | null;\n\n  /**\n   * If set to false, prevents event from propagating to other actors. If true it will be propagated\n   * to all actors that apply.\n   */\n  public get bubbles(): boolean {\n    return this._bubbles;\n  }\n\n  public set bubbles(value: boolean) {\n    this._bubbles = value;\n  }\n\n  private _bubbles: boolean = true;\n  /**\n   * Prevents event from bubbling\n   */\n  public stopPropagation() {\n    this.bubbles = false;\n  }\n}\n\n/**\n * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.\n */\nexport class KillEvent extends GameEvent<Actor> {\n  constructor(public target: Actor) {\n    super();\n  }\n}\n\n/**\n * The 'prekill' event is emitted directly before an actor is killed.\n */\nexport class PreKillEvent extends GameEvent<Actor> {\n  constructor(public target: Actor) {\n    super();\n  }\n}\n\n/**\n * The 'postkill' event is emitted directly after the actor is killed.\n */\nexport class PostKillEvent extends GameEvent<Actor> {\n  constructor(public target: Actor) {\n    super();\n  }\n}\n\n/**\n * The 'start' event is emitted on engine when has started and is ready for interaction.\n */\nexport class GameStartEvent extends GameEvent<Engine> {\n  constructor(public target: Engine) {\n    super();\n  }\n}\n\n/**\n * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.\n */\nexport class GameStopEvent extends GameEvent<Engine> {\n  constructor(public target: Engine) {\n    super();\n  }\n}\n\n/**\n * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics\n * transform so that all drawing takes place with the actor as the origin.\n *\n */\nexport class PreDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\n  constructor(public ctx: CanvasRenderingContext2D, public delta: number, public target: Entity | Scene | Engine | TileMap) {\n    super();\n  }\n}\n\n/**\n * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics\n * transform so that all drawing takes place with the actor as the origin.\n *\n */\nexport class PostDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\n  constructor(public ctx: CanvasRenderingContext2D, public delta: number, public target: Entity | Scene | Engine | TileMap) {\n    super();\n  }\n}\n\n/**\n * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.\n */\nexport class PreDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\n  constructor(public ctx: CanvasRenderingContext2D, public target: Entity | Actor | Scene | Engine) {\n    super();\n  }\n}\n\n/**\n * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.\n */\nexport class PostDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\n  constructor(public ctx: CanvasRenderingContext2D, public target: Entity | Actor | Scene | Engine) {\n    super();\n  }\n}\n\n/**\n * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.\n */\nexport class PreUpdateEvent<T extends OnPreUpdate = Entity> extends GameEvent<T> {\n  constructor(public engine: Engine, public delta: number, public target: T) {\n    super();\n  }\n}\n\n/**\n * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.\n */\nexport class PostUpdateEvent<T extends OnPostUpdate = Entity> extends GameEvent<T> {\n  constructor(public engine: Engine, public delta: number, public target: T) {\n    super();\n  }\n}\n\n/**\n * The 'preframe' event is emitted on the engine, before the frame begins.\n */\nexport class PreFrameEvent extends GameEvent<Engine> {\n  constructor(public engine: Engine, public prevStats: FrameStats) {\n    super();\n    this.target = engine;\n  }\n}\n\n/**\n * The 'postframe' event is emitted on the engine, after a frame ends.\n */\nexport class PostFrameEvent extends GameEvent<Engine> {\n  constructor(public engine: Engine, public stats: FrameStats) {\n    super();\n    this.target = engine;\n  }\n}\n\n/**\n * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\n */\nexport class GamepadConnectEvent extends GameEvent<Input.Gamepad> {\n  constructor(public index: number, public gamepad: Input.Gamepad) {\n    super();\n    this.target = gamepad;\n  }\n}\n\n/**\n * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\n */\nexport class GamepadDisconnectEvent extends GameEvent<Input.Gamepad> {\n  constructor(public index: number, public gamepad: Input.Gamepad) {\n    super();\n    this.target = gamepad;\n  }\n}\n\n/**\n * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\n */\nexport class GamepadButtonEvent extends GameEvent<Input.Gamepad> {\n  /**\n   * @param button  The Gamepad button\n   * @param value   A numeric value between 0 and 1\n   */\n  constructor(public button: Input.Buttons, public value: number, public target: Input.Gamepad) {\n    super();\n  }\n}\n\n/**\n * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\n */\nexport class GamepadAxisEvent extends GameEvent<Input.Gamepad> {\n  /**\n   * @param axis  The Gamepad axis\n   * @param value A numeric value between -1 and 1\n   */\n  constructor(public axis: Input.Axes, public value: number, public target: Input.Gamepad) {\n    super();\n  }\n}\n\n/**\n * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by\n * [[EventDispatcher|event dispatchers]].\n */\nexport class SubscribeEvent<T> extends GameEvent<T> {\n  constructor(public topic: string, public handler: (event: GameEvent<T>) => void) {\n    super();\n  }\n}\n\n/**\n * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by\n * [[EventDispatcher|event dispatchers]].\n */\nexport class UnsubscribeEvent<T> extends GameEvent<T> {\n  constructor(public topic: string, public handler: (event: GameEvent<T>) => void) {\n    super();\n  }\n}\n\n/**\n * Event received by the [[Engine]] when the browser window is visible on a screen.\n */\nexport class VisibleEvent extends GameEvent<Engine> {\n  constructor(public target: Engine) {\n    super();\n  }\n}\n\n/**\n * Event received by the [[Engine]] when the browser window is hidden from all screens.\n */\nexport class HiddenEvent extends GameEvent<Engine> {\n  constructor(public target: Engine) {\n    super();\n  }\n}\n\n/**\n * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\n */\nexport class PreCollisionEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\n  /**\n   * @param actor         The actor the event was thrown on\n   * @param other         The actor that will collided with the current actor\n   * @param side          The side that will be collided with the current actor\n   * @param intersection  Intersection vector\n   */\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\n    super();\n    this.target = actor;\n  }\n}\n\n/**\n * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\n */\nexport class PostCollisionEvent<T extends Collider | Entity = Actor> extends GameEvent<T> {\n  /**\n   * @param actor         The actor the event was thrown on\n   * @param other         The actor that did collide with the current actor\n   * @param side          The side that did collide with the current actor\n   * @param intersection  Intersection vector\n   */\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\n    super();\n    this.target = actor;\n  }\n\n  public get actor() {\n    return this.target;\n  }\n\n  public set actor(actor: T) {\n    this.target = actor;\n  }\n}\n\nexport class ContactStartEvent<T> {\n  constructor(public target: T, public other: T, public contact: CollisionContact) {}\n}\n\nexport class ContactEndEvent<T> {\n  constructor(public target: T, public other: T) {}\n}\n\nexport class CollisionPreSolveEvent<T> {\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\n}\n\nexport class CollisionPostSolveEvent<T> {\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\n}\n\n/**\n * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\n */\nexport class CollisionStartEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\n  /**\n   *\n   * @param actor\n   * @param other\n   * @param contact\n   */\n  constructor(actor: T, public other: T, public contact: CollisionContact) {\n    super();\n    this.target = actor;\n  }\n\n  public get actor() {\n    return this.target;\n  }\n\n  public set actor(actor: T) {\n    this.target = actor;\n  }\n}\n\n/**\n * Event thrown when the [[Actor|actor]] is no longer colliding with another\n */\nexport class CollisionEndEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\n  /**\n   *\n   */\n  constructor(actor: T, public other: T) {\n    super();\n    this.target = actor;\n  }\n\n  public get actor() {\n    return this.target;\n  }\n\n  public set actor(actor: T) {\n    this.target = actor;\n  }\n}\n\n/**\n * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\n */\nexport class InitializeEvent<T extends OnInitialize = Entity> extends GameEvent<T> {\n  /**\n   * @param engine  The reference to the current engine\n   */\n  constructor(public engine: Engine, public target: T) {\n    super();\n  }\n}\n\n/**\n * Event thrown on a [[Scene]] on activation\n */\nexport class ActivateEvent extends GameEvent<Scene> {\n  /**\n   * @param oldScene  The reference to the old scene\n   */\n  constructor(public oldScene: Scene, public target: Scene) {\n    super();\n  }\n}\n\n/**\n * Event thrown on a [[Scene]] on deactivation\n */\nexport class DeactivateEvent extends GameEvent<Scene> {\n  /**\n   * @param newScene  The reference to the new scene\n   */\n  constructor(public newScene: Scene, public target: Scene) {\n    super();\n  }\n}\n\n/**\n * Event thrown on an [[Actor]] when it completely leaves the screen.\n */\nexport class ExitViewPortEvent extends GameEvent<Entity> {\n  constructor(public target: Entity) {\n    super();\n  }\n}\n\n/**\n * Event thrown on an [[Actor]] when it completely leaves the screen.\n */\nexport class EnterViewPortEvent extends GameEvent<Entity> {\n  constructor(public target: Entity) {\n    super();\n  }\n}\n\nexport class EnterTriggerEvent extends GameEvent<Actor> {\n  constructor(public target: Trigger, public actor: Actor) {\n    super();\n  }\n}\n\nexport class ExitTriggerEvent extends GameEvent<Actor> {\n  constructor(public target: Trigger, public actor: Actor) {\n    super();\n  }\n}\n","import { GameEvent, SubscribeEvent, UnsubscribeEvent } from './Events';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\nexport class EventDispatcher<T = any> implements Eventable {\r\n  private _handlers: { [key: string]: { (event: GameEvent<T>): void }[] } = {};\r\n  private _wiredEventDispatchers: Eventable[] = [];\r\n\r\n  private _target: T;\r\n\r\n  /**\r\n   * @param target  The object that will be the recipient of events from this event dispatcher\r\n   */\r\n  constructor(target: T) {\r\n    this._target = target;\r\n  }\r\n\r\n  /**\r\n   * Clears any existing handlers or wired event dispatchers on this event dispatcher\r\n   */\r\n  public clear() {\r\n    this._handlers = {};\r\n    this._wiredEventDispatchers = [];\r\n  }\r\n\r\n  /**\r\n   * Emits an event for target\r\n   * @param eventName  The name of the event to publish\r\n   * @param event      Optionally pass an event data object to the handler\r\n   */\r\n  public emit(eventName: string, event: GameEvent<T>) {\r\n    if (!eventName) {\r\n      // key not mapped\r\n      return;\r\n    }\r\n    eventName = eventName.toLowerCase();\r\n    const target = this._target;\r\n    if (!event) {\r\n      event = new GameEvent();\r\n    }\r\n    try {\r\n      if (!event.target) {\r\n        event.target = target;\r\n      }\r\n    } catch {\r\n      // pass\r\n    }\r\n    let i: number, len: number;\r\n\r\n    if (this._handlers[eventName]) {\r\n      i = 0;\r\n      len = this._handlers[eventName].length;\r\n\r\n      for (i; i < len; i++) {\r\n        this._handlers[eventName][i].call(target, event);\r\n      }\r\n    }\r\n\r\n    i = 0;\r\n    len = this._wiredEventDispatchers.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this._wiredEventDispatchers[i].emit(eventName, event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n   * @param eventName  The name of the event to subscribe to\r\n   * @param handler    The handler callback to fire on this event\r\n   */\r\n  public on(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    eventName = eventName.toLowerCase();\r\n    if (!this._handlers[eventName]) {\r\n      this._handlers[eventName] = [];\r\n    }\r\n    this._handlers[eventName].push(handler);\r\n\r\n    // meta event handlers\r\n    if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {\r\n      this.emit('subscribe', new SubscribeEvent(eventName, handler));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe an event handler(s) from an event. If a specific handler\r\n   * is specified for an event, only that handler will be unsubscribed.\r\n   * Otherwise all handlers will be unsubscribed for that event.\r\n   *\r\n   * @param eventName  The name of the event to unsubscribe\r\n   * @param handler    Optionally the specific handler to unsubscribe\r\n   */\r\n  public off(eventName: string, handler?: (event: GameEvent<T>) => void) {\r\n    eventName = eventName.toLowerCase();\r\n    const eventHandlers = this._handlers[eventName];\r\n\r\n    if (eventHandlers) {\r\n      // if no explicit handler is give with the event name clear all handlers\r\n      if (!handler) {\r\n        this._handlers[eventName].length = 0;\r\n      } else {\r\n        const index = eventHandlers.indexOf(handler);\r\n        this._handlers[eventName].splice(index, 1);\r\n      }\r\n    }\r\n    // meta event handlers\r\n    if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {\r\n      this.emit('unsubscribe', new UnsubscribeEvent(eventName, handler));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    const metaHandler = (event: GameEvent<T>) => {\r\n      const ev = event || new GameEvent();\r\n      try {\r\n        ev.target = ev.target || this._target;\r\n      } catch {\r\n        // pass\r\n      }\r\n\r\n      this.off(eventName, handler);\r\n      handler.call(ev.target, ev);\r\n    };\r\n\r\n    this.on(eventName, metaHandler);\r\n  }\r\n\r\n  /**\r\n   * Wires this event dispatcher to also receive events from another\r\n   */\r\n  public wire(eventDispatcher: EventDispatcher): void {\r\n    eventDispatcher._wiredEventDispatchers.push(this);\r\n  }\r\n\r\n  /**\r\n   * Unwires this event dispatcher from another\r\n   */\r\n  public unwire(eventDispatcher: EventDispatcher): void {\r\n    const index = eventDispatcher._wiredEventDispatchers.indexOf(this);\r\n    if (index > -1) {\r\n      eventDispatcher._wiredEventDispatchers.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n","import { Loadable } from '../Interfaces/Loadable';\r\nimport { Logger } from '../Util/Log';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\n\r\n/**\r\n * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n */\r\nexport class Resource<T> implements Loadable<T> {\r\n  public data: T = null;\r\n  public logger: Logger = Logger.getInstance();\r\n  public events: EventDispatcher = new EventDispatcher(this);\r\n\r\n  /**\r\n   * @param path          Path to the remote resource\r\n   * @param responseType  The type to expect as a response: \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\n   * @param bustCache     Whether or not to cache-bust requests\r\n   */\r\n  constructor(\r\n    public path: string,\r\n    public responseType: '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text',\r\n    public bustCache: boolean = true\r\n  ) {}\r\n\r\n  /**\r\n   * Returns true if the Resource is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    return this.data !== null;\r\n  }\r\n\r\n\r\n  private _cacheBust(uri: string): string {\r\n    const query: RegExp = /\\?\\w*=\\w*/;\r\n    if (query.test(uri)) {\r\n      uri += '&__=' + Date.now();\r\n    } else {\r\n      uri += '?__=' + Date.now();\r\n    }\r\n    return uri;\r\n  }\r\n  /**\r\n   * Begin loading the resource and returns a promise to be resolved on completion\r\n   */\r\n  public load(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      // Exit early if we already have data\r\n      if (this.data !== null) {\r\n        this.logger.debug('Already have data for resource', this.path);\r\n        this.events.emit('complete', this.data as any);\r\n        resolve(this.data);\r\n        return;\r\n      }\r\n\r\n      const request = new XMLHttpRequest();\r\n      request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);\r\n      request.responseType = this.responseType;\r\n      request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e as any));\r\n      request.addEventListener('progress', (e) => this.events.emit('progress', e as any));\r\n      request.addEventListener('error', (e) => this.events.emit('error', e as any));\r\n      request.addEventListener('load', (e) => this.events.emit('load', e as any));\r\n      request.addEventListener('load', () => {\r\n        // XHR on file:// success status is 0, such as with PhantomJS\r\n        if (request.status !== 0 && request.status !== 200) {\r\n          this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);\r\n          this.events.emit('error', request.response);\r\n          reject(new Error(request.statusText));\r\n          return;\r\n        }\r\n\r\n        this.data = request.response;\r\n        this.events.emit('complete', this.data as any);\r\n        this.logger.debug('Completed loading resource', this.path);\r\n        resolve(this.data);\r\n      });\r\n      request.send();\r\n    });\r\n  }\r\n}\r\n","/**\r\n * @module\r\n * @deprecated\r\n * These effects can be applied to any bitmap image but are mainly used\r\n * for [[Sprite]] effects or [[Animation]] effects.\r\n */\r\n\r\n/**\r\n * @typedoc\r\n */\r\n\r\nimport { obsolete } from '../Util/Decorators';\r\nimport { Color } from '../Color';\r\n\r\n/**\r\n * The interface that all sprite effects must implement\r\n * @deprecated SpriteEffect will be removed in v0.26.0\r\n */\r\nexport interface SpriteEffect {\r\n  /**\r\n   * Should update individual pixels values\r\n   * @param x          The pixel's x coordinate\r\n   * @param y          The pixel's y coordinate\r\n   * @param imageData  The sprite's raw pixel data\r\n   */\r\n  updatePixel(x: number, y: number, imageData: ImageData): void;\r\n}\r\n\r\n/**\r\n * Applies the \"Grayscale\" effect to a sprite, removing color information.\r\n * @deprecated [[Grayscale]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Grayscale will be removed in v0.26.0'\r\n})\r\nexport class Grayscale implements SpriteEffect {\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    const avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;\r\n    pixel[firstPixel + 0] = avg;\r\n    pixel[firstPixel + 1] = avg;\r\n    pixel[firstPixel + 2] = avg;\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Invert\" effect to a sprite, inverting the pixel colors.\r\n * @deprecated [[Invert]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Invert will be removed in v0.26.0'\r\n})\r\nexport class Invert implements SpriteEffect {\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];\r\n    pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];\r\n    pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Opacity\" effect to a sprite, setting the alpha of all pixels to a given value.\r\n * @deprecated [[Opacity]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Opacity will be removed in v0.26.0'\r\n})\r\nexport class Opacity implements SpriteEffect {\r\n  /**\r\n   * @param opacity  The new opacity of the sprite from 0-1.0\r\n   */\r\n  constructor(public opacity: number) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    if (pixel[firstPixel + 3] !== 0) {\r\n      pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Colorize\" effect to a sprite, changing the color channels of all the pixels to an\r\n * average of the original color and the provided color\r\n * @deprecated [[Colorize]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Colorize will be removed in v0.26.0'\r\n})\r\nexport class Colorize implements SpriteEffect {\r\n  /**\r\n   * @param color  The color to apply to the sprite\r\n   */\r\n  constructor(public color: Color) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    if (pixel[firstPixel + 3] !== 0) {\r\n      pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;\r\n      pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;\r\n      pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Lighten\" effect to a sprite, changes the lightness of the color according to HSL\r\n * @deprecated [[Lighten]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Lighten will be removed in v0.26.0'\r\n})\r\nexport class Lighten implements SpriteEffect {\r\n  /**\r\n   * @param factor  The factor of the effect between 0-1\r\n   */\r\n  constructor(public factor: number = 0.1) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(\r\n      this.factor\r\n    );\r\n    pixel[firstPixel + 0] = color.r;\r\n    pixel[firstPixel + 1] = color.g;\r\n    pixel[firstPixel + 2] = color.b;\r\n    pixel[firstPixel + 3] = color.a;\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Darken\" effect to a sprite, changes the darkness of the color according to HSL\r\n * @deprecated [[Darken]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Darken will be removed v0.26.0'\r\n})\r\nexport class Darken implements SpriteEffect {\r\n  /**\r\n   * @param factor  The factor of the effect between 0-1\r\n   */\r\n  constructor(public factor: number = 0.1) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(\r\n      this.factor\r\n    );\r\n    pixel[firstPixel + 0] = color.r;\r\n    pixel[firstPixel + 1] = color.g;\r\n    pixel[firstPixel + 2] = color.b;\r\n    pixel[firstPixel + 3] = color.a;\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Saturate\" effect to a sprite, saturates the color according to HSL\r\n * @deprecated [[Saturate]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Saturate will be removed in v0.26.0'\r\n})\r\nexport class Saturate implements SpriteEffect {\r\n  /**\r\n   * @param factor  The factor of the effect between 0-1\r\n   */\r\n  constructor(public factor: number = 0.1) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(\r\n      this.factor\r\n    );\r\n    pixel[firstPixel + 0] = color.r;\r\n    pixel[firstPixel + 1] = color.g;\r\n    pixel[firstPixel + 2] = color.b;\r\n    pixel[firstPixel + 3] = color.a;\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Desaturate\" effect to a sprite, desaturates the color according to HSL\r\n * @deprecated [[Desaturate]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Desaturate will be removed in v0.26.0'\r\n})\r\nexport class Desaturate implements SpriteEffect {\r\n  /**\r\n   * @param factor  The factor of the effect between 0-1\r\n   */\r\n  constructor(public factor: number = 0.1) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(\r\n      this.factor\r\n    );\r\n    pixel[firstPixel + 0] = color.r;\r\n    pixel[firstPixel + 1] = color.g;\r\n    pixel[firstPixel + 2] = color.b;\r\n    pixel[firstPixel + 3] = color.a;\r\n  }\r\n}\r\n\r\n/**\r\n * Applies the \"Fill\" effect to a sprite, changing the color channels of all non-transparent pixels to match\r\n * a given color\r\n * @deprecated [[Fill]] will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'Fill will be removed in v0.26.0'\r\n})\r\nexport class Fill implements SpriteEffect {\r\n  /**\r\n   * @param color  The color to apply to the sprite\r\n   */\r\n  constructor(public color: Color) {}\r\n  updatePixel(x: number, y: number, imageData: ImageData): void {\r\n    const firstPixel = (x + y * imageData.width) * 4;\r\n    const pixel = imageData.data;\r\n    if (pixel[firstPixel + 3] !== 0) {\r\n      pixel[firstPixel + 0] = this.color.r;\r\n      pixel[firstPixel + 1] = this.color.g;\r\n      pixel[firstPixel + 2] = this.color.b;\r\n    }\r\n  }\r\n}\r\n","import { Resource } from '../Resources/Resource';\r\nimport { Sprite } from './Sprite';\r\nimport { Loadable } from '../Interfaces/Index';\r\n/**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n * @deprecated\r\n */\r\nexport class Texture implements Loadable<HTMLImageElement> {\r\n  private _resource: Resource<Blob>;\r\n  /**\r\n   * The width of the texture in pixels\r\n   */\r\n  public width: number;\r\n\r\n  /**\r\n   * The height of the texture in pixels\r\n   */\r\n  public height: number;\r\n\r\n  private _sprite: Sprite = null;\r\n\r\n  /**\r\n   * Populated once loading is complete\r\n   */\r\n  public data: HTMLImageElement;\r\n  public get image() {\r\n    return this.data;\r\n  }\r\n\r\n  private _loadedResolve: (image: HTMLImageElement) => any;\r\n  public loaded = new Promise<HTMLImageElement>(resolve => {\r\n    this._loadedResolve = resolve;\r\n  });\r\n\r\n  /**\r\n   * @param path       Path to the image resource or a base64 string representing an image \"data:image/png;base64,iVB...\"\r\n   * @param bustCache  Optionally load texture with cache busting\r\n   */\r\n  constructor(public path: string, public bustCache = true) {\r\n    this._resource = new Resource(path, 'blob', bustCache);\r\n    this._sprite = new Sprite(this, 0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the Texture is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    return !!this.data;\r\n  }\r\n\r\n  /**\r\n   * Begins loading the texture and returns a promise to be resolved on completion\r\n   */\r\n  public async load(): Promise<HTMLImageElement> {\r\n    try {\r\n      // Load base64 or blob if needed\r\n      let url: string;\r\n      if (!this.path.includes('data:image/')) {\r\n        const blob = await this._resource.load();\r\n        url = URL.createObjectURL(blob);\r\n      } else {\r\n        url = this.path;\r\n      }\r\n\r\n      // Decode the image\r\n      const image = new Image();\r\n      image.src = url;\r\n      await image.decode();\r\n\r\n      // Set results\r\n      this.data = image;\r\n      this.width = this._sprite.width = image.naturalWidth;\r\n      this.height = this._sprite.height = image.naturalHeight;\r\n      this._sprite = new Sprite(this, 0, 0, this.width, this.height);\r\n    } catch {\r\n      await Promise.reject('Error loading texture');\r\n    }\r\n    // todo emit complete\r\n    this._loadedResolve(this.data);\r\n    return this.data;\r\n  }\r\n\r\n  public asSprite(): Sprite {\r\n    return this._sprite;\r\n  }\r\n}\r\n","export type Constructor<T> = {\r\n  new (...args: any[]): T;\r\n};\r\n/**\r\n * Configurable helper extends base type and makes all properties available as option bag arguments\r\n * @internal\r\n * @param base\r\n */\r\nexport function Configurable<T extends Constructor<{}>>(base: T): T {\r\n  return class extends base {\r\n    public assign(props: Partial<T>) {\r\n      //set the value of every property that was passed in,\r\n      //if the constructor previously set this value, it will be overridden here\r\n      for (const k in props) {\r\n        // eslint-disable-next-line\r\n        if (typeof (<any>this)[k] !== 'function') {\r\n          // eslint-disable-next-line\r\n          (<any>this)[k] = (<any>props)[k];\r\n        }\r\n      }\r\n    }\r\n\r\n    constructor(...args: any[]) {\r\n      super(...args);\r\n      //get the number of arguments that aren't undefined. TS passes a value to all parameters\r\n      //of whatever ctor is the implementation, so args.length doesn't work here.\r\n      const size = args.filter(function(value) {\r\n        return value !== undefined;\r\n      }).length;\r\n      if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {\r\n        this.assign(args[0]);\r\n      }\r\n    }\r\n  };\r\n}\r\n","import * as Effects from './SpriteEffects';\r\nimport { Color } from '../Color';\r\n\r\nimport { Drawable, DrawOptions } from '../Interfaces/Drawable';\r\nimport { Texture } from './Texture';\r\nimport { Vector } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport { clamp } from '../Util/Util';\r\nimport { Configurable } from '../Configurable';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n/**\r\n * @hidden\r\n * @deprecated Use [[Sprite]]\r\n */\r\nexport class SpriteImpl implements Drawable {\r\n  public texture: Texture;\r\n\r\n  public x: number = 0;\r\n  public y: number = 0;\r\n\r\n  public get drawWidth(): number {\r\n    return Math.abs(this.width * this.scale.x);\r\n  }\r\n\r\n  public get drawHeight(): number {\r\n    return Math.abs(this.height * this.scale.y);\r\n  }\r\n\r\n  public rotation: number = 0.0;\r\n  public anchor: Vector = Vector.Half;\r\n  public offset: Vector = Vector.Zero;\r\n  public scale: Vector = Vector.One;\r\n  /**\r\n   * Default: false, should the sprite be drawn around the anchor or from the top left.\r\n   * Sprite rotations/scaling still happen around the anchor regardless of this setting.\r\n   */\r\n  public drawAroundAnchor = false;\r\n\r\n  public logger: Logger = Logger.getInstance();\r\n\r\n  /**\r\n   * Draws the sprite flipped vertically\r\n   */\r\n  public flipVertical: boolean = false;\r\n\r\n  /**\r\n   * Draws the sprite flipped horizontally\r\n   */\r\n  public flipHorizontal: boolean = false;\r\n\r\n  public effects: Effects.SpriteEffect[] = [];\r\n\r\n  public width: number = 0;\r\n  public height: number = 0;\r\n\r\n  private _spriteCanvas: HTMLCanvasElement = null;\r\n  private _spriteCtx: CanvasRenderingContext2D = null;\r\n  private _pixelData: ImageData = null;\r\n  private _pixelsLoaded: boolean = false;\r\n  private _dirtyEffect: boolean = true;\r\n\r\n  /**\r\n   * @param imageOrConfig  The backing image texture to build the Sprite, or Sprite option bag\r\n   * @param x      The x position of the sprite\r\n   * @param y      The y position of the sprite\r\n   * @param width  The width of the sprite in pixels\r\n   * @param height The height of the sprite in pixels\r\n   */\r\n  constructor(imageOrConfig: Texture | SpriteArgs, x: number, y: number, width: number, height: number) {\r\n    let image = imageOrConfig;\r\n    if (imageOrConfig && !(imageOrConfig instanceof Texture)) {\r\n      x = imageOrConfig.x | 0;\r\n      y = imageOrConfig.y | 0;\r\n      width = imageOrConfig.width | 0;\r\n      height = imageOrConfig.height | 0;\r\n      image = imageOrConfig.image;\r\n      if (!image) {\r\n        const message = 'An image texture is required to construct a sprite';\r\n        throw new Error(message);\r\n      }\r\n    }\r\n\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n\r\n    this.texture = image as Texture;\r\n    this._spriteCanvas = document.createElement('canvas');\r\n    this._spriteCanvas.width = width;\r\n    this._spriteCanvas.height = height;\r\n    this._spriteCtx = this._spriteCanvas.getContext('2d');\r\n    this._initPixelsFromTexture();\r\n\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n\r\n  private async _initPixelsFromTexture() {\r\n    try {\r\n      const image = await this.texture.loaded;\r\n      this.width = this.width || image.naturalWidth;\r\n      this.height = this.height || image.naturalHeight;\r\n      this._spriteCanvas.width = this._spriteCanvas.width || image.naturalWidth;\r\n      this._spriteCanvas.height = this._spriteCanvas.height || image.naturalHeight;\r\n      this._loadPixels();\r\n      this._dirtyEffect = true;\r\n    } catch (e) {\r\n      this.logger.error('Error loading texture ', this.texture.path, e);\r\n    }\r\n  }\r\n\r\n  private _loadPixels() {\r\n    if (this.texture.isLoaded() && !this._pixelsLoaded) {\r\n      const naturalWidth = this.texture.image.naturalWidth || 0;\r\n      const naturalHeight = this.texture.image.naturalHeight || 0;\r\n\r\n      if (this.width > naturalWidth) {\r\n        this.logger.warn(`The sprite width ${this.width} exceeds the width \r\n                              ${naturalWidth} of the backing texture ${this.texture.path}`);\r\n      }\r\n\r\n      if (this.width <= 0 || naturalWidth <= 0) {\r\n        throw new Error(`The width of a sprite cannot be 0 or negative, sprite width: ${this.width}, original width: ${naturalWidth}`);\r\n      }\r\n\r\n      if (this.height > naturalHeight) {\r\n        this.logger.warn(`The sprite height ${this.height} exceeds the height \r\n                              ${naturalHeight} of the backing texture ${this.texture.path}`);\r\n      }\r\n\r\n      if (this.height <= 0 || naturalHeight <= 0) {\r\n        throw new Error(`The height of a sprite cannot be 0 or negative, sprite height: ${this.height}, original height: ${naturalHeight}`);\r\n      }\r\n\r\n      this._flushTexture();\r\n\r\n      this._pixelsLoaded = true;\r\n    }\r\n  }\r\n\r\n  private _flushTexture() {\r\n    const naturalWidth = this.texture.image.naturalWidth || 0;\r\n    const naturalHeight = this.texture.image.naturalHeight || 0;\r\n\r\n    this._spriteCtx.clearRect(0, 0, this.width, this.height);\r\n    this._spriteCtx.drawImage(\r\n      this.texture.image,\r\n      clamp(this.x, 0, naturalWidth),\r\n      clamp(this.y, 0, naturalHeight),\r\n      clamp(this.width, 0, naturalWidth),\r\n      clamp(this.height, 0, naturalHeight),\r\n      0,\r\n      0,\r\n      this.width,\r\n      this.height\r\n    );\r\n  }\r\n\r\n  private _opacity: number = 1;\r\n  /**\r\n   * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value\r\n   */\r\n  public opacity(value: number) {\r\n    this._opacity = value;\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Grayscale]] effect to a sprite, removing color information.\r\n   */\r\n  public grayscale() {\r\n    this.addEffect(new Effects.Grayscale());\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.\r\n   */\r\n  public invert() {\r\n    this.addEffect(new Effects.Invert());\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color\r\n   */\r\n  public fill(color: Color) {\r\n    this.addEffect(new Effects.Fill(color));\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color\r\n   * and the provided color.\r\n   */\r\n  public colorize(color: Color) {\r\n    this.addEffect(new Effects.Colorize(color));\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL\r\n   */\r\n  public lighten(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Lighten(factor));\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL\r\n   */\r\n  public darken(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Darken(factor));\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL\r\n   */\r\n  public saturate(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Saturate(factor));\r\n  }\r\n\r\n  /**\r\n   * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL\r\n   */\r\n  public desaturate(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Desaturate(factor));\r\n  }\r\n\r\n  /**\r\n   * Adds a new [[SpriteEffect]] to this drawing.\r\n   * @param effect  Effect to add to the this drawing\r\n   */\r\n  public addEffect(effect: Effects.SpriteEffect) {\r\n    this.effects.push(effect);\r\n    // We must check if the texture and the backing sprite pixels are loaded as well before\r\n    // an effect can be applied\r\n    if (!this.texture.isLoaded() || !this._pixelsLoaded) {\r\n      this._dirtyEffect = true;\r\n    } else {\r\n      this._applyEffects();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a [[SpriteEffect]] from this sprite.\r\n   * @param effect  Effect to remove from this sprite\r\n   */\r\n  public removeEffect(effect: Effects.SpriteEffect): void;\r\n\r\n  /**\r\n   * Removes an effect given the index from this sprite.\r\n   * @param index  Index of the effect to remove from this sprite\r\n   */\r\n  public removeEffect(index: number): void;\r\n  public removeEffect(param: any) {\r\n    let indexToRemove = -1;\r\n    if (typeof param === 'number') {\r\n      indexToRemove = param;\r\n    } else {\r\n      indexToRemove = this.effects.indexOf(param);\r\n    }\r\n\r\n    // bounds check\r\n    if (indexToRemove < 0 || indexToRemove >= this.effects.length) {\r\n      return;\r\n    }\r\n\r\n    this.effects.splice(indexToRemove, 1);\r\n\r\n    // We must check if the texture and the backing sprite pixels are loaded as well before\r\n    // an effect can be applied\r\n    if (!this.texture.isLoaded() || !this._pixelsLoaded) {\r\n      this._dirtyEffect = true;\r\n    } else {\r\n      this._applyEffects();\r\n    }\r\n  }\r\n\r\n  private _applyEffects() {\r\n    this._flushTexture();\r\n\r\n    if (this.effects.length > 0) {\r\n      this._pixelData = this._spriteCtx.getImageData(0, 0, this.width, this.height);\r\n\r\n      const len = this.effects.length;\r\n      for (let i = 0; i < len; i++) {\r\n        for (let y = 0; y < this.height; y++) {\r\n          for (let x = 0; x < this.width; x++) {\r\n            this.effects[i].updatePixel(x, y, this._pixelData);\r\n          }\r\n        }\r\n      }\r\n      this._spriteCtx.clearRect(0, 0, this.width, this.height);\r\n      this._spriteCtx.putImageData(this._pixelData, 0, 0);\r\n    }\r\n\r\n    this._dirtyEffect = false;\r\n  }\r\n\r\n  /**\r\n   * Clears all effects from the drawing and return it to its original state.\r\n   */\r\n  public clearEffects() {\r\n    this.effects.length = 0;\r\n    this._applyEffects();\r\n  }\r\n\r\n  /**\r\n   * Resets the internal state of the drawing (if any)\r\n   */\r\n  public reset() {\r\n    // do nothing\r\n  }\r\n\r\n  public debugDraw(ctx: CanvasRenderingContext2D, x: number, y: number) {\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(this.rotation);\r\n    const xpoint = this.drawWidth * this.anchor.x;\r\n    const ypoint = this.drawHeight * this.anchor.y;\r\n\r\n    ctx.strokeStyle = Color.Black.toString();\r\n    ctx.strokeRect(-xpoint, -ypoint, this.drawWidth, this.drawHeight);\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.\r\n   * @param ctx  The 2D rendering context\r\n   * @param x    The x coordinate of where to draw\r\n   * @param y    The y coordinate of where to draw\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D, x: number, y: number): void;\r\n  /**\r\n   * Draws the sprite with custom options to override internals without mutating them.\r\n   * @param options\r\n   */\r\n  public draw(options: DrawOptions): void;\r\n  public draw(ctxOrOptions: CanvasRenderingContext2D | DrawOptions, x?: number, y?: number): void {\r\n    if (ctxOrOptions instanceof CanvasRenderingContext2D) {\r\n      this._drawWithOptions({ ctx: ctxOrOptions, x, y });\r\n    } else {\r\n      this._drawWithOptions(ctxOrOptions);\r\n    }\r\n  }\r\n\r\n  private _drawWithOptions(options: DrawOptions) {\r\n    const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = {\r\n      ...options,\r\n      rotation: options.rotation ?? this.rotation,\r\n      drawWidth: options.drawWidth ?? this.width,\r\n      drawHeight: options.drawHeight ?? this.height,\r\n      flipHorizontal: options.flipHorizontal ?? this.flipHorizontal,\r\n      flipVertical: options.flipVertical ?? this.flipVertical,\r\n      anchor: options.anchor ?? this.anchor,\r\n      offset: options.offset ?? this.offset,\r\n      opacity: (options.opacity ?? 1) * (this._opacity ?? 1)\r\n    };\r\n\r\n    if (this._dirtyEffect) {\r\n      this._applyEffects();\r\n    }\r\n    // calculating current dimensions\r\n    const anchorX = drawWidth * anchor.x + offset.x;\r\n    const anchorY = drawHeight * anchor.y + offset.y;\r\n    const scaleDirX = this.scale.x > 0 ? 1 : -1;\r\n    const scaleDirY = this.scale.y > 0 ? 1 : -1;\r\n\r\n    ctx.save();\r\n    // Move the draw point of origin\r\n    ctx.translate(x, y);\r\n\r\n    // Rotate and scale around anchor point\r\n    // This requires a bit of explaination, scale coordinates first positive flipping or rotating\r\n    ctx.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\r\n\r\n    if (this.drawAroundAnchor) {\r\n      // In the case where you want the anchor to match with the point of draw\r\n      // Otherwise sprites are always drawn from top-left\r\n      ctx.translate(-anchorX, -anchorY);\r\n    }\r\n\r\n    ctx.translate(anchorX, anchorY);\r\n    ctx.rotate(rotation);\r\n    // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\r\n    ctx.scale(scaleDirX, scaleDirY);\r\n    ctx.translate(-anchorX, -anchorY);\r\n\r\n    if (flipHorizontal) {\r\n      ctx.translate(drawWidth, 0);\r\n      ctx.scale(-1, 1);\r\n    }\r\n\r\n    if (flipVertical) {\r\n      ctx.translate(0, drawHeight);\r\n      ctx.scale(1, -1);\r\n    }\r\n    const oldAlpha = ctx.globalAlpha;\r\n    ctx.globalAlpha = opacity;\r\n    // Context is already rotated and scaled\r\n    ctx.drawImage(\r\n      this._spriteCanvas,\r\n      0,\r\n      0,\r\n      this.width,\r\n      this.height, // source\r\n      0,\r\n      0,\r\n      this.width,\r\n      this.height\r\n    ); // dest\r\n    ctx.globalAlpha = oldAlpha;\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Produces a copy of the current sprite\r\n   */\r\n  public clone(): SpriteImpl {\r\n    const result = new Sprite(this.texture, this.x, this.y, this.width, this.height);\r\n    result.anchor = this.anchor.clone();\r\n    result.scale = this.scale.clone();\r\n    result.rotation = this.rotation;\r\n    result.flipHorizontal = this.flipHorizontal;\r\n    result.flipVertical = this.flipVertical;\r\n\r\n    const len = this.effects.length;\r\n    for (let i = 0; i < len; i++) {\r\n      result.addEffect(this.effects[i]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * @deprecated Use [[Sprite]]\r\n */\r\nexport interface SpriteArgs extends Partial<SpriteImpl> {\r\n  image?: Texture;\r\n  x?: number;\r\n  width?: number;\r\n  height?: number;\r\n  rotation?: number;\r\n  anchor?: Vector;\r\n  scale?: Vector;\r\n  flipVertical?: boolean;\r\n  flipHorizontal?: boolean;\r\n}\r\n\r\n/**\r\n * A [[LegacyDrawing.Sprite]] is one of the main drawing primitives. It is responsible for drawing\r\n * images or parts of images from a [[LegacyDrawing.Texture]] resource to the screen.\r\n * @deprecated Use [[Sprite]]\r\n */\r\n@obsolete({\r\n  message: 'Label.clearTextShadow will be removed in v0.26.0',\r\n  alternateMethod: 'Use Label.font.shadow'\r\n})\r\nexport class Sprite extends Configurable(SpriteImpl) {\r\n  constructor(config: SpriteArgs);\r\n  constructor(image: Texture, x: number, y: number, width: number, height: number);\r\n  constructor(imageOrConfig: Texture | SpriteArgs, x?: number, y?: number, width?: number, height?: number) {\r\n    super(imageOrConfig, x, y, width, height);\r\n  }\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ImageSource } from './ImageSource';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\n\r\nimport { Sprite as LegacySprite } from '../Drawing/Sprite';\r\nimport { Texture } from '../Drawing/Texture';\r\n\r\nexport type SourceView = { x: number; y: number; width: number; height: number };\r\nexport type DestinationSize = { width: number; height: number };\r\n\r\nexport interface SpriteOptions {\r\n  /**\r\n   * Image to create a sprite from\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * By default the source is the entire dimension of the [[ImageSource]]\r\n   */\r\n  sourceView?: { x: number; y: number; width: number; height: number };\r\n  /**\r\n   * By default the size of the final sprite is the size of the [[ImageSource]]\r\n   */\r\n  destSize?: { width: number; height: number };\r\n}\r\n\r\nexport class Sprite extends Graphic {\r\n  public image: ImageSource;\r\n  public sourceView: SourceView;\r\n  public destSize: DestinationSize;\r\n\r\n  public static from(image: ImageSource): Sprite {\r\n    return new Sprite({\r\n      image: image\r\n    });\r\n  }\r\n\r\n  constructor(options: GraphicOptions & SpriteOptions) {\r\n    super(options);\r\n    this.image = options.image;\r\n    const { width, height } = options;\r\n    this.sourceView = options.sourceView ?? { x: 0, y: 0, width: width ?? 0, height: height ?? 0 };\r\n    this.destSize = options.destSize ?? { width: width ?? 0, height: height ?? 0 };\r\n    this._updateSpriteDimensions();\r\n    this.image.ready.then(() => {\r\n      this._updateSpriteDimensions();\r\n    });\r\n  }\r\n\r\n  private _updateSpriteDimensions() {\r\n    const { width: nativeWidth, height: nativeHeight } = this.image;\r\n    // This code uses || to avoid 0's\r\n    // If the source is not specified, use the native dimension\r\n    this.sourceView.width = this.sourceView?.width || nativeWidth;\r\n    this.sourceView.height = this.sourceView?.height || nativeHeight;\r\n\r\n    // If the destination is not specified, use the source if specified, then native\r\n    this.destSize.width = this.destSize?.width || this.sourceView?.width || nativeWidth;\r\n    this.destSize.height = this.destSize?.height || this.sourceView?.height || nativeHeight;\r\n\r\n    this.width = Math.ceil(this.destSize.width);\r\n    this.height = Math.ceil(this.destSize.height);\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded()) {\r\n      this._updateSpriteDimensions();\r\n    }\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  public _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded()) {\r\n      this._updateSpriteDimensions();\r\n      ex.drawImage(\r\n        this.image.image,\r\n        this.sourceView.x,\r\n        this.sourceView.y,\r\n        this.sourceView.width,\r\n        this.sourceView.height,\r\n        x,\r\n        y,\r\n        this.destSize.width,\r\n        this.destSize.height\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a ImageSource from legacy texture\r\n   * @param sprite\r\n   */\r\n  public static fromLegacySprite(sprite: LegacySprite): Sprite {\r\n    const tex = sprite.texture;\r\n    const image = ImageSource.fromLegacyTexture(tex);\r\n    return new Sprite({\r\n      image,\r\n      sourceView: {\r\n        x: sprite.x,\r\n        y: sprite.y,\r\n        width: sprite.width,\r\n        height: sprite.height\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Converts a sprite to a Legacy sprite\r\n   * @deprecated\r\n   * @param sprite\r\n   * @returns LegacyDrawing.Sprite\r\n   */\r\n  public static toLegacySprite(sprite: Sprite): LegacySprite {\r\n    const image = sprite.image;\r\n    const tex = new Texture(image.path);\r\n    tex.data = image.image;\r\n\r\n    return new LegacySprite(tex, sprite.sourceView.x, sprite.sourceView.y, sprite.sourceView.width, sprite.sourceView.height);\r\n  }\r\n\r\n  public clone(): Sprite {\r\n    return new Sprite({\r\n      image: this.image,\r\n      sourceView: { ...this.sourceView },\r\n      destSize: { ...this.destSize },\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n}\r\n","import { Resource } from '../Resources/Resource';\r\nimport { Texture } from '../Drawing/Texture';\r\nimport { Sprite } from './Sprite';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { Logger } from '../Util/Log';\r\n\r\nexport class ImageSource implements Loadable<HTMLImageElement> {\r\n  private _logger = Logger.getInstance();\r\n  private _resource: Resource<Blob>;\r\n\r\n  /**\r\n   * The original size of the source image in pixels\r\n   */\r\n  public get width() {\r\n    return this.image.naturalWidth;\r\n  }\r\n\r\n  /**\r\n   * The original height of the source image in pixels\r\n   */\r\n  public get height() {\r\n    return this.image.naturalHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the Texture is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    return !!this.data.src;\r\n  }\r\n\r\n  /**\r\n   * Access to the underlying html image elmeent\r\n   */\r\n  public data: HTMLImageElement = new Image();\r\n  public get image(): HTMLImageElement {\r\n    return this.data;\r\n  }\r\n\r\n  /**\r\n   * Promise the resolves when the image is loaded and ready for use, does not initiate loading\r\n   */\r\n  public ready: Promise<HTMLImageElement>;\r\n  private _loadedResolve: (value?: HTMLImageElement | PromiseLike<HTMLImageElement>) => void;\r\n\r\n  /**\r\n   * The path to the image, can also be a data url like 'data:image/'\r\n   * @param path\r\n   */\r\n  constructor(public readonly path: string, bustCache: boolean = false) {\r\n    this._resource = new Resource(path, 'blob', bustCache);\r\n    if (path.endsWith('.svg') || path.endsWith('.gif')) {\r\n      this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);\r\n    }\r\n    this.ready = new Promise<HTMLImageElement>((resolve) => {\r\n      this._loadedResolve = resolve;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Begins loading the image and returns a promise that resolves when the image is loaded\r\n   */\r\n  async load(): Promise<HTMLImageElement> {\r\n    if (this.isLoaded()) {\r\n      return this.data;\r\n    }\r\n    try {\r\n      // Load base64 or blob if needed\r\n      let url: string;\r\n      if (!this.path.includes('data:image/')) {\r\n        const blob = await this._resource.load();\r\n        url = URL.createObjectURL(blob);\r\n      } else {\r\n        url = this.path;\r\n      }\r\n\r\n      // Decode the image\r\n      const image = new Image();\r\n      image.src = url;\r\n      await image.decode();\r\n\r\n      // Set results\r\n      this.data = image;\r\n    } catch (error) {\r\n      throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;\r\n    }\r\n    // todo emit complete\r\n    this._loadedResolve(this.data);\r\n    return this.data;\r\n  }\r\n\r\n  /**\r\n   * Build a sprite from this ImageSource\r\n   */\r\n  public toSprite(): Sprite {\r\n    return Sprite.from(this);\r\n  }\r\n\r\n  /**\r\n   * Create a ImageSource from legacy texture\r\n   * @param tex\r\n   */\r\n  public static fromLegacyTexture(tex: Texture): ImageSource {\r\n    const image = new ImageSource(tex.path);\r\n    if (tex.isLoaded()) {\r\n      image.data = tex.data;\r\n    } else {\r\n      tex.loaded.then(() => {\r\n        image.data = tex.data;\r\n      });\r\n    }\r\n    return image;\r\n  }\r\n\r\n  /**\r\n   * Unload images from memory\r\n   */\r\n  unload(): void {\r\n    this.data = new Image();\r\n  }\r\n}\r\n","import { Sprite } from './Sprite';\r\nimport * as Effects from './SpriteEffects';\r\nimport { Color } from '../Color';\r\n\r\nimport { Drawable, DrawOptions } from '../Interfaces/Drawable';\r\nimport { Vector } from '../Math/vector';\r\nimport { Engine } from '../Engine';\r\nimport * as Util from '../Util/Util';\r\nimport { Configurable } from '../Configurable';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n/**\r\n * @deprecated Use [[HasTick]]\r\n */\r\nexport interface HasTick {\r\n  /**\r\n   *\r\n   * @param elapsedMilliseconds The amount of real world time in milliseconds that has elapsed that must be updated in the animation\r\n   */\r\n  tick(elapsedMilliseconds: number, idempotencyToken?: number): void;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * @deprecated Use [[Animation]]\r\n */\r\nexport class AnimationImpl implements Drawable, HasTick {\r\n  /**\r\n   * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly\r\n   * generate an [[Animation]].\r\n   */\r\n  public sprites: Sprite[] = [];\r\n\r\n  /**\r\n   * Duration to show each frame (in milliseconds)\r\n   */\r\n  public speed: number;\r\n\r\n  /**\r\n   * Current frame index being shown\r\n   */\r\n  public currentFrame: number = 0;\r\n\r\n  private _timeLeftInFrame: number = 0;\r\n  private _idempotencyToken: number = -1;\r\n\r\n  public anchor: Vector = Vector.Zero;\r\n  public rotation: number = 0.0;\r\n  public scale: Vector = Vector.One;\r\n\r\n  /**\r\n   * Indicates whether the animation should loop after it is completed\r\n   */\r\n  public loop: boolean = true;\r\n\r\n  /**\r\n   * Indicates the frame index the animation should freeze on for a non-looping\r\n   * animation. By default it is the last frame.\r\n   */\r\n  public freezeFrame: number = -1;\r\n\r\n  private _engine: Engine;\r\n\r\n  /**\r\n   * Flip each frame vertically. Sets [[Sprite.flipVertical]].\r\n   */\r\n  public flipVertical: boolean = false;\r\n\r\n  /**\r\n   * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].\r\n   */\r\n  public flipHorizontal: boolean = false;\r\n\r\n  public drawWidth: number = 0;\r\n  public drawHeight: number = 0;\r\n  public width: number = 0;\r\n  public height: number = 0;\r\n\r\n  private _opacity = 1;\r\n\r\n  /**\r\n   * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].\r\n   *\r\n   * @param engineOrConfig  Reference to the current game engine\r\n   * @param sprites  An array of sprites to create the frames for the animation\r\n   * @param speed   The number in milliseconds to display each frame in the animation\r\n   * @param loop    Indicates whether the animation should loop after it is completed\r\n   */\r\n  constructor(engineOrConfig: Engine | AnimationArgs, sprites: Sprite[], speed: number, loop?: boolean) {\r\n    let engine = engineOrConfig;\r\n    if (engineOrConfig && !(engineOrConfig instanceof Engine)) {\r\n      const config = engineOrConfig;\r\n      engine = config.engine;\r\n      sprites = config.sprites;\r\n      speed = config.speed;\r\n      loop = config.loop;\r\n    }\r\n\r\n    this.sprites = sprites;\r\n    this.speed = speed;\r\n    this._engine = <Engine>engine;\r\n    this._timeLeftInFrame = this.speed;\r\n\r\n    if (loop != null) {\r\n      this.loop = loop;\r\n    }\r\n\r\n    if (sprites && sprites[0]) {\r\n      this.drawHeight = sprites[0] ? sprites[0].drawHeight : 0;\r\n      this.drawWidth = sprites[0] ? sprites[0].drawWidth : 0;\r\n\r\n      this.width = sprites[0] ? sprites[0].width : 0;\r\n      this.height = sprites[0] ? sprites[0].height : 0;\r\n\r\n      this.freezeFrame = sprites.length - 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value\r\n   */\r\n  public opacity(value: number) {\r\n    this._opacity = value;\r\n  }\r\n\r\n  /**\r\n   * Applies the grayscale effect to a sprite, removing color information.\r\n   */\r\n  public grayscale() {\r\n    this.addEffect(new Effects.Grayscale());\r\n  }\r\n\r\n  /**\r\n   * Applies the invert effect to a sprite, inverting the pixel colors.\r\n   */\r\n  public invert() {\r\n    this.addEffect(new Effects.Invert());\r\n  }\r\n\r\n  /**\r\n   * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color\r\n   */\r\n  public fill(color: Color) {\r\n    this.addEffect(new Effects.Fill(color));\r\n  }\r\n\r\n  /**\r\n   * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the\r\n   * provided color.\r\n   */\r\n  public colorize(color: Color) {\r\n    this.addEffect(new Effects.Colorize(color));\r\n  }\r\n\r\n  /**\r\n   * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl\r\n   */\r\n  public lighten(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Lighten(factor));\r\n  }\r\n\r\n  /**\r\n   * Applies the darken effect to a sprite, changes the darkness of the color according to hsl\r\n   */\r\n  public darken(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Darken(factor));\r\n  }\r\n\r\n  /**\r\n   * Applies the saturate effect to a sprite, saturates the color according to hsl\r\n   */\r\n  public saturate(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Saturate(factor));\r\n  }\r\n\r\n  /**\r\n   * Applies the desaturate effect to a sprite, desaturates the color according to hsl\r\n   */\r\n  public desaturate(factor: number = 0.1) {\r\n    this.addEffect(new Effects.Desaturate(factor));\r\n  }\r\n\r\n  /**\r\n   * Add a [[SpriteEffect]] manually\r\n   */\r\n  public addEffect(effect: Effects.SpriteEffect) {\r\n    for (const i in this.sprites) {\r\n      this.sprites[i].addEffect(effect);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an [[SpriteEffect]] from this animation.\r\n   * @param effect Effect to remove from this animation\r\n   */\r\n  public removeEffect(effect: Effects.SpriteEffect): void;\r\n\r\n  /**\r\n   * Removes an effect given the index from this animation.\r\n   * @param index  Index of the effect to remove from this animation\r\n   */\r\n  public removeEffect(index: number): void;\r\n  public removeEffect(param: any) {\r\n    for (const i in this.sprites) {\r\n      this.sprites[i].removeEffect(param);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all sprite effects\r\n   */\r\n  public clearEffects() {\r\n    for (const i in this.sprites) {\r\n      this.sprites[i].clearEffects();\r\n    }\r\n  }\r\n\r\n  private _setAnchor(point: Vector) {\r\n    //if (!this.anchor.equals(point)) {\r\n    for (const i in this.sprites) {\r\n      this.sprites[i].anchor.setTo(point.x, point.y);\r\n    }\r\n    //}\r\n  }\r\n\r\n  private _setRotation(radians: number) {\r\n    //if (this.rotation !== radians) {\r\n    for (const i in this.sprites) {\r\n      this.sprites[i].rotation = radians;\r\n    }\r\n    //}\r\n  }\r\n\r\n  private _setScale(scale: Vector) {\r\n    //if (!this.scale.equals(scale)) {\r\n    for (const i in this.sprites) {\r\n      this.sprites[i].scale = scale;\r\n    }\r\n    //}\r\n  }\r\n\r\n  /**\r\n   * Resets the animation to first frame.\r\n   */\r\n  public reset() {\r\n    this.currentFrame = 0;\r\n  }\r\n\r\n  /**\r\n   * Indicates whether the animation is complete, animations that loop are never complete.\r\n   */\r\n  public isDone() {\r\n    return !this.loop && this.currentFrame >= this.sprites.length;\r\n  }\r\n\r\n  /**\r\n   * Not meant to be called by game developers. Ticks the animation forward internally and\r\n   * calculates whether to change to the frame.\r\n   * @internal\r\n   */\r\n  public tick(elapsed: number, idempotencyToken?: number) {\r\n    if (this._idempotencyToken === idempotencyToken) {\r\n      return;\r\n    }\r\n    this._idempotencyToken = idempotencyToken;\r\n    this._timeLeftInFrame -= elapsed;\r\n    if (this._timeLeftInFrame <= 0) {\r\n      this.currentFrame = this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1;\r\n      this._timeLeftInFrame = this.speed;\r\n    }\r\n\r\n    this._updateValues();\r\n    const current = this.sprites[this.currentFrame];\r\n    if (current) {\r\n      this.width = current.width;\r\n      this.height = current.height;\r\n      this.drawWidth = current.drawWidth;\r\n      this.drawHeight = current.drawHeight;\r\n    }\r\n  }\r\n\r\n  private _updateValues(): void {\r\n    this._setAnchor(this.anchor);\r\n    this._setRotation(this.rotation);\r\n    this._setScale(this.scale);\r\n  }\r\n\r\n  /**\r\n   * Skips ahead a specified number of frames in the animation\r\n   * @param frames  Frames to skip ahead\r\n   */\r\n  public skip(frames: number) {\r\n    this.currentFrame = (this.currentFrame + frames) % this.sprites.length;\r\n  }\r\n\r\n  /**\r\n   * Draws the animation appropriately to the 2D rendering context, at an x and y coordinate.\r\n   * @param ctx  The 2D rendering context\r\n   * @param x    The x coordinate of where to draw\r\n   * @param y    The y coordinate of where to draw\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D, x: number, y: number): void;\r\n  /**\r\n   * Draws the animation with custom options to override internals without mutating them.\r\n   * @param options\r\n   */\r\n  public draw(options: DrawOptions): void;\r\n  public draw(ctxOrOptions: CanvasRenderingContext2D | DrawOptions, x?: number, y?: number) {\r\n    if (ctxOrOptions instanceof CanvasRenderingContext2D) {\r\n      this._drawWithOptions({ ctx: ctxOrOptions, x, y });\r\n    } else {\r\n      this._drawWithOptions(ctxOrOptions);\r\n    }\r\n  }\r\n\r\n  private _drawWithOptions(options: DrawOptions) {\r\n    const animOptions = {\r\n      ...options,\r\n      rotation: options.rotation ?? this.rotation,\r\n      drawWidth: options.drawWidth ?? this.drawWidth,\r\n      drawHeight: options.drawHeight ?? this.drawHeight,\r\n      flipHorizontal: options.flipHorizontal ?? this.flipHorizontal,\r\n      flipVertical: options.flipVertical ?? this.flipVertical,\r\n      anchor: options.anchor ?? this.anchor,\r\n      opacity: (options.opacity ?? 1) * (this._opacity ?? 1)\r\n    };\r\n\r\n    this._updateValues();\r\n    let currSprite: Sprite;\r\n    if (this.currentFrame < this.sprites.length) {\r\n      currSprite = this.sprites[this.currentFrame];\r\n      currSprite.draw(animOptions);\r\n    }\r\n\r\n    if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {\r\n      currSprite = this.sprites[Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];\r\n      currSprite.draw(animOptions);\r\n    }\r\n\r\n    // add the calculated width\r\n    if (currSprite) {\r\n      this.drawWidth = currSprite.drawWidth;\r\n      this.drawHeight = currSprite.drawHeight;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Plays an animation at an arbitrary location in the game.\r\n   * @param x  The x position in the game to play\r\n   * @param y  The y position in the game to play\r\n   */\r\n  public play(x: number, y: number) {\r\n    this.reset();\r\n    this._engine.playAnimation(this, x, y);\r\n  }\r\n}\r\n\r\n/**\r\n * @deprecated Use [[Animation]]\r\n */\r\nexport interface AnimationArgs extends Partial<AnimationImpl> {\r\n  engine: Engine;\r\n  sprites: Sprite[];\r\n  speed: number;\r\n  loop?: boolean;\r\n  anchor?: Vector;\r\n  rotation?: number;\r\n  scale?: Vector;\r\n  flipVertical?: boolean;\r\n  flipHorizontal?: boolean;\r\n  width?: number;\r\n  height?: number;\r\n}\r\n\r\n/**\r\n * Animations allow you to display a series of images one after another,\r\n * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.\r\n * @deprecated Use [[Animation]]\r\n */\r\n@obsolete({\r\n  message: 'Animation will be removed in v0.26.0',\r\n  alternateMethod: 'Use Graphics.Animation'\r\n})\r\nexport class Animation extends Configurable(AnimationImpl) {\r\n  constructor(config: AnimationArgs);\r\n  constructor(engine: Engine, images: Sprite[], speed: number, loop?: boolean);\r\n  constructor(engineOrConfig: Engine | AnimationArgs, images?: Sprite[], speed?: number, loop?: boolean) {\r\n    super(engineOrConfig, images, speed, loop);\r\n  }\r\n}\r\n","import { Color } from '../Color';\nimport { Vector } from '../Math/vector';\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\n\n/**\n * Enum representing the different font size units\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\n */\nexport enum FontUnit {\n  /**\n   * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\n   */\n  Em = 'em',\n  /**\n   * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element\n   */\n  Rem = 'rem',\n  /**\n   * Pixel is a unit of length in screen pixels\n   */\n  Px = 'px',\n  /**\n   * Point is a physical unit length (1/72 of an inch)\n   */\n  Pt = 'pt',\n  /**\n   * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\n   */\n  Percent = '%'\n}\n\n/**\n * Enum representing the different horizontal text alignments\n */\nexport enum TextAlign {\n  /**\n   * The text is left-aligned.\n   */\n  Left = 'left',\n  /**\n   * The text is right-aligned.\n   */\n  Right = 'right',\n  /**\n   * The text is centered.\n   */\n  Center = 'center',\n  /**\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\n   * right-aligned for right-to-left locales).\n   */\n  Start = 'start',\n  /**\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\n   * left-aligned for right-to-left locales).\n   */\n  End = 'end'\n}\n\n/**\n * Enum representing the different baseline text alignments\n */\nexport enum BaseAlign {\n  /**\n   * The text baseline is the top of the em square.\n   */\n  Top = 'top',\n  /**\n   * The text baseline is the hanging baseline.  Currently unsupported; this will act like\n   * alphabetic.\n   */\n  Hanging = 'hanging',\n  /**\n   * The text baseline is the middle of the em square.\n   */\n  Middle = 'middle',\n  /**\n   * The text baseline is the normal alphabetic baseline.\n   */\n  Alphabetic = 'alphabetic',\n  /**\n   * The text baseline is the ideographic baseline; this is the bottom of\n   * the body of the characters, if the main body of characters protrudes\n   * beneath the alphabetic baseline.  Currently unsupported; this will\n   * act like alphabetic.\n   */\n  Ideographic = 'ideographic',\n  /**\n   * The text baseline is the bottom of the bounding box.  This differs\n   * from the ideographic baseline in that the ideographic baseline\n   * doesn't consider descenders.\n   */\n  Bottom = 'bottom'\n}\n\n/**\n * Enum representing the different possible font styles\n */\nexport enum FontStyle {\n  Normal = 'normal',\n  Italic = 'italic',\n  Oblique = 'oblique'\n}\n\nexport enum Direction {\n  LeftToRight = 'ltr',\n  RightToLeft = 'rtl'\n}\n\nexport interface FontOptions {\n  size?: number;\n  unit?: FontUnit;\n  lineHeight?: number;\n  family?: string;\n  style?: FontStyle;\n  bold?: boolean;\n  textAlign?: TextAlign;\n  baseAlign?: BaseAlign;\n  direction?: Direction;\n  quality?: number;\n  shadow?: {\n    blur?: number;\n    offset?: Vector;\n    color?: Color;\n  };\n}\n\nexport interface FontRenderer {\n  render(ex: ExcaliburGraphicsContext, text: string, x: number, y: number): void;\n}\n","import { Sprite, SpriteArgs } from './Sprite';\nimport { Animation } from './Animation';\nimport { Color } from '../Color';\nimport * as Effects from './SpriteEffects';\n\nimport { Texture } from './Texture';\nimport { Engine } from '../Engine';\nimport { Logger } from '../Util/Log';\nimport { BaseAlign, TextAlign } from '../Graphics/FontCommon';\nimport { obsolete } from '../Util/Decorators';\nimport { vec } from '../Math/vector';\n\nexport interface SpriteSheetArgs {\n  image: Texture;\n  sprites?: Sprite[];\n  spWidth: number;\n  spHeight: number;\n  rows: number;\n  columns: number;\n  spacing?: number | SpriteSheetSpacingDimensions;\n}\n\nexport interface SpriteSheetSpacingDimensions {\n  top?: number;\n  left?: number;\n  margin?: number;\n}\n\n/**\n * Sprite sheets are a useful mechanism for slicing up image resources into\n * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized\n * in row major order in the [[SpriteSheet]].\n * @deprecated Will be removed in v0.26.0\n */\nexport class SpriteSheet {\n  private _sprites: Sprite[] = [];\n  private _image: Texture | null = null;\n  private _columns: number = 0;\n  private _rows: number = 0;\n  private _spWidth: number = 0;\n  private _spHeight: number = 0;\n  private _spacing: number | SpriteSheetSpacingDimensions = 0;\n\n  /**\n   * @param config    The configuration of the SpriteSheet\n   */\n  constructor(config: SpriteSheetArgs);\n\n  /**\n   * @param sprites   The backing sprite array to use, if already available\n   */\n  constructor(sprites: Sprite[]);\n\n  /**\n   * @param image     The backing image texture to build the SpriteSheet\n   * @param columns   The number of columns in the image texture\n   * @param rows      The number of rows in the image texture\n   * @param spWidth   The width of each individual sprite in pixels\n   * @param spHeight  The height of each individual sprite in pixels\n   * @param spacing   The spacing between every sprite in a spritesheet\n   */\n  constructor(\n    image: Texture,\n    columns: number,\n    rows: number,\n    spWidth: number,\n    spHeight: number,\n    spacing?: number | SpriteSheetSpacingDimensions\n  );\n\n  /**\n   * @param imageOrConfigOrSprites The backing image texture to build the SpriteSheet, option bag, or sprite list\n   * @param columns   The number of columns in the image texture\n   * @param rows      The number of rows in the image texture\n   * @param spWidth   The width of each individual sprite in pixels\n   * @param spHeight  The height of each individual sprite in pixels\n   * @param spacing   The spacing between every sprite in a spritesheet\n   */\n  constructor(\n    imageOrConfigOrSprites: Texture | SpriteSheetArgs | Sprite[],\n    columns?: number,\n    rows?: number,\n    spWidth?: number,\n    spHeight?: number,\n    spacing?: number | SpriteSheetSpacingDimensions\n  ) {\n    let loadFromImage: boolean = false;\n    if (imageOrConfigOrSprites instanceof Array) {\n      this._sprites = imageOrConfigOrSprites;\n    } else {\n      if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture)) {\n        this._columns = imageOrConfigOrSprites.columns;\n        this._rows = imageOrConfigOrSprites.rows;\n        this._spWidth = imageOrConfigOrSprites.spWidth;\n        this._spHeight = imageOrConfigOrSprites.spHeight;\n        this._image = imageOrConfigOrSprites.image;\n        this._spacing = imageOrConfigOrSprites.spacing || 0;\n      } else {\n        this._image = <Texture>imageOrConfigOrSprites;\n        this._columns = columns;\n        this._rows = rows;\n        this._spWidth = spWidth;\n        this._spHeight = spHeight;\n        this._spacing = spacing || 0;\n      }\n      this._sprites = new Array(this._columns * this._rows);\n      loadFromImage = true;\n    }\n\n    // Inspect actual image dimensions with preloading\n    if (this.image instanceof Texture) {\n      let isWidthError: boolean = false;\n      let isHeightError: boolean = false;\n      if (this.image.isLoaded()) {\n        isWidthError = this.spWidth * this.columns > this.image.image.naturalWidth;\n        isHeightError = this.spHeight * this.rows > this.image.image.naturalHeight;\n        if (isWidthError) {\n          throw new RangeError(\n            `SpriteSheet specified is wider, ` +\n              `${this.columns} cols x ${this.spWidth} pixels > ${this.image.image.naturalWidth} ` +\n              `pixels than image width`\n          );\n        }\n        if (isHeightError) {\n          throw new RangeError(\n            `SpriteSheet specified is taller, ` +\n              `${this.rows} rows x ${this.spHeight} pixels > ${this.image.image.naturalHeight} ` +\n              `pixels than image height`\n          );\n        }\n      }\n    }\n\n    if (loadFromImage) {\n      const spacing = this.getSpacingDimensions();\n\n      for (let row = 0; row < this.rows; row++) {\n        for (let col = 0; col < this.columns; col++) {\n          this._sprites[col + row * this.columns] = new Sprite(\n            this.image,\n            col * this.spWidth + spacing.margin * col + spacing.left,\n            row * this.spHeight + spacing.margin * row + spacing.top,\n            this.spWidth,\n            this.spHeight\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the raw spacing dimensions for the sprites in the sheet, which can be a fixed number or custom dimensions.\n   */\n  public get spacing() {\n    return this._spacing;\n  }\n\n  /**\n   * Get a copy of the backing sprite array\n   */\n  public get sprites() {\n    return [...this._sprites];\n  }\n\n  /**\n   * The backing texture used for the sprite sheet\n   */\n  public get image() {\n    return this._image;\n  }\n\n  /**\n   * The number of columns in the sheet\n   */\n  public get columns() {\n    return this._columns;\n  }\n\n  /**\n   * The number of rows in the sheet\n   */\n  public get rows() {\n    return this._rows;\n  }\n\n  /**\n   * The width of the individual sprites\n   */\n  public get spWidth() {\n    return this._spWidth;\n  }\n\n  /**\n   * The height of the individual sprites\n   */\n  public get spHeight() {\n    return this._spHeight;\n  }\n\n  /**\n   * Gets the calculated spacing dimensions based on whether spacing\n   * is a fixed number or has different values for each dimension\n   */\n  public getSpacingDimensions(): SpriteSheetSpacingDimensions {\n    if (typeof this.spacing === 'number') {\n      return {\n        left: this.spacing,\n        top: this.spacing,\n        margin: this.spacing\n      };\n    } else {\n      return {\n        left: this.spacing.left ?? 0,\n        top: this.spacing.top ?? 0,\n        margin: this.spacing.margin ?? 0\n      };\n    }\n  }\n\n  /**\n   * Create an animation from the this SpriteSheet by listing out the\n   * sprite indices. Sprites are organized in row major order in the SpriteSheet.\n   * @param engine   Reference to the current game [[Engine]]\n   * @param indices  An array of sprite indices to use in the animation\n   * @param speed    The number in milliseconds to display each frame in the animation\n   */\n  public getAnimationByIndices(engine: Engine, indices: number[], speed: number) {\n    let images: Sprite[] = indices.map((index) => {\n      return this.sprites[index];\n    });\n\n    images = images.map(function (i) {\n      return i.clone();\n    });\n    return new Animation(engine, images, speed);\n  }\n\n  /**\n   * Create an animation from the this SpriteSheet by specifying the range of\n   * images with the beginning (inclusive) and ending (exclusive) index\n   * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.\n   * @param engine      Reference to the current game Engine\n   * @param beginIndex  The index to start taking frames (inclusive)\n   * @param endIndex    The index to stop taking frames (exclusive)\n   * @param speed       The number in milliseconds to display each frame in the animation\n   */\n  public getAnimationBetween(engine: Engine, beginIndex: number, endIndex: number, speed: number) {\n    let images = this.sprites.slice(beginIndex, endIndex);\n    images = images.map(function (i) {\n      return i.clone();\n    });\n    return new Animation(engine, images, speed);\n  }\n\n  /**\n   * Treat the entire SpriteSheet as one animation, organizing the frames in\n   * row major order.\n   * @param engine  Reference to the current game [[Engine]]\n   * @param speed   The number in milliseconds to display each frame the animation\n   */\n  public getAnimationForAll(engine: Engine, speed: number) {\n    const sprites = this.sprites.map(function (i) {\n      return i.clone();\n    });\n    return new Animation(engine, sprites, speed);\n  }\n\n  /**\n   * Retrieve a specific sprite from the SpriteSheet by its index. Sprites are organized\n   * in row major order in the SpriteSheet.\n   * @param index  The index of the sprite\n   */\n  public getSprite(index: number): Sprite {\n    if (index >= 0 && index < this.sprites.length) {\n      return this.sprites[index];\n    } else {\n      throw new Error('Invalid index: ' + index);\n    }\n  }\n\n  /**\n   * Get an animation with bespoke sprite coordinates. This is useful if the SpriteSheet is\n   * packed and not a uniform width or height. The resulting [[Animation]] will have the height and width of the\n   * largest dimension (width, height) from among the sprite coordinates\n   * @param engine\n   * @param spriteCoordinates\n   * @param speed\n   */\n  public getAnimationByCoords(engine: Engine, spriteCoordinates: SpriteArgs[], speed: number): Animation {\n    let maxWidth: number = 0;\n    let maxHeight: number = 0;\n    const sprites: Sprite[] = new Array(spriteCoordinates.length);\n    for (let i = 0; i < spriteCoordinates.length; i++) {\n      const coord = spriteCoordinates[i];\n      // no need to pass image again if using a spritesheet\n      coord.image = coord.image || this.image;\n      maxWidth = Math.max(maxWidth, coord.drawWidth);\n      maxHeight = Math.max(maxHeight, coord.drawHeight);\n      sprites[i] = new Sprite(coord);\n    }\n\n    const anim = new Animation(engine, sprites, speed);\n\n    anim.drawWidth = maxWidth;\n    anim.drawHeight = maxHeight;\n    return anim;\n  }\n}\n\n/**\n * Specify various font attributes for sprite fonts\n */\nexport interface SpriteFontOptions {\n  color?: Color;\n  opacity?: number;\n  fontSize?: number;\n  letterSpacing?: number;\n  textAlign?: TextAlign;\n  baseAlign?: BaseAlign;\n  maxWidth?: number;\n}\n\nexport interface SpriteFontArgs extends SpriteSheetArgs {\n  alphabet: string;\n  caseInsensitive: boolean;\n}\n\n/**\n * Sprite fonts are a used in conjunction with a [[Label]] to specify\n * a particular bitmap as a font. Note that some font features are not\n * supported by Sprite fonts.\n * @deprecated Will be removed into v0.26.0\n */\n@obsolete({\n  message: 'SpriteSheet will be removed in v0.26.0',\n  alternateMethod: 'Use Graphics.SpriteSheet'\n})\nexport class SpriteFont extends SpriteSheet {\n  private _currentColor: Color = Color.Black;\n  private _currentOpacity: Number = 1.0;\n  private _spriteRecord: Record<string, Sprite> = {};\n\n  // text shadow\n  private _textShadowOn: boolean = false;\n  private _textShadowDirty: boolean = true;\n  private _textShadowColor: Color = Color.Black;\n  private _textShadowSprites: { [key: string]: Sprite } = {};\n  private _shadowOffsetX: number = 5;\n  private _shadowOffsetY: number = 5;\n  public readonly alphabet: string;\n  public readonly caseInsensitive: boolean;\n\n  constructor(config: SpriteFontArgs);\n\n  constructor(\n    image: Texture,\n    alphabet: string,\n    caseInsensitive: boolean,\n    columns: number,\n    rows: number,\n    spWidth: number,\n    spHeight: number,\n    spacing?: number | SpriteSheetSpacingDimensions\n  );\n\n  /**\n   * @param imageOrConfig   The backing image texture to build the SpriteFont or the sprite font option bag\n   * @param alphabet        A string representing all the characters in the image, in row major order.\n   * @param caseInsensitive  Indicate whether this font takes case into account\n   * @param columns         The number of columns of characters in the image\n   * @param rows            The number of rows of characters in the image\n   * @param spWidth         The width of each character in pixels\n   * @param spHeight        The height of each character in pixels\n   */\n  constructor(\n    imageOrConfig: Texture | SpriteFontArgs,\n    alphabet?: string,\n    caseInsensitive?: boolean,\n    columns?: number,\n    rows?: number,\n    spWidth?: number,\n    spHeight?: number,\n    spacing?: number | SpriteSheetSpacingDimensions\n  ) {\n    super(\n      imageOrConfig instanceof Texture\n        ? {\n          image: imageOrConfig,\n          spWidth: spWidth,\n          spHeight: spHeight,\n          rows: rows,\n          columns: columns,\n          spacing: spacing || 0\n        }\n        : imageOrConfig\n    );\n\n    if (imageOrConfig && !(imageOrConfig instanceof Texture)) {\n      alphabet = imageOrConfig.alphabet;\n      caseInsensitive = imageOrConfig.caseInsensitive;\n    }\n\n    this.alphabet = alphabet;\n    this.caseInsensitive = caseInsensitive;\n    this._spriteRecord = this.getTextSprites();\n  }\n\n  /**\n   * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].\n   */\n  public getTextSprites(): { [key: string]: Sprite } {\n    const lookup: { [key: string]: Sprite } = {};\n    for (let i = 0; i < this.alphabet.length; i++) {\n      let char = this.alphabet[i];\n      if (this.caseInsensitive) {\n        char = char.toLowerCase();\n      }\n      lookup[char] = this.sprites[i].clone();\n    }\n    return lookup;\n  }\n\n  /**\n   * Sets the text shadow for sprite fonts\n   * @param offsetX      The x offset in pixels to place the shadow\n   * @param offsetY      The y offset in pixels to place the shadow\n   * @param shadowColor  The color of the text shadow\n   */\n  public setTextShadow(offsetX: number, offsetY: number, shadowColor: Color) {\n    this._textShadowOn = true;\n    this._shadowOffsetX = offsetX;\n    this._shadowOffsetY = offsetY;\n    this._textShadowColor = shadowColor.clone();\n    this._textShadowDirty = true;\n    for (const character in this._spriteRecord) {\n      this._textShadowSprites[character] = this._spriteRecord[character].clone();\n    }\n  }\n\n  /**\n   * Toggles text shadows on or off\n   */\n  public useTextShadow(on: boolean) {\n    this._textShadowOn = on;\n    if (on) {\n      this.setTextShadow(5, 5, this._textShadowColor);\n    }\n  }\n\n  /**\n   * Draws the current sprite font\n   */\n  public draw(ctx: CanvasRenderingContext2D, text: string, x: number, y: number, options: SpriteFontOptions) {\n    options = this._parseOptions(options);\n\n    if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {\n      this._currentOpacity = options.opacity;\n      this._currentColor = options.color;\n      for (const char in this._spriteRecord) {\n        this._spriteRecord[char].clearEffects();\n        this._spriteRecord[char].fill(options.color);\n        this._spriteRecord[char].opacity(options.opacity);\n      }\n    }\n\n    if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {\n      for (const characterShadow in this._textShadowSprites) {\n        this._textShadowSprites[characterShadow].clearEffects();\n        this._textShadowSprites[characterShadow].addEffect(new Effects.Fill(this._textShadowColor.clone()));\n      }\n      this._textShadowDirty = false;\n    }\n\n    // find the current length of text in pixels\n    const sprite = this.sprites[0];\n\n    // find the current height fo the text in pixels\n    const height = sprite.height;\n\n    // calculate appropriate scale for font size\n    const scale = options.fontSize / height;\n\n    const length = text.length * sprite.width * scale + text.length * options.letterSpacing;\n\n    let currX = x;\n    if (options.textAlign === TextAlign.Left || options.textAlign === TextAlign.Start) {\n      currX = x;\n    } else if (options.textAlign === TextAlign.Right || options.textAlign === TextAlign.End) {\n      currX = x - length;\n    } else if (options.textAlign === TextAlign.Center) {\n      currX = x - length / 2;\n    }\n\n    let currY = y - height * scale;\n    if (options.baseAlign === BaseAlign.Top || options.baseAlign === BaseAlign.Hanging) {\n      currY = y;\n    } else if (\n      options.baseAlign === BaseAlign.Ideographic ||\n      options.baseAlign === BaseAlign.Bottom ||\n      options.baseAlign === BaseAlign.Alphabetic\n    ) {\n      currY = y - height * scale;\n    } else if (options.baseAlign === BaseAlign.Middle) {\n      currY = y - (height * scale) / 2;\n    }\n\n    for (let i = 0; i < text.length; i++) {\n      let character = text[i];\n      if (this.caseInsensitive) {\n        character = character.toLowerCase();\n      }\n      try {\n        // if text shadow\n        if (this._textShadowOn) {\n          this._textShadowSprites[character].drawAroundAnchor = false;\n          this._textShadowSprites[character].scale = vec(scale, scale);\n          this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);\n        }\n\n        const charSprite = this._spriteRecord[character];\n        charSprite.drawAroundAnchor = false;\n        charSprite.scale = vec(scale, scale);\n        charSprite.draw(ctx, currX, currY);\n        currX += charSprite.drawWidth + options.letterSpacing;\n      } catch (e) {\n        Logger.getInstance().error(`SpriteFont Error drawing char ${character}`);\n      }\n    }\n  }\n\n  private _parseOptions(options: SpriteFontOptions): SpriteFontOptions {\n    return {\n      fontSize: options.fontSize || 10,\n      letterSpacing: options.letterSpacing || 0,\n      color: options.color || Color.Black,\n      textAlign: typeof options.textAlign === undefined ? TextAlign.Left : options.textAlign,\n      baseAlign: typeof options.baseAlign === undefined ? BaseAlign.Bottom : options.baseAlign,\n      maxWidth: options.maxWidth || -1,\n      opacity: options.opacity || 0\n    };\n  }\n}\n","import { ImageSource } from './ImageSource';\r\nimport { Sprite } from './Sprite';\r\nimport { SpriteSheet as LegacySpriteSheet } from '../Drawing/SpriteSheet';\r\nimport { Logger } from '..';\r\n\r\n\r\n/**\r\n * Specify sprite sheet spacing options, useful if your sprites are not tightly packed\r\n * and have space between them.\r\n */\r\nexport interface SpriteSheetSpacingDimensions {\r\n  /**\r\n   * The starting point to offset and start slicing the sprite sheet from the top left of the image.\r\n   * Default is (0, 0)\r\n   */\r\n  originOffset?: { x?: number, y?: number };\r\n\r\n  /**\r\n   * The margin between sprites.\r\n   * Default is (0, 0)\r\n   */\r\n  margin?: {x?: number, y?: number};\r\n}\r\n\r\n/**\r\n * Sprite sheet options for slicing up images\r\n */\r\nexport interface SpriteSheetGridOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * Grid definition for the sprite sheet\r\n   */\r\n  grid: {\r\n    /**\r\n     * Number of rows in the sprite sheet\r\n     */\r\n    rows: number;\r\n    /**\r\n     * Number of columns in the sprite sheet\r\n     */\r\n    columns: number;\r\n    /**\r\n     * Width of each individual sprite\r\n     */\r\n    spriteWidth: number;\r\n    /**\r\n     * Height of each individual sprite\r\n     */\r\n    spriteHeight: number;\r\n  };\r\n  /**\r\n   * Optionally specifiy any spacing information between sprites\r\n   */\r\n  spacing?: SpriteSheetSpacingDimensions;\r\n}\r\n\r\nexport interface SpriteSheetOptions {\r\n  /**\r\n   * Source sprites for the sprite sheet\r\n   */\r\n  sprites: Sprite[];\r\n  /**\r\n   * Optionally specify the number of rows in a sprite sheet (default 1 row)\r\n   */\r\n  rows?: number;\r\n  /**\r\n   * Optionally specify the number of columns in a sprite sheet (default sprites.length)\r\n   */\r\n  columns?: number;\r\n}\r\n\r\n/**\r\n * Represents a collection of sprites from a source image with some organization in a grid\r\n */\r\nexport class SpriteSheet {\r\n  private _logger = Logger.getInstance();\r\n  public readonly sprites: Sprite[] = [];\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  /**\r\n   * Build a new sprite sheet from a list of sprites\r\n   *\r\n   * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   * @param options\r\n   */\r\n  constructor(options: SpriteSheetOptions) {\r\n    const { sprites, rows, columns } = options;\r\n    this.sprites = sprites;\r\n    this.rows = rows ?? 1;\r\n    this.columns = columns ?? this.sprites.length;\r\n  }\r\n\r\n  /**\r\n   * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public getSprite(x: number, y: number): Sprite | null {\r\n    if (x >= this.columns || x < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);\r\n      return null;\r\n    }\r\n    if (y >= this.rows || y < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);\r\n      return null;\r\n    }\r\n    const spriteIndex = x + y * this.columns;\r\n    return this.sprites[spriteIndex];\r\n  }\r\n\r\n  /**\r\n   * To a graphics sprite sheet from a legacy sprite sheet\r\n   */\r\n  public static fromLegacySpriteSheet(legacySpriteSheet: LegacySpriteSheet): SpriteSheet {\r\n    const sprites = legacySpriteSheet.sprites.map(oldSprite => Sprite.fromLegacySprite(oldSprite));\r\n    return new SpriteSheet({\r\n      sprites\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @deprecated\r\n   * @param spriteSheet\r\n   * @returns\r\n   */\r\n  public static toLegacySpriteSheet(spriteSheet: SpriteSheet): LegacySpriteSheet {\r\n    const sprites = spriteSheet.sprites.map(sprite => Sprite.toLegacySprite(sprite));\r\n    return new LegacySpriteSheet(sprites);\r\n  }\r\n\r\n  /**\r\n   * Create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   *\r\n   * Example:\r\n   * ```\r\n   * const spriteSheet = SpriteSheet.fromImageSource({\r\n   *   image: imageSource,\r\n   *   grid: {\r\n   *     rows: 5,\r\n   *     columns: 2,\r\n   *     spriteWidth: 32, // pixels\r\n   *     spriteHeight: 32 // pixels\r\n   *   },\r\n   *   // Optionally specify spacing\r\n   *   spacing: {\r\n   *     // pixels from the top left to start the sprite parsing\r\n   *     originOffset: {\r\n   *       x: 5,\r\n   *       y: 5\r\n   *     },\r\n   *     // pixels between each sprite while parsing\r\n   *     margin: {\r\n   *       x: 1,\r\n   *       y: 1\r\n   *     }\r\n   *   }\r\n   * })\r\n   * ```\r\n   *\r\n   * @param options\r\n   */\r\n  public static fromImageSource(options: SpriteSheetGridOptions): SpriteSheet {\r\n    const sprites: Sprite[] = [];\r\n    options.spacing = options.spacing ?? {};\r\n    const {\r\n      image,\r\n      grid: { rows, columns: cols, spriteWidth, spriteHeight },\r\n      spacing: { originOffset, margin }\r\n    } = options;\r\n    const offsetDefaults = { x: 0, y: 0, ...originOffset};\r\n    const marginDefaults = { x: 0, y: 0, ...margin};\r\n    for (let x = 0; x < cols; x++) {\r\n      for (let y = 0; y < rows; y++) {\r\n        sprites[x + y * cols] = new Sprite({\r\n          image: image,\r\n          sourceView: {\r\n            x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,\r\n            y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,\r\n            width: spriteWidth,\r\n            height: spriteHeight\r\n          },\r\n          destSize: { height: spriteHeight, width: spriteWidth }\r\n        });\r\n      }\r\n    }\r\n    return new SpriteSheet({\r\n      sprites: sprites,\r\n      rows: rows,\r\n      columns: cols\r\n    });\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\nimport { SpriteFont as LegacySpriteFont } from '../Drawing/Index';\nimport { Logger } from '../Util/Log';\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\nimport { FontRenderer } from './FontCommon';\nimport { Graphic, GraphicOptions } from './Graphic';\nimport { Sprite } from './Sprite';\nimport { SpriteSheet } from './SpriteSheet';\n\nexport interface SpriteFontOptions {\n  /**\n   * Alphabet string in spritsheet order (default is row column order)\n   * example: 'abcdefghijklmnopqrstuvwxyz'\n   */\n  alphabet: string;\n  /**\n   * [[SpriteSheet]] to source character sprites from\n   */\n  spriteSheet: SpriteSheet;\n  /**\n   * Optionally ignore case in the supplied text;\n   */\n  caseInsensitive?: boolean;\n  /**\n   * Optionally adjust the spacing between character sprites\n   */\n  spacing?: number;\n  /**\n   * Optionally specify a \"shadow\"\n   */\n  shadow?: { offset: Vector };\n}\n\nexport class SpriteFont extends Graphic implements FontRenderer {\n  private _text = '';\n  private _dirty = true;\n  public alphabet: string = '';\n  public spriteSheet: SpriteSheet;\n\n  public shadow: { offset: Vector } = null;\n  public caseInsensitive = false;\n  public spacing: number = 0;\n\n  private _logger = Logger.getInstance();\n\n  static fromLegacySpriteFont(spriteFont: LegacySpriteFont): SpriteFont {\n    const sprites = spriteFont.sprites.map(Sprite.fromLegacySprite);\n    return new SpriteFont({\n      alphabet: spriteFont.alphabet,\n      spacing: 0,\n      caseInsensitive: spriteFont.caseInsensitive,\n      spriteSheet: new SpriteSheet({\n        sprites\n      })\n    });\n  }\n\n  constructor(options: SpriteFontOptions & GraphicOptions) {\n    super(options);\n    const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;\n    this.alphabet = alphabet;\n    this.spriteSheet = spriteSheet;\n    this.caseInsensitive = caseInsensitive ?? this.caseInsensitive;\n    this.spacing = spacing ?? this.spacing;\n    this.shadow = shadow ?? this.shadow;\n\n    this.spriteSheet.sprites[0].image.ready.then(() => {\n      this._updateDimensions();\n    });\n  }\n\n  private _sprites: Sprite[] = [];\n  private _getCharacterSprites(text: string): Sprite[] {\n    if (!this._dirty) {\n      return this._sprites;\n    }\n\n    const results: Sprite[] = [];\n    // handle case insenstive\n    const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;\n    const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;\n\n    // for each letter in text\n    for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {\n      // find the sprite index in alphabet , if there is an error pick the first\n      const letter = textToRender[letterIndex];\n      let spriteIndex = alphabet.indexOf(letter);\n      if (spriteIndex === -1) {\n        spriteIndex = 0;\n        this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'`);\n      }\n\n      const letterSprite = this.spriteSheet.sprites[spriteIndex];\n      if (letterSprite) {\n        results.push(letterSprite);\n      } else {\n        this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);\n      }\n    }\n    this._dirty = false;\n    return (this._sprites = results);\n  }\n\n  private _updateDimensions() {\n    const sprites = this._getCharacterSprites(this._text);\n    let width = 0;\n    let height = 0;\n    for (const sprite of sprites) {\n      width += sprite.width + this.spacing;\n      height = Math.max(height, sprite.height);\n    }\n    this.width = width;\n    this.height = height;\n  }\n\n  public updateText(text: string) {\n    if (this._text !== text) {\n      this._dirty = true;\n      this._text = text;\n      this._updateDimensions();\n    }\n  }\n\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\n    this._updateDimensions();\n    super._preDraw(ex, x, y);\n  }\n\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\n    let cursor = 0;\n    for (const sprite of this._getCharacterSprites(this._text)) {\n      // draw it in the right spot and increase the cursor by sprite width\n      sprite.draw(ex, x + cursor, y);\n      cursor += sprite.width + this.spacing;\n    }\n  }\n\n  render(ex: ExcaliburGraphicsContext, text: string, x: number, y: number) {\n    if (this._text !== text) {\n      this._dirty = true;\n      this._text = text;\n    }\n\n    if (this.shadow) {\n      ex.save();\n      ex.translate(this.shadow.offset.x, this.shadow.offset.y);\n      this.draw(ex, x, y);\n      ex.restore();\n    }\n\n    this.draw(ex, x, y);\n  }\n\n  clone(): SpriteFont {\n    return new SpriteFont({\n      alphabet: this.alphabet,\n      spriteSheet: this.spriteSheet,\n      spacing: this.spacing\n    });\n  }\n}\n","export default \"data:image/png;base64,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\"","import { ExcaliburGraphicsContext, ImageSource, SpriteFont, SpriteSheet } from '..';\r\nimport { Vector } from '../..';\r\nimport debugFont from './debug-font.png';\r\n\r\n/**\r\n * Internal debugtext helper\r\n */\r\nexport class DebugText {\r\n  constructor() {\r\n    this.load();\r\n  }\r\n\r\n  /**\r\n   * base64 font\r\n   */\r\n  public readonly fontSheet = debugFont;\r\n  public size: number = 16;\r\n  private _imageSource: ImageSource;\r\n  private _spriteSheet: SpriteSheet;\r\n  private _spriteFont: SpriteFont;\r\n  public load() {\r\n    this._imageSource = new ImageSource(this.fontSheet);\r\n    return this._imageSource.load().then(() => {\r\n      this._spriteSheet = SpriteSheet.fromImageSource({\r\n        image: this._imageSource,\r\n        grid: {\r\n          rows: 3,\r\n          columns: 16,\r\n          spriteWidth: 16,\r\n          spriteHeight: 16\r\n        }\r\n      });\r\n      this._spriteFont = new SpriteFont({\r\n        alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\\'&.\"?-()+ ',\r\n        caseInsensitive: true,\r\n        spriteSheet: this._spriteSheet,\r\n        spacing: -6\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Writes debug text using the built in sprint font\r\n   * @param ctx\r\n   * @param text\r\n   * @param pos\r\n   */\r\n  public write(ctx: ExcaliburGraphicsContext, text: string, pos: Vector) {\r\n    if (this._imageSource.isLoaded()) {\r\n      this._spriteFont.render(ctx, text, pos.x, pos.y);\r\n    }\r\n  }\r\n}\r\n","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  RectGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\n\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { TransformStack } from './transform-stack';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { Logger } from '../../Util/Log';\r\nimport { LineRenderer } from './line-renderer';\r\nimport { ImageRenderer } from './image-renderer';\r\nimport { PointRenderer } from './point-renderer';\r\nimport { Canvas } from '../Canvas';\r\nimport { GraphicsDiagnostics } from '../GraphicsDiagnostics';\r\nimport { DebugText } from './debug-text';\r\nimport { ScreenDimension } from '../../Screen';\r\n\r\nclass ExcaliburGraphicsContextWebGLDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _webglCtx: ExcaliburGraphicsContextWebGL) {}\r\n\r\n  /**\r\n   * Draw a debugging rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number, rectOptions: RectGraphicsOptions = { color: Color.Black }): void {\r\n    this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging line to the context\r\n   * @param start\r\n   * @param end\r\n   * @param lineOptions\r\n   */\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._webglCtx.__lineRenderer.addLine(start, end, lineOptions.color);\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging point to the context\r\n   * @param point\r\n   * @param pointOptions\r\n   */\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._webglCtx.__pointRenderer.addPoint(point, pointOptions.color, pointOptions.size);\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._webglCtx, text, pos);\r\n  }\r\n}\r\n\r\nexport interface WebGLGraphicsContextInfo {\r\n  transform: TransformStack;\r\n  state: StateStack;\r\n  matrix: Matrix;\r\n}\r\n\r\nexport class ExcaliburGraphicsContextWebGL implements ExcaliburGraphicsContext {\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __gl: WebGLRenderingContext;\r\n\r\n  /**\r\n   * Holds the 2d context shim\r\n   */\r\n  private _canvas: Canvas; // Configure z for shim?\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __ctx: CanvasRenderingContext2D;\r\n\r\n  private _transform = new TransformStack();\r\n  private _state = new StateStack();\r\n  private _ortho!: Matrix;\r\n\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __pointRenderer: PointRenderer;\r\n\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __lineRenderer: LineRenderer;\r\n\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __imageRenderer: ImageRenderer;\r\n\r\n  public snapToPixel: boolean = true;\r\n\r\n  public smoothing: boolean = false;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public get width() {\r\n    return this.__gl.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__gl.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Checks the underlying webgl implementation if the requested internal resolution is supported\r\n   * @param dim\r\n   */\r\n  public checkIfResolutionSupported(dim: ScreenDimension): boolean {\r\n    // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo\r\n    const gl = this.__gl;\r\n    // If any dimension is greater than max texture size (divide by 4 bytes per pixel)\r\n    const maxDim = gl.getParameter(gl.MAX_TEXTURE_SIZE) / 4;\r\n    let supported = true;\r\n    if (dim.width > maxDim ||dim.height > maxDim) {\r\n      supported = false;\r\n    }\r\n    return supported;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor } = options;\r\n    this.__gl = canvasElement.getContext('webgl', {\r\n      antialias: smoothing ?? this.smoothing,\r\n      premultipliedAlpha: false,\r\n      alpha: enableTransparency ?? true,\r\n      depth: true,\r\n      powerPreference: 'high-performance'\r\n    });\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this._init();\r\n  }\r\n\r\n  private _init() {\r\n    const gl = this.__gl;\r\n    // Setup viewport and view matrix\r\n    this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n    // Clear background\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // Enable alpha blending\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n    this.__pointRenderer = new PointRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });\r\n    this.__lineRenderer = new LineRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });\r\n    this.__imageRenderer = new ImageRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });\r\n\r\n    // 2D ctx shim\r\n    this._canvas = new Canvas({\r\n      width: gl.canvas.width,\r\n      height: gl.canvas.height\r\n    });\r\n    this.__ctx = this._canvas.ctx;\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this._transform.current = Matrix.identity();\r\n  }\r\n\r\n  public updateViewport(): void {\r\n    const gl = this.__gl;\r\n    this._ortho = this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\r\n    this.__pointRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);\r\n    this.__lineRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);\r\n    this.__imageRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);\r\n\r\n    // 2D ctx shim\r\n    this._canvas.width = gl.canvas.width;\r\n    this._canvas.height = gl.canvas.height;\r\n  }\r\n\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    if (!image) {\r\n      Logger.getInstance().warn('Cannot draw a null or undefined image');\r\n      // tslint:disable-next-line: no-console\r\n      if (console.trace) {\r\n        // tslint:disable-next-line: no-console\r\n        console.trace();\r\n      }\r\n      return;\r\n    }\r\n    this.__imageRenderer.addImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.__imageRenderer.addLine(color, start, end, thickness);\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color) {\r\n    this.__imageRenderer.addRectangle(color, pos, width, height);\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color) {\r\n    this.__imageRenderer.addCircle(pos, radius, color);\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContextWebGLDebug(this);\r\n\r\n  public save(): void {\r\n    this._transform.save();\r\n    this._state.save();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._transform.restore();\r\n    this._state.restore();\r\n  }\r\n\r\n  public translate(x: number, y: number): void {\r\n    this._transform.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);\r\n  }\r\n\r\n  public rotate(angle: number): void {\r\n    this._transform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): void {\r\n    this._transform.scale(x, y);\r\n  }\r\n\r\n  public transform(matrix: Matrix) {\r\n    this._transform.current = matrix;\r\n  }\r\n\r\n  clear() {\r\n    const gl = this.__gl;\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    // Clear the context with the newly set color. This is\r\n    // the function call that actually does the drawing.\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    GraphicsDiagnostics.clear();\r\n  }\r\n\r\n  /**\r\n   * Flushes all batched rendering to the screen\r\n   */\r\n  flush() {\r\n    const gl = this.__gl;\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n    this.__imageRenderer.render();\r\n    this.__lineRenderer.render();\r\n    this.__pointRenderer.render();\r\n  }\r\n}\r\n","import { Vector, vec } from './Math/vector';\r\nimport { Logger } from './Util/Log';\r\nimport { Camera } from './Camera';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { BoundingBox } from './Collision/Index';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { getPosition } from './Util/Util';\r\nimport { ExcaliburGraphicsContextWebGL } from './Graphics/Context/ExcaliburGraphicsContextWebGL';\r\n\r\n/**\r\n * Enum representing the different display modes available to Excalibur.\r\n */\r\nexport enum DisplayMode {\r\n  /**\r\n   * Default, use a specified resolution for the game. Like 800x600 pixels for example.\r\n   */\r\n  Fixed = 'Fixed',\r\n\r\n  /**\r\n   * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.\r\n   * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.\r\n   *\r\n   * You may want to center your game here is an example\r\n   * ```html\r\n   * <!-- html -->\r\n   * <body>\r\n   * <main>\r\n   *   <canvas id=\"game\"></canvas>\r\n   * </main>\r\n   * </body>\r\n   * ```\r\n   *\r\n   * ```css\r\n   * // css\r\n   * main {\r\n   *   display: flex;\r\n   *   align-items: center;\r\n   *   justify-content: center;\r\n   *   height: 100%;\r\n   *   width: 100%;\r\n   * }\r\n   * ```\r\n   *\r\n   */\r\n  FitScreen = 'FitScreen',\r\n\r\n  /**\r\n   * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will\r\n   * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]\r\n   */\r\n  FillScreen = 'FillScreen',\r\n\r\n  /**\r\n   * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.\r\n   */\r\n  FitContainer = 'FitContainer',\r\n\r\n  /**\r\n   * Use the parent DOM container's css width/height for the game resolution dynamically\r\n   */\r\n  FillContainer = 'FillContainer',\r\n\r\n  /**\r\n   * Allow the game to be positioned with the [[EngineOptions.position]] option\r\n   * @deprecated Use CSS to position the game canvas, will be removed in v0.26.0\r\n   */\r\n  Position = 'Position'\r\n}\r\n\r\n/**\r\n * Convenience class for quick resolutions\r\n * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution\r\n */\r\nexport class Resolution {\r\n  /* istanbul ignore next */\r\n  public static get SVGA(): ScreenDimension {\r\n    return { width: 800, height: 600 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Standard(): ScreenDimension {\r\n    return { width: 1920, height: 1080 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Atari2600(): ScreenDimension {\r\n    return { width: 160, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoy(): ScreenDimension {\r\n    return { width: 160, height: 144 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoyAdvance(): ScreenDimension {\r\n    return { width: 240, height: 160 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NintendoDS(): ScreenDimension {\r\n    return { width: 256, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NES(): ScreenDimension {\r\n    return { width: 256, height: 224 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get SNES(): ScreenDimension {\r\n    return { width: 256, height: 244 };\r\n  }\r\n}\r\n\r\n/**\r\n * Interface describing the absolute CSS position of the game window. For use when [[DisplayMode.Position]]\r\n * is specified and when the user wants to define exact pixel spacing of the window.\r\n * When a number is given, the value is interpreted as pixels\r\n */\r\nexport interface AbsolutePosition {\r\n  top?: number | string;\r\n  left?: number | string;\r\n  right?: number | string;\r\n  bottom?: number | string;\r\n}\r\n\r\nexport type CanvasPosition = string | AbsolutePosition;\r\n\r\nexport interface ScreenDimension {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface ScreenOptions {\r\n  /**\r\n   * Canvas element to build a screen on\r\n   */\r\n  canvas: HTMLCanvasElement;\r\n  /**\r\n   * Graphics context for the screen\r\n   */\r\n  context: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Browser abstraction\r\n   */\r\n  browser: BrowserEvents;\r\n  /**\r\n   * Optionally set antialiasing, defaults to true. If set to true, images will be smoothed\r\n   */\r\n  antialiasing?: boolean;\r\n  /**\r\n   * Optionally override the pixel ratio to use for the screen, otherwise calculated automatically from the browser\r\n   */\r\n  pixelRatio?: number;\r\n  /**\r\n   * Optionally specify the actual pixel resolution in width/height pixels (also known as logical resolution), by default the\r\n   * resolution will be the same as the viewport. Resolution will be overridden by [[DisplayMode.FillContainer]] and\r\n   * [[DisplayMode.FillScreen]].\r\n   */\r\n  resolution?: ScreenDimension;\r\n  /**\r\n   * Visual viewport size in css pixel, if resolution is not specified it will be the same as the viewport\r\n   */\r\n  viewport: ScreenDimension;\r\n  /**\r\n   * Set the display mode of the screen, by default DisplayMode.Fixed.\r\n   */\r\n  displayMode?: DisplayMode;\r\n  /**\r\n   * Specify how the game window is to be positioned when the [[DisplayMode.Position]] is chosen. This option MUST be specified\r\n   * if the DisplayMode is set as [[DisplayMode.Position]]. The position can be either a string or an [[AbsolutePosition]].\r\n   * String must be in the format of css style background-position. The vertical position must precede the horizontal position in strings.\r\n   *\r\n   * Valid String examples: \"top left\", \"top\", \"bottom\", \"middle\", \"middle center\", \"bottom right\"\r\n   * Valid [[AbsolutePosition]] examples: `{top: 5, right: 10%}`, `{bottom: 49em, left: 10px}`, `{left: 10, bottom: 40}`\r\n   */\r\n  position?: CanvasPosition;\r\n}\r\n\r\n/**\r\n * The Screen handles all aspects of interacting with the screen for Excalibur.\r\n */\r\nexport class Screen {\r\n  private _canvas: HTMLCanvasElement;\r\n  private _ctx: ExcaliburGraphicsContext;\r\n  private _antialiasing: boolean = true;\r\n  private _browser: BrowserEvents;\r\n  private _camera: Camera;\r\n  private _resolution: ScreenDimension;\r\n  private _resolutionStack: ScreenDimension[] = [];\r\n  private _viewport: ScreenDimension;\r\n  private _viewportStack: ScreenDimension[] = [];\r\n  private _pixelRatioOverride: number | null = null;\r\n  private _position: CanvasPosition;\r\n  private _displayMode: DisplayMode;\r\n  private _isFullScreen = false;\r\n  private _mediaQueryList: MediaQueryList;\r\n  private _isDisposed = false;\r\n  private _logger = Logger.getInstance();\r\n  private _resizeObserver: ResizeObserver;\r\n\r\n  constructor(options: ScreenOptions) {\r\n    this.viewport = options.viewport;\r\n    this.resolution = options.resolution ?? { ...this.viewport };\r\n    this._displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    this._canvas = options.canvas;\r\n    this._ctx = options.context;\r\n    this._antialiasing = options.antialiasing ?? this._antialiasing;\r\n    this._browser = options.browser;\r\n    this._position = options.position;\r\n    this._pixelRatioOverride = options.pixelRatio;\r\n    this._applyDisplayMode();\r\n\r\n    this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\r\n    this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler);\r\n\r\n    this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    this.applyResolutionAndViewport();\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (!this._isDisposed) {\r\n      // Clean up handlers\r\n      this._isDisposed = true;\r\n      this._browser.window.off('resize', this._resizeHandler);\r\n      if (this._resizeObserver) {\r\n        this._resizeObserver.disconnect();\r\n      }\r\n      this.parent.removeEventListener('resize', this._resizeHandler);\r\n      this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);\r\n      this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    }\r\n  }\r\n\r\n  private _fullscreenChangeHandler = () => {\r\n    this._isFullScreen = !this._isFullScreen;\r\n    this._logger.debug('Fullscreen Change', this._isFullScreen);\r\n  };\r\n\r\n  private _pixelRatioChangeHandler = () => {\r\n    this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);\r\n    this._devicePixelRatio = this._calculateDevicePixelRatio();\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _resizeHandler = () => {\r\n    const parent = this.parent;\r\n    this._logger.debug('View port resized');\r\n    this._setResolutionAndViewportByDisplayMode(parent);\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _calculateDevicePixelRatio() {\r\n    if (window.devicePixelRatio < 1) {\r\n      return 1;\r\n    }\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n\r\n    return devicePixelRatio;\r\n  }\r\n\r\n  // Asking the window.devicePixelRatio is expensive we do it once\r\n  private _devicePixelRatio = this._calculateDevicePixelRatio();\r\n\r\n  public get pixelRatio(): number {\r\n    if (this._pixelRatioOverride) {\r\n      return this._pixelRatioOverride;\r\n    }\r\n\r\n    return this._devicePixelRatio;\r\n  }\r\n\r\n  public get isHiDpi() {\r\n    return this.pixelRatio !== 1;\r\n  }\r\n\r\n  public get displayMode(): DisplayMode {\r\n    return this._displayMode;\r\n  }\r\n\r\n  public get canvas(): HTMLCanvasElement {\r\n    return this._canvas;\r\n  }\r\n\r\n  public get parent(): HTMLElement | Window {\r\n    return <HTMLElement | Window>(\r\n      (this.displayMode === DisplayMode.FillContainer || this.displayMode === DisplayMode.FitContainer\r\n        ? this.canvas.parentElement || document.body\r\n        : window)\r\n    );\r\n  }\r\n\r\n  public get resolution(): ScreenDimension {\r\n    return this._resolution;\r\n  }\r\n\r\n  public set resolution(resolution: ScreenDimension) {\r\n    this._resolution = resolution;\r\n  }\r\n\r\n  public get viewport(): ScreenDimension {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n    return this._resolution;\r\n  }\r\n\r\n  public set viewport(viewport: ScreenDimension) {\r\n    this._viewport = viewport;\r\n  }\r\n\r\n  public get aspectRatio() {\r\n    return this._resolution.width / this._resolution.height;\r\n  }\r\n\r\n  public get scaledWidth() {\r\n    return this._resolution.width * this.pixelRatio;\r\n  }\r\n\r\n  public get scaledHeight() {\r\n    return this._resolution.height * this.pixelRatio;\r\n  }\r\n\r\n  public setCurrentCamera(camera: Camera) {\r\n    this._camera = camera;\r\n  }\r\n\r\n  public pushResolutionAndViewport() {\r\n    this._resolutionStack.push(this.resolution);\r\n    this._viewportStack.push(this.viewport);\r\n\r\n    this.resolution = { ...this.resolution };\r\n    this.viewport = { ...this.viewport };\r\n  }\r\n\r\n  public peekViewport(): ScreenDimension {\r\n    return this._viewportStack[this._viewportStack.length - 1];\r\n  }\r\n\r\n  public peekResolution(): ScreenDimension {\r\n    return this._resolutionStack[this._resolutionStack.length - 1];\r\n  }\r\n\r\n  public popResolutionAndViewport() {\r\n    this.resolution = this._resolutionStack.pop();\r\n    this.viewport = this._viewportStack.pop();\r\n  }\r\n\r\n  private _alreadyWarned = false;\r\n  public applyResolutionAndViewport() {\r\n    this._canvas.width = this.scaledWidth;\r\n    this._canvas.height = this.scaledHeight;\r\n\r\n    if (this._ctx instanceof ExcaliburGraphicsContextWebGL) {\r\n      const supported = this._ctx.checkIfResolutionSupported({\r\n        width: this.scaledWidth,\r\n        height: this.scaledHeight\r\n      });\r\n      if (!supported && !this._alreadyWarned) {\r\n        this._alreadyWarned = true; // warn once\r\n        this._logger.warn(\r\n          `The currently configured resolution (${this.resolution.width}x${this.resolution.height})` +\r\n          ' is too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +\r\n          ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +\r\n          ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');\r\n      }\r\n    }\r\n\r\n    if (this._antialiasing) {\r\n      this._canvas.style.imageRendering = 'auto';\r\n    } else {\r\n      this._canvas.style.imageRendering = 'pixelated';\r\n      // Fall back to 'crisp-edges' if 'pixelated' is not supported\r\n      // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\r\n      if (this._canvas.style.imageRendering === '') {\r\n        this._canvas.style.imageRendering = 'crisp-edges';\r\n      }\r\n    }\r\n    this._canvas.style.width = this.viewport.width + 'px';\r\n    this._canvas.style.height = this.viewport.height + 'px';\r\n\r\n    // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset\r\n    this._ctx.updateViewport();\r\n    this._ctx.resetTransform();\r\n    this._ctx.scale(this.pixelRatio, this.pixelRatio);\r\n    this._ctx.smoothing = this._antialiasing;\r\n  }\r\n\r\n  public get antialiasing() {\r\n    return this._antialiasing;\r\n  }\r\n\r\n  public set antialiasing(isSmooth: boolean) {\r\n    this._antialiasing = isSmooth;\r\n    this._ctx.smoothing = this._antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Returns true if excalibur is fullscreened using the browser fullscreen api\r\n   */\r\n  public get isFullScreen() {\r\n    return this._isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.\r\n   * For example, wire this to a user click handler.\r\n   */\r\n  public goFullScreen(): Promise<void> {\r\n    return this._canvas.requestFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Requests to exit fullscreen using the browser fullscreen api\r\n   */\r\n  public exitFullScreen(): Promise<void> {\r\n    return document.exitFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to\r\n   * Excalibur screen space.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public pageToScreenCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    if (!this._isFullScreen) {\r\n      newX -= getPosition(this._canvas).x;\r\n      newY -= getPosition(this._canvas).y;\r\n    }\r\n\r\n    // if fullscreen api on it centers with black bars\r\n    // we need to adjust the screen to world coordinates in this case\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;\r\n        newX = (newX / window.innerWidth) * this.viewport.width;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;\r\n        newY = (newY / window.innerHeight) * this.viewport.height;\r\n      }\r\n    }\r\n\r\n    newX = (newX / this.viewport.width) * this.resolution.width;\r\n    newY = (newY / this.viewport.height) * this.resolution.height;\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,\r\n   * this is where html elements might live if you want to position them relative to Excalibur.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public screenToPageCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    newX = (newX / this.resolution.width) * this.viewport.width;\r\n    newY = (newY / this.resolution.height) * this.viewport.height;\r\n\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = (newY / this.viewport.height) * screenHeight + screenMarginY;\r\n        newX = (newX / this.viewport.width) * window.innerWidth;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = (newX / this.viewport.width) * screenWidth + screenMarginX;\r\n        newY = (newY / this.viewport.height) * window.innerHeight;\r\n      }\r\n    }\r\n\r\n    if (!this._isFullScreen) {\r\n      newX += getPosition(this._canvas).x;\r\n      newY += getPosition(this._canvas).y;\r\n    }\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.\r\n   *\r\n   * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]\r\n   * and extends infinitely out relative from the [[Camera]].\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    // transform back to world space\r\n    newX = (newX / this.resolution.width) * this.drawWidth;\r\n    newY = (newY / this.resolution.height) * this.drawHeight;\r\n\r\n    // transform based on zoom\r\n    newX = newX - this.halfDrawWidth;\r\n    newY = newY - this.halfDrawHeight;\r\n\r\n    // shift by camera focus\r\n    newX += this._camera?.x ?? 0;\r\n    newY += this._camera?.y ?? 0;\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.\r\n   *\r\n   * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    let screenX = point.x;\r\n    let screenY = point.y;\r\n\r\n    // shift by camera focus\r\n    screenX -= this._camera?.x ?? 0;\r\n    screenY -= this._camera?.y ?? 0;\r\n\r\n    // transform back on zoom\r\n    screenX = screenX + this.halfDrawWidth;\r\n    screenY = screenY + this.halfDrawHeight;\r\n\r\n    // transform back to screen space\r\n    screenX = (screenX / this.drawWidth) * this.resolution.width;\r\n    screenY = (screenY / this.drawHeight) * this.resolution.height;\r\n\r\n    return new Vector(screenX, screenY);\r\n  }\r\n\r\n  public pageToWorldCoordinates(point: Vector): Vector {\r\n    const screen = this.pageToScreenCoordinates(point);\r\n    return this.screenToWorldCoordinates(screen);\r\n  }\r\n\r\n  public worldToPageCoordinates(point: Vector): Vector {\r\n    const screen = this.worldToScreenCoordinates(point);\r\n    return this.screenToPageCoordinates(screen);\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   *\r\n   * World bounds are in world coordinates, useful for culling objects offscreen\r\n   */\r\n  public getWorldBounds(): BoundingBox {\r\n    const left = this.screenToWorldCoordinates(Vector.Zero).x;\r\n    const top = this.screenToWorldCoordinates(Vector.Zero).y;\r\n    const right = left + this.drawWidth;\r\n    const bottom = top + this.drawHeight;\r\n\r\n    return new BoundingBox(left, top, right, bottom);\r\n  }\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.canvas.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.canvas.width / 2;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.canvas.height / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    if (this._camera) {\r\n      return this.resolution.width / this._camera.zoom;\r\n    }\r\n    return this.resolution.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.drawWidth / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    if (this._camera) {\r\n      return this.resolution.height / this._camera.zoom;\r\n    }\r\n    return this.resolution.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.drawHeight / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns screen center coordinates including zoom and device pixel ratio.\r\n   */\r\n  public get center(): Vector {\r\n    return vec(this.halfDrawWidth, this.halfDrawHeight);\r\n  }\r\n\r\n  private _computeFit() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (window.innerWidth / aspect < window.innerHeight) {\r\n      adjustedWidth = window.innerWidth;\r\n      adjustedHeight = window.innerWidth / aspect;\r\n    } else {\r\n      adjustedWidth = window.innerHeight * aspect;\r\n      adjustedHeight = window.innerHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n  }\r\n\r\n  private _computeFitContainer() {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    const parent = this.canvas.parentElement;\r\n    if (parent.clientWidth / aspect < parent.clientHeight) {\r\n      adjustedWidth = parent.clientWidth;\r\n      adjustedHeight = parent.clientWidth / aspect;\r\n    } else {\r\n      adjustedWidth = parent.clientHeight * aspect;\r\n      adjustedHeight = parent.clientHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n  }\r\n\r\n  private _applyDisplayMode() {\r\n    if (this.displayMode === DisplayMode.Position) {\r\n      this._initializeDisplayModePosition(this._position);\r\n    } else {\r\n      this._setResolutionAndViewportByDisplayMode(this.parent);\r\n\r\n      // watch resizing\r\n      if (this.parent instanceof Window) {\r\n        this._browser.window.on('resize', this._resizeHandler);\r\n      } else {\r\n        this._resizeObserver = new ResizeObserver(() => {\r\n          this._resizeHandler();\r\n        });\r\n        this._resizeObserver.observe(this.parent);\r\n      }\r\n      this.parent.addEventListener('resize', this._resizeHandler);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the resoultion and viewport based on the selected display mode.\r\n   */\r\n  private _setResolutionAndViewportByDisplayMode(parent: HTMLElement | Window) {\r\n    if (this.displayMode === DisplayMode.FillContainer) {\r\n      this.resolution = {\r\n        width: (<HTMLElement>parent).clientWidth,\r\n        height: (<HTMLElement>parent).clientHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FillScreen) {\r\n      document.body.style.margin = '0px';\r\n      document.body.style.overflow = 'hidden';\r\n      this.resolution = {\r\n        width: (<Window>parent).innerWidth,\r\n        height: (<Window>parent).innerHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreen) {\r\n      this._computeFit();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainer) {\r\n      this._computeFitContainer();\r\n    }\r\n  }\r\n\r\n  private _initializeDisplayModePosition(position: CanvasPosition) {\r\n    if (!position) {\r\n      throw new Error('DisplayMode of Position was selected but no position option was given');\r\n    } else {\r\n      this.canvas.style.display = 'block';\r\n      this.canvas.style.position = 'absolute';\r\n\r\n      if (typeof position === 'string') {\r\n        const specifiedPosition = position.split(' ');\r\n\r\n        switch (specifiedPosition[0]) {\r\n          case 'top':\r\n            this.canvas.style.top = '0px';\r\n            break;\r\n          case 'bottom':\r\n            this.canvas.style.bottom = '0px';\r\n            break;\r\n          case 'middle':\r\n            this.canvas.style.top = '50%';\r\n            const offsetY = -this.halfDrawHeight;\r\n            this.canvas.style.marginTop = offsetY.toString();\r\n            break;\r\n          default:\r\n            throw new Error('Invalid Position Given');\r\n        }\r\n\r\n        if (specifiedPosition[1]) {\r\n          switch (specifiedPosition[1]) {\r\n            case 'left':\r\n              this.canvas.style.left = '0px';\r\n              break;\r\n            case 'right':\r\n              this.canvas.style.right = '0px';\r\n              break;\r\n            case 'center':\r\n              this.canvas.style.left = '50%';\r\n              const offsetX = -this.halfDrawWidth;\r\n              this.canvas.style.marginLeft = offsetX.toString();\r\n              break;\r\n            default:\r\n              throw new Error('Invalid Position Given');\r\n          }\r\n        }\r\n      } else {\r\n        if (position.top) {\r\n          typeof position.top === 'number'\r\n            ? (this.canvas.style.top = position.top.toString() + 'px')\r\n            : (this.canvas.style.top = position.top);\r\n        }\r\n        if (position.right) {\r\n          typeof position.right === 'number'\r\n            ? (this.canvas.style.right = position.right.toString() + 'px')\r\n            : (this.canvas.style.right = position.right);\r\n        }\r\n        if (position.bottom) {\r\n          typeof position.bottom === 'number'\r\n            ? (this.canvas.style.bottom = position.bottom.toString() + 'px')\r\n            : (this.canvas.style.bottom = position.bottom);\r\n        }\r\n        if (position.left) {\r\n          typeof position.left === 'number'\r\n            ? (this.canvas.style.left = position.left.toString() + 'px')\r\n            : (this.canvas.style.left = position.left);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Internal class used to build instances of AudioContext\r\n */\r\n/* istanbul ignore next */\r\nexport class AudioContextFactory {\r\n  private static _INSTANCE: AudioContext = null;\r\n\r\n  public static create(): AudioContext {\r\n    if (!this._INSTANCE) {\r\n      if ((<any>window).AudioContext || (<any>window).webkitAudioContext) {\r\n        this._INSTANCE = new AudioContext();\r\n      }\r\n    }\r\n\r\n    return this._INSTANCE;\r\n  }\r\n}\r\n","import { AudioContextFactory } from '../Resources/Sound/AudioContext';\r\nimport { Logger } from './Log';\r\n\r\nexport interface LegacyWebAudioSource {\r\n  playbackState: string;\r\n  PLAYING_STATE: 'playing';\r\n  FINISHED_STATE: 'finished';\r\n}\r\n\r\n/**\r\n * Patch for detecting legacy web audio in browsers\r\n * @internal\r\n * @param source\r\n */\r\nfunction isLegacyWebAudioSource(source: any): source is LegacyWebAudioSource {\r\n  return !!source.playbackState;\r\n}\r\n\r\nexport class WebAudio {\r\n  private static _UNLOCKED: boolean = false;\r\n\r\n  /**\r\n   * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n   * right after a user interaction event.\r\n   * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n   */\r\n  static unlock(): Promise<boolean> {\r\n    const promise = new Promise<boolean>((resolve, reject) => {\r\n      if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {\r\n        return resolve(true);\r\n      }\r\n      const unlockTimeoutTimer = setTimeout(() => {\r\n        Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');\r\n        resolve(false);\r\n      }, 200);\r\n\r\n      const audioContext = AudioContextFactory.create();\r\n      audioContext.resume().then(\r\n        () => {\r\n          // create empty buffer and play it\r\n          const buffer = audioContext.createBuffer(1, 1, 22050);\r\n          const source = audioContext.createBufferSource();\r\n          let ended = false;\r\n\r\n          source.buffer = buffer;\r\n          source.connect(audioContext.destination);\r\n          source.onended = () => (ended = true);\r\n\r\n          source.start(0);\r\n\r\n          // by checking the play state after some time, we know if we're really unlocked\r\n          setTimeout(() => {\r\n            if (isLegacyWebAudioSource(source)) {\r\n              if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            } else {\r\n              if (audioContext.currentTime > 0 || ended) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            }\r\n          }, 0);\r\n\r\n          clearTimeout(unlockTimeoutTimer);\r\n          resolve(true);\r\n        },\r\n        () => {\r\n          reject();\r\n        }\r\n      );\r\n    });\r\n\r\n\r\n    return promise;\r\n  }\r\n\r\n  static isUnlocked() {\r\n    return this._UNLOCKED;\r\n  }\r\n}\r\n","import { Color } from '../Color';\nimport { Vector } from '../Math/vector';\n\n/**\n * A canvas linecap style. \"butt\" is the default flush style, \"round\" is a semi-circle cap with a radius half the width of\n * the line, and \"square\" is a rectangle that is an equal width and half height cap.\n */\nexport type LineCapStyle = 'butt' | 'round' | 'square';\n\n/* istanbul ignore next */\n/**\n * Draw a line on canvas context\n *\n * @param ctx The canvas context\n * @param color The color of the line\n * @param x1 The start x coordinate\n * @param y1 The start y coordinate\n * @param x2 The ending x coordinate\n * @param y2 The ending y coordinate\n * @param thickness The line thickness\n * @param cap The [[LineCapStyle]] (butt, round, or square)\n */\nexport function line(\n  ctx: CanvasRenderingContext2D,\n  color: Color = Color.Red,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  thickness: number = 1,\n  cap: LineCapStyle = 'butt'\n) {\n  ctx.beginPath();\n  ctx.lineWidth = thickness;\n  ctx.lineCap = cap;\n  ctx.strokeStyle = color.toString();\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.closePath();\n  ctx.stroke();\n}\n\n/* istanbul ignore next */\n/**\n * Draw the vector as a point onto the canvas.\n */\nexport function point(ctx: CanvasRenderingContext2D, color: Color = Color.Red, point: Vector): void {\n  ctx.beginPath();\n  ctx.strokeStyle = color.toString();\n  ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n  ctx.closePath();\n  ctx.stroke();\n}\n\n/**\n * Draw the vector as a line onto the canvas starting a origin point.\n */\n/* istanbul ignore next */\n/**\n *\n */\nexport function vector(ctx: CanvasRenderingContext2D, color: Color, origin: Vector, vector: Vector, scale: number = 1.0): void {\n  const c = color ? color.toString() : 'blue';\n  const v = vector.scale(scale);\n  ctx.beginPath();\n  ctx.strokeStyle = c;\n  ctx.moveTo(origin.x, origin.y);\n  ctx.lineTo(origin.x + v.x, origin.y + v.y);\n  ctx.closePath();\n  ctx.stroke();\n}\n\n/**\n * Represents border radius values\n */\nexport interface BorderRadius {\n  /**\n   * Top-left\n   */\n  tl: number;\n  /**\n   * Top-right\n   */\n  tr: number;\n  /**\n   * Bottom-right\n   */\n  br: number;\n  /**\n   * Bottom-left\n   */\n  bl: number;\n}\n\n/**\n * Draw a round rectangle on a canvas context\n *\n * @param ctx The canvas context\n * @param x The top-left x coordinate\n * @param y The top-left y coordinate\n * @param width The width of the rectangle\n * @param height The height of the rectangle\n * @param radius The border radius of the rectangle\n * @param stroke The [[Color]] to stroke rectangle with\n * @param fill The [[Color]] to fill rectangle with\n */\nexport function roundRect(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number | BorderRadius = 5,\n  stroke: Color = Color.White,\n  fill: Color = null\n) {\n  let br: BorderRadius;\n\n  if (typeof radius === 'number') {\n    br = { tl: radius, tr: radius, br: radius, bl: radius };\n  } else {\n    const defaultRadius: BorderRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\n\n    for (const prop in defaultRadius) {\n      if (defaultRadius.hasOwnProperty(prop)) {\n        const side = <keyof BorderRadius>prop;\n        br[side] = radius[side] || defaultRadius[side];\n      }\n    }\n  }\n\n  ctx.beginPath();\n  ctx.moveTo(x + br.tl, y);\n  ctx.lineTo(x + width - br.tr, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\n  ctx.lineTo(x + width, y + height - br.br);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\n  ctx.lineTo(x + br.bl, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\n  ctx.lineTo(x, y + br.tl);\n  ctx.quadraticCurveTo(x, y, x + br.tl, y);\n  ctx.closePath();\n\n  if (fill) {\n    ctx.fillStyle = fill.toString();\n    ctx.fill();\n  }\n\n  if (stroke) {\n    ctx.strokeStyle = stroke.toString();\n    ctx.stroke();\n  }\n}\n\n/**\n *\n */\nexport function circle(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  radius: number,\n  stroke: Color = Color.White,\n  fill: Color = null\n) {\n  ctx.beginPath();\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\n  ctx.closePath();\n\n  if (fill) {\n    ctx.fillStyle = fill.toString();\n    ctx.fill();\n  }\n\n  if (stroke) {\n    ctx.strokeStyle = stroke.toString();\n    ctx.stroke();\n  }\n}\n","import { GameEvent } from './Events';\r\nimport { EventDispatcher } from './EventDispatcher';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\n/**\r\n * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n * and extending abilities for vanilla Javascript projects\r\n */\r\nexport class Class implements Eventable {\r\n  /**\r\n   * Direct access to the game object event dispatcher.\r\n   */\r\n  public eventDispatcher: EventDispatcher;\r\n\r\n  constructor() {\r\n    this.eventDispatcher = new EventDispatcher(this);\r\n  }\r\n\r\n  /**\r\n   * Alias for `addEventListener`. You can listen for a variety of\r\n   * events off of the engine; see the events section below for a complete list.\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void) {\r\n    this.eventDispatcher.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Alias for `removeEventListener`. If only the eventName is specified\r\n   * it will remove all handlers registered for that specific event. If the eventName\r\n   * and the handler instance are specified only that handler will be removed.\r\n   *\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void) {\r\n    this.eventDispatcher.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Emits a new event\r\n   * @param eventName   Name of the event to emit\r\n   * @param eventObject Data associated with this event\r\n   */\r\n  public emit(eventName: string, eventObject: GameEvent<any>) {\r\n    this.eventDispatcher.emit(eventName, eventObject);\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void) {\r\n    this.eventDispatcher.once(eventName, handler);\r\n  }\r\n}\r\n","export default \"data:image/png;base64,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\"","import { Color } from './Color';\r\nimport { WebAudio } from './Util/WebAudio';\r\nimport { Engine } from './Engine';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Class } from './Class';\r\nimport * as DrawUtil from './Util/DrawUtil';\r\n\r\nimport logoImg from './Loader.logo.png';\r\nimport loaderCss from './Loader.css';\r\nimport { Canvas } from './Graphics/Canvas';\r\nimport { Vector } from './Math/vector';\r\nimport { clamp, delay } from './Util/Util';\r\n\r\n/**\r\n * Pre-loading assets\r\n *\r\n * The loader provides a mechanism to preload multiple resources at\r\n * one time. The loader must be passed to the engine in order to\r\n * trigger the loading progress bar.\r\n *\r\n * The [[Loader]] itself implements [[Loadable]] so you can load loaders.\r\n *\r\n * ## Example: Pre-loading resources for a game\r\n *\r\n * ```js\r\n * // create a loader\r\n * var loader = new ex.Loader();\r\n *\r\n * // create a resource dictionary (best practice is to keep a separate file)\r\n * var resources = {\r\n *   TextureGround: new ex.Texture(\"/images/textures/ground.png\"),\r\n *   SoundDeath: new ex.Sound(\"/sound/death.wav\", \"/sound/death.mp3\")\r\n * };\r\n *\r\n * // loop through dictionary and add to loader\r\n * for (var loadable in resources) {\r\n *   if (resources.hasOwnProperty(loadable)) {\r\n *     loader.addResource(resources[loadable]);\r\n *   }\r\n * }\r\n *\r\n * // start game\r\n * game.start(loader).then(function () {\r\n *   console.log(\"Game started!\");\r\n * });\r\n * ```\r\n *\r\n * ## Customize the Loader\r\n *\r\n * The loader can be customized to show different, text, logo, background color, and button.\r\n *\r\n * ```typescript\r\n * const loader = new ex.Loader([playerTexture]);\r\n *\r\n * // The loaders button text can simply modified using this\r\n * loader.playButtonText = 'Start the best game ever';\r\n *\r\n * // The logo can be changed by inserting a base64 image string here\r\n *\r\n * loader.logo = 'data:image/png;base64,iVBORw...';\r\n * loader.logoWidth = 15;\r\n * loader.logoHeight = 14;\r\n *\r\n * // The background color can be changed like so by supplying a valid CSS color string\r\n *\r\n * loader.backgroundColor = 'red'\r\n * loader.backgroundColor = '#176BAA'\r\n *\r\n * // To build a completely new button\r\n * loader.startButtonFactory = () => {\r\n *     let myButton = document.createElement('button');\r\n *     myButton.textContent = 'The best button';\r\n *     return myButton;\r\n * };\r\n *\r\n * engine.start(loader).then(() => {});\r\n * ```\r\n */\r\nexport class Loader extends Class implements Loadable<Loadable<any>[]> {\r\n  public canvas: Canvas = new Canvas({\r\n    smoothing: true,\r\n    draw: this.draw.bind(this)\r\n  });\r\n  private _resourceList: Loadable<any>[] = [];\r\n  private _index = 0;\r\n\r\n  private _playButtonShown: boolean = false;\r\n  private _resourceCount: number = 0;\r\n  private _numLoaded: number = 0;\r\n  private _progressCounts: { [key: string]: number } = {};\r\n  private _totalCounts: { [key: string]: number } = {};\r\n  private _engine: Engine;\r\n\r\n  // logo drawing stuff\r\n\r\n  // base64 string encoding of the excalibur logo (logo-white.png)\r\n  public logo = logoImg;\r\n  public logoWidth = 468;\r\n  public logoHeight = 118;\r\n  /**\r\n   * Positions the top left corner of the logo image\r\n   * If not set, the loader automatically positions the logo\r\n   */\r\n  public logoPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the play button.\r\n   * If not set, the loader automatically positions the play button\r\n   */\r\n  public playButtonPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the loading bar\r\n   * If not set, the loader automatically positions the loading bar\r\n   */\r\n  public loadingBarPosition: Vector | null;\r\n\r\n  /**\r\n   * Gets or sets the color of the loading bar, default is [[Color.White]]\r\n   */\r\n  public loadingBarColor: Color = Color.White;\r\n\r\n  /**\r\n   * Gets or sets the background color of the loader as a hex string\r\n   */\r\n  public backgroundColor: string = '#176BAA';\r\n\r\n  protected _imageElement: HTMLImageElement;\r\n  protected get _image() {\r\n    if (!this._imageElement) {\r\n      this._imageElement = new Image();\r\n      this._imageElement.src = this.logo;\r\n    }\r\n\r\n    return this._imageElement;\r\n  }\r\n\r\n  public suppressPlayButton: boolean = false;\r\n  public get playButtonRootElement(): HTMLElement | null {\r\n    return this._playButtonRootElement;\r\n  }\r\n  public get playButtonElement(): HTMLButtonElement | null {\r\n    return this._playButtonElement;\r\n  }\r\n  protected _playButtonRootElement: HTMLElement;\r\n  protected _playButtonElement: HTMLButtonElement;\r\n  protected _styleBlock: HTMLStyleElement;\r\n  /** Loads the css from Loader.css */\r\n  protected _playButtonStyles: string = loaderCss.toString();\r\n  protected get _playButton() {\r\n    const existingRoot = document.getElementById('excalibur-play-root');\r\n    if (existingRoot) {\r\n      this._playButtonRootElement = existingRoot;\r\n    }\r\n    if (!this._playButtonRootElement) {\r\n      this._playButtonRootElement = document.createElement('div');\r\n      this._playButtonRootElement.id = 'excalibur-play-root';\r\n      this._playButtonRootElement.style.position = 'absolute';\r\n      document.body.appendChild(this._playButtonRootElement);\r\n    }\r\n    if (!this._styleBlock) {\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._playButtonStyles;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n    if (!this._playButtonElement) {\r\n      this._playButtonElement = this.startButtonFactory();\r\n      this._playButtonRootElement.appendChild(this._playButtonElement);\r\n    }\r\n    return this._playButtonElement;\r\n  }\r\n\r\n  /**\r\n   * Get/set play button text\r\n   */\r\n  public playButtonText: string = 'Play game';\r\n\r\n  /**\r\n   * Return a html button element for excalibur to use as a play button\r\n   */\r\n  public startButtonFactory = () => {\r\n    let buttonElement: HTMLButtonElement = document.getElementById('excalibur-play') as HTMLButtonElement;\r\n    if (!buttonElement) {\r\n      buttonElement = document.createElement('button');\r\n    }\r\n\r\n    buttonElement.id = 'excalibur-play';\r\n    buttonElement.textContent = this.playButtonText;\r\n    buttonElement.style.display = 'none';\r\n    return buttonElement;\r\n  };\r\n\r\n  /**\r\n   * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n   */\r\n  constructor(loadables?: Loadable<any>[]) {\r\n    super();\r\n\r\n    if (loadables) {\r\n      this.addResources(loadables);\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    this._engine = engine;\r\n    this.canvas.width = this._engine.canvas.width;\r\n    this.canvas.height = this._engine.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Add a resource to the loader to load\r\n   * @param loadable  Resource to add\r\n   */\r\n  public addResource(loadable: Loadable<any>) {\r\n    const key = this._index++;\r\n    this._resourceList.push(loadable);\r\n    this._progressCounts[key] = 0;\r\n    this._totalCounts[key] = 1;\r\n    this._resourceCount++;\r\n  }\r\n\r\n  /**\r\n   * Add a list of resources to the loader to load\r\n   * @param loadables  The list of resources to load\r\n   */\r\n  public addResources(loadables: Loadable<any>[]) {\r\n    let i = 0;\r\n    const len = loadables.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this.addResource(loadables[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the loader has completely loaded all resources\r\n   */\r\n  public isLoaded() {\r\n    return this._numLoaded === this._resourceCount;\r\n  }\r\n\r\n  /**\r\n   * Shows the play button and returns a promise that resolves when clicked\r\n   */\r\n  public showPlayButton(): Promise<void> {\r\n    if (this.suppressPlayButton) {\r\n      this.hidePlayButton();\r\n      return Promise.resolve();\r\n    } else {\r\n      const resizeHandler = () => {\r\n        this._positionPlayButton();\r\n      };\r\n      if (this._engine?.browser) {\r\n        this._engine.browser.window.on('resize', resizeHandler);\r\n      }\r\n      this._playButtonShown = true;\r\n      this._playButton.style.display = 'block';\r\n      document.body.addEventListener('keyup', (evt: KeyboardEvent) => {\r\n        if (evt.key === 'Enter') {\r\n          this._playButton.click();\r\n        }\r\n      });\r\n      const promise = new Promise<void>((resolve) => {\r\n        const startButtonHandler = (e: Event) => {\r\n          // We want to stop propogation to keep bubbling to the engine pointer handlers\r\n          e.stopPropagation();\r\n          // Hide Button after click\r\n          this.hidePlayButton();\r\n          if (this._engine?.browser) {\r\n            this._engine.browser.window.off('resize', resizeHandler);\r\n          }\r\n          resolve();\r\n        };\r\n        this._playButton.addEventListener('click', startButtonHandler);\r\n        this._playButton.addEventListener('touchend', startButtonHandler);\r\n        this._playButton.addEventListener('pointerup', startButtonHandler);\r\n      });\r\n\r\n      return promise;\r\n    }\r\n  }\r\n\r\n  public hidePlayButton() {\r\n    this._playButtonShown = false;\r\n    this._playButton.style.display = 'none';\r\n  }\r\n\r\n  /**\r\n   * Clean up generated elements for the loader\r\n   */\r\n  public dispose() {\r\n    if (this._playButtonRootElement.parentElement) {\r\n      this._playButtonRootElement.removeChild(this._playButtonElement);\r\n      document.body.removeChild(this._playButtonRootElement);\r\n      document.head.removeChild(this._styleBlock);\r\n      this._playButtonRootElement = null;\r\n      this._playButtonElement = null;\r\n      this._styleBlock = null;\r\n    }\r\n  }\r\n\r\n  update(_engine: Engine, _delta: number): void {\r\n    // override me\r\n  }\r\n\r\n  data: Loadable<any>[];\r\n\r\n  /**\r\n   * Begin loading all of the supplied resources, returning a promise\r\n   * that resolves when loading of all is complete\r\n   */\r\n  public async load(): Promise<Loadable<any>[]> {\r\n    await Promise.all(\r\n      this._resourceList.map((r) =>\r\n        r.load().finally(() => {\r\n          // capture progress\r\n          this._numLoaded++;\r\n        })\r\n      )\r\n    );\r\n\r\n    // short delay in showing the button for aesthetics\r\n    await delay(200);\r\n    await this.showPlayButton();\r\n    // Unlock browser AudioContext in after user gesture\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/262\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/1031\r\n    await WebAudio.unlock();\r\n\r\n    return (this.data = this._resourceList);\r\n  }\r\n\r\n  public markResourceComplete(): void {\r\n    this._numLoaded++;\r\n  }\r\n\r\n  /**\r\n   * Returns the progess of the loader as a number between [0, 1] inclusive.\r\n   */\r\n  public get progress(): number {\r\n    return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;\r\n  }\r\n\r\n  private _positionPlayButton() {\r\n    const screenHeight = this._engine.screen.viewport.height;\r\n    const screenWidth = this._engine.screen.viewport.width;\r\n    if (this._playButtonRootElement) {\r\n      const left = this._engine.canvas.offsetLeft;\r\n      const top = this._engine.canvas.offsetTop;\r\n      const buttonWidth = this._playButton.clientWidth;\r\n      const buttonHeight = this._playButton.clientHeight;\r\n      if (this.playButtonPosition) {\r\n        this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;\r\n        this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;\r\n      } else {\r\n        this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;\r\n        this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loader draw function. Draws the default Excalibur loading screen.\r\n   * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n   * to customize the drawing, or just override entire method.\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D) {\r\n    const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;\r\n    const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;\r\n\r\n    this._positionPlayButton();\r\n\r\n    ctx.fillStyle = this.backgroundColor;\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    let logoY = canvasHeight / 2;\r\n    const width = Math.min(this.logoWidth, canvasWidth * 0.75);\r\n    let logoX = canvasWidth / 2 - width / 2;\r\n\r\n    if (this.logoPosition) {\r\n      logoX = this.logoPosition.x;\r\n      logoY = this.logoPosition.y;\r\n    }\r\n\r\n    const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\r\n    const oldAntialias = this._engine.getAntialiasing();\r\n    this._engine.setAntialiasing(true);\r\n    if (!this.logoPosition) {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);\r\n    } else {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);\r\n    }\r\n\r\n    // loading box\r\n    if (!this.suppressPlayButton && this._playButtonShown) {\r\n      this._engine.setAntialiasing(oldAntialias);\r\n      return;\r\n    }\r\n\r\n    let loadingX = logoX;\r\n    let loadingY = logoY;\r\n    if (this.loadingBarPosition) {\r\n      loadingX = this.loadingBarPosition.x;\r\n      loadingY = this.loadingBarPosition.y;\r\n    }\r\n\r\n    ctx.lineWidth = 2;\r\n    DrawUtil.roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);\r\n    const progress = width * this.progress;\r\n    const margin = 5;\r\n    const progressWidth = progress - margin * 2;\r\n    const height = 20 - margin * 2;\r\n    DrawUtil.roundRect(\r\n      ctx,\r\n      loadingX + margin,\r\n      loadingY + margin,\r\n      progressWidth > 10 ? progressWidth : 10,\r\n      height,\r\n      5,\r\n      null,\r\n      this.loadingBarColor\r\n    );\r\n    this._engine.setAntialiasing(oldAntialias);\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n/**\r\n * This is the list of features that will be used to log the supported\r\n * features to the console when Detector.logBrowserFeatures() is called.\r\n */\r\n\r\nconst REPORTED_FEATURES: { [key: string]: string } = {\r\n  webgl: 'WebGL',\r\n  webaudio: 'WebAudio',\r\n  gamepadapi: 'Gamepad API'\r\n};\r\n\r\n/**\r\n * Interface for detected browser features matrix\r\n */\r\nexport interface DetectedFeatures {\r\n  readonly canvas: boolean;\r\n  readonly arraybuffer: boolean;\r\n  readonly dataurl: boolean;\r\n  readonly objecturl: boolean;\r\n  readonly rgba: boolean;\r\n  readonly webaudio: boolean;\r\n  readonly webgl: boolean;\r\n  readonly gamepadapi: boolean;\r\n}\r\n\r\ninterface CriticalTests {\r\n  canvasSupport(): boolean;\r\n  arrayBufferSupport(): boolean;\r\n  dataUrlSupport(): boolean;\r\n  objectUrlSupport(): boolean;\r\n  rgbaSupport(): boolean;\r\n}\r\n\r\ninterface WarningTests {\r\n  webAudioSupport(): boolean;\r\n  webglSupport(): boolean;\r\n}\r\n\r\n/**\r\n * Excalibur internal feature detection helper class\r\n */\r\nexport class Detector {\r\n  private _features: DetectedFeatures = null;\r\n\r\n  public failedTests: string[] = [];\r\n\r\n  public constructor() {\r\n    this._features = this._loadBrowserFeatures();\r\n  }\r\n\r\n  /**\r\n   * Returns a map of currently supported browser features. This method\r\n   * treats the features as a singleton and will only calculate feature\r\n   * support if it has not previously been done.\r\n   */\r\n  public getBrowserFeatures(): DetectedFeatures {\r\n    if (this._features === null) {\r\n      this._features = this._loadBrowserFeatures();\r\n    }\r\n    return this._features;\r\n  }\r\n\r\n  /**\r\n   * Report on non-critical browser support for debugging purposes.\r\n   * Use native browser console colors for visibility.\r\n   */\r\n  public logBrowserFeatures(): void {\r\n    let msg = '%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n';\r\n    const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];\r\n\r\n    const supported: any = this.getBrowserFeatures();\r\n    for (const feature of Object.keys(REPORTED_FEATURES)) {\r\n      if (supported[feature]) {\r\n        msg += '(%c\\u2713%c)'; // (✓)\r\n        args.push('font-weight: bold; color: green');\r\n        args.push('font-weight: normal; color: inherit');\r\n      } else {\r\n        msg += '(%c\\u2717%c)'; // (✗)\r\n        args.push('font-weight: bold; color: red');\r\n        args.push('font-weight: normal; color: inherit');\r\n      }\r\n\r\n      msg += ' ' + REPORTED_FEATURES[feature] + '\\n';\r\n    }\r\n\r\n    args.unshift(msg);\r\n    // eslint-disable-next-line no-console\r\n    console.log.apply(console, args);\r\n  }\r\n\r\n  /**\r\n   * Executes several IIFE's to get a constant reference to supported\r\n   * features within the current execution context.\r\n   */\r\n  private _loadBrowserFeatures(): DetectedFeatures {\r\n    return {\r\n      // IIFE to check canvas support\r\n      canvas: (() => {\r\n        return this._criticalTests.canvasSupport();\r\n      })(),\r\n\r\n      // IIFE to check arraybuffer support\r\n      arraybuffer: (() => {\r\n        return this._criticalTests.arrayBufferSupport();\r\n      })(),\r\n\r\n      // IIFE to check dataurl support\r\n      dataurl: (() => {\r\n        return this._criticalTests.dataUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check objecturl support\r\n      objecturl: (() => {\r\n        return this._criticalTests.objectUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check rgba support\r\n      rgba: (() => {\r\n        return this._criticalTests.rgbaSupport();\r\n      })(),\r\n\r\n      // IIFE to check webaudio support\r\n      webaudio: (() => {\r\n        return this._warningTest.webAudioSupport();\r\n      })(),\r\n\r\n      // IIFE to check webgl support\r\n      webgl: (() => {\r\n        return this._warningTest.webglSupport();\r\n      })(),\r\n\r\n      // IIFE to check gamepadapi support\r\n      gamepadapi: (() => {\r\n        return !!(<any>navigator).getGamepads;\r\n      })()\r\n    };\r\n  }\r\n\r\n  // critical browser features required for ex to run\r\n  private _criticalTests: CriticalTests = {\r\n    // Test canvas/2d context support\r\n    canvasSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('2d'));\r\n    },\r\n\r\n    // Test array buffer support ex uses for downloading binary data\r\n    arrayBufferSupport: function() {\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('GET', '/');\r\n      try {\r\n        xhr.responseType = 'arraybuffer';\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n      return xhr.responseType === 'arraybuffer';\r\n    },\r\n\r\n    // Test data urls ex uses for sprites\r\n    dataUrlSupport: function() {\r\n      const canvas = document.createElement('canvas');\r\n      return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;\r\n    },\r\n\r\n    // Test object url support for loading\r\n    objectUrlSupport: function() {\r\n      return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;\r\n    },\r\n\r\n    // RGBA support for colors\r\n    rgbaSupport: function() {\r\n      const style = document.createElement('a').style;\r\n      style.cssText = 'background-color:rgba(150,255,150,.5)';\r\n      return ('' + style.backgroundColor).indexOf('rgba') > -1;\r\n    }\r\n  };\r\n\r\n  // warnings excalibur performance will be degraded\r\n  private _warningTest: WarningTests = {\r\n    webAudioSupport: function() {\r\n      return !!(\r\n        (<any>window).AudioContext ||\r\n        (<any>window).webkitAudioContext ||\r\n        (<any>window).mozAudioContext ||\r\n        (<any>window).msAudioContext ||\r\n        (<any>window).oAudioContext\r\n      );\r\n    },\r\n    webglSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('webgl'));\r\n    }\r\n  };\r\n\r\n  public test(): boolean {\r\n    // Critical test will for ex not to run\r\n    let failedCritical = false;\r\n    for (const test in this._criticalTests) {\r\n      if (!this._criticalTests[<keyof CriticalTests>test].call(this)) {\r\n        this.failedTests.push(test);\r\n        Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);\r\n        failedCritical = true;\r\n      }\r\n    }\r\n    if (failedCritical) {\r\n      return false;\r\n    }\r\n\r\n    // Warning tests do not for ex to return false to compatibility\r\n    for (const warning in this._warningTest) {\r\n      if (!this._warningTest[<keyof WarningTests>warning]()) {\r\n        Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the types of collisions bodies can participate in\r\n */\r\nexport enum CollisionType {\r\n  /**\r\n   * Bodies with the `PreventCollision` setting do not participate in any\r\n   * collisions and do not raise collision events.\r\n   */\r\n  PreventCollision = 'PreventCollision',\r\n  /**\r\n   * Bodies with the `Passive` setting only raise collision events, but are not\r\n   * influenced or moved by other bodies and do not influence or move other bodies.\r\n   * This is useful for use in trigger type behavior.\r\n   */\r\n  Passive = 'Passive',\r\n  /**\r\n   * Bodies with the `Active` setting raise collision events and participate\r\n   * in collisions with other bodies and will be push or moved by bodies sharing\r\n   * the `Active` or `Fixed` setting.\r\n   */\r\n  Active = 'Active',\r\n  /**\r\n   * Bodies with the `Fixed` setting raise collision events and participate in\r\n   * collisions with other bodies. Actors with the `Fixed` setting will not be\r\n   * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed\r\n   * bodies as \"immovable/unstoppable\" objects. If two `Fixed` bodies meet they will\r\n   * not be pushed or moved by each other, they will not interact except to throw\r\n   * collision events.\r\n   */\r\n  Fixed = 'Fixed'\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n\r\n/**\r\n * Possible collision resolution strategies\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things\r\n * like platformers or top down games.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */\r\nexport enum CollisionResolutionStrategy {\r\n  Arcade = 'arcade',\r\n  Realistic = 'realistic'\r\n}\r\n\r\n/**\r\n * Possible broadphase collision pair identification strategies\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */\r\nexport enum BroadphaseStrategy {\r\n  DynamicAABBTree\r\n}\r\n\r\n/**\r\n * Possible numerical integrators for position and velocity\r\n */\r\nexport enum Integrator {\r\n  Euler\r\n}\r\n\r\n/**\r\n * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n */\r\n/* istanbul ignore next */\r\nexport class Physics {\r\n  /**\r\n   * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.\r\n   * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.\r\n   *\r\n   * This is a great way to globally simulate effects like gravity.\r\n   */\r\n  public static acc = new Vector(0, 0);\r\n  public static get gravity() {\r\n    return Physics.acc;\r\n  }\r\n  public static set gravity(v: Vector) {\r\n    Physics.acc = v;\r\n  }\r\n\r\n  /**\r\n   * Globally switches all Excalibur physics behavior on or off.\r\n   */\r\n  public static enabled = true;\r\n\r\n  /**\r\n   * Gets or sets the broadphase pair identification strategy.\r\n   *\r\n   * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n   * potential collision pairs which is O(nlog(n)) faster.\r\n   */\r\n  public static broadphaseStrategy: BroadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\r\n\r\n  /**\r\n   * Gets or sets the global collision resolution strategy (narrowphase).\r\n   *\r\n   * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.\r\n   *\r\n   * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static collisionResolutionStrategy: CollisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  /**\r\n   * The default mass to use if none is specified\r\n   */\r\n  public static defaultMass: number = 10;\r\n  /**\r\n   * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n   */\r\n  public static integrator: Integrator = Integrator.Euler;\r\n\r\n  /**\r\n   * Configures Excalibur to use \"arcade\" physics. Arcade physics which performs simple axis aligned arcade style physics.\r\n   */\r\n  public static useArcadePhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  }\r\n\r\n  /**\r\n   * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static useRealisticPhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;\r\n  }\r\n\r\n  /**\r\n   * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);\r\n   */\r\n  public static dynamicTreeVelocityMultiplier = 2;\r\n\r\n  @obsolete({\r\n    message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',\r\n    alternateMethod: 'dynamicTreeVelocityMultiplier'\r\n  })\r\n  public static get dynamicTreeVelocityMultiplyer() {\r\n    return Physics.dynamicTreeVelocityMultiplier;\r\n  }\r\n\r\n  public static set dynamicTreeVelocityMultiplyer(value: number) {\r\n    Physics.dynamicTreeVelocityMultiplier = value;\r\n  }\r\n\r\n  /**\r\n   * Pad RigidBody BoundingBox by a constant amount\r\n   */\r\n  public static boundsPadding = 5;\r\n\r\n  /**\r\n   * Number of position iterations (overlap) to run in the solver\r\n   */\r\n  public static positionIterations = 3;\r\n\r\n  /**\r\n   * Number of velocity iteration (response) to run in the solver\r\n   */\r\n  public static velocityIterations = 8;\r\n\r\n  /**\r\n   * Amount of overlap to tolerate in pixels\r\n   */\r\n  public static slop = 1;\r\n\r\n  /**\r\n   * Amount of positional overlap correction to apply each position iteration of the solver\r\n   * O - meaning no correction, 1 - meaning correct all overlap\r\n   */\r\n  public static steeringFactor = 0.2;\r\n\r\n  /**\r\n   * Warm start set to true re-uses impulses from previous frames back in the solver\r\n   */\r\n  public static warmStart = true;\r\n\r\n  /**\r\n   * By default bodies do not sleep\r\n   */\r\n  public static bodiesCanSleepByDefault = false;\r\n\r\n  /**\r\n   * Surface epsilon is used to help deal with surface penetration\r\n   */\r\n  public static surfaceEpsilon = 0.1;\r\n\r\n  public static sleepEpsilon = 0.07;\r\n\r\n  public static wakeThreshold = Physics.sleepEpsilon * 3;\r\n\r\n  public static sleepBias = 0.9;\r\n\r\n  /**\r\n   * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n   * bodies from tunneling through one another.\r\n   */\r\n  public static checkForFastBodies = true;\r\n\r\n  /**\r\n   * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n   * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n   * Excalibur will always perform the fast body raycast regardless of speed.\r\n   */\r\n  public static disableMinimumSpeedForFastBody = false;\r\n}\r\n","import { Vector } from './vector';\r\n\r\nexport interface VectorViewOptions {\r\n  getX: () => number;\r\n  getY: () => number;\r\n  setX: (x: number) => void;\r\n  setY: (y: number) => void;\r\n}\r\nexport class VectorView extends Vector {\r\n  private _getX: () => number;\r\n  private _getY: () => number;\r\n  private _setX: (x: number) => void;\r\n  private _setY: (y: number) => void;\r\n  constructor(options: VectorViewOptions) {\r\n    super(0, 0);\r\n    this._getX = options.getX;\r\n    this._getY = options.getY;\r\n    this._setX = options.setX;\r\n    this._setY = options.setY;\r\n  }\r\n  public get x() {\r\n    return (this._x = this._getX());\r\n  }\r\n\r\n  public set x(val) {\r\n    this._setX(val);\r\n    this._x = val;\r\n  }\r\n\r\n  public get y() {\r\n    return (this._y = this._getY());\r\n  }\r\n  public set y(val) {\r\n    this._setY(val);\r\n    this._y = val;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\n\r\n/**\r\n * Component Contructor Types\r\n */\r\nexport declare type ComponentCtor<T extends Component = Component> = new (...args:any[]) => T;\r\n\r\n/**\r\n * Type guard to check if a component implements clone\r\n * @param x\r\n */\r\nfunction hasClone(x: any): x is { clone(): any } {\r\n  return !!x?.clone;\r\n}\r\n\r\nexport type ComponentType<ComponentToParse> = ComponentToParse extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * Plucks the string type out of a component type\r\n */\r\nexport type ComponentStringType<T> = T extends Component<infer R> ? R : string;\r\n\r\n/**\r\n * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity posesses\r\n *\r\n * Implementations of Component must have a zero-arg constructor to support dependecies\r\n *\r\n * ```typescript\r\n * class MyComponent extends ex.Component<'my'> {\r\n *   public readonly type = 'my';\r\n *   // zero arg support required if you want to use component dependencies\r\n *   constructor(public optionalPos?: ex.Vector) {}\r\n * }\r\n * ```\r\n */\r\nexport abstract class Component<TypeName extends string = string> {\r\n  /**\r\n   * Optionally list any component types this component depends on\r\n   * If the owner entity does not have these components, new components will be added to the entity\r\n   *\r\n   * Only components with zero-arg constructors are supported as automatic component dependencies\r\n   */\r\n  readonly dependencies?: ComponentCtor[];\r\n\r\n  // todo implement optional\r\n  readonly optional?: ComponentCtor[];\r\n\r\n  /**\r\n   * Type of this component, must be a unique type among component types in you game.\r\n   */\r\n  abstract readonly type: TypeName;\r\n\r\n  /**\r\n   * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]\r\n   */\r\n  owner?: Entity = null;\r\n\r\n  /**\r\n   * Clones any properties on this component, if that property value has a `clone()` method it will be called\r\n   */\r\n  clone(): this {\r\n    const newComponent = new (this.constructor as any)();\r\n    for (const prop in this) {\r\n      if (this.hasOwnProperty(prop)) {\r\n        const val = this[prop];\r\n        if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {\r\n          newComponent[prop] = val.clone();\r\n        } else {\r\n          newComponent[prop] = val;\r\n        }\r\n      }\r\n    }\r\n    return newComponent;\r\n  }\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onAdd?(owner: Entity): void;\r\n\r\n  /**\r\n   * Opitonal callback called when acomponent is added to an entity\r\n   */\r\n  onRemove?(previousOwner: Entity): void;\r\n}\r\n\r\n/**\r\n * Tag components are a way of tagging a component with label and a simple value\r\n *\r\n * For example:\r\n *\r\n * ```typescript\r\n * const isOffscreen = new TagComponent('offscreen');\r\n * entity.addComponent(isOffscreen);\r\n * entity.tags.includes\r\n * ```\r\n */\r\nexport class TagComponent<TypeName extends string, MaybeValueType extends string | symbol | number | boolean = never> extends Component<\r\nTypeName\r\n> {\r\n  constructor(public readonly type: TypeName, public readonly value?: MaybeValueType) {\r\n    super();\r\n  }\r\n}\r\n","import { Matrix, MatrixLocations } from '../../Math/matrix';\r\nimport { VectorView } from '../../Math/vector-view';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Component } from '../Component';\r\n\r\nexport interface Transform {\r\n  /**\r\n   * The [[CoordPlane|coordinate plane]] for this transform for the entity.\r\n   */\r\n  coordPlane: CoordPlane;\r\n\r\n  /**\r\n   * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].\r\n   *\r\n   * If the entity has a parent this position is relative to the parent entity.\r\n   */\r\n  pos: Vector;\r\n\r\n  /**\r\n   * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n   * For example z=99 would be drawn on top of z=0.\r\n   */\r\n  z: number;\r\n\r\n  /**\r\n   * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.\r\n   *\r\n   * If the entity has a parent this rotation is relative to the parent.\r\n   */\r\n  rotation: number;\r\n\r\n  /**\r\n   * The scale of the entity. If the entity has a parent this scale is relative to the parent.\r\n   */\r\n  scale: Vector;\r\n}\r\n\r\nconst createPosView = (matrix: Matrix) => {\r\n  const source = matrix;\r\n  return new VectorView({\r\n    setX: (x) => {\r\n      source.data[MatrixLocations.X] = x;\r\n    },\r\n    setY: (y) => {\r\n      source.data[MatrixLocations.Y] = y;\r\n    },\r\n    getX: () => {\r\n      return source.data[MatrixLocations.X];\r\n    },\r\n    getY: () => {\r\n      return source.data[MatrixLocations.Y];\r\n    }\r\n  });\r\n};\r\n\r\nconst createScaleView = (matrix: Matrix) => {\r\n  const source = matrix;\r\n  return new VectorView({\r\n    setX: (x) => {\r\n      source.setScaleX(x);\r\n    },\r\n    setY: (y) => {\r\n      source.setScaleY(y);\r\n    },\r\n    getX: () => {\r\n      return source.getScaleX();\r\n    },\r\n    getY: () => {\r\n      return source.getScaleY();\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]\r\n */\r\nexport enum CoordPlane {\r\n  /**\r\n   * The world coordinate plane (default) represents world space, any entities drawn with world\r\n   * space move when the camera moves.\r\n   */\r\n  World = 'world',\r\n  /**\r\n   * The screen coordinate plane represents screen space, entities drawn in screen space are pinned\r\n   * to screen coordinates ignoring the camera.\r\n   */\r\n  Screen = 'screen'\r\n}\r\n\r\nexport class TransformComponent extends Component<'ex.transform'> implements Transform {\r\n  public readonly type = 'ex.transform';\r\n\r\n  private _dirty = false;\r\n\r\n  public readonly matrix = Matrix.identity().translate(0, 0).rotate(0).scale(1, 1);\r\n  private _position = createPosView(this.matrix);\r\n  private _rotation = 0;\r\n  private _scale = createScaleView(this.matrix);\r\n\r\n  private _recalculate() {\r\n    this._rotation = this.matrix.getRotation();\r\n    this._dirty = false;\r\n  }\r\n\r\n  public getGlobalMatrix(): Matrix {\r\n    if (!this.parent) {\r\n      return this.matrix;\r\n    } else {\r\n      return this.parent.getGlobalMatrix().multm(this.matrix);\r\n    }\r\n  }\r\n\r\n  public getGlobalTransform(): Transform {\r\n    return {\r\n      pos: this.globalPos,\r\n      scale: this.globalScale,\r\n      rotation: this.globalRotation,\r\n      z: this.z,\r\n      coordPlane: this.coordPlane\r\n    };\r\n  }\r\n\r\n  public get parent(): TransformComponent | null {\r\n    return this?.owner?.parent?.get(TransformComponent);\r\n  }\r\n\r\n  /**\r\n   * The [[CoordPlane|coordinate plane|]] for this transform for the entity.\r\n   */\r\n  public coordPlane = CoordPlane.World;\r\n\r\n  /**\r\n   * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].\r\n   *\r\n   * If a parent entity exists coordinates are local to the parent.\r\n   */\r\n  public get pos(): Vector {\r\n    if (this._dirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._position;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this.matrix.setPosition(val.x, val.y);\r\n    this._dirty = true;\r\n  }\r\n\r\n  // Dirty flag check up the chain\r\n  public get dirty(): boolean {\r\n    if (this?.owner?.parent) {\r\n      const parent = this.parent;\r\n      return parent.dirty || this._dirty;\r\n    }\r\n    return this._dirty;\r\n  }\r\n\r\n  /**\r\n   * The current world position calculated\r\n   */\r\n  public get globalPos(): Vector {\r\n    const source = this.getGlobalMatrix();\r\n    return new VectorView({\r\n      getX: () => source.data[MatrixLocations.X],\r\n      getY: () => source.data[MatrixLocations.Y],\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const [newX] = this.parent?.getGlobalMatrix().getAffineInverse().multv([x, source.data[MatrixLocations.Y]]);\r\n          this.matrix.data[MatrixLocations.X] = newX;\r\n        } else {\r\n          this.matrix.data[MatrixLocations.X] = x;\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const [, newY] = this.parent?.getGlobalMatrix().getAffineInverse().multv([source.data[MatrixLocations.X], y]);\r\n          this.matrix.data[MatrixLocations.Y] = newY;\r\n        } else {\r\n          this.matrix.data[MatrixLocations.Y] = y;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public set globalPos(val: Vector) {\r\n    const parentTransform = this.parent;\r\n    if (!parentTransform) {\r\n      this.pos = val;\r\n    } else {\r\n      this.pos = parentTransform.getGlobalMatrix().getAffineInverse().multv(val);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n   * For example z=99 would be drawn on top of z=0.\r\n   */\r\n  public z: number = 0;\r\n\r\n  /**\r\n   * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.\r\n   */\r\n  public get rotation(): number {\r\n    if (this._dirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._rotation;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    this.matrix.setRotation(val);\r\n    this._dirty = true;\r\n  }\r\n\r\n  public get globalRotation(): number {\r\n    return this.getGlobalMatrix().getRotation();\r\n  }\r\n\r\n  public set globalRotation(val: number) {\r\n    const parentTransform = this.parent;\r\n    if (!parentTransform) {\r\n      this.rotation = val;\r\n    } else {\r\n      this.rotation = val - parentTransform.globalRotation;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The scale of the entity.\r\n   */\r\n  public get scale(): Vector {\r\n    if (this._dirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._scale;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    this.matrix.setScale(val);\r\n    this._dirty = true;\r\n  }\r\n\r\n  public get globalScale(): Vector {\r\n    const source = this.getGlobalMatrix();\r\n    return new VectorView({\r\n      getX: () => source.getScaleX(),\r\n      getY: () => source.getScaleY(),\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const globalScaleX = this.parent.globalScale.x;\r\n          this.matrix.setScaleX(x / globalScaleX);\r\n        } else {\r\n          this.matrix.setScaleX(x);\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const globalScaleY = this.parent.globalScale.y;\r\n          this.matrix.setScaleY(y / globalScaleY);\r\n        } else {\r\n          this.matrix.setScaleY(y);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public set globalScale(val: Vector) {\r\n    const parentTransform = this.parent;\r\n    if (!parentTransform) {\r\n      this.scale = val;\r\n    } else {\r\n      this.scale = vec(val.x / parentTransform.globalScale.x, val.y / parentTransform.globalScale.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply the transform to a point\r\n   * @param point\r\n   */\r\n  public apply(point: Vector): Vector {\r\n    return this.matrix.multv(point);\r\n  }\r\n\r\n  /**\r\n   * Apply the inverse transform to a point\r\n   * @param point\r\n   */\r\n  public applyInverse(point: Vector): Vector {\r\n    return this.matrix.getAffineInverse().multv(point);\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\nimport { Component } from '../Component';\n\nexport interface Motion {\n  /**\n   * The velocity of an entity in pixels per second\n   */\n  vel: Vector;\n\n  /**\n   * The acceleration of entity in pixels per second^2\n   */\n  acc: Vector;\n\n  /**\n   * The scale rate of change in scale units per second\n   */\n  scaleFactor: Vector;\n\n  /**\n   * The angular velocity which is how quickly the entity is rotating in radians per second\n   */\n  angularVelocity: number;\n\n  /**\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\n   */\n  torque: number;\n\n  /**\n   * Inerita can be thought of as the resistance to motion\n   */\n  inertia: number;\n}\n\nexport class MotionComponent extends Component<'ex.motion'> {\n  public readonly type = 'ex.motion';\n\n  /**\n   * The velocity of an entity in pixels per second\n   */\n  public vel: Vector = Vector.Zero;\n\n  /**\n   * The acceleration of entity in pixels per second^2\n   */\n  public acc: Vector = Vector.Zero;\n\n  /**\n   * The scale rate of change in scale units per second\n   */\n  public scaleFactor: Vector = Vector.Zero;\n\n  /**\n   * The angular velocity which is how quickly the entity is rotating in radians per second\n   */\n  public angularVelocity = 0;\n\n  /**\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\n   */\n  public torque: number = 0;\n\n  /**\n   * Inerita can be thought of as the resistance to motion\n   */\n  public inertia: number = 1;\n}\n","/**\r\n * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s\r\n *\r\n * For example:\r\n *\r\n * Players have collision group \"player\"\r\n *\r\n * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)\r\n *\r\n * Enemies have collision group \"enemy\"\r\n *\r\n * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)\r\n *\r\n * Blocks have collision group \"ground\"\r\n *\r\n * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)\r\n *\r\n * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide\r\n * with players and blocks.\r\n *\r\n * This is done with bitmasking, see the following pseudo-code\r\n *\r\n * PlayerGroup = `0b001`\r\n * PlayerGroupMask = `0b110`\r\n *\r\n * EnemyGroup = `0b010`\r\n * EnemyGroupMask = `0b101`\r\n *\r\n * BlockGroup = `0b100`\r\n * BlockGroupMask = `0b011`\r\n *\r\n * Should Players collide? No because the bitwise mask evaluates to 0\r\n * `(player1.group & player2.mask) === 0`\r\n * `(0b001 & 0b110) === 0`\r\n *\r\n * Should Players and Enemies collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & enemy1.mask) === 1`\r\n * `(0b001 & 0b101) === 1`\r\n *\r\n * Should Players and Blocks collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & blocks1.mask) === 1`\r\n * `(0b001 & 0b011) === 1`\r\n */\r\nexport class CollisionGroup {\r\n  /**\r\n   * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,\r\n   * it is the default collision group on colliders.\r\n   */\r\n  public static All = new CollisionGroup('Collide with all groups', -1, -1);\r\n\r\n  private _name: string;\r\n  private _category: number;\r\n  private _mask: number;\r\n\r\n  /**\r\n   * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups\r\n   *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.\r\n   * @param name Name of the collision group\r\n   * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`\r\n   * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`\r\n   */\r\n  constructor(name: string, category: number, mask: number) {\r\n    this._name = name;\r\n    this._category = category;\r\n    this._mask = mask;\r\n  }\r\n\r\n  /**\r\n   * Get the name of the collision group\r\n   */\r\n  public get name() {\r\n    return this._name;\r\n  }\r\n\r\n  /**\r\n   * Get the category of the collision group, a 32 bit number which should be a unique power of 2\r\n   */\r\n  public get category() {\r\n    return this._category;\r\n  }\r\n\r\n  /**\r\n   * Get the mask for this collision group\r\n   */\r\n  public get mask() {\r\n    return this._mask;\r\n  }\r\n\r\n  /**\r\n   * Evaluates whether 2 collision groups can collide\r\n   * @param other  CollisionGroup\r\n   */\r\n  public canCollide(other: CollisionGroup): boolean {\r\n    return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Inverts the collision group. For example, if before the group specified \"players\",\r\n   * inverting would specify all groups except players\r\n   * @returns CollisionGroup\r\n   */\r\n  public invert(): CollisionGroup {\r\n    return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);\r\n  }\r\n\r\n  /**\r\n   * Combine collision groups with each other. The new group includes all of the previous groups.\r\n   *\r\n   * @param collisionGroups\r\n   * @returns\r\n   */\r\n  public static combine(collisionGroups: CollisionGroup[]) {\r\n    const combinedName = collisionGroups.map((c) => c.name).join('+');\r\n    const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);\r\n    const combinedMask = ~combinedCategory;\r\n\r\n    return new CollisionGroup(combinedName, combinedCategory, combinedMask);\r\n  }\r\n\r\n  /**\r\n   * Creates a collision group that collides with the listed groups\r\n   * @param collisionGroups\r\n   */\r\n  public static collidesWith(collisionGroups: CollisionGroup[]) {\r\n    return CollisionGroup.combine(collisionGroups).invert();\r\n  }\r\n}\r\n","/**\r\n * Defines a generic message that can contain any data\r\n * @template T is the typescript Type of the data\r\n */\r\nexport interface Message<T> {\r\n  type: string;\r\n  data: T;\r\n}\r\n\r\n/**\r\n * Defines an interface for an observer to receive a message via a notify() method\r\n */\r\nexport interface Observer<T> {\r\n  notify(message: T): void;\r\n}\r\n\r\n/**\r\n * Defines an interface for something that might be an observer if a notify() is present\r\n */\r\nexport type MaybeObserver<T> = Partial<Observer<T>>;\r\n\r\n/**\r\n * Simple Observable implemenation\r\n * @template T is the typescript Type that defines the data being observed\r\n */\r\nexport class Observable<T> {\r\n  public observers: Observer<T>[] = [];\r\n  public subscriptions: ((val: T) => any)[] = [];\r\n\r\n  /**\r\n   * Register an observer to listen to this observable\r\n   * @param observer\r\n   */\r\n  register(observer: Observer<T>) {\r\n    this.observers.push(observer);\r\n  }\r\n\r\n  /**\r\n   * Register a callback to listen to this observable\r\n   * @param func\r\n   */\r\n  subscribe(func: (val: T) => any) {\r\n    this.subscriptions.push(func);\r\n  }\r\n\r\n  /**\r\n   * Remove an observer from the observable\r\n   * @param observer\r\n   */\r\n  unregister(observer: Observer<T>) {\r\n    const i = this.observers.indexOf(observer);\r\n    if (i !== -1) {\r\n      this.observers.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback that is listening to this observable\r\n   * @param func\r\n   */\r\n  unsubscribe(func: (val: T) => any) {\r\n    const i = this.subscriptions.indexOf(func);\r\n    if (i !== -1) {\r\n      this.subscriptions.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcasts a message to all observers and callbacks\r\n   * @param message\r\n   */\r\n  notifyAll(message: T) {\r\n    this.observers.forEach((o) => o.notify(message));\r\n    this.subscriptions.forEach(cb => cb(message));\r\n  }\r\n\r\n  /**\r\n   * Removes all observers and callbacks\r\n   */\r\n  clear() {\r\n    this.observers.length = 0;\r\n    this.subscriptions.length = 0;\r\n  }\r\n}\r\n","import { CollisionContact } from './CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Id } from '../../Id';\r\nimport { Collider } from '../Colliders/Collider';\r\n\r\n/**\r\n * Models a potential collision between 2 colliders\r\n */\r\nexport class Pair {\r\n  public id: string = null;\r\n  constructor(public colliderA: Collider, public colliderB: Collider) {\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n  }\r\n\r\n  public static canCollide(colliderA: Collider, colliderB: Collider) {\r\n    const bodyA = colliderA?.owner?.get(BodyComponent);\r\n    const bodyB = colliderB?.owner?.get(BodyComponent);\r\n\r\n    // Body's needed for collision in the current state\r\n    // TODO can we collide without a body?\r\n    if (!bodyA || !bodyB) {\r\n      return false;\r\n    }\r\n\r\n    // If both are in the same collision group short circuit\r\n    if (!bodyA.group.canCollide(bodyB.group)) {\r\n      return false;\r\n    }\r\n\r\n    // if both are fixed short circuit\r\n    if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {\r\n      return false;\r\n    }\r\n\r\n    // if the either is prevent collision short circuit\r\n    if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {\r\n      return false;\r\n    }\r\n\r\n    // if either is dead short circuit\r\n    if (!bodyA.active || !bodyB.active) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not it is possible for the pairs to collide\r\n   */\r\n  public get canCollide(): boolean {\r\n    const colliderA = this.colliderA;\r\n    const colliderB = this.colliderB;\r\n    return Pair.canCollide(colliderA, colliderB);\r\n  }\r\n\r\n  /**\r\n   * Runs the collision intersection logic on the members of this pair\r\n   */\r\n  public collide(): CollisionContact[] {\r\n    return this.colliderA.collide(this.colliderB);\r\n  }\r\n\r\n  /**\r\n   * Check if the collider is part of the pair\r\n   * @param collider\r\n   * @returns\r\n   */\r\n  public hasCollider(collider: Collider) {\r\n    return collider === this.colliderA || collider === this.colliderB;\r\n  }\r\n\r\n  /**\r\n   * Calculates the unique pair hash id for this collision pair (owning id)\r\n   */\r\n  public static calculatePairHash(idA: Id<'collider'>, idB: Id<'collider'>): string {\r\n    if (idA.value < idB.value) {\r\n      return `#${idA.value}+${idB.value}`;\r\n    } else {\r\n      return `#${idB.value}+${idA.value}`;\r\n    }\r\n  }\r\n}\r\n","/**\n * A 1 dimensional projection on an axis, used to test overlaps\n */\n\nexport class Projection {\n  constructor(public min: number, public max: number) {}\n  public overlaps(projection: Projection): boolean {\n    return this.max > projection.min && projection.max > this.min;\n  }\n\n  public getOverlap(projection: Projection): number {\n    if (this.overlaps(projection)) {\n      if (this.max > projection.max) {\n        return projection.max - this.min;\n      } else {\n        return this.max - projection.min;\n      }\n    }\n    return 0;\n  }\n}\n","import { Physics } from '../Physics';\r\nimport { BoundingBox } from '../BoundingBox';\r\n\r\nimport { Ray } from '../../Math/ray';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Id } from '../../Id';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Color, ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Dynamic Tree Node used for tracking bounds within the tree\r\n */\r\nexport class TreeNode<T> {\r\n  public left: TreeNode<T>;\r\n  public right: TreeNode<T>;\r\n  public bounds: BoundingBox;\r\n  public height: number;\r\n  public data: T;\r\n  constructor(public parent?: TreeNode<T>) {\r\n    this.parent = parent || null;\r\n    this.data = null;\r\n    this.bounds = new BoundingBox();\r\n    this.left = null;\r\n    this.right = null;\r\n    this.height = 0;\r\n  }\r\n\r\n  public isLeaf(): boolean {\r\n    return !this.left && !this.right;\r\n  }\r\n}\r\n\r\nexport interface ColliderProxy<T> {\r\n  id: Id<'collider'>;\r\n  owner: T;\r\n  bounds: BoundingBox;\r\n}\r\n\r\n/**\r\n * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for\r\n * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n *\r\n * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n */\r\nexport class DynamicTree<T extends ColliderProxy<Entity>> {\r\n  public root: TreeNode<T>;\r\n  public nodes: { [key: number]: TreeNode<T> };\r\n  constructor(public worldBounds: BoundingBox = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {\r\n    this.root = null;\r\n    this.nodes = {};\r\n  }\r\n\r\n  /**\r\n   * Inserts a node into the dynamic tree\r\n   */\r\n  private _insert(leaf: TreeNode<T>): void {\r\n    // If there are no nodes in the tree, make this the root leaf\r\n    if (this.root === null) {\r\n      this.root = leaf;\r\n      this.root.parent = null;\r\n      return;\r\n    }\r\n\r\n    // Search the tree for a node that is not a leaf and find the best place to insert\r\n    const leafAABB = leaf.bounds;\r\n    let currentRoot = this.root;\r\n    while (!currentRoot.isLeaf()) {\r\n      const left = currentRoot.left;\r\n      const right = currentRoot.right;\r\n\r\n      const area = currentRoot.bounds.getPerimeter();\r\n      const combinedAABB = currentRoot.bounds.combine(leafAABB);\r\n      const combinedArea = combinedAABB.getPerimeter();\r\n\r\n      // Calculate cost heuristic for creating a new parent and leaf\r\n      const cost = 2 * combinedArea;\r\n\r\n      // Minimum cost of pushing the leaf down the tree\r\n      const inheritanceCost = 2 * (combinedArea - area);\r\n\r\n      // Cost of descending\r\n      let leftCost = 0;\r\n      const leftCombined = leafAABB.combine(left.bounds);\r\n      let newArea;\r\n      let oldArea;\r\n      if (left.isLeaf()) {\r\n        leftCost = leftCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = left.bounds.getPerimeter();\r\n        newArea = leftCombined.getPerimeter();\r\n        leftCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      let rightCost = 0;\r\n      const rightCombined = leafAABB.combine(right.bounds);\r\n      if (right.isLeaf()) {\r\n        rightCost = rightCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = right.bounds.getPerimeter();\r\n        newArea = rightCombined.getPerimeter();\r\n        rightCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      // cost is acceptable\r\n      if (cost < leftCost && cost < rightCost) {\r\n        break;\r\n      }\r\n\r\n      // Descend to the depths\r\n      if (leftCost < rightCost) {\r\n        currentRoot = left;\r\n      } else {\r\n        currentRoot = right;\r\n      }\r\n    }\r\n\r\n    // Create the new parent node and insert into the tree\r\n    const oldParent = currentRoot.parent;\r\n    const newParent = new TreeNode(oldParent);\r\n    newParent.bounds = leafAABB.combine(currentRoot.bounds);\r\n    newParent.height = currentRoot.height + 1;\r\n\r\n    if (oldParent !== null) {\r\n      // The sibling node was not the root\r\n      if (oldParent.left === currentRoot) {\r\n        oldParent.left = newParent;\r\n      } else {\r\n        oldParent.right = newParent;\r\n      }\r\n\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n    } else {\r\n      // The sibling node was the root\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n      this.root = newParent;\r\n    }\r\n\r\n    // Walk up the tree fixing heights and AABBs\r\n    let currentNode = leaf.parent;\r\n    while (currentNode) {\r\n      currentNode = this._balance(currentNode);\r\n\r\n      if (!currentNode.left) {\r\n        throw new Error('Parent of current leaf cannot have a null left child' + currentNode);\r\n      }\r\n      if (!currentNode.right) {\r\n        throw new Error('Parent of current leaf cannot have a null right child' + currentNode);\r\n      }\r\n\r\n      currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n      currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n\r\n      currentNode = currentNode.parent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a node from the dynamic tree\r\n   */\r\n  private _remove(leaf: TreeNode<T>) {\r\n    if (leaf === this.root) {\r\n      this.root = null;\r\n      return;\r\n    }\r\n\r\n    const parent = leaf.parent;\r\n    const grandParent = parent.parent;\r\n    let sibling: TreeNode<T>;\r\n    if (parent.left === leaf) {\r\n      sibling = parent.right;\r\n    } else {\r\n      sibling = parent.left;\r\n    }\r\n\r\n    if (grandParent) {\r\n      if (grandParent.left === parent) {\r\n        grandParent.left = sibling;\r\n      } else {\r\n        grandParent.right = sibling;\r\n      }\r\n      sibling.parent = grandParent;\r\n\r\n      let currentNode = grandParent;\r\n      while (currentNode) {\r\n        currentNode = this._balance(currentNode);\r\n        currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n        currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n\r\n        currentNode = currentNode.parent;\r\n      }\r\n    } else {\r\n      this.root = sibling;\r\n      sibling.parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tracks a body in the dynamic tree\r\n   */\r\n  public trackCollider(collider: T) {\r\n    const node = new TreeNode<T>();\r\n    node.data = collider;\r\n    node.bounds = collider.bounds;\r\n    node.bounds.left -= 2;\r\n    node.bounds.top -= 2;\r\n    node.bounds.right += 2;\r\n    node.bounds.bottom += 2;\r\n    this.nodes[collider.id.value] = node;\r\n    this._insert(node);\r\n  }\r\n\r\n  /**\r\n   * Updates the dynamic tree given the current bounds of each body being tracked\r\n   */\r\n  public updateCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return false;\r\n    }\r\n    const b = collider.bounds;\r\n\r\n    // if the body is outside the world no longer update it\r\n    if (!this.worldBounds.contains(b)) {\r\n      Logger.getInstance().warn(\r\n        'Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics'\r\n      );\r\n      this.untrackCollider(collider);\r\n      return false;\r\n    }\r\n\r\n    if (node.bounds.contains(b)) {\r\n      return false;\r\n    }\r\n\r\n    this._remove(node);\r\n    b.left -= Physics.boundsPadding;\r\n    b.top -= Physics.boundsPadding;\r\n    b.right += Physics.boundsPadding;\r\n    b.bottom += Physics.boundsPadding;\r\n\r\n    // THIS IS CAUSING UNECESSARY CHECKS\r\n    if (collider.owner) {\r\n      const body = collider.owner?.get(BodyComponent);\r\n      if (body) {\r\n        const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n        const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n\r\n        if (multdx < 0) {\r\n          b.left += multdx;\r\n        } else {\r\n          b.right += multdx;\r\n        }\r\n\r\n        if (multdy < 0) {\r\n          b.top += multdy;\r\n        } else {\r\n          b.bottom += multdy;\r\n        }\r\n      }\r\n    }\r\n\r\n    node.bounds = b;\r\n    this._insert(node);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Untracks a body from the dynamic tree\r\n   */\r\n  public untrackCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return;\r\n    }\r\n    this._remove(node);\r\n    this.nodes[collider.id.value] = null;\r\n    delete this.nodes[collider.id.value];\r\n  }\r\n\r\n  /**\r\n   * Balances the tree about a node\r\n   */\r\n  private _balance(node: TreeNode<T>) {\r\n    if (node === null) {\r\n      throw new Error('Cannot balance at null node');\r\n    }\r\n\r\n    if (node.isLeaf() || node.height < 2) {\r\n      return node;\r\n    }\r\n\r\n    const left = node.left;\r\n    const right = node.right;\r\n\r\n    const a = node;\r\n    const b = left;\r\n    const c = right;\r\n    const d = left.left;\r\n    const e = left.right;\r\n    const f = right.left;\r\n    const g = right.right;\r\n\r\n    const balance = c.height - b.height;\r\n    // Rotate c node up\r\n    if (balance > 1) {\r\n      // Swap the right node with it's parent\r\n      c.left = a;\r\n      c.parent = a.parent;\r\n      a.parent = c;\r\n\r\n      // The original node's old parent should point to the right node\r\n      // this is mega confusing\r\n      if (c.parent) {\r\n        if (c.parent.left === a) {\r\n          c.parent.left = c;\r\n        } else {\r\n          c.parent.right = c;\r\n        }\r\n      } else {\r\n        this.root = c;\r\n      }\r\n\r\n      // Rotate\r\n      if (f.height > g.height) {\r\n        c.right = f;\r\n        a.right = g;\r\n        g.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(g.bounds);\r\n        c.bounds = a.bounds.combine(f.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, g.height);\r\n        c.height = 1 + Math.max(a.height, f.height);\r\n      } else {\r\n        c.right = g;\r\n        a.right = f;\r\n        f.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(f.bounds);\r\n        c.bounds = a.bounds.combine(g.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, f.height);\r\n        c.height = 1 + Math.max(a.height, g.height);\r\n      }\r\n\r\n      return c;\r\n    }\r\n    // Rotate left node up\r\n    if (balance < -1) {\r\n      // swap\r\n      b.left = a;\r\n      b.parent = a.parent;\r\n      a.parent = b;\r\n\r\n      // node's old parent should point to b\r\n      if (b.parent) {\r\n        if (b.parent.left === a) {\r\n          b.parent.left = b;\r\n        } else {\r\n          if (b.parent.right !== a) {\r\n            throw 'Error rotating Dynamic Tree';\r\n          }\r\n          b.parent.right = b;\r\n        }\r\n      } else {\r\n        this.root = b;\r\n      }\r\n\r\n      // rotate\r\n      if (d.height > e.height) {\r\n        b.right = d;\r\n        a.left = e;\r\n        e.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(e.bounds);\r\n        b.bounds = a.bounds.combine(d.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, e.height);\r\n        b.height = 1 + Math.max(a.height, d.height);\r\n      } else {\r\n        b.right = e;\r\n        a.left = d;\r\n        d.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(d.bounds);\r\n        b.bounds = a.bounds.combine(e.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, d.height);\r\n        b.height = 1 + Math.max(a.height, e.height);\r\n      }\r\n      return b;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n   */\r\n  public getHeight(): number {\r\n    if (this.root === null) {\r\n      return 0;\r\n    }\r\n    return this.root.height;\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n   *\r\n   * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n   * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n   * the tree until all possible colliders have been returned.\r\n   */\r\n  public query(collider: T, callback: (other: T) => boolean): void {\r\n    const bounds = collider.bounds;\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.intersect(bounds)) {\r\n        if (currentNode.isLeaf() && currentNode.data !== collider) {\r\n          if (callback.call(collider, currentNode.data)) {\r\n            return true;\r\n          }\r\n        } else {\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n   * long ray to test the tree specified by `max`.\r\n   *\r\n   * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this\r\n   * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n   * the tree until all possible bodies that would intersect with the ray have been returned.\r\n   */\r\n  public rayCastQuery(ray: Ray, max: number = Infinity, callback: (other: T) => boolean): void {\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.rayCast(ray, max)) {\r\n        if (currentNode.isLeaf()) {\r\n          if (callback.call(ray, currentNode.data)) {\r\n            // ray hit a leaf! return the body\r\n            return true;\r\n          }\r\n        } else {\r\n          // ray hit but not at a leaf, recurse deeper\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false; // ray missed\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  public getNodes(): TreeNode<T>[] {\r\n    const helper = (currentNode: TreeNode<T>): TreeNode<T>[] => {\r\n      if (currentNode) {\r\n        return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    return helper(this.root);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    // draw all the nodes in the Dynamic Tree\r\n    const helper = (currentNode: TreeNode<T>) => {\r\n      if (currentNode) {\r\n        if (currentNode.isLeaf()) {\r\n          currentNode.bounds.draw(ex, Color.Green);\r\n        } else {\r\n          currentNode.bounds.draw(ex, Color.White);\r\n        }\r\n\r\n        if (currentNode.left) {\r\n          helper(currentNode.left);\r\n        }\r\n        if (currentNode.right) {\r\n          helper(currentNode.right);\r\n        }\r\n      }\r\n    };\r\n\r\n    helper(this.root);\r\n  }\r\n}\r\n","import { Line } from './line';\nimport { Vector } from './vector';\n\n/**\n * A 2D ray that can be cast into the scene to do collision detection\n */\n\nexport class Ray {\n  public pos: Vector;\n  public dir: Vector;\n\n  /**\n   * @param pos The starting position for the ray\n   * @param dir The vector indicating the direction of the ray\n   */\n  constructor(pos: Vector, dir: Vector) {\n    this.pos = pos;\n    this.dir = dir.normalize();\n  }\n\n  /**\n   * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\n   * This number indicates the mathematical intersection time.\n   * @param line  The line to test\n   */\n  public intersect(line: Line): number {\n    const numerator = line.begin.sub(this.pos);\n\n    // Test is line and ray are parallel and non intersecting\n    if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {\n      return -1;\n    }\n\n    // Lines are parallel\n    const divisor = this.dir.cross(line.getSlope());\n    if (divisor === 0) {\n      return -1;\n    }\n\n    const t = numerator.cross(line.getSlope()) / divisor;\n\n    if (t >= 0) {\n      const u = numerator.cross(this.dir) / divisor / line.getLength();\n      if (u >= 0 && u <= 1) {\n        return t;\n      }\n    }\n    return -1;\n  }\n\n  public intersectPoint(line: Line): Vector {\n    const time = this.intersect(line);\n    if (time < 0) {\n      return null;\n    }\n    return this.getPoint(time);\n  }\n\n  /**\n   * Returns the point of intersection given the intersection time\n   */\n  public getPoint(time: number): Vector {\n    return this.pos.add(this.dir.scale(time));\n  }\n}\n","import { Physics } from '../Physics';\r\nimport { CollisionProcessor } from './CollisionProcessor';\r\nimport { DynamicTree } from './DynamicTree';\r\nimport { Pair } from './Pair';\r\n\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { FrameStats } from '../../Debug';\r\nimport { Logger } from '../../Util/Log';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CompositeCollider } from '../Colliders/CompositeCollider';\r\nimport { ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Responsible for performing the collision broadphase (locating potential colllisions) and\r\n * the narrowphase (actual collision contacts)\r\n */\r\nexport class DynamicTreeCollisionProcessor implements CollisionProcessor {\r\n  private _dynamicCollisionTree = new DynamicTree<Collider>();\r\n  private _collisions = new Set<string>();\r\n\r\n  private _collisionPairCache: Pair[] = [];\r\n  private _colliders: Collider[] = [];\r\n\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Tracks a physics body for collisions\r\n   */\r\n  public track(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot track null collider');\r\n      return;\r\n    }\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        c.owner = target.owner;\r\n        this._colliders.push(c);\r\n        this._dynamicCollisionTree.trackCollider(c);\r\n      }\r\n    } else {\r\n      this._colliders.push(target);\r\n      this._dynamicCollisionTree.trackCollider(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Untracks a physics body\r\n   */\r\n  public untrack(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot untrack a null collider');\r\n      return;\r\n    }\r\n\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        const index = this._colliders.indexOf(c);\r\n        if (index !== -1) {\r\n          this._colliders.splice(index, 1);\r\n        }\r\n        this._dynamicCollisionTree.untrackCollider(c);\r\n      }\r\n    } else {\r\n      const index = this._colliders.indexOf(target);\r\n      if (index !== -1) {\r\n        this._colliders.splice(index, 1);\r\n      }\r\n      this._dynamicCollisionTree.untrackCollider(target);\r\n    }\r\n  }\r\n\r\n  private _shouldGenerateCollisionPair(colliderA: Collider, colliderB: Collider) {\r\n    // if the collision pair must be 2 separate colliders\r\n    // Also separate owners for composite colliders\r\n    if (\r\n      (colliderA.id !== null &&\r\n      colliderB.id !== null &&\r\n      colliderA.id === colliderB.id) ||\r\n      (colliderA.owner !== null &&\r\n       colliderB.owner !== null &&\r\n       colliderA.owner === colliderB.owner)) {\r\n      return false;\r\n    }\r\n\r\n    // if the collision pair has been calculated already short circuit\r\n    const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    if (this._collisions.has(hash)) {\r\n      return false; // pair exists easy exit return false\r\n    }\r\n\r\n    // if the pair has a member with zero dimension\r\n    if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {\r\n      return false;\r\n    }\r\n\r\n    return Pair.canCollide(colliderA, colliderB);\r\n  }\r\n\r\n  /**\r\n   * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy\r\n   */\r\n  public broadphase(targets: Collider[], delta: number, stats?: FrameStats): Pair[] {\r\n    const seconds = delta / 1000;\r\n\r\n    // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n    const potentialColliders = targets.filter((other) => {\r\n      const body = other.owner?.get(BodyComponent);\r\n      return other.owner?.active && body.collisionType !== CollisionType.PreventCollision;\r\n    });\r\n\r\n    // clear old list of collision pairs\r\n    this._collisionPairCache = [];\r\n    this._collisions.clear();\r\n\r\n    // check for normal collision pairs\r\n    let collider: Collider;\r\n    for (let j = 0, l = potentialColliders.length; j < l; j++) {\r\n      collider = potentialColliders[j];\r\n      // Query the collision tree for potential colliders\r\n      this._dynamicCollisionTree.query(collider, (other: Collider) => {\r\n        if (this._shouldGenerateCollisionPair(collider, other)) {\r\n          const pair = new Pair(collider, other);\r\n          this._collisions.add(pair.id);\r\n          this._collisionPairCache.push(pair);\r\n        }\r\n        // Always return false, to query whole tree. Returning true in the query method stops searching\r\n        return false;\r\n      });\r\n    }\r\n    if (stats) {\r\n      stats.physics.pairs = this._collisionPairCache.length;\r\n    }\r\n\r\n    // Check dynamic tree for fast moving objects\r\n    // Fast moving objects are those moving at least there smallest bound per frame\r\n    if (Physics.checkForFastBodies) {\r\n      for (const collider of potentialColliders) {\r\n        const body = collider.owner.get(BodyComponent);\r\n        // Skip non-active objects. Does not make sense on other collision types\r\n        if (body.collisionType !== CollisionType.Active) {\r\n          continue;\r\n        }\r\n\r\n        // Maximum travel distance next frame\r\n        const updateDistance =\r\n          body.vel.size * seconds + // velocity term\r\n          body.acc.size * 0.5 * seconds * seconds; // acc term\r\n\r\n        // Find the minimum dimension\r\n        const minDimension = Math.min(collider.bounds.height, collider.bounds.width);\r\n        if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {\r\n          if (stats) {\r\n            stats.physics.fastBodies++;\r\n          }\r\n\r\n          // start with the oldPos because the integration for actors has already happened\r\n          // objects resting on a surface may be slightly penetrating in the current position\r\n          const updateVec = body.pos.sub(body.oldPos);\r\n          const centerPoint = collider.center;\r\n          const furthestPoint = collider.getFurthestPoint(body.vel);\r\n          const origin: Vector = furthestPoint.sub(updateVec);\r\n\r\n          const ray: Ray = new Ray(origin, body.vel);\r\n\r\n          // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface\r\n          ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));\r\n          let minCollider: Collider;\r\n          let minTranslate: Vector = new Vector(Infinity, Infinity);\r\n          this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other: Collider) => {\r\n            if (collider !== other && Pair.canCollide(collider, other)) {\r\n              const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);\r\n              if (hitPoint) {\r\n                const translate = hitPoint.sub(origin);\r\n                if (translate.size < minTranslate.size) {\r\n                  minTranslate = translate;\r\n                  minCollider = other;\r\n                }\r\n              }\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (minCollider && Vector.isValid(minTranslate)) {\r\n            const pair = new Pair(collider, minCollider);\r\n            if (!this._collisions.has(pair.id)) {\r\n              this._collisions.add(pair.id);\r\n              this._collisionPairCache.push(pair);\r\n            }\r\n            // move the fast moving object to the other body\r\n            // need to push into the surface by ex.Physics.surfaceEpsilon\r\n            const shift = centerPoint.sub(furthestPoint);\r\n            body.pos = origin\r\n              .add(shift)\r\n              .add(minTranslate)\r\n              .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact\r\n            collider.update(body.transform);\r\n\r\n            if (stats) {\r\n              stats.physics.fastBodyCollisions++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // return cache\r\n    return this._collisionPairCache;\r\n  }\r\n\r\n  /**\r\n   * Applies narrow phase on collision pairs to find actual area intersections\r\n   * Adds actual colliding pairs to stats' Frame data\r\n   */\r\n  public narrowphase(pairs: Pair[], stats?: FrameStats): CollisionContact[] {\r\n    let contacts: CollisionContact[] = [];\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const newContacts = pairs[i].collide();\r\n      contacts = contacts.concat(newContacts);\r\n      if (stats && newContacts.length > 0) {\r\n        for (const c of newContacts) {\r\n          stats.physics.contacts.set(c.id, c);\r\n        }\r\n      }\r\n    }\r\n    if (stats) {\r\n      stats.physics.collisions += contacts.length;\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  /**\r\n   * Update the dynamic tree positions\r\n   */\r\n  public update(targets: Collider[]): number {\r\n    let updated = 0;\r\n    const len = targets.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (this._dynamicCollisionTree.updateCollider(targets[i])) {\r\n        updated++;\r\n      }\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    this._dynamicCollisionTree.debug(ex);\r\n  }\r\n}\r\n","import { Color } from '../../Color';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { Projection } from '../../Math/projection';\r\nimport { Line } from '../../Math/line';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Clonable } from '../../Interfaces/Clonable';\r\nimport { Entity, Transform } from '../../EntityComponentSystem';\r\nimport { createId, Id } from '../../Id';\r\nimport { EventDispatcher } from '../../EventDispatcher';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\n\r\n/**\r\n * A collision collider specifies the geometry that can detect when other collision colliders intersect\r\n * for the purposes of colliding 2 objects in excalibur.\r\n */\r\nexport abstract class Collider implements Clonable<Collider> {\r\n  private static _ID = 0;\r\n  public readonly id: Id<'collider'> = createId('collider', Collider._ID++);\r\n  public events: EventDispatcher<Collider> = new EventDispatcher<Collider>(this);\r\n\r\n  /**\r\n   * Returns a boolean indicating whether this body collided with\r\n   * or was in stationary contact with\r\n   * the body of the other [[Collider]]\r\n   */\r\n  public touching(other: Collider): boolean {\r\n    const contact = this.collide(other);\r\n\r\n    if (contact) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public owner: Entity;\r\n\r\n  /**\r\n   * Pixel offset of the collision collider relative to the collider, by default (0, 0) meaning the collider is positioned\r\n   * on top of the collider.\r\n   */\r\n  offset: Vector;\r\n\r\n  /**\r\n   * Position of the collision collider in world coordinates\r\n   */\r\n  abstract get worldPos(): Vector;\r\n\r\n  /**\r\n   * The center point of the collision collider, for example if the collider is a circle it would be the center.\r\n   */\r\n  abstract get center(): Vector;\r\n\r\n  /**\r\n   * Return the axis-aligned bounding box of the collision collider in world coordinates\r\n   */\r\n  abstract get bounds(): BoundingBox;\r\n\r\n  /**\r\n   * Return the axis-aligned bounding box of the collision collider in local coordinates\r\n   */\r\n  abstract get localBounds(): BoundingBox;\r\n\r\n  /**\r\n   * Return the axes of this particular collider\r\n   */\r\n  abstract get axes(): Vector[];\r\n  /**\r\n   * Find the furthest point on the convex hull of this particular collider in a certain direction.\r\n   */\r\n  abstract getFurthestPoint(direction: Vector): Vector;\r\n\r\n  abstract getInertia(mass: number): number;\r\n\r\n  // All new CollisionShape need to do the following\r\n  // Create a new collision function in the CollisionJumpTable against all the primitives\r\n  // Currently there are 3 primitive collision collider 3! = 6 jump functions\r\n  abstract collide(collider: Collider): CollisionContact[];\r\n\r\n  /**\r\n   * Returns the closest line between the surfaces this collider and another\r\n   * @param collider\r\n   */\r\n  abstract getClosestLineBetween(collider: Collider): Line;\r\n\r\n  /**\r\n   * Return wether the collider contains a point inclusive to it's border\r\n   */\r\n  abstract contains(point: Vector): boolean;\r\n\r\n  /**\r\n   * Return the point on the border of the collision collider that intersects with a ray (if any).\r\n   */\r\n  abstract rayCast(ray: Ray, max?: number): Vector;\r\n\r\n  /**\r\n   * Create a projection of this collider along an axis. Think of this as casting a \"shadow\" along an axis\r\n   */\r\n  abstract project(axis: Vector): Projection;\r\n\r\n  /**\r\n   * Updates collider world space geometry\r\n   */\r\n  abstract update(transform: Transform): void;\r\n\r\n  /**\r\n   * Draw the collider\r\n   * @deprecated Will be removed in 0.26.0\r\n   * @param ctx\r\n   * @param color\r\n   */\r\n  abstract draw(ctx: CanvasRenderingContext2D, color?: Color, pos?: Vector): void;\r\n\r\n  abstract debug(ex: ExcaliburGraphicsContext, color: Color): void;\r\n  /**\r\n   * Draw any debug information\r\n   * @deprecated Will be removed in 0.26.0\r\n   */\r\n  abstract debugDraw(ctx: CanvasRenderingContext2D, color: Color): void;\r\n\r\n  abstract clone(): Collider;\r\n}\r\n","import { Util } from '../..';\r\nimport { Pair } from '../Detection/Pair';\r\nimport { Color } from '../../Color';\r\nimport { Transform } from '../../EntityComponentSystem';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Line } from '../../Math/line';\r\nimport { Projection } from '../../Math/projection';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Vector } from '../../Math/vector';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { DynamicTree } from '../Detection/DynamicTree';\r\nimport { DynamicTreeCollisionProcessor } from '../Detection/DynamicTreeCollisionProcessor';\r\nimport { Collider } from './Collider';\r\n\r\nexport class CompositeCollider extends Collider {\r\n  private _transform: Transform;\r\n  private _collisionProcessor = new DynamicTreeCollisionProcessor();\r\n  private _dynamicAABBTree = new DynamicTree();\r\n  private _colliders: Collider[] = [];\r\n\r\n  constructor(colliders: Collider[]) {\r\n    super();\r\n    for (const c of colliders) {\r\n      this.addCollider(c);\r\n    }\r\n  }\r\n\r\n  clearColliders() {\r\n    this._colliders = [];\r\n  }\r\n\r\n  addCollider(collider: Collider) {\r\n    this.events.wire(collider.events);\r\n    this._colliders.push(collider);\r\n    this._collisionProcessor.track(collider);\r\n    this._dynamicAABBTree.trackCollider(collider);\r\n  }\r\n\r\n  removeCollider(collider: Collider) {\r\n    this.events.unwire(collider.events);\r\n    Util.removeItemFromArray(collider, this._colliders);\r\n    this._collisionProcessor.untrack(collider);\r\n    this._dynamicAABBTree.untrackCollider(collider);\r\n  }\r\n\r\n  getColliders(): Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    // TODO transform component world pos\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get center(): Vector {\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get bounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce(\r\n      (acc, collider) => acc.combine(collider.bounds),\r\n      colliders[0]?.bounds ?? new BoundingBox().translate(this.worldPos)\r\n    );\r\n\r\n    return results;\r\n  }\r\n\r\n  get localBounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), colliders[0]?.localBounds ?? new BoundingBox());\r\n\r\n    return results;\r\n  }\r\n\r\n  get axes(): Vector[] {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    let axes: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      axes = axes.concat(collider.axes);\r\n    }\r\n    return axes;\r\n  }\r\n\r\n  getFurthestPoint(direction: Vector): Vector {\r\n    const colliders = this.getColliders();\r\n    const furthestPoints: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      furthestPoints.push(collider.getFurthestPoint(direction));\r\n    }\r\n    // Pick best point from all colliders\r\n    let bestPoint = furthestPoints[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (const point of furthestPoints) {\r\n      const distance = point.dot(direction);\r\n      if (distance > maxDistance) {\r\n        bestPoint = point;\r\n        maxDistance = distance;\r\n      }\r\n    }\r\n    return bestPoint;\r\n  }\r\n\r\n  getInertia(mass: number): number {\r\n    const colliders = this.getColliders();\r\n    let totalInertia = 0;\r\n    for (const collider of colliders) {\r\n      totalInertia += collider.getInertia(mass);\r\n    }\r\n    return totalInertia;\r\n  }\r\n\r\n  collide(other: Collider): CollisionContact[] {\r\n    let otherColliders = [other];\r\n    if (other instanceof CompositeCollider) {\r\n      otherColliders = other.getColliders();\r\n    }\r\n\r\n    const pairs: Pair[] = [];\r\n    for (const c of otherColliders) {\r\n      this._dynamicAABBTree.query(c, (potentialCollider: Collider) => {\r\n        pairs.push(new Pair(c, potentialCollider));\r\n        return false;\r\n      });\r\n    }\r\n\r\n    let contacts: CollisionContact[] = [];\r\n    for (const p of pairs) {\r\n      contacts = contacts.concat(p.collide());\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  getClosestLineBetween(other: Collider): Line {\r\n    const colliders = this.getColliders();\r\n    const lines: Line[] = [];\r\n    if (other instanceof CompositeCollider) {\r\n      const otherColliders = other.getColliders();\r\n      for (const colliderA of colliders) {\r\n        for (const colliderB of otherColliders) {\r\n          const maybeLine = colliderA.getClosestLineBetween(colliderB);\r\n          if (maybeLine) {\r\n            lines.push(maybeLine);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      for (const collider of colliders) {\r\n        const maybeLine = other.getClosestLineBetween(collider);\r\n        if (maybeLine) {\r\n          lines.push(maybeLine);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lines.length) {\r\n      let minLength = lines[0].getLength();\r\n      let minLine = lines[0];\r\n      for (const line of lines) {\r\n        const length = line.getLength();\r\n        if (length < minLength) {\r\n          minLength = length;\r\n          minLine = line;\r\n        }\r\n      }\r\n      return minLine;\r\n    }\r\n    return null;\r\n  }\r\n  contains(point: Vector): boolean {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      if (collider.contains(point)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  rayCast(ray: Ray, max?: number): Vector {\r\n    const colliders = this.getColliders();\r\n    const points: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      const vec = collider.rayCast(ray, max);\r\n      if (vec) {\r\n        points.push(vec);\r\n      }\r\n    }\r\n    if (points.length) {\r\n      let minPoint = points[0];\r\n      let minDistance = minPoint.dot(ray.dir);\r\n      for (const point of points) {\r\n        const distance = ray.dir.dot(point);\r\n        if (distance < minDistance) {\r\n          minPoint = point;\r\n          minDistance = distance;\r\n        }\r\n      }\r\n      return minPoint;\r\n    }\r\n    return null;\r\n  }\r\n  project(axis: Vector): Projection {\r\n    const colliders = this.getColliders();\r\n    const projs: Projection[] = [];\r\n    for (const collider of colliders) {\r\n      const proj = collider.project(axis);\r\n      if (proj) {\r\n        projs.push(proj);\r\n      }\r\n    }\r\n    // Merge all proj's on the same axis\r\n    if (projs.length) {\r\n      const newProjection = new Projection(projs[0].min, projs[0].max);\r\n      for (const proj of projs) {\r\n        newProjection.min = Math.min(proj.min, newProjection.min);\r\n        newProjection.max = Math.max(proj.max, newProjection.max);\r\n      }\r\n      return newProjection;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  update(transform: Transform): void {\r\n    if (transform) {\r\n      const colliders = this.getColliders();\r\n      for (const collider of colliders) {\r\n        collider.owner = this.owner;\r\n        collider.update(transform);\r\n      }\r\n    }\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D, color?: Color, pos?: Vector): void {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      collider.draw(ctx, color, pos);\r\n    }\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      collider.debug(ex, color);\r\n    }\r\n  }\r\n\r\n  debugDraw(ctx: CanvasRenderingContext2D, color: Color): void {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      collider.draw(ctx, color);\r\n    }\r\n  }\r\n  clone(): Collider {\r\n    return new CompositeCollider(this._colliders.map((c) => c.clone()));\r\n  }\r\n}\r\n","import { Vector } from './vector';\n\n/**\n * A 2D line segment\n */\n\nexport class Line {\n  /**\n   * @param begin  The starting point of the line segment\n   * @param end  The ending point of the line segment\n   */\n  constructor(public begin: Vector, public end: Vector) {}\n\n  /**\n   * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\n   */\n  public get slope() {\n    return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\n  }\n\n  /**\n   * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\n   */\n  public get intercept() {\n    return this.begin.y - this.slope * this.begin.x;\n  }\n\n  /**\n   * Gets the normal of the line\n   */\n  public normal(): Vector {\n    return this.end.sub(this.begin).normal();\n  }\n\n  public dir(): Vector {\n    return this.end.sub(this.begin);\n  }\n\n  public getPoints(): Vector[] {\n    return [this.begin, this.end];\n  }\n\n  /**\n   * Returns the slope of the line in the form of a vector of length 1\n   */\n  public getSlope(): Vector {\n    const begin = this.begin;\n    const end = this.end;\n    const distance = begin.distance(end);\n    return end.sub(begin).scale(1 / distance);\n  }\n\n  /**\n   * Returns the edge of the line as vector, the length of the vector is the length of the edge\n   */\n  public getEdge(): Vector {\n    const begin = this.begin;\n    const end = this.end;\n    return end.sub(begin);\n  }\n\n  /**\n   * Returns the length of the line segment in pixels\n   */\n  public getLength(): number {\n    const begin = this.begin;\n    const end = this.end;\n    const distance = begin.distance(end);\n    return distance;\n  }\n\n  /**\n   * Returns the midpoint of the edge\n   */\n  public get midpoint(): Vector {\n    return this.begin.add(this.end).scale(0.5);\n  }\n\n  /**\n   * Flips the direction of the line segment\n   */\n  public flip(): Line {\n    return new Line(this.end, this.begin);\n  }\n\n  /**\n   * Tests if a given point is below the line, points in the normal direction above the line are considered above.\n   * @param point\n   */\n  public below(point: Vector): boolean {\n    const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);\n    return above2 >= 0;\n  }\n\n  /**\n   * Returns the clip point\n   * @param sideVector Vector that traces the line\n   * @param length Length to clip along side\n   */\n  public clip(sideVector: Vector, length: number): Line {\n    let dir = sideVector;\n    dir = dir.normalize();\n\n    const near = dir.dot(this.begin) - length;\n    const far = dir.dot(this.end) - length;\n\n    const results = [];\n    if (near <= 0) {\n      results.push(this.begin);\n    }\n    if (far <= 0) {\n      results.push(this.end);\n    }\n\n    if (near * far < 0) {\n      const clipTime = near / (near - far);\n      results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));\n    }\n    if (results.length !== 2) {\n      return null;\n    }\n\n    return new Line(results[0], results[1]);\n  }\n\n  /**\n   * Find the perpendicular distance from the line to a point\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n   * @param point\n   */\n  public distanceToPoint(point: Vector, signed: boolean = false) {\n    const x0 = point.x;\n    const y0 = point.y;\n\n    const l = this.getLength();\n\n    const dy = this.end.y - this.begin.y;\n    const dx = this.end.x - this.begin.x;\n    const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\n    return signed ? distance : Math.abs(distance);\n  }\n\n  /**\n   * Find the perpendicular line from the line to a point\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n   * (a - p) - ((a - p) * n)n\n   * a is a point on the line\n   * p is the arbitrary point above the line\n   * n is a unit vector in direction of the line\n   * @param point\n   */\n  public findVectorToPoint(point: Vector): Vector {\n    const aMinusP = this.begin.sub(point);\n    const n = this.getSlope();\n\n    return aMinusP.sub(n.scale(aMinusP.dot(n)));\n  }\n\n  /**\n   * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\n   * a new point with the calculated Y value and vice-versa.\n   *\n   * @param x The known X value of the target point\n   * @param y The known Y value of the target point\n   * @returns A new point with the other calculated axis value\n   */\n  public findPoint(x: number = null, y: number = null): Vector {\n    const m = this.slope;\n    const b = this.intercept;\n\n    if (x !== null) {\n      return new Vector(x, m * x + b);\n    } else if (y !== null) {\n      return new Vector((y - b) / m, y);\n    } else {\n      throw new Error('You must provide an X or a Y value');\n    }\n  }\n\n  /**\n   * Whether or not the given point lies on this line. This method is precise by default\n   * meaning the point must lie exactly on the line. Adjust threshold to\n   * loosen the strictness of the check for floating-point calculations.\n   */\n  public hasPoint(x: number, y: number, threshold?: number): boolean;\n\n  /**\n   * Whether or not the given point lies on this line. This method is precise by default\n   * meaning the point must lie exactly on the line. Adjust threshold to\n   * loosen the strictness of the check for floating-point calculations.\n   */\n  public hasPoint(v: Vector, threshold?: number): boolean;\n\n  /**\n   * @see http://stackoverflow.com/a/11908158/109458\n   */\n  public hasPoint(): boolean {\n    let currPoint: Vector;\n    let threshold = 0;\n\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      currPoint = new Vector(arguments[0], arguments[1]);\n      threshold = arguments[2] || 0;\n    } else if (arguments[0] instanceof Vector) {\n      currPoint = arguments[0];\n      threshold = arguments[1] || 0;\n    } else {\n      throw 'Could not determine the arguments for Vector.hasPoint';\n    }\n\n    const dxc = currPoint.x - this.begin.x;\n    const dyc = currPoint.y - this.begin.y;\n\n    const dx1 = this.end.x - this.begin.x;\n    const dy1 = this.end.y - this.begin.y;\n\n    const cross = dxc * dy1 - dyc * dx1;\n\n    // check whether point lines on the line\n    if (Math.abs(cross) > threshold) {\n      return false;\n    }\n\n    // check whether point lies in-between start and end\n    if (Math.abs(dx1) >= Math.abs(dy1)) {\n      return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\n    } else {\n      return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\n    }\n  }\n}\n","import { Line } from '../../Math/line';\nimport { Vector } from '../../Math/vector';\nimport { Ray } from '../../Math/ray';\nimport { PolygonCollider } from './PolygonCollider';\nimport { EdgeCollider } from './EdgeCollider';\nimport { CircleCollider } from './CircleCollider';\n\n/**\n * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment\n * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n * @param p0 Point where L1 begins\n * @param u Direction and length of L1\n * @param q0 Point were L2 begins\n * @param v Direction and length of L2\n */\nexport function ClosestLine(p0: Vector, u: Vector, q0: Vector, v: Vector) {\n  // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html\n\n  // w(s, t) = P(s) - Q(t)\n  // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest\n  //\n  // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.\n  // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0\n  //\n  // The closest point between 2 lines then satisfies this pair of equations\n  // 1: u * wClosest = 0\n  // 2: v * wClosest = 0\n  //\n  // Substituting wClosest into the equations we get\n  //\n  // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0\n  // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0\n\n  // simplify w0\n  const w0 = p0.sub(q0);\n\n  // simplify (u * u);\n  const a = u.dot(u);\n  // simplify (u * v);\n  const b = u.dot(v);\n  // simplify (v * v)\n  const c = v.dot(v);\n  // simplify (u * w0)\n  const d = u.dot(w0);\n  // simplify (v * w0)\n  const e = v.dot(w0);\n\n  // denominator ac - b^2\n  const denom = a * c - b * b;\n  let sDenom = denom;\n  let tDenom = denom;\n  // if denom is 0 they are parallel, use any point from either as the start in this case p0\n  if (denom === 0 || denom <= 0.01) {\n    const tClosestParallel = d / b;\n    return new Line(p0, q0.add(v.scale(tClosestParallel)));\n  }\n\n  // Solve for sClosest for infinite line\n  let sClosest = b * e - c * d; // / denom;\n\n  // Solve for tClosest for infinite line\n  let tClosest = a * e - b * d; // / denom;\n\n  // Solve for segments candidate edges, if sClosest and tClosest are outside their segments\n  if (sClosest < 0) {\n    sClosest = 0;\n    tClosest = e;\n    tDenom = c;\n  } else if (sClosest > sDenom) {\n    sClosest = sDenom;\n    tClosest = e + b;\n    tDenom = c;\n  }\n\n  if (tClosest < 0) {\n    tClosest = 0;\n    if (-d < 0) {\n      sClosest = 0;\n    } else if (-d > a) {\n      sClosest = sDenom;\n    } else {\n      sClosest = -d;\n      sDenom = a;\n    }\n  } else if (tClosest > tDenom) {\n    tClosest = tDenom;\n    if (-d + b < 0) {\n      sClosest = 0;\n    } else if (-d + b > a) {\n      sClosest = sDenom;\n    } else {\n      sClosest = -d + b;\n      sDenom = a;\n    }\n  }\n  sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;\n  tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;\n\n  return new Line(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));\n}\n\nexport const ClosestLineJumpTable = {\n  PolygonPolygonClosestLine(polygonA: PolygonCollider, polygonB: PolygonCollider) {\n    // Find the 2 closest faces on each polygon\n    const otherWorldPos = polygonB.worldPos;\n    const otherDirection = otherWorldPos.sub(polygonA.worldPos);\n    const thisDirection = otherDirection.negate();\n\n    const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);\n    const rayTowardsThis = new Ray(otherWorldPos, thisDirection);\n\n    const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\n    const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));\n\n    const thisFace = polygonA.getClosestFace(thisPoint);\n    const otherFace = polygonB.getClosestFace(otherPoint);\n\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n    const p0 = thisFace.face.begin;\n    const u = thisFace.face.getEdge();\n\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n    const q0 = otherFace.face.begin;\n    const v = otherFace.face.getEdge();\n\n    return ClosestLine(p0, u, q0, v);\n  },\n\n  PolygonEdgeClosestLine(polygon: PolygonCollider, edge: EdgeCollider) {\n    // Find the 2 closest faces on each polygon\n    const otherWorldPos = edge.worldPos;\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\n\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);\n\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\n\n    const thisFace = polygon.getClosestFace(thisPoint);\n\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n    const p0 = thisFace.face.begin;\n    const u = thisFace.face.getEdge();\n\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n    const edgeLine = edge.asLine();\n    const edgeStart = edgeLine.begin;\n    const edgeVector = edgeLine.getEdge();\n    const q0 = edgeStart;\n    const v = edgeVector;\n\n    return ClosestLine(p0, u, q0, v);\n  },\n\n  PolygonCircleClosestLine(polygon: PolygonCollider, circle: CircleCollider) {\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\n    // Find the 2 closest faces on each polygon\n    const otherWorldPos = circle.worldPos;\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\n\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());\n\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\n\n    const thisFace = polygon.getClosestFace(thisPoint);\n\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n    const p0 = thisFace.face.begin;\n    const u = thisFace.face.getEdge();\n\n    // Time of minimum distance\n    let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\n\n    // If time of minimum is past the edge clamp\n    if (t > 1) {\n      t = 1;\n    } else if (t < 0) {\n      t = 0;\n    }\n\n    // Minimum distance\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;\n\n    const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);\n    const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);\n    return new Line(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));\n  },\n\n  CircleCircleClosestLine(circleA: CircleCollider, circleB: CircleCollider) {\n    // Find the 2 closest faces on each polygon\n    const otherWorldPos = circleB.worldPos;\n    const otherDirection = otherWorldPos.sub(circleA.worldPos);\n\n    const thisWorldPos = circleA.worldPos;\n    const thisDirection = thisWorldPos.sub(circleB.worldPos);\n\n    const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);\n    const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);\n\n    const thisPoint = circleA.rayCast(rayTowardsOther);\n    const otherPoint = circleB.rayCast(rayTowardsThis);\n\n    return new Line(thisPoint, otherPoint);\n  },\n\n  CircleEdgeClosestLine(circle: CircleCollider, edge: EdgeCollider) {\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\n    const circleWorlPos = circle.worldPos;\n\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n    const edgeLine = edge.asLine();\n    const edgeStart = edgeLine.begin;\n    const edgeVector = edgeLine.getEdge();\n    const p0 = edgeStart;\n    const u = edgeVector;\n\n    // Time of minimum distance\n    let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\n\n    // If time of minimum is past the edge clamp to edge\n    if (t > 1) {\n      t = 1;\n    } else if (t < 0) {\n      t = 0;\n    }\n\n    // Minimum distance\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;\n\n    const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);\n    const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);\n    return new Line(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));\n  },\n\n  EdgeEdgeClosestLine(edgeA: EdgeCollider, edgeB: EdgeCollider) {\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\n    const edgeLineA = edgeA.asLine();\n    const edgeStartA = edgeLineA.begin;\n    const edgeVectorA = edgeLineA.getEdge();\n    const p0 = edgeStartA;\n    const u = edgeVectorA;\n\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\n    const edgeLineB = edgeB.asLine();\n    const edgeStartB = edgeLineB.begin;\n    const edgeVectorB = edgeLineB.getEdge();\n    const q0 = edgeStartB;\n    const v = edgeVectorB;\n\n    return ClosestLine(p0, u, q0, v);\n  }\n};\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { Line } from '../../Math/line';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\n\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Transform, TransformComponent } from '../../EntityComponentSystem';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\n\r\nexport interface CircleColliderOptions {\r\n  /**\r\n   * Optional pixel offset to shift the circle relative to the collider, by default (0, 0).\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Required radius of the circle\r\n   */\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * This is a circle collider for the excalibur rigid body physics simulation\r\n */\r\nexport class CircleCollider extends Collider {\r\n  /**\r\n   * Position of the circle relative to the collider, by default (0, 0).\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  public get worldPos(): Vector {\r\n    return this.offset.add(this._transform?.pos ?? Vector.Zero);\r\n  }\r\n\r\n  /**\r\n   * This is the radius of the circle\r\n   */\r\n  public radius: number;\r\n\r\n  private _transform: Transform;\r\n\r\n  constructor(options: CircleColliderOptions) {\r\n    super();\r\n    this.offset = options.offset || Vector.Zero;\r\n    this.radius = options.radius || 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this shape, not associated with any collider\r\n   */\r\n  public clone(): CircleCollider {\r\n    return new CircleCollider({\r\n      offset: this.offset.clone(),\r\n      radius: this.radius\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this.offset.add(this._transform?.pos ?? Vector.Zero);\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    const pos = this._transform?.pos ?? this.offset;\r\n    const distance = pos.distance(point);\r\n    if (distance <= this.radius) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Casts a ray at the Circle collider and returns the nearest point of collision\r\n   * @param ray\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n    const c = this.center;\r\n    const dir = ray.dir;\r\n    const orig = ray.pos;\r\n\r\n    const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));\r\n\r\n    if (discriminant < 0) {\r\n      // no intersection\r\n      return null;\r\n    } else {\r\n      let toi = 0;\r\n      if (discriminant === 0) {\r\n        toi = -dir.dot(orig.sub(c));\r\n        if (toi > 0 && toi < max) {\r\n          return ray.getPoint(toi);\r\n        }\r\n        return null;\r\n      } else {\r\n        const toi1 = -dir.dot(orig.sub(c)) + discriminant;\r\n        const toi2 = -dir.dot(orig.sub(c)) - discriminant;\r\n\r\n        const positiveToi: number[] = [];\r\n        if (toi1 >= 0) {\r\n          positiveToi.push(toi1);\r\n        }\r\n\r\n        if (toi2 >= 0) {\r\n          positiveToi.push(toi2);\r\n        }\r\n\r\n        const mintoi = Math.min(...positiveToi);\r\n        if (mintoi <= max) {\r\n          return ray.getPoint(mintoi);\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  public getClosestLineBetween(shape: Collider): Line {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleCircle(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    return this.center.add(direction.normalize().scale(this.radius));\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the shape in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const dir = direction.normalize();\r\n    return dir.scale(this.radius);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const tx = this._transform as TransformComponent;\r\n    const bodyPos = tx?.globalPos ?? Vector.Zero;\r\n    return new BoundingBox(\r\n      this.offset.x + bodyPos.x - this.radius,\r\n      this.offset.y + bodyPos.y - this.radius,\r\n      this.offset.x + bodyPos.x + this.radius,\r\n      this.offset.y + bodyPos.y + this.radius\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return new BoundingBox(\r\n      this.offset.x - this.radius,\r\n      this.offset.y - this.radius,\r\n      this.offset.x + this.radius,\r\n      this.offset.y + this.radius\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get axis not implemented on circles, since there are infinite axis in a circle\r\n   */\r\n  public get axes(): Vector[] {\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Returns the moment of inertia of a circle given it's mass\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    return (mass * this.radius * this.radius) / 2;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n  }\r\n\r\n  /**\r\n   * Project the circle along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n    const point = this.center;\r\n    const dotProduct = point.dot(axis);\r\n    scalars.push(dotProduct);\r\n    scalars.push(dotProduct + this.radius);\r\n    scalars.push(dotProduct - this.radius);\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D, color: Color = Color.Green, pos: Vector = Vector.Zero) {\r\n    const newPos = pos.add(this.offset);\r\n    ctx.beginPath();\r\n    ctx.fillStyle = color.toString();\r\n    ctx.arc(newPos.x, newPos.y, this.radius, 0, Math.PI * 2);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const tx = this._transform as TransformComponent;\r\n    const pos = tx?.globalPos ? tx?.globalPos.add(this.offset) : this.offset;\r\n    ex.drawCircle(pos, this.radius, color);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: CanvasRenderingContext2D, color: Color = Color.Green) {\r\n    const transform = this._transform;\r\n    const pos = transform ? transform.pos.add(this.offset) : this.offset;\r\n    const rotation = transform ? transform.rotation : 0;\r\n\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = color.toString();\r\n    ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n    ctx.beginPath();\r\n    ctx.moveTo(pos.x, pos.y);\r\n    ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\nimport { Physics } from '../Physics';\nimport { Collider } from '../Colliders/Collider';\nimport { CollisionType } from '../CollisionType';\nimport { Pair } from './Pair';\nimport { SeparationInfo } from '../Colliders/SeparatingAxis';\nimport { BodyComponent } from '../BodyComponent';\n\n/**\n * Collision contacts are used internally by Excalibur to resolve collision between colliders. This\n * Pair prevents collisions from being evaluated more than one time\n */\nexport class CollisionContact {\n  private _canceled = false;\n\n  /**\n   * Currently the ids between colliders\n   */\n  readonly id: string;\n\n  /**\n   * The first collider in the collision\n   */\n  colliderA: Collider;\n\n  /**\n   * The second collider in the collision\n   */\n  colliderB: Collider;\n\n  /**\n   * The minimum translation vector to resolve overlap, pointing away from colliderA\n   */\n  mtv: Vector;\n\n  /**\n   * World space contact points between colliderA and colliderB\n   */\n  points: Vector[];\n\n  /**\n   * Local space contact points between colliderA and colliderB\n   */\n  localPoints: Vector[];\n\n  /**\n   * The collision normal, pointing away from colliderA\n   */\n  normal: Vector;\n\n  /**\n   * The collision tangent\n   */\n  tangent: Vector;\n\n  /**\n   * Information about the specifics of the collision contact separation\n   */\n  info: SeparationInfo;\n\n  constructor(\n    colliderA: Collider,\n    colliderB: Collider,\n    mtv: Vector,\n    normal: Vector,\n    tangent: Vector,\n    points: Vector[],\n    localPoints: Vector[],\n    info: SeparationInfo\n  ) {\n    this.colliderA = colliderA;\n    this.colliderB = colliderB;\n    this.mtv = mtv;\n    this.normal = normal;\n    this.tangent = tangent;\n    this.points = points;\n    this.localPoints = localPoints;\n    this.info = info;\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\n  }\n\n  /**\n   * Match contact awake state, except if body's are Fixed\n   */\n  public matchAwake(): void {\n    const bodyA = this.colliderA.owner.get(BodyComponent);\n    const bodyB = this.colliderB.owner.get(BodyComponent);\n    if (bodyA && bodyB) {\n      if (bodyA.sleeping !== bodyB.sleeping) {\n        if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {\n          bodyA.setSleeping(false);\n        }\n        if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {\n          bodyB.setSleeping(false);\n        }\n      }\n    }\n  }\n\n  public isCanceled() {\n    return this._canceled;\n  }\n\n  public cancel(): void {\n    this._canceled = true;\n  }\n}\n","import { Line } from '../../Math/line';\nimport { Vector } from '../../Math/vector';\nimport { Collider } from './Collider';\nimport { CircleCollider } from './CircleCollider';\nimport { PolygonCollider } from './PolygonCollider';\n\n/**\n * Specific information about a contact and it's separation\n */\nexport interface SeparationInfo {\n  /**\n   * Collider A\n   */\n  collider: Collider;\n\n  /**\n   * Signed value (negative means overlap, positive no overlap)\n   */\n  separation: number;\n\n  /**\n   * Axis of separation from the collider's perpective\n   */\n  axis: Vector;\n\n  /**\n   * Side of separation (reference) from the collider's perpsective\n   */\n\n  side?: Line;\n\n  /**\n   * Local side of separation (reference) from the collider's perspective\n   */\n  localSide?: Line;\n\n  /**\n   * Index of the separation side (reference) from the collider's perspective\n   */\n  sideId?: number;\n\n  /**\n   * Point on collider B (incident point)\n   */\n  point: Vector;\n\n  /**\n   * Local point on collider B (incident point)\n   */\n  localPoint?: Vector;\n}\n\nexport class SeparatingAxis {\n  static findPolygonPolygonSeparation(polyA: PolygonCollider, polyB: PolygonCollider): SeparationInfo {\n    let bestSeparation = -Number.MAX_VALUE;\n    let bestSide: Line | null = null;\n    let bestAxis: Vector | null = null;\n    let bestSideIndex: number = -1;\n    let bestOtherPoint: Vector | null = null;\n    const sides = polyA.getSides();\n    const localSides = polyA.getLocalSides();\n    for (let i = 0; i < sides.length; i++) {\n      const side = sides[i];\n      const axis = side.normal();\n      const vertB = polyB.getFurthestPoint(axis.negate());\n      // Separation on side i's axis\n      // We are looking for the largest separation between poly A's sides\n      const vertSeparation = side.distanceToPoint(vertB, true);\n      if (vertSeparation > bestSeparation) {\n        bestSeparation = vertSeparation;\n        bestSide = side;\n        bestAxis = axis;\n        bestSideIndex = i;\n        bestOtherPoint = vertB;\n      }\n    }\n\n    return {\n      collider: polyA,\n      separation: bestAxis ? bestSeparation : 99,\n      axis: bestAxis as Vector,\n      side: bestSide,\n      localSide: localSides[bestSideIndex],\n      sideId: bestSideIndex,\n      point: bestOtherPoint as Vector,\n      localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis!.negate()) : null\n    };\n  }\n\n  static findCirclePolygonSeparation(circle: CircleCollider, polygon: PolygonCollider): Vector | null {\n    const axes = polygon.axes;\n    const pc = polygon.center;\n    // Special SAT with circles\n    const polyDir = pc.sub(circle.worldPos);\n    const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());\n    axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());\n\n    let minOverlap = Number.MAX_VALUE;\n    let minAxis = null;\n    let minIndex = -1;\n    for (let i = 0; i < axes.length; i++) {\n      const proj1 = polygon.project(axes[i]);\n      const proj2 = circle.project(axes[i]);\n      const overlap = proj1.getOverlap(proj2);\n      if (overlap <= 0) {\n        return null;\n      } else {\n        if (overlap < minOverlap) {\n          minOverlap = overlap;\n          minAxis = axes[i];\n          minIndex = i;\n        }\n      }\n    }\n    if (minIndex < 0) {\n      return null;\n    }\n    return minAxis.normalize().scale(minOverlap);\n  }\n}\n","import { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { SeparatingAxis, SeparationInfo } from './SeparatingAxis';\r\nimport { Line } from '../../Math/line';\r\nimport { Vector } from '../../Math/vector';\r\nimport { TransformComponent } from '../../EntityComponentSystem';\r\nimport { Pair } from '../Detection/Pair';\r\n\r\nexport const CollisionJumpTable = {\r\n  CollideCircleCircle(circleA: CircleCollider, circleB: CircleCollider): CollisionContact[] {\r\n    const circleAPos = circleA.worldPos;\r\n    const circleBPos = circleB.worldPos;\r\n    const combinedRadius = circleA.radius + circleB.radius;\r\n    const distance = circleAPos.distance(circleBPos);\r\n\r\n    if (distance > combinedRadius) {\r\n      return [];\r\n    }\r\n\r\n    // negative means overlap\r\n    const separation = combinedRadius - distance;\r\n\r\n    // Normal points from A -> B\r\n    const normal = circleBPos.sub(circleAPos).normalize();\r\n    const tangent = normal.perpendicular();\r\n    const mvt = normal.scale(separation);\r\n\r\n    const point = circleA.getFurthestPoint(normal);\r\n    const local = circleA.getFurthestLocalPoint(normal);\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circleA,\r\n      separation,\r\n      axis: normal,\r\n      point: point\r\n    };\r\n\r\n    return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];\r\n  },\r\n\r\n  CollideCirclePolygon(circle: CircleCollider, polygon: PolygonCollider): CollisionContact[] {\r\n    let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);\r\n    if (!minAxis) {\r\n      return [];\r\n    }\r\n\r\n    // make sure that the minAxis is pointing away from circle\r\n    const samedir = minAxis.dot(polygon.center.sub(circle.center));\r\n    minAxis = samedir < 0 ? minAxis.negate() : minAxis;\r\n\r\n    const point = circle.getFurthestPoint(minAxis);\r\n    const xf = circle.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const local = xf.applyInverse(point);\r\n    const normal = minAxis.normalize();\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: -minAxis.size,\r\n      axis: normal,\r\n      point: point,\r\n      localPoint: local,\r\n      side: polygon.findSide(normal.negate()),\r\n      localSide: polygon.findLocalSide(normal.negate())\r\n    };\r\n\r\n    return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];\r\n  },\r\n\r\n  CollideCircleEdge(circle: CircleCollider, edge: EdgeCollider): CollisionContact[] {\r\n    // TODO not sure this actually abides by local/world collisions\r\n    // Are edge.begin and edge.end local space or world space? I think they should be local\r\n\r\n    // center of the circle in world pos\r\n    const cc = circle.center;\r\n    // vector in the direction of the edge\r\n    const edgeWorld = edge.asLine();\r\n    const e = edgeWorld.end.sub(edgeWorld.begin);\r\n\r\n    // amount of overlap with the circle's center along the edge direction\r\n    const u = e.dot(edgeWorld.end.sub(cc));\r\n    const v = e.dot(cc.sub(edgeWorld.begin));\r\n    const side = edge.asLine();\r\n    const localSide = edge.asLocalLine();\r\n\r\n    // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n    if (v <= 0) {\r\n      const da = edgeWorld.begin.sub(cc);\r\n      const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n      // save some sqrts\r\n      if (dda > circle.radius * circle.radius) {\r\n        return []; // no collision\r\n      }\r\n\r\n      const normal = da.normalize();\r\n      const separation = circle.radius - Math.sqrt(dda);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.begin,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)\r\n      ];\r\n    }\r\n\r\n    // Potential region B collision (circle is on the right side of the edge, after the end)\r\n    if (u <= 0) {\r\n      const db = edgeWorld.end.sub(cc);\r\n      const ddb = db.dot(db);\r\n      if (ddb > circle.radius * circle.radius) {\r\n        return [];\r\n      }\r\n\r\n      const normal = db.normalize();\r\n      const separation = circle.radius - Math.sqrt(ddb);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.end,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)\r\n      ];\r\n    }\r\n\r\n    // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n    const den = e.dot(e);\r\n    const pointOnEdge = edgeWorld.begin\r\n      .scale(u)\r\n      .add(edgeWorld.end.scale(v))\r\n      .scale(1 / den);\r\n    const d = cc.sub(pointOnEdge);\r\n\r\n    const dd = d.dot(d);\r\n    if (dd > circle.radius * circle.radius) {\r\n      return []; // no collision\r\n    }\r\n\r\n    let normal = e.perpendicular();\r\n    // flip correct direction\r\n    if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {\r\n      normal.x = -normal.x;\r\n      normal.y = -normal.y;\r\n    }\r\n\r\n    normal = normal.normalize();\r\n    const separation = circle.radius - Math.sqrt(dd);\r\n\r\n    const mvt = normal.scale(separation);\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: separation,\r\n      axis: normal,\r\n      point: pointOnEdge,\r\n      side: side,\r\n      localSide: localSide\r\n    };\r\n\r\n    return [\r\n      new CollisionContact(\r\n        circle,\r\n        edge,\r\n        mvt,\r\n        normal.negate(),\r\n        normal.negate().perpendicular(),\r\n        [pointOnEdge],\r\n        [pointOnEdge.sub(edge.worldPos)],\r\n        info\r\n      )\r\n    ];\r\n  },\r\n\r\n  CollideEdgeEdge(): CollisionContact[] {\r\n    // Edge-edge collision doesn't make sense\r\n    return [];\r\n  },\r\n\r\n  CollidePolygonEdge(polygon: PolygonCollider, edge: EdgeCollider): CollisionContact[] {\r\n    const pc = polygon.center;\r\n    const ec = edge.center;\r\n    const dir = ec.sub(pc).normalize();\r\n\r\n    // build a temporary polygon from the edge to use SAT\r\n    const linePoly = new PolygonCollider({\r\n      points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],\r\n      offset: edge.offset\r\n    });\r\n    linePoly.owner = edge.owner;\r\n    const tx = edge.owner?.get(TransformComponent);\r\n    if (tx) {\r\n      linePoly.update(edge.owner.get(TransformComponent));\r\n    }\r\n    // Gross hack but poly-poly works well\r\n    const contact = this.CollidePolygonPolygon(polygon, linePoly);\r\n    if (contact.length) {\r\n      // Fudge the contact back to edge\r\n      contact[0].colliderB = edge;\r\n      (contact[0].id as any) = Pair.calculatePairHash(polygon.id, edge.id);\r\n      // contact[0].info.collider\r\n    }\r\n    return contact;\r\n  },\r\n\r\n  CollidePolygonPolygon(polyA: PolygonCollider, polyB: PolygonCollider): CollisionContact[] {\r\n    // Multi contact from SAT\r\n    // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection\r\n    // do a SAT test to find a min axis if it exists\r\n    const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);\r\n    // If there is no overlap from boxA's perspective we can end early\r\n    if (separationA.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);\r\n    // If there is no overlap from boxB's perspective exit now\r\n    if (separationB.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    // Separations are both negative, we want to pick the least negative (minimal movement)\r\n    const separation = separationA.separation > separationB.separation ? separationA : separationB;\r\n\r\n    // The incident side is the most opposite from the axes of collision on the other collider\r\n    const other = separation.collider === polyA ? polyB : polyA;\r\n    const incident = other.findSide(separation.axis.negate()) as Line;\r\n\r\n    // Clip incident side by the perpendicular lines at each end of the reference side\r\n    // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\r\n    const reference = separation.side;\r\n    const refDir = reference.dir().normalize();\r\n\r\n    // Find our contact points by clipping the incident by the collision side\r\n    const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));\r\n    let clipLeft: Line | null = null;\r\n    if (clipRight) {\r\n      clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));\r\n    }\r\n\r\n    // If there is no left there is no collision\r\n    if (clipLeft) {\r\n      // We only want clip points below the reference edge, discard the others\r\n      const points = clipLeft.getPoints().filter((p) => {\r\n        return reference.below(p);\r\n      });\r\n\r\n      let normal = separation.axis;\r\n      let tangent = normal.perpendicular();\r\n      // Point Contact A -> B\r\n      if (polyB.worldPos.sub(polyA.worldPos).dot(normal) < 0) {\r\n        normal = normal.negate();\r\n        tangent = normal.perpendicular();\r\n      }\r\n      // Points are clipped from incident which is the other collider\r\n      // Store those as locals\r\n      let localPoints: Vector[] = [];\r\n      if (separation.collider === polyA) {\r\n        const xf = polyB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      } else {\r\n        const xf = polyA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      }\r\n      return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];\r\n    }\r\n    return [];\r\n  },\r\n\r\n  FindContactSeparation(contact: CollisionContact, localPoint: Vector) {\r\n    const shapeA = contact.colliderA;\r\n    const txA = contact.colliderA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const shapeB = contact.colliderB;\r\n    const txB = contact.colliderB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n\r\n    // both are circles\r\n    if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {\r\n      const combinedRadius = shapeA.radius + shapeB.radius;\r\n      const distance = txA.pos.distance(txB.pos);\r\n      const separation = combinedRadius - distance;\r\n      return -separation;\r\n    }\r\n\r\n    // both are polygons\r\n    if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {\r\n      if (contact.info.localSide) {\r\n        let side: Line;\r\n        let worldPoint: Vector;\r\n        if (contact.info.collider === shapeA) {\r\n          side = new Line(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));\r\n          worldPoint = txB.apply(localPoint);\r\n        } else {\r\n          side = new Line(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));\r\n          worldPoint = txA.apply(localPoint);\r\n        }\r\n\r\n        return side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v circle\r\n    if (\r\n      (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||\r\n      (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)\r\n    ) {\r\n      const worldPoint = txA.apply(localPoint);\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v edge\r\n    if (\r\n      (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||\r\n      (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)\r\n    ) {\r\n      let worldPoint: Vector;\r\n      if (contact.info.collider === shapeA) {\r\n        worldPoint = txB.apply(localPoint);\r\n      } else {\r\n        worldPoint = txA.apply(localPoint);\r\n      }\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // circle v edge\r\n    if (\r\n      (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||\r\n      (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)\r\n    ) {\r\n      // Local point is always on the edge which is always shapeB\r\n      const worldPoint = txB.apply(localPoint);\r\n\r\n      let circlePoint: Vector;\r\n      if (shapeA instanceof CircleCollider) {\r\n        circlePoint = shapeA.getFurthestPoint(contact.normal);\r\n      }\r\n\r\n      const dist = worldPoint.distance(circlePoint);\r\n\r\n      if (contact.info.side) {\r\n        return dist > 0 ? -dist : 0;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { Line } from '../../Math/line';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Transform, TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\n\r\nexport interface EdgeColliderOptions {\r\n  /**\r\n   * The beginning of the edge defined in local coordinates to the collider\r\n   */\r\n  begin: Vector;\r\n  /**\r\n   * The ending of the edge defined in local coordinates to the collider\r\n   */\r\n  end: Vector;\r\n  /**\r\n   * Optionall specify an offset\r\n   */\r\n  offset?: Vector;\r\n}\r\n\r\n/**\r\n * Edge is a single line collider to create collisions with a single line.\r\n */\r\nexport class EdgeCollider extends Collider {\r\n  offset: Vector;\r\n  begin: Vector;\r\n  end: Vector;\r\n\r\n  private _transform: Transform;\r\n\r\n  constructor(options: EdgeColliderOptions) {\r\n    super();\r\n    this.begin = options.begin || Vector.Zero;\r\n    this.end = options.end || Vector.Zero;\r\n    this.offset = options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this Edge, not associated with any collider\r\n   */\r\n  public clone(): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: this.begin.clone(),\r\n      end: this.end.clone()\r\n    });\r\n  }\r\n\r\n  public get worldPos(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    return tx?.globalPos.add(this.offset) ?? this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collision area in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    const pos = this.begin.average(this.end).add(this._getBodyPos());\r\n    return pos;\r\n  }\r\n\r\n  private _getBodyPos(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const bodyPos = tx?.globalPos ?? Vector.Zero;\r\n    return bodyPos;\r\n  }\r\n\r\n  private _getTransformedBegin(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const angle = tx ? tx.globalRotation : 0;\r\n    return this.begin.rotate(angle).add(this._getBodyPos());\r\n  }\r\n\r\n  private _getTransformedEnd(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const angle = tx ? tx.globalRotation : 0;\r\n    return this.end.rotate(angle).add(this._getBodyPos());\r\n  }\r\n\r\n  /**\r\n   * Returns the slope of the line in the form of a vector\r\n   */\r\n  public getSlope(): Vector {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return distance;\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collision area\r\n   */\r\n  public contains(): boolean {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    const numerator = this._getTransformedBegin().sub(ray.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {\r\n      return null;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = ray.dir.cross(this.getSlope());\r\n    if (divisor === 0) {\r\n      return null;\r\n    }\r\n\r\n    const t = numerator.cross(this.getSlope()) / divisor;\r\n\r\n    if (t >= 0 && t <= max) {\r\n      const u = numerator.cross(ray.dir) / divisor / this.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return ray.getPoint(t);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the closes line between this and another collider, from this -> collider\r\n   * @param shape\r\n   */\r\n  public getClosestLineBetween(shape: Collider): Line {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(shape: Collider): CollisionContact[] {\r\n    if (shape instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(shape, this);\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideEdgeEdge();\r\n    } else {\r\n      throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    if (direction.dot(transformedBegin) > 0) {\r\n      return transformedBegin;\r\n    } else {\r\n      return transformedEnd;\r\n    }\r\n  }\r\n\r\n  private _boundsFromBeginEnd(begin: Vector, end: Vector, padding = 10) {\r\n    // A perfectly vertical or horizontal edge would have a bounds 0 width or height\r\n    // this causes problems for the collision system so we give them some padding\r\n    return new BoundingBox(\r\n      Math.min(begin.x, end.x) - padding,\r\n      Math.min(begin.y, end.y) - padding,\r\n      Math.max(begin.x, end.x) + padding,\r\n      Math.max(begin.y, end.y) + padding\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in world space\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    return this._boundsFromBeginEnd(transformedBegin, transformedEnd);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in local space\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return this._boundsFromBeginEnd(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Returns this edge represented as a line in world coordinates\r\n   */\r\n  public asLine(): Line {\r\n    return new Line(this._getTransformedBegin(), this._getTransformedEnd());\r\n  }\r\n\r\n  /**\r\n   * Return this edge as a line in local line coordinates (relative to the position)\r\n   */\r\n  public asLocalLine(): Line {\r\n    return new Line(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the edge\r\n   */\r\n  public get axes(): Vector[] {\r\n    const e = this._getTransformedEnd().sub(this._getTransformedBegin());\r\n    const edgeNormal = e.normal();\r\n\r\n    const axes = [];\r\n    axes.push(edgeNormal);\r\n    axes.push(edgeNormal.negate());\r\n    axes.push(edgeNormal.normal());\r\n    axes.push(edgeNormal.normal().negate());\r\n    return axes;\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia for an edge\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    const length = this.end.sub(this.begin).distance() / 2;\r\n    return mass * length * length;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n  }\r\n\r\n  /**\r\n   * Project the edge along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n\r\n    const points = [this._getTransformedBegin(), this._getTransformedEnd()];\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      scalars.push(points[i].dot(axis));\r\n    }\r\n\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D, color: Color = Color.Green, pos: Vector = Vector.Zero) {\r\n    const begin = this.begin.add(pos);\r\n    const end = this.end.add(pos);\r\n    ctx.strokeStyle = color.toString();\r\n    ctx.beginPath();\r\n    ctx.moveTo(begin.x, begin.y);\r\n    ctx.lineTo(end.x, end.y);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    ex.drawLine(begin, end, color, 2);\r\n    ex.drawCircle(begin, 2, color);\r\n    ex.drawCircle(end, 2, color);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: CanvasRenderingContext2D, color: Color = Color.Red) {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    ctx.strokeStyle = color.toString();\r\n    ctx.beginPath();\r\n    ctx.moveTo(begin.x, begin.y);\r\n    ctx.lineTo(end.x, end.y);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  }\r\n}\r\n","import { Color } from '../../Color';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { Projection } from '../../Math/projection';\r\nimport { Line } from '../../Math/line';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Transform, TransformComponent } from '../../EntityComponentSystem';\r\nimport { Collider } from './Collider';\r\nimport { ExcaliburGraphicsContext } from '../..';\r\n\r\nexport interface PolygonColliderOptions {\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   */\r\n  points: Vector[];\r\n  /**\r\n   * Whether points are specified in clockwise or counter clockwise order, default counter-clockwise\r\n   */\r\n  clockwiseWinding?: boolean;\r\n}\r\n\r\n/**\r\n * Polygon collider for detecting collisions\r\n */\r\nexport class PolygonCollider extends Collider {\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  public offset: Vector;\r\n\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   */\r\n  public points: Vector[];\r\n\r\n  private _transform: Transform;\r\n\r\n  private _transformedPoints: Vector[] = [];\r\n  private _axes: Vector[] = [];\r\n  private _sides: Line[] = [];\r\n  private _localSides: Line[] = [];\r\n\r\n  constructor(options: PolygonColliderOptions) {\r\n    super();\r\n    this.offset = options.offset ?? Vector.Zero;\r\n    const winding = !!options.clockwiseWinding;\r\n    this.points = (winding ? options.points.reverse() : options.points) || [];\r\n\r\n    // calculate initial transformation\r\n    this._calculateTransformation();\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this ConvexPolygon, not associated with any collider\r\n   */\r\n  public clone(): PolygonCollider {\r\n    return new PolygonCollider({\r\n      offset: this.offset.clone(),\r\n      points: this.points.map((p) => p.clone())\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the world position of the collider, which is the current body transform plus any defined offset\r\n   */\r\n  public get worldPos(): Vector {\r\n    if (this._transform) {\r\n      return this._transform.pos.add(this.offset);\r\n    }\r\n    return this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this.bounds.center;\r\n  }\r\n\r\n  /**\r\n   * Calculates the underlying transformation from the body relative space to world space\r\n   */\r\n  private _calculateTransformation() {\r\n    const transform = this._transform as TransformComponent;\r\n\r\n    const pos = transform ? transform.globalPos.add(this.offset) : this.offset;\r\n    const angle = transform ? transform.globalRotation : 0;\r\n    const scale = transform ? transform.globalScale : Vector.One;\r\n\r\n    const len = this.points.length;\r\n    this._transformedPoints.length = 0; // clear out old transform\r\n    for (let i = 0; i < len; i++) {\r\n      this._transformedPoints[i] = this.points[i].scale(scale).rotate(angle).add(pos);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n   */\r\n  public getTransformedPoints(): Vector[] {\r\n    this._calculateTransformation();\r\n    return this._transformedPoints;\r\n  }\r\n\r\n  /**\r\n   * Gets the sides of the polygon in world space\r\n   */\r\n  public getSides(): Line[] {\r\n    if (this._sides.length) {\r\n      return this._sides;\r\n    }\r\n    const lines = [];\r\n    const points = this.getTransformedPoints();\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      // This winding is important\r\n      lines.push(new Line(points[i], points[(i + 1) % len]));\r\n    }\r\n    this._sides = lines;\r\n    return this._sides;\r\n  }\r\n\r\n  /**\r\n   * Returns the local coordinate space sides\r\n   */\r\n  public getLocalSides(): Line[] {\r\n    if (this._localSides.length) {\r\n      return this._localSides;\r\n    }\r\n    const lines = [];\r\n    const points = this.points;\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      // This winding is important\r\n      lines.push(new Line(points[i], points[(i + 1) % len]));\r\n    }\r\n    this._localSides = lines;\r\n    return this._localSides;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the world space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findSide(direction: Vector): Line {\r\n    const sides = this.getSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the local space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findLocalSide(direction: Vector): Line {\r\n    const sides = this.getLocalSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the convex polygon\r\n   */\r\n  public get axes(): Vector[] {\r\n    if (this._axes.length) {\r\n      return this._axes;\r\n    }\r\n    const axes = this.getSides().map((s) => s.normal());\r\n    this._axes = axes;\r\n    return this._axes;\r\n  }\r\n\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    this._sides.length = 0;\r\n    this._localSides.length = 0;\r\n    this._axes.length = 0;\r\n    this._transformedPoints.length = 0;\r\n    this.getTransformedPoints();\r\n    this.getSides();\r\n    this.getLocalSides();\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider in world space\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    // Always cast to the right, as long as we cast in a consistent fixed direction we\r\n    // will be fine\r\n    const testRay = new Ray(point, new Vector(1, 0));\r\n    const intersectCount = this.getSides().reduce(function (accum, side) {\r\n      if (testRay.intersect(side) >= 0) {\r\n        return accum + 1;\r\n      }\r\n      return accum;\r\n    }, 0);\r\n\r\n    if (intersectCount % 2 === 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public getClosestLineBetween(collider: Collider): Line {\r\n    if (collider instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a collision contact if the 2 colliders collide, otherwise collide will\r\n   * return null.\r\n   * @param collider\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(collider, this);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonPolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const pts = this.getTransformedPoints();\r\n    let furthestPoint = null;\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the collider furthest in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const pts = this.points;\r\n    let furthestPoint = pts[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Finds the closes face to the point using perpendicular distance\r\n   * @param point point to test against polygon\r\n   */\r\n  public getClosestFace(point: Vector): { distance: Vector; face: Line } {\r\n    const sides = this.getSides();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let faceIndex = -1;\r\n    let distance = -1;\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const dist = sides[i].distanceToPoint(point);\r\n      if (dist < min) {\r\n        min = dist;\r\n        faceIndex = i;\r\n        distance = dist;\r\n      }\r\n    }\r\n\r\n    if (faceIndex !== -1) {\r\n      return {\r\n        distance: sides[faceIndex].normal().scale(distance),\r\n        face: sides[faceIndex]\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero).add(this.offset);\r\n    return this.localBounds.scale(scale).rotate(rotation).translate(pos);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return BoundingBox.fromPoints(this.points);\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia for an arbitrary polygon\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    let numerator = 0;\r\n    let denominator = 0;\r\n    for (let i = 0; i < this.points.length; i++) {\r\n      const iplusone = (i + 1) % this.points.length;\r\n      const crossTerm = this.points[iplusone].cross(this.points[i]);\r\n      numerator +=\r\n        crossTerm *\r\n        (this.points[i].dot(this.points[i]) + this.points[i].dot(this.points[iplusone]) + this.points[iplusone].dot(this.points[iplusone]));\r\n      denominator += crossTerm;\r\n    }\r\n    return (mass / 6) * (numerator / denominator);\r\n  }\r\n\r\n  /**\r\n   * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity) {\r\n    // find the minimum contact time greater than 0\r\n    // contact times less than 0 are behind the ray and we don't want those\r\n    const sides = this.getSides();\r\n    const len = sides.length;\r\n    let minContactTime = Number.MAX_VALUE;\r\n    let contactIndex = -1;\r\n    for (let i = 0; i < len; i++) {\r\n      const contactTime = ray.intersect(sides[i]);\r\n      if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\r\n        minContactTime = contactTime;\r\n        contactIndex = i;\r\n      }\r\n    }\r\n\r\n    // contact was found\r\n    if (contactIndex >= 0) {\r\n      return ray.getPoint(minContactTime);\r\n    }\r\n\r\n    // no contact found\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Project the edges of the polygon along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const points = this.getTransformedPoints();\r\n    const len = points.length;\r\n    let min = Number.MAX_VALUE;\r\n    let max = -Number.MAX_VALUE;\r\n    for (let i = 0; i < len; i++) {\r\n      const scalar = points[i].dot(axis);\r\n      min = Math.min(min, scalar);\r\n      max = Math.max(max, scalar);\r\n    }\r\n\r\n    return new Projection(min, max);\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D, color: Color = Color.Green, pos: Vector = Vector.Zero) {\r\n    const effectiveOffset = pos.add(this.offset);\r\n    ctx.beginPath();\r\n    ctx.fillStyle = color.toString();\r\n\r\n    const firstPoint = this.points[0].add(effectiveOffset);\r\n    ctx.moveTo(firstPoint.x, firstPoint.y);\r\n\r\n    // Points are relative\r\n    this.points\r\n      .map((p) => p.add(effectiveOffset))\r\n      .forEach(function (point) {\r\n        ctx.lineTo(point.x, point.y);\r\n      });\r\n    ctx.lineTo(firstPoint.x, firstPoint.y);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n  }\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const firstPoint = this.getTransformedPoints()[0];\r\n    const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n      ex.drawLine(points[i], points[i + 1], color, 2);\r\n      ex.drawCircle(points[i], 2, color);\r\n      ex.drawCircle(points[i + 1], 2, color);\r\n    }\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: CanvasRenderingContext2D, color: Color = Color.Red) {\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = color.toString();\r\n    // Iterate through the supplied points and construct a 'polygon'\r\n    const firstPoint = this.getTransformedPoints()[0];\r\n    ctx.moveTo(firstPoint.x, firstPoint.y);\r\n    this.getTransformedPoints().forEach(function (point) {\r\n      ctx.lineTo(point.x, point.y);\r\n    });\r\n    ctx.lineTo(firstPoint.x, firstPoint.y);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  }\r\n}\r\n","import { PolygonCollider } from './PolygonCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Logger } from '../..';\r\n\r\n/**\r\n * Excalibur helper for defining colliders quickly\r\n */\r\nexport class Shape {\r\n  /**\r\n   * Creates a box collider, under the hood defines a [[PolygonCollider]] collider\r\n   * @param width Width of the box\r\n   * @param height Height of the box\r\n   * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Box(width: number, height: number, anchor: Vector = Vector.Half, offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[PolygonCollider|arbitrary polygon]] collider\r\n   *\r\n   * PolygonColliders are useful for creating convex polygon shapes\r\n   * @param points Points specified in counter clockwise\r\n   * @param clockwiseWinding Optionally changed the winding of points, by default false meaning counter-clockwise winding.\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Polygon(points: Vector[], clockwiseWinding: boolean = false, offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: points,\r\n      offset: offset,\r\n      clockwiseWinding: clockwiseWinding\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[CircleCollider|circle]] collider\r\n   *\r\n   * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges\r\n   * @param radius Radius of the circle collider\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Circle(radius: number, offset: Vector = Vector.Zero): CircleCollider {\r\n    return new CircleCollider({\r\n      radius: radius,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[EdgeCollider|edge]] collider\r\n   *\r\n   * Edge colliders are useful for  floors, walls, and other barriers\r\n   * @param begin Beginning of the edge in local coordinates to the collider\r\n   * @param end Ending of the edge in local coordinates to the collider\r\n   */\r\n  static Edge(begin: Vector, end: Vector): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: begin,\r\n      end: end\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box\r\n   *\r\n   * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth\r\n   * player experience.\r\n   *\r\n   * @param width\r\n   * @param height\r\n   * @param offset Optional offset\r\n   */\r\n  static Capsule(width: number, height: number, offset = Vector.Zero): CompositeCollider {\r\n    const logger = Logger.getInstance();\r\n    if (width === height) {\r\n      logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');\r\n    }\r\n\r\n    const vertical = height >= width;\r\n\r\n    if (vertical) {\r\n      // height > width, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),\r\n        Shape.Box(width, height - width, Vector.Half, offset),\r\n        Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))\r\n      ]);\r\n      return capsule;\r\n    } else {\r\n      // width > height, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),\r\n        Shape.Box(width - height, height, Vector.Half, offset),\r\n        Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))\r\n      ]);\r\n      return capsule;\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { CollisionEndEvent, CollisionStartEvent, PostCollisionEvent, PreCollisionEvent } from '../Events';\r\nimport { Observable } from '../Util/Observable';\r\nimport { BoundingBox } from './BoundingBox';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { CircleCollider } from './Colliders/CircleCollider';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { PolygonCollider } from './Colliders/PolygonCollider';\r\nimport { EdgeCollider } from './Colliders/EdgeCollider';\r\nimport { Shape } from './Colliders/Shape';\r\n\r\nexport class ColliderComponent extends Component<'ex.collider'> {\r\n  public readonly type = 'ex.collider';\r\n\r\n  public events = new EventDispatcher(this);\r\n  /**\r\n   * Observable that notifies when a collider is added to the body\r\n   */\r\n  public $colliderAdded = new Observable<Collider>();\r\n\r\n  /**\r\n   * Observable that notifies when a collider is removed from the body\r\n   */\r\n  public $colliderRemoved = new Observable<Collider>();\r\n\r\n  constructor(collider?: Collider) {\r\n    super();\r\n    this.set(collider);\r\n  }\r\n\r\n  private _collider: Collider;\r\n  /**\r\n   * Get the current collider geometry\r\n   * @returns\r\n   */\r\n  public get() {\r\n    return this._collider;\r\n  }\r\n\r\n  /**\r\n   * Set the collider geometry\r\n   * @param collider\r\n   * @returns the collider you set\r\n   */\r\n  public set<T extends Collider>(collider: T): T {\r\n    this.clear();\r\n    if (collider) {\r\n      this._collider = collider;\r\n      this._collider.owner = this.owner;\r\n      this.events.wire(collider.events);\r\n      this.$colliderAdded.notifyAll(collider);\r\n      this.update();\r\n    }\r\n    return collider;\r\n  }\r\n\r\n  /**\r\n   * Remove collider geometry from collider component\r\n   */\r\n  public clear() {\r\n    if (this._collider) {\r\n      this.events.unwire(this._collider.events);\r\n      this.$colliderRemoved.notifyAll(this._collider);\r\n      this._collider.owner = null;\r\n      this._collider = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return world space bounds\r\n   */\r\n  public get bounds() {\r\n    return this._collider?.bounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Return local space bounds\r\n   */\r\n  public get localBounds() {\r\n    return this._collider?.localBounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Update the collider's transformed geometry\r\n   */\r\n  public update() {\r\n    const tx = this.owner?.get(TransformComponent);\r\n    if (this._collider) {\r\n      this._collider.owner = this.owner;\r\n      if (tx) {\r\n        this._collider.update(tx);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collide component with another\r\n   * @param other\r\n   * @returns\r\n   */\r\n  collide(other: ColliderComponent): CollisionContact[] {\r\n    let colliderA = this._collider;\r\n    let colliderB = other._collider;\r\n    if (!colliderA || !colliderB) {\r\n      return [];\r\n    }\r\n\r\n    // If we have a composite lefthand side :(\r\n    // Might bite us, but to avoid updating all the handlers make composite always left side\r\n    let flipped = false;\r\n    if (colliderB instanceof CompositeCollider) {\r\n      colliderA = colliderB;\r\n      colliderB = this._collider;\r\n      flipped = true;\r\n    }\r\n\r\n    if (this._collider) {\r\n      const contacts = colliderA.collide(colliderB);\r\n      if (contacts) {\r\n        if (flipped) {\r\n          contacts.forEach((contact) => {\r\n            contact.mtv = contact.mtv.negate();\r\n            contact.normal = contact.normal.negate();\r\n            contact.tangent = contact.normal.perpendicular();\r\n            contact.colliderA = this._collider;\r\n            contact.colliderB = other._collider;\r\n          });\r\n        }\r\n        return contacts;\r\n      }\r\n      return [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  onAdd(entity: Entity) {\r\n    if (this._collider) {\r\n      this.update();\r\n    }\r\n    // Wire up the collider events to the owning entity\r\n    this.events.on('precollision', (evt: any) => {\r\n      const precollision = evt as PreCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('postcollision', (evt: any) => {\r\n      const postcollision = evt as PostCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('collisionstart', (evt: any) => {\r\n      const start = evt as CollisionStartEvent<Collider>;\r\n      entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));\r\n    });\r\n    this.events.on('collisionend', (evt: any) => {\r\n      const end = evt as CollisionEndEvent<Collider>;\r\n      entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));\r\n    });\r\n  }\r\n\r\n  onRemove() {\r\n    this.events.clear();\r\n    this.$colliderRemoved.notifyAll(this._collider);\r\n  }\r\n\r\n  /**\r\n   * Sets up a box geometry based on the current bounds of the associated actor of this physics body.\r\n   *\r\n   * If no width/height are specified the body will attempt to use the associated actor's width/height.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useBoxCollider(width: number, height: number, anchor: Vector = Vector.Half, center: Vector = Vector.Zero): PolygonCollider {\r\n    const collider = Shape.Box(width, height, anchor, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative\r\n   *  to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  usePolygonCollider(points: Vector[], center: Vector = Vector.Zero): PolygonCollider {\r\n    const poly = Shape.Polygon(points, false, center);\r\n    return (this.set(poly));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useCircleCollider(radius: number, center: Vector = Vector.Zero): CircleCollider {\r\n    const collider = Shape.Circle(radius, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useEdgeCollider(begin: Vector, end: Vector): EdgeCollider {\r\n    const collider = Shape.Edge(begin, end);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders\r\n   * @param colliders\r\n   * @returns\r\n   */\r\n  useCompositeCollider(colliders: Collider[]): CompositeCollider {\r\n    return (this.set(new CompositeCollider(colliders)));\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { CollisionType } from './CollisionType';\r\nimport { Physics } from './Physics';\r\nimport { Clonable } from '../Interfaces/Clonable';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { CollisionGroup } from './Group/CollisionGroup';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { createId, Id } from '../Id';\r\nimport { clamp } from '../Util/Util';\r\nimport { ColliderComponent } from './ColliderComponent';\r\n\r\nexport interface BodyComponentOptions {\r\n  type?: CollisionType;\r\n  group?: CollisionGroup;\r\n  useGravity?: boolean;\r\n}\r\n\r\nexport enum DegreeOfFreedom {\r\n  Rotation = 'rotation',\r\n  X = 'x',\r\n  Y = 'y'\r\n}\r\n\r\n/**\r\n * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of\r\n * of physics simulation.\r\n */\r\nexport class BodyComponent extends Component<'ex.body'> implements Clonable<BodyComponent> {\r\n  public readonly type = 'ex.body';\r\n  public dependencies = [TransformComponent, MotionComponent];\r\n  public static _ID = 0;\r\n  public readonly id: Id<'body'> = createId('body', BodyComponent._ID++);\r\n  public events = new EventDispatcher(this);\r\n\r\n  constructor(options?: BodyComponentOptions) {\r\n    super();\r\n    if (options) {\r\n      this.collisionType = options.type ?? this.collisionType;\r\n      this.group = options.group ?? this.group;\r\n      this.useGravity = options.useGravity ?? this.useGravity;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]\r\n   */\r\n  public collisionType: CollisionType = CollisionType.PreventCollision;\r\n\r\n  /**\r\n   * The collision group for the body's colliders, by default body colliders collide with everything\r\n   */\r\n  public group: CollisionGroup = CollisionGroup.All;\r\n\r\n  /**\r\n   * The amount of mass the body has\r\n   */\r\n  public mass: number = Physics.defaultMass;\r\n\r\n  /**\r\n   * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseMass(): number {\r\n    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;\r\n  }\r\n\r\n  /**\r\n   * Amount of \"motion\" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to \"sleep\"\r\n   */\r\n  public sleepMotion: number = Physics.sleepEpsilon * 5;\r\n\r\n  /**\r\n   * Can this body sleep, by default bodies do not sleep\r\n   */\r\n  public canSleep: boolean = Physics.bodiesCanSleepByDefault;\r\n\r\n  private _sleeping = false;\r\n  /**\r\n   * Whether this body is sleeping or not\r\n   */\r\n  public get sleeping(): boolean {\r\n    return this._sleeping;\r\n  }\r\n\r\n  /**\r\n   * Set the sleep state of the body\r\n   * @param sleeping\r\n   */\r\n  public setSleeping(sleeping: boolean) {\r\n    this._sleeping = sleeping;\r\n    if (!sleeping) {\r\n      // Give it a kick to keep it from falling asleep immediately\r\n      this.sleepMotion = Physics.sleepEpsilon * 5;\r\n    } else {\r\n      this.vel = Vector.Zero;\r\n      this.acc = Vector.Zero;\r\n      this.angularVelocity = 0;\r\n      this.sleepMotion = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping\r\n   */\r\n  public updateMotion() {\r\n    if (this._sleeping) {\r\n      this.setSleeping(true);\r\n    }\r\n    const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);\r\n    const bias = Physics.sleepBias;\r\n    this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;\r\n    this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);\r\n    if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {\r\n      this.setSleeping(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia from the [[ColliderComponent]]\r\n   */\r\n  public get inertia() {\r\n    // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?\r\n    const collider = this.owner.get(ColliderComponent);\r\n    if (collider?.get()) {\r\n      return collider.get().getInertia(this.mass);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseInertia() {\r\n    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;\r\n  }\r\n\r\n  /**\r\n   * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the\r\n   * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.\r\n   */\r\n  public bounciness: number = 0.2;\r\n\r\n  /**\r\n   * The coefficient of friction on this actor\r\n   */\r\n  public friction: number = 0.99;\r\n\r\n  /**\r\n   * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true\r\n   */\r\n  public useGravity: boolean = true;\r\n\r\n  /**\r\n   * Degrees of freedom to limit\r\n   */\r\n  public limitDegreeOfFreedom: DegreeOfFreedom[] = [];\r\n\r\n  /**\r\n   * Returns if the owner is active\r\n   */\r\n  public get active() {\r\n    return !!this.owner?.active;\r\n  }\r\n\r\n  public get center() {\r\n    return this.pos;\r\n  }\r\n\r\n  public get transform(): TransformComponent {\r\n    return this.owner?.get(TransformComponent);\r\n  }\r\n\r\n  public get motion(): MotionComponent {\r\n    return this.owner?.get(MotionComponent);\r\n  }\r\n\r\n  /**\r\n   * The (x, y) position of the actor this will be in the middle of the actor if the\r\n   * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n   * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n   */\r\n  public get pos(): Vector {\r\n    return this.transform.globalPos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this.transform.globalPos = val;\r\n  }\r\n\r\n  /**\r\n   * The position of the actor last frame (x, y) in pixels\r\n   */\r\n  public oldPos: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * The current velocity vector (vx, vy) of the actor in pixels/second\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this.motion.vel = val;\r\n  }\r\n\r\n  /**\r\n   * The velocity of the actor last frame (vx, vy) in pixels/second\r\n   */\r\n  public oldVel: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n   * be useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  public set acc(val: Vector) {\r\n    this.motion.acc = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public oldAcc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The current torque applied to the actor\r\n   */\r\n  public get torque(): number {\r\n    return this.motion.torque;\r\n  }\r\n\r\n  public set torque(val: number) {\r\n    this.motion.torque = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the rotation of the body from the last frame.\r\n   */\r\n  public oldRotation: number = 0; // radians\r\n\r\n  /**\r\n   * The rotation of the body in radians\r\n   */\r\n  public get rotation() {\r\n    return this.transform.globalRotation;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    this.transform.globalRotation = val;\r\n  }\r\n\r\n  /**\r\n   * The scale vector of the actor\r\n   * @deprecated ex.Body.scale will be removed in v0.25.0, Use ex.Transform.scale\r\n   */\r\n  public get scale(): Vector {\r\n    return this.transform.globalScale;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    this.transform.globalScale = val;\r\n  }\r\n\r\n  /**\r\n   * The scale of the actor last frame\r\n   * @deprecated ex.Body.scale will be removed in v0.25.0\r\n   */\r\n  public oldScale: Vector = Vector.One;\r\n\r\n  /**\r\n   * The x scalar velocity of the actor in scale/second\r\n   * @deprecated ex.Body.scale will be removed in v0.25.0\r\n   */\r\n  public get sx(): number {\r\n    return this.motion.scaleFactor.x;\r\n  }\r\n\r\n  public set sx(xFactor: number) {\r\n    this.motion.scaleFactor.x = xFactor;\r\n  }\r\n\r\n  /**\r\n   * The y scalar velocity of the actor in scale/second\r\n   * @deprecated ex.Body.scale will be removed in v0.25.0\r\n   */\r\n  public get sy(): number {\r\n    return this.motion.scaleFactor.y;\r\n  }\r\n\r\n  public set sy(yFactor: number) {\r\n    this.motion.scaleFactor.y = yFactor;\r\n  }\r\n\r\n  /**\r\n   * The rotational velocity of the actor in radians/second\r\n   * @deprecated\r\n   */\r\n  public get rx(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * The rotational velocity of the actor in radians/second\r\n   * @deprecated\r\n   */\r\n  public set rx(value: number) {\r\n    this.motion.angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Get the angular velocity in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Set the angular velocity in radians/second\r\n   */\r\n  public set angularVelocity(value: number) {\r\n    this.motion.angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Apply a specific impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel.addEqual(finalImpulse);\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.pos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply only linear impulse to the body\r\n   * @param impulse\r\n   */\r\n  public applyLinearImpulse(impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel = this.vel.add(finalImpulse);\r\n  }\r\n\r\n  /**\r\n   * Apply only angular impuse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyAngularImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.pos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the old versions of pos, vel, acc, and scale.\r\n   */\r\n  public captureOldTransform() {\r\n    // Capture old values before integration step updates them\r\n    this.oldVel.setTo(this.vel.x, this.vel.y);\r\n    this.oldPos.setTo(this.pos.x, this.pos.y);\r\n    this.oldAcc.setTo(this.acc.x, this.acc.y);\r\n    this.oldScale.setTo(this.scale.x, this.scale.y);\r\n    this.oldRotation = this.rotation;\r\n  }\r\n\r\n  debugDraw(_ctx: CanvasRenderingContext2D) {\r\n    // pass\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\nimport { Actor } from '../Actor';\nimport { Engine } from '../Engine';\nimport { Color } from '../Color';\n\n/**\n * @deprecated Will be removed in 0.26.0\n */\nexport class CullingBox {\n  private _topLeft: Vector = new Vector(0, 0);\n  private _topRight: Vector = new Vector(0, 0);\n  private _bottomLeft: Vector = new Vector(0, 0);\n  private _bottomRight: Vector = new Vector(0, 0);\n\n  private _xCoords: Array<number>;\n  private _yCoords: Array<number>;\n  private _xMin: number;\n  private _yMin: number;\n  private _xMax: number;\n  private _yMax: number;\n\n  private _xMinWorld: number;\n  private _yMinWorld: number;\n  private _xMaxWorld: number;\n  private _yMaxWorld: number;\n\n  public isSpriteOffScreen(actor: Actor, engine: Engine): boolean {\n    const drawingWidth = actor.currentDrawing.drawWidth;\n    const drawingHeight = actor.currentDrawing.drawHeight;\n    const rotation = actor.rotation;\n    const anchor = actor.center;\n    const worldPos = actor.getGlobalPos();\n\n    this._topLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y - drawingHeight / 2);\n    this._topLeft = this._topLeft.rotate(rotation, anchor);\n\n    this._topRight = vec(worldPos.x + drawingWidth / 2, worldPos.y - drawingHeight / 2);\n    this._topRight = this._topRight.rotate(rotation, anchor);\n\n    this._bottomLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y + drawingHeight / 2);\n    this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);\n\n    this._bottomRight = vec(worldPos.x + drawingWidth / 2, worldPos.y + drawingHeight / 2);\n    this._bottomRight = this._bottomRight.rotate(rotation, anchor);\n\n    const topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);\n    const topRightScreen = engine.worldToScreenCoordinates(this._topRight);\n    const bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);\n    const bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);\n    this._xCoords = [];\n    this._yCoords = [];\n\n    this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);\n    this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);\n\n    this._xMin = Math.min.apply(null, this._xCoords);\n    this._yMin = Math.min.apply(null, this._yCoords);\n    this._xMax = Math.max.apply(null, this._xCoords);\n    this._yMax = Math.max.apply(null, this._yCoords);\n\n    const minWorld = engine.screenToWorldCoordinates(new Vector(this._xMin, this._yMin));\n    const maxWorld = engine.screenToWorldCoordinates(new Vector(this._xMax, this._yMax));\n    this._xMinWorld = minWorld.x;\n    this._yMinWorld = minWorld.y;\n    this._xMaxWorld = maxWorld.x;\n    this._yMaxWorld = maxWorld.y;\n\n    const boundingPoints = [\n      new Vector(this._xMin, this._yMin), // top left\n      new Vector(this._xMax, this._yMin), // top right\n      new Vector(this._xMin, this._yMax), // bottom left\n      new Vector(this._xMax, this._yMax) // bottom right\n    ];\n\n    // sprite can be wider than canvas screen (and still visible within canvas)\n    // top or bottom of sprite must be within canvas\n    if (\n      boundingPoints[0].x < 0 &&\n      boundingPoints[1].x > engine.canvas.clientWidth &&\n      (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)\n    ) {\n      return false;\n    }\n\n    // sprite can be taller than canvas screen (and still visible within canvas)\n    // left or right of sprite must be within canvas\n    if (\n      boundingPoints[0].y < 0 &&\n      boundingPoints[2].y > engine.canvas.clientHeight &&\n      (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)\n    ) {\n      return false;\n    }\n\n    // otherwise if any corner is visible, we're not offscreen\n    for (let i = 0; i < boundingPoints.length; i++) {\n      if (\n        boundingPoints[i].x > 0 &&\n        boundingPoints[i].y > 0 &&\n        boundingPoints[i].x < engine.canvas.clientWidth &&\n        boundingPoints[i].y < engine.canvas.clientHeight\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public debugDraw(ctx: CanvasRenderingContext2D) {\n    // bounding rectangle\n    ctx.beginPath();\n    ctx.strokeStyle = Color.White.toString();\n    ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);\n    ctx.stroke();\n\n    ctx.fillStyle = Color.Red.toString();\n    ctx.beginPath();\n    ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = Color.Green.toString();\n    ctx.beginPath();\n    ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = Color.Blue.toString();\n    ctx.beginPath();\n    ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = Color.Magenta.toString();\n    ctx.beginPath();\n    ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n  }\n}\n","import { CullingBox } from './../Util/CullingBox';\nimport { Trait } from '../Interfaces/Trait';\nimport { Actor } from '../Actor';\nimport { Engine } from '../Engine';\nimport { ExitViewPortEvent, EnterViewPortEvent } from '../Events';\nimport { TagComponent } from '../EntityComponentSystem';\n\n/**\n * @deprecated will be removed in 0.26.0\n */\nexport class OffscreenCulling implements Trait {\n  public cullingBox: CullingBox = new CullingBox();\n\n  public update(actor: Actor, engine: Engine) {\n    const events = actor.eventDispatcher;\n\n    let isSpriteOffScreen = true;\n    if (actor.currentDrawing != null) {\n      isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);\n    }\n\n    let actorBoundsOffscreen = false;\n    if (engine && engine.currentScene && engine.currentScene.camera && engine.currentScene.camera.viewport && !actor.parent) {\n      actorBoundsOffscreen = !engine.currentScene.camera.viewport.intersect(actor.collider.bounds);\n    }\n\n    if (!actor.isOffScreen) {\n      if (actorBoundsOffscreen && isSpriteOffScreen) {\n        events.emit('exitviewport', new ExitViewPortEvent(actor));\n        actor.addComponent(new TagComponent('offscreen'));\n      }\n    } else {\n      if (!actorBoundsOffscreen || !isSpriteOffScreen) {\n        events.emit('enterviewport', new EnterViewPortEvent(actor));\n        actor.removeComponent('offscreen');\n      }\n    }\n  }\n}\n","import { Trait } from '../Interfaces/Trait';\r\nimport { Actor } from '../Actor';\r\nimport { Engine } from '../Engine';\r\n\r\n/**\r\n * Revises pointer events path accordingly to the actor\r\n * @deprecated Will be removed in 0.26.0\r\n */\r\nexport class CapturePointer implements Trait {\r\n  public update(actor: Actor, engine: Engine) {\r\n    if (!actor.enableCapturePointer) {\r\n      return;\r\n    }\r\n    if (actor.isKilled()) {\r\n      return;\r\n    }\r\n\r\n    engine.input.pointers.checkAndUpdateActorUnderPointer(actor);\r\n  }\r\n}\r\n","import { Component, ComponentCtor, TagComponent } from './Component';\r\n\r\nimport { Observable, Message } from '../Util/Observable';\r\nimport { Class } from '../Class';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate } from '../Interfaces/LifecycleEvents';\r\nimport { Engine } from '../Engine';\r\nimport { InitializeEvent, PreUpdateEvent, PostUpdateEvent } from '../Events';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { Util } from '..';\r\n\r\n/**\r\n * Interface holding an entity component pair\r\n */\r\nexport interface EntityComponent {\r\n  component: Component;\r\n  entity: Entity;\r\n}\r\n\r\n/**\r\n * AddedComponent message\r\n */\r\nexport class AddedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Added' = 'Component Added';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is f an Added Component\r\n */\r\nexport function isAddedComponent(x: Message<EntityComponent>): x is AddedComponent {\r\n  return !!x && x.type === 'Component Added';\r\n}\r\n\r\n/**\r\n * RemovedComponent message\r\n */\r\nexport class RemovedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Removed' = 'Component Removed';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is for a Removed Component\r\n */\r\nexport function isRemovedComponent(x: Message<EntityComponent>): x is RemovedComponent {\r\n  return !!x && x.type === 'Component Removed';\r\n}\r\n\r\n/**\r\n * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system\r\n *\r\n * Entities can be strongly typed with the components they contain\r\n *\r\n * ```typescript\r\n * const entity = new Entity<ComponentA | ComponentB>();\r\n * entity.components.a; // Type ComponentA\r\n * entity.components.b; // Type ComponentB\r\n * ```\r\n */\r\nexport class Entity extends Class implements OnInitialize, OnPreUpdate, OnPostUpdate {\r\n  private static _ID = 0;\r\n\r\n  constructor(components?: Component[], name?: string) {\r\n    super();\r\n    this._setName(name);\r\n    if (components) {\r\n      for (const component of components) {\r\n        this.addComponent(component);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The unique identifier for the entity\r\n   */\r\n  public id: number = Entity._ID++;\r\n\r\n  private _name: string = 'anonymous';\r\n  protected _setName(name: string) {\r\n    if (name) {\r\n      this._name = name;\r\n    }\r\n  }\r\n  public get name(): string {\r\n    return this._name;\r\n  }\r\n\r\n  public get events(): EventDispatcher {\r\n    return this.eventDispatcher;\r\n  }\r\n\r\n  /**\r\n   * Whether this entity is active, if set to false it will be reclaimed\r\n   */\r\n  public active: boolean = true;\r\n\r\n  /**\r\n   * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.\r\n   */\r\n  public kill() {\r\n    this.active = false;\r\n  }\r\n\r\n  public isKilled() {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Specifically get the tags on the entity from [[TagComponent]]\r\n   */\r\n  public get tags(): readonly string[] {\r\n    return this._tagsMemo;\r\n  }\r\n\r\n  /**\r\n   * Check if a tag exists on the entity\r\n   * @param tag name to check for\r\n   */\r\n  public hasTag(tag: string): boolean {\r\n    return this.tags.includes(tag);\r\n  }\r\n\r\n  /**\r\n   * Adds a tag to an entity\r\n   * @param tag\r\n   * @returns Entity\r\n   */\r\n  public addTag(tag: string) {\r\n    return this.addComponent(new TagComponent(tag));\r\n  }\r\n\r\n  /**\r\n   * Removes a tag on the entity\r\n   *\r\n   * Removals are deferred until the end of update\r\n   * @param tag\r\n   * @param force Remove component immediately, no deferred\r\n   */\r\n  public removeTag(tag: string, force = false) {\r\n    return this.removeComponent(tag, force);\r\n  }\r\n\r\n  /**\r\n   * The types of the components on the Entity\r\n   */\r\n  public get types(): string[] {\r\n    return this._typesMemo;\r\n  }\r\n\r\n  /**\r\n   * Bucket to hold on to deferred removals\r\n   */\r\n  private _componentsToRemove: (Component | string)[] = [];\r\n  private _componentTypeToInstance = new Map<ComponentCtor, Component>();\r\n  private _componentStringToInstance = new Map<string, Component>();\r\n\r\n  private _tagsMemo: string[] = [];\r\n  private _typesMemo: string[] = [];\r\n  private _rebuildMemos() {\r\n    this._tagsMemo = Array.from(this._componentStringToInstance.values())\r\n      .filter((c) => c instanceof TagComponent)\r\n      .map((c) => c.type);\r\n    this._typesMemo = Array.from(this._componentStringToInstance.keys());\r\n  }\r\n\r\n  public getComponents(): Component[] {\r\n    return Array.from(this._componentStringToInstance.values());\r\n  }\r\n\r\n  /**\r\n   * Observable that keeps track of component add or remove changes on the entity\r\n   */\r\n  public componentAdded$ = new Observable<AddedComponent>();\r\n  private _notifyAddComponent(component: Component) {\r\n    this._rebuildMemos();\r\n    const added = new AddedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentAdded$.notifyAll(added);\r\n  }\r\n\r\n  public componentRemoved$ = new Observable<RemovedComponent>();\r\n  private _notifyRemoveComponent(component: Component) {\r\n    const removed = new RemovedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentRemoved$.notifyAll(removed);\r\n    this._rebuildMemos();\r\n  }\r\n\r\n  private _parent: Entity = null;\r\n  public get parent(): Entity {\r\n    return this._parent;\r\n  }\r\n\r\n  public childrenAdded$ = new Observable<Entity>();\r\n  public childrenRemoved$ = new Observable<Entity>();\r\n\r\n  private _children: Entity[] = [];\r\n  /**\r\n   * Get the direct children of this entity\r\n   */\r\n  public get children(): readonly Entity[] {\r\n    return this._children;\r\n  }\r\n\r\n  /**\r\n   * Unparents this entity, if there is a parent. Otherwise it does nothing.\r\n   */\r\n  public unparent() {\r\n    if (this._parent) {\r\n      this._parent.removeChild(this);\r\n      this._parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be a child of this entity\r\n   * @param entity\r\n   */\r\n  public addChild(entity: Entity): Entity {\r\n    if (entity.parent === null) {\r\n      if (this.getAncestors().includes(entity)) {\r\n        throw new Error('Cycle detected, cannot add entity');\r\n      }\r\n      this._children.push(entity);\r\n      entity._parent = this;\r\n      this.childrenAdded$.notifyAll(entity);\r\n    } else {\r\n      throw new Error('Entity already has a parent, cannot add without unparenting');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from children if it exists\r\n   * @param entity\r\n   */\r\n  public removeChild(entity: Entity): Entity {\r\n    if (entity.parent === this) {\r\n      Util.removeItemFromArray(entity, this._children);\r\n      entity._parent = null;\r\n      this.childrenRemoved$.notifyAll(entity);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all children from this entity\r\n   */\r\n  public removeAllChildren(): Entity {\r\n    this.children.forEach((c) => {\r\n      this.removeChild(c);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of parent entities starting with the topmost parent. Includes the current entity.\r\n   */\r\n  public getAncestors(): Entity[] {\r\n    const result: Entity[] = [this];\r\n    let current = this.parent;\r\n    while (current) {\r\n      result.push(current);\r\n      current = current.parent;\r\n    }\r\n    return result.reverse();\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all the entities that descend from this entity. Includes the current entity.\r\n   */\r\n  public getDescendants(): Entity[] {\r\n    let result: Entity[] = [this];\r\n    let queue: Entity[] = [this];\r\n    while (queue.length > 0) {\r\n      const curr = queue.pop();\r\n      queue = queue.concat(curr.children);\r\n      result = result.concat(curr.children);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a deep copy of the entity and a copy of all its components\r\n   */\r\n  public clone(): Entity {\r\n    const newEntity = new Entity();\r\n    for (const c of this.types) {\r\n      newEntity.addComponent(this.get(c).clone());\r\n    }\r\n    for (const child of this.children) {\r\n      newEntity.addChild(child.clone());\r\n    }\r\n    return newEntity;\r\n  }\r\n\r\n  /**\r\n   * Adds a copy of all the components from another template entity as a \"prefab\"\r\n   * @param templateEntity Entity to use as a template\r\n   * @param force Force component replacement if it aleady exists on the target entity\r\n   */\r\n  public addTemplate(templateEntity: Entity, force: boolean = false): Entity {\r\n    for (const c of templateEntity.getComponents()) {\r\n      this.addComponent(c.clone(), force);\r\n    }\r\n    for (const child of templateEntity.children) {\r\n      this.addChild(child.clone().addTemplate(child));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a component to the entity\r\n   * @param component Component or Entity to add copy of components from\r\n   * @param force Optionally overwrite any existing components of the same type\r\n   */\r\n  public addComponent<T extends Component>(component: T, force: boolean = false): Entity {\r\n    // if component already exists, skip if not forced\r\n    if (this.has(component.type)) {\r\n      if (force) {\r\n        // Remove existing component type if exists when forced\r\n        this.removeComponent(component);\r\n      } else {\r\n        // early exit component exiss\r\n        return this;\r\n      }\r\n    }\r\n\r\n    // TODO circular dependencies will be a problem\r\n    if (component.dependencies && component.dependencies.length) {\r\n      for (const ctor of component.dependencies) {\r\n        this.addComponent(new ctor());\r\n      }\r\n    }\r\n\r\n    component.owner = this;\r\n    const constuctorType = component.constructor as ComponentCtor<T>;\r\n    this._componentTypeToInstance.set(constuctorType, component);\r\n    this._componentStringToInstance.set(component.type, component);\r\n    if (component.onAdd) {\r\n      component.onAdd(this);\r\n    }\r\n    this._notifyAddComponent(component);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues\r\n   *\r\n   * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately\r\n   * @param componentOrType\r\n   * @param force\r\n   */\r\n  public removeComponent<ComponentOrType extends string | Component>(componentOrType: ComponentOrType, force = false): Entity {\r\n    if (force) {\r\n      if (typeof componentOrType === 'string') {\r\n        this._removeComponentByType(componentOrType);\r\n      } else if (componentOrType instanceof Component) {\r\n        this._removeComponentByType(componentOrType.type);\r\n      }\r\n    } else {\r\n      this._componentsToRemove.push(componentOrType);\r\n    }\r\n\r\n    return this as any;\r\n  }\r\n\r\n  private _removeComponentByType(type: string) {\r\n    if (this.has(type)) {\r\n      const component = this.get(type);\r\n      component.owner = null;\r\n      if (component.onRemove) {\r\n        component.onRemove(this);\r\n      }\r\n      const ctor = component.constructor as ComponentCtor;\r\n      this._componentTypeToInstance.delete(ctor);\r\n      this._componentStringToInstance.delete(component.type);\r\n      this._notifyRemoveComponent(component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @internal\r\n   */\r\n  public processComponentRemoval() {\r\n    for (const componentOrType of this._componentsToRemove) {\r\n      const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;\r\n      this._removeComponentByType(type);\r\n    }\r\n    this._componentsToRemove.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Check if a component type exists\r\n   * @param type\r\n   */\r\n  public has<T extends Component>(type: ComponentCtor<T>): boolean;\r\n  public has(type: string): boolean;\r\n  public has<T extends Component>(type: ComponentCtor<T> | string): boolean {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.has(type);\r\n    } else {\r\n      return this._componentTypeToInstance.has(type);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a component by type with typecheck\r\n   *\r\n   * (Does not work on tag components, use .hasTag(\"mytag\") instead)\r\n   * @param type\r\n   */\r\n  public get<T extends Component>(type: ComponentCtor<T>): T | null;\r\n  public get<T extends Component>(type: string): T | null;\r\n  public get<T extends Component>(type: ComponentCtor<T> | string): T | null {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.get(type) as T;\r\n    } else {\r\n      return this._componentTypeToInstance.get(type) as T;\r\n    }\r\n  }\r\n\r\n  private _isInitialized = false;\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overriden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overriden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overriden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the entity. This method is meant to be\r\n   * overridden.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an entity is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an entity is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Entity update lifecycle, called internally\r\n   *\r\n   * @internal\r\n   * @param engine\r\n   * @param delta\r\n   */\r\n  public update(engine: Engine, delta: number): void {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    for (const child of this.children) {\r\n      child.update(engine, delta);\r\n    }\r\n    this._postupdate(engine, delta);\r\n  }\r\n}\r\n","import { Component } from '../EntityComponentSystem';\r\n\r\n/**\r\n * Shim to draw to the canvas when in LegacyDrawing mode\r\n * @deprecated\r\n */\r\nexport class CanvasDrawComponent extends Component<'ex.canvas'> {\r\n  public readonly type = 'ex.canvas';\r\n\r\n  constructor(public draw?: (ctx: CanvasRenderingContext2D, delta: number) => void) {\r\n    super();\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    this.draw = this.draw ?? (() => {});\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { Graphic } from './Graphic';\r\nimport { HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Logger } from '../Util/Log';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)\r\n * @param graphic\r\n */\r\nexport function hasGraphicsTick(graphic: Graphic): graphic is Graphic & HasTick {\r\n  return !!(graphic as unknown as HasTick).tick;\r\n}\r\nexport interface GraphicsShowOptions {\r\n  offset?: Vector;\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsComponentOptions {\r\n  onPostDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n  onPreDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n\r\n  /**\r\n   * Name of current graphic to use\r\n   */\r\n  current?: string;\r\n\r\n  /**\r\n   * Optionally copy instances of graphics by calling .clone(), you may set this to false to avoid sharing graphics when added to the\r\n   * component for performance reasons. By default graphics are not copied and are shared when added to the component.\r\n   */\r\n  copyGraphics?: boolean;\r\n\r\n  /**\r\n   * Optional visible flag, if the graphics component is not visible it will not be displayed\r\n   */\r\n  visible?: boolean;\r\n\r\n  /**\r\n   * Optional opacity\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * List of graphics\r\n   */\r\n  graphics?: { [graphicName: string]: Graphic };\r\n\r\n  /**\r\n   * Optional offset in absolute pixels to shift all graphics in this component from each graphic's anchor (default is top left corner)\r\n   */\r\n  offset?: Vector;\r\n\r\n  /**\r\n   * Optional anchor\r\n   */\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsLayerOptions {\r\n  /**\r\n   * Name of the layer required, for example 'background'\r\n   */\r\n  name: string;\r\n  /**\r\n   * Order of the layer, a layer with order -1 will be below a layer with order of 1\r\n   */\r\n  order: number;\r\n  /**\r\n   * Offset to shift the entire layer\r\n   */\r\n  offset?: Vector;\r\n}\r\nexport class GraphicsLayer {\r\n  public graphics: { graphic: Graphic; options: GraphicsShowOptions }[] = [];\r\n  constructor(private _options: GraphicsLayerOptions, private _graphics: GraphicsComponent) {}\r\n  public get name(): string {\r\n    return this._options.name;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in this layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in this layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    if (!nameOrGraphic) {\r\n      this.graphics.length = 0;\r\n    } else {\r\n      let gfx: Graphic = null;\r\n      if (nameOrGraphic instanceof Graphic) {\r\n        gfx = nameOrGraphic;\r\n      } else {\r\n        gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      }\r\n      this.graphics = this.graphics.filter((g) => g.graphic !== gfx);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.\r\n   *\r\n   * If `show()` is called multiple times for the same graphic it will be shown multiple times.\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    let gfx: Graphic;\r\n    if (nameOrGraphic instanceof Graphic) {\r\n      gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;\r\n    } else {\r\n      gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      if (!gfx) {\r\n        Logger.getInstance().error(\r\n          `No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `,\r\n          this._graphics.getNames()\r\n        );\r\n      }\r\n    }\r\n    if (gfx) {\r\n      this.graphics.push({ graphic: gfx, options });\r\n      return gfx as T;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use a specific graphic, swap out any current graphics being shown\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    this.hide();\r\n    return this.show<T>(nameOrGraphic, options);\r\n  }\r\n\r\n  /**\r\n   * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public get order(): number {\r\n    return this._options.order;\r\n  }\r\n\r\n  /**\r\n   * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public set order(order: number) {\r\n    this._options.order = order;\r\n  }\r\n\r\n  /**\r\n   * Get or set the pixel offset from the layer anchor for all graphics in the layer\r\n   */\r\n  public get offset(): Vector {\r\n    return this._options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  public set offset(value: Vector) {\r\n    this._options.offset = value;\r\n  }\r\n\r\n  public get currentKeys(): string {\r\n    return this.name ?? 'anonymous';\r\n  }\r\n}\r\n\r\nexport class GraphicsLayers {\r\n  private _layers: GraphicsLayer[] = [];\r\n  private _layerMap: { [layerName: string]: GraphicsLayer } = {};\r\n  public default: GraphicsLayer;\r\n  constructor(private _component: GraphicsComponent) {\r\n    this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);\r\n    this._maybeAddLayer(this.default);\r\n  }\r\n  public create(options: GraphicsLayerOptions): GraphicsLayer {\r\n    const layer = new GraphicsLayer(options, this._component);\r\n    return this._maybeAddLayer(layer);\r\n  }\r\n\r\n  /**\r\n   * Retrieve a single layer by name\r\n   * @param name\r\n   */\r\n  public get(name: string): GraphicsLayer;\r\n  /**\r\n   * Retrieve all layers\r\n   */\r\n  public get(): readonly GraphicsLayer[];\r\n  public get(name?: string): GraphicsLayer | readonly GraphicsLayer[] {\r\n    if (name) {\r\n      return this._getLayer(name);\r\n    }\r\n    return this._layers;\r\n  }\r\n\r\n  public currentKeys() {\r\n    const graphicsLayerKeys = [];\r\n    for (const layer of this._layers) {\r\n      graphicsLayerKeys.push(layer.currentKeys);\r\n    }\r\n    return graphicsLayerKeys;\r\n  }\r\n\r\n  public has(name: string): boolean {\r\n    return name in this._layerMap;\r\n  }\r\n\r\n  private _maybeAddLayer(layer: GraphicsLayer) {\r\n    if (this._layerMap[layer.name]) {\r\n      // todo log warning\r\n      return this._layerMap[layer.name];\r\n    }\r\n    this._layerMap[layer.name] = layer;\r\n    this._layers.push(layer);\r\n    this._layers.sort((a, b) => a.order - b.order);\r\n    return layer;\r\n  }\r\n\r\n  private _getLayer(name: string): GraphicsLayer | undefined {\r\n    return this._layerMap[name];\r\n  }\r\n}\r\n\r\n/**\r\n * Component to manage drawings, using with the position component\r\n */\r\nexport class GraphicsComponent extends Component<'ex.graphics'> {\r\n  readonly type = 'ex.graphics';\r\n\r\n  private _graphics: { [graphicName: string]: Graphic } = {};\r\n\r\n  public layers: GraphicsLayers;\r\n\r\n  public getGraphic(name: string): Graphic | undefined {\r\n    return this._graphics[name];\r\n  }\r\n\r\n  /**\r\n   * Get registered graphics names\r\n   */\r\n  public getNames(): string[] {\r\n    return Object.keys(this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Draws after the entity transform has bene applied, but before graphics component graphics have been drawn\r\n   */\r\n  public onPreDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Draws after the entity transform has been applied, and after graphics component graphics has been drawn\r\n   */\r\n  public onPostDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Sets or gets wether any drawing should be visible in this component\r\n   */\r\n  public visible: boolean = true;\r\n\r\n  /**\r\n   * Sets or gets wither all drawings should have an opacity applied\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  /**\r\n   * Offset to apply to graphics by default\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Anchor to apply to graphics by default\r\n   */\r\n  public anchor: Vector = Vector.Half;\r\n\r\n  /**\r\n   * If set to true graphics added to the component will be copied. This can affect performance\r\n   */\r\n  public copyGraphics: boolean = false;\r\n\r\n  constructor(options?: GraphicsComponentOptions) {\r\n    super();\r\n    // Defaults\r\n    options = {\r\n      visible: this.visible,\r\n      ...options\r\n    };\r\n\r\n    const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;\r\n\r\n    this._graphics = graphics || {};\r\n    this.offset = offset ?? this.offset;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.anchor = anchor ?? this.anchor;\r\n    this.copyGraphics = copyGraphics ?? this.copyGraphics;\r\n    this.onPreDraw = onPreDraw ?? this.onPreDraw;\r\n    this.onPostDraw = onPostDraw ?? this.onPostDraw;\r\n    this.visible = !!visible;\r\n\r\n    this.layers = new GraphicsLayers(this);\r\n    if (current && this._graphics[current]) {\r\n      this.show(this._graphics[current]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the currently displayed graphics and their offsets, empty array if hidden\r\n   */\r\n  public get current(): { graphic: Graphic; options: GraphicsShowOptions }[] {\r\n    return this.layers.default.graphics;\r\n  }\r\n\r\n  /**\r\n   * Returns all graphics associated with this component\r\n   */\r\n  public get graphics(): { [graphicName: string]: Graphic } {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Adds a named graphic to this component, if the name is \"default\" or not specified, it will be shown by default without needing to call\r\n   * `show(\"default\")`\r\n   * @param graphic\r\n   */\r\n  public add(graphic: Graphic): Graphic;\r\n  public add(name: string, graphic: Graphic): Graphic;\r\n  public add(nameOrGraphic: string | Graphic, graphic?: Graphic): Graphic {\r\n    let name = 'default';\r\n    let graphicToSet: Graphic = null;\r\n    if (typeof nameOrGraphic === 'string') {\r\n      name = nameOrGraphic;\r\n      graphicToSet = graphic;\r\n    } else {\r\n      graphicToSet = nameOrGraphic;\r\n    }\r\n\r\n    this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;\r\n    if (name === 'default') {\r\n      this.show('default');\r\n    }\r\n    return graphicToSet;\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name on the **default** layer, returns the new [[Graphic]]\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    return this.layers.default.show<T>(nameOrGraphic, options);\r\n  }\r\n\r\n  /**\r\n   * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    return this.layers.default.use<T>(nameOrGraphic, options);\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in the **default** layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in the **default** layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    this.layers.default.hide(nameOrGraphic);\r\n  }\r\n\r\n  private _bounds: BoundingBox = null;\r\n  public set localBounds(bounds: BoundingBox) {\r\n    this._bounds = bounds;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    if (this._bounds) {\r\n      return this._bounds;\r\n    }\r\n    let bb = new BoundingBox();\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic, options } of layer.graphics) {\r\n        let anchor = this.anchor;\r\n        let offset = this.offset;\r\n        if (options?.anchor) {\r\n          anchor = options.anchor;\r\n        }\r\n        if (options?.offset) {\r\n          offset = options.offset;\r\n        }\r\n        const bounds = graphic.localBounds;\r\n        const offsetX = -bounds.width * graphic.scale.x * anchor.x + offset.x;\r\n        const offsetY = -bounds.height * graphic.scale.y * anchor.y + offset.y;\r\n        bb = graphic?.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);\r\n      }\r\n    }\r\n    return bb;\r\n  }\r\n\r\n  /**\r\n   * Update underlying graphics if necesary, called internally\r\n   * @param elapsed\r\n   * @internal\r\n   */\r\n  public update(elapsed: number, idempotencyToken: number = 0) {\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic } of layer.graphics) {\r\n        if (hasGraphicsTick(graphic)) {\r\n          graphic?.tick(elapsed, idempotencyToken);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface RectangleOptions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\n/**\r\n * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]\r\n */\r\nexport class Rectangle extends Raster {\r\n  constructor(options: RasterOptions & RectangleOptions) {\r\n    super(options);\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Rectangle {\r\n    return new Rectangle({\r\n      width: this.width,\r\n      height: this.height,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.color) {\r\n      ctx.fillRect(0, 0, this.width, this.height);\r\n    }\r\n    if (this.strokeColor) {\r\n      ctx.strokeRect(0, 0, this.width, this.height);\r\n    }\r\n  }\r\n}\r\n","import { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CircleOptions {\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]\r\n */\r\nexport class Circle extends Raster {\r\n  private _radius: number = 0;\r\n  public get radius() {\r\n    return this._radius;\r\n  }\r\n  public set radius(value: number) {\r\n    this._radius = value;\r\n    this.width = this._radius * 2;\r\n    this.height = this._radius * 2;\r\n    this.flagDirty();\r\n  }\r\n  constructor(options: RasterOptions & CircleOptions) {\r\n    super(options);\r\n    this.padding = options.padding ?? 2; // default 2 padding for circles looks nice\r\n    this.radius = options.radius;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Circle {\r\n    return new Circle({\r\n      radius: this.radius,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.radius > 0) {\r\n      ctx.beginPath();\r\n      ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);\r\n\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\nimport { obsolete } from '../Util/Decorators';\n\n/**\n * A definition of an EasingFunction. See [[EasingFunctions]].\n */\n// tslint:disable-next-line\nexport interface EasingFunction {\n  (currentTime: number, startValue: number, endValue: number, duration: number): number;\n}\n\n/**\n * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\n * Given a time, the function will return a value from positive startValue to positive endValue.\n *\n * ```js\n * function Linear (t) {\n *    return t * t;\n * }\n *\n * // accelerating from zero velocity\n * function EaseInQuad (t) {\n *    return t * t;\n * }\n *\n * // decelerating to zero velocity\n * function EaseOutQuad (t) {\n *    return t * (2 - t);\n * }\n *\n * // acceleration until halfway, then deceleration\n * function EaseInOutQuad (t) {\n *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n * }\n *\n * // accelerating from zero velocity\n * function EaseInCubic (t) {\n *    return t * t * t;\n * }\n *\n * // decelerating to zero velocity\n * function EaseOutCubic (t) {\n *    return (--t) * t * t + 1;\n * }\n *\n * // acceleration until halfway, then deceleration\n * function EaseInOutCubic (t) {\n *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n * }\n * ```\n */\nexport class EasingFunctions {\n  public static CreateReversibleEasingFunction(easing: EasingFunction) {\n    return (time: number, start: number, end: number, duration: number) => {\n      if (end < start) {\n        return start - (easing(time, end, start, duration) - end);\n      } else {\n        return easing(time, start, end, duration);\n      }\n    };\n  }\n\n  @obsolete({\n    message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',\n    alternateMethod: 'CreateReversibleEasingFunction'\n  })\n  public static CreateReversableEasingFunction(easing: EasingFunction) {\n    return EasingFunctions.CreateReversibleEasingFunction(easing);\n  }\n\n  public static CreateVectorEasingFunction(easing: EasingFunction) {\n    return (time: number, start: Vector, end: Vector, duration: number) => {\n      return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));\n    };\n  }\n\n  public static Linear: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      return (endValue * currentTime) / duration + startValue;\n    }\n  );\n\n  public static EaseInQuad = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      currentTime /= duration;\n\n      return endValue * currentTime * currentTime + startValue;\n    }\n  );\n\n  public static EaseOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      currentTime /= duration;\n      return -endValue * currentTime * (currentTime - 2) + startValue;\n    }\n  );\n\n  public static EaseInOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      currentTime /= duration / 2;\n\n      if (currentTime < 1) {\n        return (endValue / 2) * currentTime * currentTime + startValue;\n      }\n      currentTime--;\n\n      return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\n    }\n  );\n\n  public static EaseInCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      currentTime /= duration;\n      return endValue * currentTime * currentTime * currentTime + startValue;\n    }\n  );\n\n  public static EaseOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      currentTime /= duration;\n      currentTime--;\n      return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\n    }\n  );\n\n  public static EaseInOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\n      endValue = endValue - startValue;\n      currentTime /= duration / 2;\n      if (currentTime < 1) {\n        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;\n      }\n      currentTime -= 2;\n      return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;\n    }\n  );\n}\n","import { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * Action Queues represent an ordered sequence of actions\r\n *\r\n * Action queues are part of the [[ActionContext|Action API]] and\r\n * store the list of actions to be executed for an [[Actor]].\r\n *\r\n * Actors implement [[Actor.actions]] which can be manipulated by\r\n * advanced users to adjust the actions currently being executed in the\r\n * queue.\r\n */\r\nexport class ActionQueue {\r\n  private _entity: Entity;\r\n  private _actions: Action[] = [];\r\n  private _currentAction: Action;\r\n  private _completedActions: Action[] = [];\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  /**\r\n   * Add an action to the sequence\r\n   * @param action\r\n   */\r\n  public add(action: Action) {\r\n    this._actions.push(action);\r\n  }\r\n\r\n  /**\r\n   * Remove an action by reference from the sequence\r\n   * @param action\r\n   */\r\n  public remove(action: Action) {\r\n    const index = this._actions.indexOf(action);\r\n    this._actions.splice(index, 1);\r\n  }\r\n\r\n  /**\r\n   * Removes all actions from this sequence\r\n   */\r\n  public clearActions(): void {\r\n    this._actions.length = 0;\r\n    this._completedActions.length = 0;\r\n    if (this._currentAction) {\r\n      this._currentAction.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns The total list of actions in this sequence complete or not\r\n   */\r\n  public getActions(): Action[] {\r\n    return this._actions.concat(this._completedActions);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns `true` if there are more actions to process in the sequence\r\n   */\r\n  public hasNext(): boolean {\r\n    return this._actions.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @returns `true` if the current sequence of actions is done\r\n   */\r\n  public isComplete(): boolean {\r\n    return this._actions.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Resets the sequence of actions, this is used to restart a sequence from the beginning\r\n   */\r\n  public reset(): void {\r\n    this._actions = this.getActions();\r\n\r\n    const len = this._actions.length;\r\n    for (let i = 0; i < len; i++) {\r\n      this._actions[i].reset();\r\n    }\r\n    this._completedActions = [];\r\n  }\r\n\r\n  /**\r\n   * Update the queue which updates actions and handles completing actions\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number) {\r\n    if (this._actions.length > 0) {\r\n      this._currentAction = this._actions[0];\r\n      this._currentAction.update(elapsedMs);\r\n\r\n      if (this._currentAction.isComplete(this._entity)) {\r\n        this._completedActions.push(this._actions.shift());\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\nexport class Repeat implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _repeat: number;\r\n  private _originalRepeat: number;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any, repeat: number) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeat = repeat;\r\n    this._originalRepeat = repeat;\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n    this._repeat--; // current execution is the first repeat\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n      this._repeat--;\r\n    }\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._repeat = this._originalRepeat;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\n/**\r\n * RepeatForever Action implementation, it is recommended you use the fluent action\r\n * context API.\r\n *\r\n *\r\n */\r\nexport class RepeatForever implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._stopped) {\r\n      return;\r\n    }\r\n\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n    }\r\n\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n    this._actionQueue.clearActions();\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _entity: Entity;\r\n  public x: number;\r\n  public y: number;\r\n  private _distance: number;\r\n  private _speed: number;\r\n\r\n  private _start: Vector;\r\n  private _offset: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, offsetX: number, offsetY: number, speed: number) {\r\n    this._entity = entity;\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = new Vector(offsetX, offsetY);\r\n    if (speed <= 0) {\r\n      Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);\r\n      throw new Error('Speed must be greater than 0 pixels per second');\r\n    }\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._end = this._start.add(this._offset);\r\n      this._distance = this._offset.size;\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n\r\n    if (this.isComplete(this._entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    } else {\r\n      this._motion.vel = this._dir.scale(this._speed);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || tx.pos.distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distance: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(public entity: Entity, destx: number, desty: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = new Vector(destx, desty);\r\n    this._speed = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._distance = this._start.distance(this._end);\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete(this.entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the strategies that rotation actions can use\r\n */\r\nexport enum RotationType {\r\n  /**\r\n   * Rotation via `ShortestPath` will use the smallest angle\r\n   * between the starting and ending points. This strategy is the default behavior.\r\n   */\r\n  ShortestPath = 0,\r\n  /**\r\n   * Rotation via `LongestPath` will use the largest angle\r\n   * between the starting and ending points.\r\n   */\r\n  LongestPath = 1,\r\n  /**\r\n   * Rotation via `Clockwise` will travel in a clockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  Clockwise = 2,\r\n  /**\r\n   * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  CounterClockwise = 3\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport * as Util from '../../Util/Util';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\n\r\nexport class RotateTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadians: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = angleRadians;\r\n    this._speed = speed;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = Util.TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (!this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTravelled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport * as Util from '../../Util/Util';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\n\r\nexport class RotateBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _offset: number;\r\n\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadiansOffset: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = angleRadiansOffset;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      this._end = this._start + this._offset;\r\n\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = Util.TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortDistance >= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (this._shortDistance <= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTravelled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { vec } from '../../Math/vector';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\n\r\nexport class ScaleTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startX: number;\r\n  private _startY: number;\r\n  private _endX: number;\r\n  private _endY: number;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, scaleX: number, scaleY: number, speedX: number, speedY: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._endX = scaleX;\r\n    this._endY = scaleY;\r\n    this._speedX = speedX;\r\n    this._speedY = speedY;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startX = this._tx.scale.x;\r\n      this._startY = this._tx.scale.y;\r\n      this._distanceX = Math.abs(this._endX - this._startX);\r\n      this._distanceY = Math.abs(this._endY - this._startY);\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {\r\n      const directionX = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.x = this._speedX * directionX;\r\n    } else {\r\n      this._motion.scaleFactor.x = 0;\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {\r\n      const directionY = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.y = this._speedY * directionY;\r\n    } else {\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = vec(this._endX, this._endY);\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.y - this._startX) >= this._distanceX && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\n\r\nexport class ScaleBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startScale: Vector;\r\n  private _endScale: Vector;\r\n  private _offset: Vector;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _directionX: number;\r\n  private _directionY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  constructor(entity: Entity, scaleOffsetX: number, scaleOffsetY: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._offset = new Vector(scaleOffsetX, scaleOffsetY);\r\n    this._speedX = this._speedY = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startScale = this._tx.scale.clone();\r\n      this._endScale = this._startScale.add(this._offset);\r\n      this._distanceX = Math.abs(this._endScale.x - this._startScale.x);\r\n      this._distanceY = Math.abs(this._endScale.y - this._startScale.y);\r\n      this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;\r\n      this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;\r\n    }\r\n\r\n    this._motion.scaleFactor.x = this._speedX * this._directionX;\r\n    this._motion.scaleFactor.y = this._speedY * this._directionY;\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = this._endScale;\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX &&\r\n        Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY)\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class CallMethod implements Action {\r\n  private _method: () => any = null;\r\n  private _hasBeenCalled: boolean = false;\r\n  constructor(method: () => any) {\r\n    this._method = method;\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    this._method();\r\n    this._hasBeenCalled = true;\r\n  }\r\n  public isComplete() {\r\n    return this._hasBeenCalled;\r\n  }\r\n  public reset() {\r\n    this._hasBeenCalled = false;\r\n  }\r\n  public stop() {\r\n    this._hasBeenCalled = true;\r\n  }\r\n}\r\n","import { Entity} from '../../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Actor } from '../../Actor';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class EaseTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1 * 1000; // 1 second\r\n  private _lerpStart: Vector = new Vector(0, 0);\r\n  private _lerpEnd: Vector = new Vector(0, 0);\r\n  private _initialized: boolean = false;\r\n  private _stopped: boolean = false;\r\n  private _distance: number = 0;\r\n  constructor(\r\n    entity: Entity,\r\n    x: number,\r\n    y: number,\r\n    duration: number,\r\n    public easingFcn: (currentTime: number, startValue: number, endValue: number, duration: number) => number\r\n  ) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = new Vector(x, y);\r\n  }\r\n  private _initialize() {\r\n    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._currentLerpTime = 0;\r\n    this._distance = this._lerpStart.distance(this._lerpEnd);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._initialized) {\r\n      this._initialize();\r\n      this._initialized = true;\r\n    }\r\n\r\n    // Need to update lerp time first, otherwise the first update will always be zero\r\n    this._currentLerpTime += delta;\r\n    let newX = this._tx.pos.x;\r\n    let newY = this._tx.pos.y;\r\n    if (this._currentLerpTime < this._lerpDuration) {\r\n      if (this._lerpEnd.x < this._lerpStart.x) {\r\n        newX =\r\n          this._lerpStart.x -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n      } else {\r\n        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n      }\r\n\r\n      if (this._lerpEnd.y < this._lerpStart.y) {\r\n        newY =\r\n          this._lerpStart.y -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n      } else {\r\n        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n      }\r\n      // Given the lerp position figure out the velocity in pixels per second\r\n      this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n    } else {\r\n      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n      this._motion.vel = Vector.Zero;\r\n    }\r\n  }\r\n  public isComplete(actor: Actor): boolean {\r\n    return this._stopped || new Vector(actor.pos.x, actor.pos.y).distance(this._lerpStart) >= this._distance;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._initialized = false;\r\n  }\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n}\r\n","import { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\n\r\nexport class Blink implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  private _timeVisible: number = 0;\r\n  private _timeNotVisible: number = 0;\r\n  private _elapsedTime: number = 0;\r\n  private _totalTime: number = 0;\r\n  private _duration: number;\r\n  private _stopped: boolean = false;\r\n  private _started: boolean = false;\r\n  constructor(entity: Entity, timeVisible: number, timeNotVisible: number, numBlinks: number = 1) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._timeVisible = timeVisible;\r\n    this._timeNotVisible = timeNotVisible;\r\n    this._duration = (timeVisible + timeNotVisible) * numBlinks;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n    }\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n    this._totalTime += delta;\r\n    if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {\r\n      this._graphics.visible = false;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {\r\n      this._graphics.visible = true;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.visible = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._totalTime >= this._duration;\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this._graphics) {\r\n      this._graphics.visible = true;\r\n    }\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset() {\r\n    this._started = false;\r\n    this._elapsedTime = 0;\r\n    this._totalTime = 0;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class Fade implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  public x: number;\r\n  public y: number;\r\n\r\n  private _endOpacity: number;\r\n  private _speed: number;\r\n  private _multiplier: number = 1;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, endOpacity: number, speed: number) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._endOpacity = endOpacity;\r\n    this._speed = speed;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    if (!this._started) {\r\n      this._started = true;\r\n\r\n      // determine direction when we start\r\n      if (this._endOpacity < this._graphics.opacity) {\r\n        this._multiplier = -1;\r\n      } else {\r\n        this._multiplier = 1;\r\n      }\r\n    }\r\n\r\n    if (this._speed > 0) {\r\n      this._graphics.opacity += (this._multiplier *\r\n        (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;\r\n    }\r\n\r\n    this._speed -= delta;\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.opacity = this._endOpacity;\r\n    }\r\n\r\n    Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class Delay implements Action {\r\n  private _elapsedTime: number = 0;\r\n  private _delay: number;\r\n  private _started: boolean = false;\r\n  private _stopped = false;\r\n  constructor(delay: number) {\r\n    this._delay = delay;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n  }\r\n\r\n  isComplete(): boolean {\r\n    return this._stopped || this._elapsedTime >= this._delay;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  reset(): void {\r\n    this._elapsedTime = 0;\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionsComponent } from '../ActionsComponent';\r\n\r\nexport class Die implements Action {\r\n  private _entity: Entity;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    this._entity.get(ActionsComponent).clearActions();\r\n    this._entity.kill();\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    return;\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Follow implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _followTx: TransformComponent;\r\n  private _followMotion: MotionComponent;\r\n\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _maximumDistance: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, entityToFollow: Entity, followDistance?: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._followTx = entityToFollow.get(TransformComponent);\r\n    this._followMotion = entityToFollow.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);\r\n    this._speed = 0;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));\r\n    if (actorToFollowSpeed !== 0) {\r\n      this._speed = actorToFollowSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    if (this._distanceBetween >= this._maximumDistance) {\r\n      const m = this._dir.scale(this._speed);\r\n      this._motion.vel = vec(m.x, m.y);\r\n    } else {\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    // the actor following should never stop unless specified to do so\r\n    return this._stopped;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Meet implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _meetTx: TransformComponent;\r\n  private _meetMotion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedWasSpecified = false;\r\n\r\n  constructor(actor: Entity, actorToMeet: Entity, speed?: number) {\r\n    this._tx = actor.get(TransformComponent);\r\n    this._motion = actor.get(MotionComponent);\r\n    this._meetTx = actorToMeet.get(TransformComponent);\r\n    this._meetMotion = actorToMeet.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._speed = speed || 0;\r\n\r\n    if (speed !== undefined) {\r\n      this._speedWasSpecified = true;\r\n    }\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));\r\n    if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {\r\n      this._speed = actorToMeetSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._distanceBetween <= 1;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { RotationType } from './RotationType';\r\n\r\nimport { EasingFunction, EasingFunctions } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { Repeat } from './Action/Repeat';\r\nimport { RepeatForever } from './Action/RepeatForever';\r\nimport { MoveBy } from './Action/MoveBy';\r\nimport { MoveTo } from './Action/MoveTo';\r\nimport { RotateTo } from './Action/RotateTo';\r\nimport { RotateBy } from './Action/RotateBy';\r\nimport { ScaleTo } from './Action/ScaleTo';\r\nimport { ScaleBy } from './Action/ScaleBy';\r\nimport { CallMethod } from './Action/CallMethod';\r\nimport { EaseTo } from './Action/EaseTo';\r\nimport { Blink } from './Action/Blink';\r\nimport { Fade } from './Action/Fade';\r\nimport { Delay } from './Action/Delay';\r\nimport { Die } from './Action/Die';\r\nimport { Follow } from './Action/Follow';\r\nimport { Meet } from './Action/Meet';\r\nimport { Vector } from '../Math/vector';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\n\r\n/**\r\n * The fluent Action API allows you to perform \"actions\" on\r\n * [[Actor|Actors]] such as following, moving, rotating, and\r\n * more. You can implement your own actions by implementing\r\n * the [[Action]] interface.\r\n */\r\nexport class ActionContext {\r\n  private _entity: Entity;\r\n  private _queue: ActionQueue;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n    this._queue = new ActionQueue(entity);\r\n  }\r\n\r\n  public getQueue(): ActionQueue {\r\n    return this._queue;\r\n  }\r\n\r\n  public update(elapsedMs: number) {\r\n    this._queue.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._queue.clearActions();\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  public easeTo(...args: any[]): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let duration = 0;\r\n    let easingFcn = EasingFunctions.Linear;\r\n    if (args[0] instanceof Vector) {\r\n      x = args[0].x;\r\n      y = args[0].y;\r\n      duration = args[1];\r\n      easingFcn = args[2] ?? easingFcn;\r\n    } else {\r\n      x = args[0];\r\n      y = args[1];\r\n      duration = args[2];\r\n      easingFcn = args[3] ?? easingFcn;\r\n    }\r\n\r\n    this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let speed = 0;\r\n    if (xOrPos instanceof Vector) {\r\n      x = xOrPos.x;\r\n      y = xOrPos.y;\r\n      speed = yOrSpeed;\r\n    } else {\r\n      x = xOrPos;\r\n      y = yOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveTo(this._entity, x, y, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let xOffset = 0;\r\n    let yOffset = 0;\r\n    let speed = 0;\r\n    if (xOffsetOrVector instanceof Vector) {\r\n      xOffset = xOffsetOrVector.x;\r\n      yOffset = xOffsetOrVector.y;\r\n      speed = yOffsetOrSpeed;\r\n    } else {\r\n      xOffset = xOffsetOrVector;\r\n      yOffset = yOffsetOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number | undefined,\r\n    speedYOrUndefined?: number | undefined): ActionContext {\r\n\r\n    let sizeX = 1;\r\n    let sizeY = 1;\r\n    let speedX = 0;\r\n    let speedY = 0;\r\n\r\n    if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {\r\n      sizeX = sizeXOrVector.x;\r\n      sizeY = sizeXOrVector.y;\r\n\r\n      speedX = sizeYOrSpeed.x;\r\n      speedY = sizeYOrSpeed.y;\r\n    }\r\n    if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {\r\n      sizeX = sizeXOrVector;\r\n      sizeY = sizeYOrSpeed;\r\n\r\n      speedX = speedXOrUndefined;\r\n      speedY = speedYOrUndefined;\r\n    }\r\n\r\n    this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number | undefined): ActionContext {\r\n    let sizeOffsetX = 1;\r\n    let sizeOffsetY = 1;\r\n\r\n    if (sizeOffsetXOrVector instanceof Vector) {\r\n      sizeOffsetX = sizeOffsetXOrVector.x;\r\n      sizeOffsetY = sizeOffsetXOrVector.y;\r\n\r\n      speed = sizeOffsetYOrSpeed;\r\n    }\r\n    if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {\r\n      sizeOffsetX = sizeOffsetXOrVector;\r\n      sizeOffsetY = sizeOffsetYOrSpeed;\r\n    }\r\n\r\n    this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks: number = 1): ActionContext {\r\n    this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    this._queue.add(new Fade(this._entity, opacity, time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    this._queue.add(new Delay(time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    this._queue.add(new Die(this._entity));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    this._queue.add(new CallMethod(method));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    if (!times) {\r\n      this.repeatForever(repeatBuilder);\r\n      return this;\r\n    }\r\n    this._queue.add(new Repeat(this._entity, repeatBuilder, times));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    this._queue.add(new RepeatForever(this._entity, repeatBuilder));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Entity, followDistance?: number): ActionContext {\r\n    if (followDistance === undefined) {\r\n      this._queue.add(new Follow(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Follow(this._entity, entity, followDistance));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Entity, speed?: number): ActionContext {\r\n    if (speed === undefined) {\r\n      this._queue.add(new Meet(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Meet(this._entity, entity, speed));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   * @deprecated Use `toPromise()` will be removed in v0.26.0\r\n   */\r\n  public asPromise(): Promise<void> {\r\n    return this.toPromise();\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    const temp = new Promise<void>((resolve) => {\r\n      this._queue.add(\r\n        new CallMethod(() => {\r\n          resolve();\r\n        })\r\n      );\r\n    });\r\n    return temp;\r\n  }\r\n}\r\n","import { ActionContext } from './ActionContext';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Actor } from '../Actor';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Vector } from '../Math/vector';\r\nimport { EasingFunction } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { RotationType } from './RotationType';\r\n\r\nexport interface ActionContextMethods extends Pick<ActionContext, keyof ActionContext> { };\r\n\r\nexport class ActionsComponent extends Component<'ex.actions'> implements ActionContextMethods {\r\n  public readonly type = 'ex.actions';\r\n  dependencies = [TransformComponent, MotionComponent]\r\n  private _ctx: ActionContext;\r\n\r\n  onAdd(entity: Entity) {\r\n    this._ctx = new ActionContext(entity);\r\n  }\r\n\r\n  onRemove() {\r\n    this._ctx = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal action queue\r\n   * @returns action queu\r\n   */\r\n  public getQueue(): ActionQueue {\r\n    return this._ctx?.getQueue();\r\n  }\r\n\r\n  /**\r\n   * Updates the internal action context, performing action and moving through the internal queue\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number): void {\r\n    return this._ctx?.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._ctx?.clearActions();\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeTo(...args: any[]): ActionContext {\r\n    return this._ctx.easeTo.apply(this._ctx, args);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset The (x, y) offset to apply to this actor\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateTo(angleRadians, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(\r\n    sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number,\r\n    speedYOrUndefined?: number): ActionContext {\r\n    return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number): ActionContext {\r\n    return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks?: number): ActionContext {\r\n    return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    return this._ctx.fade(opacity, time);\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    return this._ctx.delay(time);\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    return this._ctx.die();\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    return this._ctx.callMethod(method);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    return this._ctx.repeat(repeatBuilder, times);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    return this._ctx.repeatForever(repeatBuilder);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Actor, followDistance?: number): ActionContext {\r\n    return this._ctx.follow(entity, followDistance);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Actor, speed?: number): ActionContext {\r\n    return this._ctx.meet(entity, speed);\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   * @deprecated Use `toPromise()` will be removed in v0.26.0\r\n   */\r\n  public asPromise(): Promise<void> {\r\n    return this.toPromise();\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    return this._ctx.toPromise();\r\n  }\r\n}","import { Texture } from './Drawing/Texture';\r\nimport {\r\n  InitializeEvent,\r\n  KillEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  PreDebugDrawEvent,\r\n  PostDebugDrawEvent,\r\n  PostCollisionEvent,\r\n  PreCollisionEvent,\r\n  CollisionStartEvent,\r\n  CollisionEndEvent,\r\n  PostKillEvent,\r\n  PreKillEvent,\r\n  GameEvent,\r\n  ExitTriggerEvent,\r\n  EnterTriggerEvent,\r\n  EnterViewPortEvent,\r\n  ExitViewPortEvent\r\n} from './Events';\r\nimport { PointerEvent, WheelEvent, PointerDragEvent, PointerEventName } from './Input/PointerEvents';\r\nimport { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { Sprite } from './Drawing/Sprite';\r\nimport { Animation } from './Drawing/Animation';\r\nimport { Trait } from './Interfaces/Trait';\r\nimport { Drawable } from './Interfaces/Drawable';\r\nimport { CanInitialize, CanUpdate, CanDraw, CanBeKilled } from './Interfaces/LifecycleEvents';\r\nimport { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { Eventable } from './Interfaces/Evented';\r\nimport * as Traits from './Traits/Index';\r\nimport * as Events from './Events';\r\nimport { PointerEvents } from './Interfaces/PointerEventHandlers';\r\nimport { CollisionType } from './Collision/CollisionType';\r\n\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { CanvasDrawComponent } from './Drawing/CanvasDrawComponent';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from './EntityComponentSystem/Components/MotionComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Rectangle } from './Graphics/Rectangle';\r\nimport { Flags, Legacy } from './Flags';\r\nimport { obsolete } from './Util/Decorators';\r\nimport { ColliderComponent } from './Collision/ColliderComponent';\r\nimport { Shape } from './Collision/Colliders/Shape';\r\nimport { watch } from './Util/Watch';\r\nimport { Collider, CollisionGroup } from './Collision/Index';\r\nimport { Circle } from './Graphics/Circle';\r\nimport { CapturePointerConfig } from './Input/CapturePointerConfig';\r\nimport { ActionsComponent } from './Actions/ActionsComponent';\r\n\r\n/**\r\n * Type guard for checking if something is an Actor\r\n * @param x\r\n */\r\nexport function isActor(x: any): x is Actor {\r\n  return x instanceof Actor;\r\n}\r\n\r\n/**\r\n * Actor contructor options\r\n */\r\nexport interface ActorArgs {\r\n  /**\r\n   * Optionally set the name of the actor, default is 'anonymous'\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally set the x position of the actor, default is 0\r\n   */\r\n  x?: number;\r\n  /**\r\n   * Optionally set the y position of the actor, default is 0\r\n   */\r\n  y?: number;\r\n  /**\r\n   * Optionaly set the (x, y) position of the actor as a vector, default is (0, 0)\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally set the width of a box collider for the actor\r\n   */\r\n  width?: number;\r\n  /**\r\n   * Optionally set the height of a box collider for the actor\r\n   */\r\n  height?: number;\r\n  /**\r\n   * Optionally set the radius of the circle collider for the actor\r\n   */\r\n  radius?: number;\r\n  /**\r\n   * Optionally set the velocity of the actor in pixels/sec\r\n   */\r\n  vel?: Vector;\r\n  /**\r\n   * Optionally set the acceleration of the actor in pixels/sec^2\r\n   */\r\n  acc?: Vector;\r\n  /**\r\n   * Optionally se the rotation in radians (180 degrees = Math.PI radians)\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * Optionally set the angular velocity of the actor in radians/sec (180 degrees = Math.PI radians)\r\n   */\r\n  angularVelocity?: number;\r\n  /**\r\n   * Optionally set the scale of the actor's transform\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * Optionally set the z index of the actor, default is 0\r\n   */\r\n  z?: number;\r\n  /**\r\n   * Optionally set the color of an actor, only used if no graphics are present\r\n   * If a width/height or a radius was set a default graphic will be added\r\n   */\r\n  color?: Color;\r\n  /**\r\n   * Optionally set the visibility of the actor\r\n   */\r\n  visible?: boolean;\r\n  /**\r\n   * Optionally set the anchor for graphics in the actor\r\n   */\r\n  anchor?: Vector;\r\n  /**\r\n   * Optionally set the collision type\r\n   */\r\n  collisionType?: CollisionType;\r\n  /**\r\n   * Optionally supply a collider for an actor, if supplied ignores any supplied width/height\r\n   */\r\n  collider?: Collider;\r\n  /**\r\n   * Optionally suppy a [[CollisionGroup]]\r\n   */\r\n  collisionGroup?: CollisionGroup;\r\n}\r\n\r\n/**\r\n * The most important primitive in Excalibur is an `Actor`. Anything that\r\n * can move on the screen, collide with another `Actor`, respond to events,\r\n * or interact with the current scene, must be an actor. An `Actor` **must**\r\n * be part of a [[Scene]] for it to be drawn to the screen.\r\n */\r\nexport class Actor extends Entity implements Eventable, PointerEvents, CanInitialize, CanUpdate, CanDraw, CanBeKilled {\r\n  // #region Properties\r\n\r\n  /**\r\n   * Set defaults for all Actors\r\n   */\r\n  public static defaults = {\r\n    anchor: Vector.Half\r\n  };\r\n\r\n  /**\r\n   * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n   * acceleration, mass, inertia, etc.\r\n   */\r\n  public get body(): BodyComponent {\r\n    return this.get(BodyComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[TransformComponent]]\r\n   */\r\n  public get transform(): TransformComponent {\r\n    return this.get(TransformComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[MotionComponent]]\r\n   */\r\n  public get motion(): MotionComponent {\r\n    return this.get(MotionComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[GraphicsComponent]]\r\n   */\r\n  public get graphics(): GraphicsComponent {\r\n    return this.get(GraphicsComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[ColliderComponent]]\r\n   */\r\n  public get collider(): ColliderComponent {\r\n    return this.get(ColliderComponent);\r\n  }\r\n\r\n  /**\r\n   * Useful for quickly scripting actor behavior, like moving to a place, patroling back and forth, blinking, etc.\r\n   *\r\n   *  Access to the Actor's built in [[ActionsComponent]] which forwards to the\r\n   * [[ActionContext|Action context]] of the actor.\r\n   */\r\n  public get actions(): ActionsComponent {\r\n    return this.get(ActionsComponent);\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor in pixels\r\n   */\r\n  public get pos(): Vector {\r\n    return this.transform.pos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in pixels\r\n   */\r\n  public set pos(thePos: Vector) {\r\n    this.transform.pos = thePos.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor from the last frame\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this.body.oldPos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in the last frame\r\n   */\r\n  public set oldPos(thePos: Vector) {\r\n    this.body.oldPos.setTo(thePos.x, thePos.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public set vel(theVel: Vector) {\r\n    this.motion.vel = theVel.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor from the last frame\r\n   */\r\n  public get oldVel(): Vector {\r\n    return this.body.oldVel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor from the last frame\r\n   */\r\n  public set oldVel(theVel: Vector) {\r\n    this.body.oldVel.setTo(theVel.x, theVel.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n   * useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration vector of teh actor in pixels/second/second\r\n   */\r\n  public set acc(theAcc: Vector) {\r\n    this.motion.acc = theAcc.clone();\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public set oldAcc(theAcc: Vector) {\r\n    this.body.oldAcc.setTo(theAcc.x, theAcc.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public get oldAcc(): Vector {\r\n    return this.body.oldAcc;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public get rotation(): number {\r\n    return this.transform.rotation;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public set rotation(theAngle: number) {\r\n    this.transform.rotation = theAngle;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotational velocity of the actor in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotational velocity of the actor in radians/sec\r\n   */\r\n  public set angularVelocity(angularVelocity: number) {\r\n    this.motion.angularVelocity = angularVelocity;\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this.get(TransformComponent).scale;\r\n  }\r\n\r\n  public set scale(scale: Vector) {\r\n    this.get(TransformComponent).scale = scale;\r\n  }\r\n\r\n  /**\r\n   * The anchor to apply all actor related transformations like rotation,\r\n   * translation, and scaling. By default the anchor is in the center of\r\n   * the actor. By default it is set to the center of the actor (.5, .5)\r\n   *\r\n   * An anchor of (.5, .5) will ensure that drawings are centered.\r\n   *\r\n   * Use `anchor.setTo` to set the anchor to a different point using\r\n   * values between 0 and 1. For example, anchoring to the top-left would be\r\n   * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.\r\n   */\r\n  private _anchor: Vector = watch(Vector.Half, (v) => this._handleAnchorChange(v));\r\n  public get anchor(): Vector {\r\n    return this._anchor;\r\n  }\r\n\r\n  public set anchor(vec: Vector) {\r\n    this._anchor = watch(vec, (v) => this._handleAnchorChange(v));\r\n    this._handleAnchorChange(vec);\r\n  }\r\n\r\n  private _handleAnchorChange(v: Vector) {\r\n    if (this.graphics) {\r\n      this.graphics.anchor = v;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates whether the actor is physically in the viewport\r\n   */\r\n  public get isOffScreen(): boolean {\r\n    return this.hasTag('offscreen');\r\n  }\r\n  /**\r\n   * The visibility of an actor\r\n   * @deprecated Use [[GraphicsComponent.visible|Actor.graphics.visible]], will be removed in v0.26.0\r\n   */\r\n  @obsolete({ message: 'Actor.visible will be removed in v0.26.0', alternateMethod: 'Use Actor.graphics.visible' })\r\n  public get visible(): boolean {\r\n    return this.graphics.visible;\r\n  }\r\n\r\n  public set visible(isVisible: boolean) {\r\n    this.graphics.visible = isVisible;\r\n  }\r\n\r\n  /**\r\n   * The opacity of an actor.\r\n   *\r\n   * @deprecated Actor.opacity will be removed in v0.26.0, use [[GraphicsComponent.opacity|Actor.graphics.opacity]].\r\n   */\r\n  @obsolete({\r\n    message: 'Actor.opacity will be removed in v0.26.0',\r\n    alternateMethod: 'Use Actor.graphics.opacity'\r\n  })\r\n  public get opacity(): number {\r\n    return this.graphics.opacity;\r\n  }\r\n\r\n  public set opacity(opacity: number) {\r\n    this.graphics.opacity = opacity;\r\n  }\r\n\r\n  /**\r\n   * Convenience reference to the global logger\r\n   */\r\n  public logger: Logger = Logger.getInstance();\r\n\r\n  /**\r\n   * The scene that the actor is in\r\n   */\r\n  public scene: Scene = null;\r\n\r\n  public frames: { [key: string]: Drawable } = {};\r\n\r\n  /**\r\n   * Access to the current drawing for the actor, this can be\r\n   * an [[Animation]], [[Sprite]], or [[Polygon]].\r\n   * Set drawings with [[setDrawing]].\r\n   * @deprecated\r\n   */\r\n  public currentDrawing: Drawable = null;\r\n\r\n  /**\r\n   * Draggable helper\r\n   */\r\n  private _draggable: boolean = false;\r\n  private _dragging: boolean = false;\r\n\r\n  private _pointerDragStartHandler = () => {\r\n    this._dragging = true;\r\n  };\r\n\r\n  private _pointerDragEndHandler = () => {\r\n    this._dragging = false;\r\n  };\r\n\r\n  private _pointerDragMoveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.pointer.lastWorldPos;\r\n    }\r\n  };\r\n\r\n  private _pointerDragLeaveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.pointer.lastWorldPos;\r\n    }\r\n  };\r\n\r\n  public get draggable(): boolean {\r\n    return this._draggable;\r\n  }\r\n\r\n  public set draggable(isDraggable: boolean) {\r\n    if (isDraggable) {\r\n      if (isDraggable && !this._draggable) {\r\n        this.on('pointerdragstart', this._pointerDragStartHandler);\r\n        this.on('pointerdragend', this._pointerDragEndHandler);\r\n        this.on('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.on('pointerdragleave', this._pointerDragLeaveHandler);\r\n      } else if (!isDraggable && this._draggable) {\r\n        this.off('pointerdragstart', this._pointerDragStartHandler);\r\n        this.off('pointerdragend', this._pointerDragEndHandler);\r\n        this.off('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.off('pointerdragleave', this._pointerDragLeaveHandler);\r\n      }\r\n\r\n      this._draggable = isDraggable;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Modify the current actor update pipeline.\r\n   */\r\n  public traits: Trait[] = [];\r\n\r\n  /**\r\n   * Sets the color of the actor. A rectangle of this color will be\r\n   * drawn if no [[Drawable]] is specified as the actors drawing.\r\n   *\r\n   * The default is `null` which prevents a rectangle from being drawn.\r\n   */\r\n  public get color(): Color {\r\n    return this._color;\r\n  }\r\n  public set color(v: Color) {\r\n    this._color = v.clone();\r\n  }\r\n  private _color: Color;\r\n\r\n  /**\r\n   * Whether or not to enable the [[Traits.CapturePointer]] trait that propagates\r\n   * pointer events to this actor\r\n   */\r\n  public enableCapturePointer: boolean = false;\r\n\r\n  /**\r\n   * Configuration for [[Traits.CapturePointer]] trait\r\n   */\r\n  public capturePointer: CapturePointerConfig = {\r\n    captureMoveEvents: false,\r\n    captureDragEvents: false\r\n  };\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   *\r\n   * @param config\r\n   */\r\n  constructor(config?: ActorArgs) {\r\n    super();\r\n\r\n    const {\r\n      name,\r\n      x,\r\n      y,\r\n      pos,\r\n      scale,\r\n      width,\r\n      height,\r\n      radius,\r\n      collider,\r\n      vel,\r\n      acc,\r\n      rotation,\r\n      angularVelocity,\r\n      z,\r\n      color,\r\n      visible,\r\n      anchor,\r\n      collisionType,\r\n      collisionGroup\r\n    } = {\r\n      ...config\r\n    };\r\n\r\n    this._setName(name);\r\n    this.anchor = anchor ?? Actor.defaults.anchor.clone();\r\n\r\n    this.addComponent(new TransformComponent());\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.rotation = rotation ?? 0;\r\n    this.scale = scale ?? vec(1, 1);\r\n    this.z = z ?? 0;\r\n\r\n    this.addComponent(new GraphicsComponent());\r\n    this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));\r\n    this.addComponent(new MotionComponent());\r\n    this.vel = vel ?? Vector.Zero;\r\n    this.acc = acc ?? Vector.Zero;\r\n    this.angularVelocity = angularVelocity ?? 0;\r\n\r\n    this.addComponent(new ActionsComponent());\r\n\r\n    this.addComponent(new BodyComponent());\r\n    this.body.collisionType = collisionType ?? CollisionType.Passive;\r\n    if (collisionGroup) {\r\n      this.body.group = collisionGroup;\r\n    }\r\n\r\n    if (collider) {\r\n      this.addComponent(new ColliderComponent(collider));\r\n    } else if (radius) {\r\n      this.addComponent(new ColliderComponent(Shape.Circle(radius, this.anchor)));\r\n    } else {\r\n      if (width > 0 && height > 0) {\r\n        this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));\r\n      } else {\r\n        this.addComponent(new ColliderComponent()); // no collider\r\n      }\r\n    }\r\n\r\n    this.graphics.visible = visible ?? true;\r\n\r\n    if (color) {\r\n      this.color = color;\r\n      if (width && height) {\r\n        this.graphics.add(\r\n          new Rectangle({\r\n            color: color,\r\n            width,\r\n            height\r\n          })\r\n        );\r\n      } else if (radius) {\r\n        this.graphics.add(\r\n          new Circle({\r\n            color: color,\r\n            radius\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    // Build default pipeline\r\n    if (Flags.isEnabled(Legacy.LegacyDrawing)) {\r\n      // TODO remove offscreen trait after legacy drawing removed\r\n      this.traits.push(new Traits.OffscreenCulling());\r\n    }\r\n    this.traits.push(new Traits.CapturePointer());\r\n\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the actor. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n    for (const child of this.children) {\r\n      child._initialize(engine);\r\n    }\r\n  }\r\n\r\n  // #region Events\r\n\r\n  private _capturePointerEvents: PointerEventName[] = [\r\n    'pointerup',\r\n    'pointerdown',\r\n    'pointermove',\r\n    'pointerenter',\r\n    'pointerleave',\r\n    'pointerdragstart',\r\n    'pointerdragend',\r\n    'pointerdragmove',\r\n    'pointerdragenter',\r\n    'pointerdragleave'\r\n  ];\r\n\r\n  private _captureMoveEvents: PointerEventName[] = [\r\n    'pointermove',\r\n    'pointerenter',\r\n    'pointerleave',\r\n    'pointerdragmove',\r\n    'pointerdragenter',\r\n    'pointerdragleave'\r\n  ];\r\n\r\n  private _captureDragEvents: PointerEventName[] = [\r\n    'pointerdragstart',\r\n    'pointerdragend',\r\n    'pointerdragmove',\r\n    'pointerdragenter',\r\n    'pointerdragleave'\r\n  ];\r\n\r\n  private _checkForPointerOptIn(eventName: string) {\r\n    if (eventName) {\r\n      const normalized = <PointerEventName>eventName.toLowerCase();\r\n\r\n      if (this._capturePointerEvents.indexOf(normalized) !== -1) {\r\n        this.enableCapturePointer = true;\r\n\r\n        if (this._captureMoveEvents.indexOf(normalized) !== -1) {\r\n          this.capturePointer.captureMoveEvents = true;\r\n        }\r\n\r\n        if (this._captureDragEvents.indexOf(normalized) !== -1) {\r\n          this.capturePointer.captureDragEvents = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public on(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public on(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touched a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public on(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public on(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public on(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public on(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public on(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public on(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public on(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public on(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public on(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public on(eventName: Events.pointerdragstart, handler: (event: PointerDragEvent) => void): void;\r\n  public on(eventName: Events.pointerdragend, handler: (event: PointerDragEvent) => void): void;\r\n  public on(eventName: Events.pointerdragenter, handler: (event: PointerDragEvent) => void): void;\r\n  public on(eventName: Events.pointerdragleave, handler: (event: PointerDragEvent) => void): void;\r\n  public on(eventName: Events.pointerdragmove, handler: (event: PointerDragEvent) => void): void;\r\n  public on(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public on(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    this._checkForPointerOptIn(eventName);\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public once(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public once(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public once(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public once(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public once(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public once(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public once(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public once(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public once(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public once(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public once(eventName: Events.pointerdragstart, handler: (event: PointerDragEvent) => void): void;\r\n  public once(eventName: Events.pointerdragend, handler: (event: PointerDragEvent) => void): void;\r\n  public once(eventName: Events.pointerdragenter, handler: (event: PointerDragEvent) => void): void;\r\n  public once(eventName: Events.pointerdragleave, handler: (event: PointerDragEvent) => void): void;\r\n  public once(eventName: Events.pointerdragmove, handler: (event: PointerDragEvent) => void): void;\r\n  public once(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public once(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    this._checkForPointerOptIn(eventName);\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.exittrigger, handler?: (event: ExitTriggerEvent) => void): void;\r\n  public off(eventName: Events.entertrigger, handler?: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public off(eventName: Events.collisionstart, handler?: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public off(eventName: Events.collisionend, handler?: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public off(eventName: Events.precollision, handler?: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public off(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public off(eventName: Events.pointerup, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdown, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointermove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointercancel, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerwheel, handler?: (event: WheelEvent) => void): void;\r\n  public off(eventName: Events.pointerdragstart, handler?: (event: PointerDragEvent) => void): void;\r\n  public off(eventName: Events.pointerdragend, handler?: (event: PointerDragEvent) => void): void;\r\n  public off(eventName: Events.pointerdragenter, handler?: (event: PointerDragEvent) => void): void;\r\n  public off(eventName: Events.pointerdragleave, handler?: (event: PointerDragEvent) => void): void;\r\n  public off(eventName: Events.pointerdragmove, handler?: (event: PointerDragEvent) => void): void;\r\n  public off(eventName: Events.prekill, handler?: (event: PreKillEvent) => void): void;\r\n  public off(eventName: Events.postkill, handler?: (event: PostKillEvent) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Actor>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n  public off(eventName: Events.enterviewport, handler?: (event: EnterViewPortEvent) => void): void;\r\n  public off(eventName: Events.exitviewport, handler?: (event: ExitViewPortEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<Actor>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPreKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _prekill(_scene: Scene) {\r\n    super.emit('prekill', new PreKillEvent(this));\r\n    this.onPreKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`\r\n   *\r\n   * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].\r\n   */\r\n  public onPreKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPostKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postkill(_scene: Scene) {\r\n    super.emit('postkill', new PostKillEvent(this));\r\n    this.onPostKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`\r\n   *\r\n   * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].\r\n   */\r\n  public onPostKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If the current actor is a member of the scene, this will remove\r\n   * it from the scene graph. It will no longer be drawn or updated.\r\n   */\r\n  public kill() {\r\n    if (this.scene) {\r\n      this._prekill(this.scene);\r\n      this.emit('kill', new KillEvent(this));\r\n      super.kill();\r\n      this._postkill(this.scene);\r\n    } else {\r\n      this.logger.warn('Cannot kill actor, it was never added to the Scene');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the current actor is killed, it will now not be killed.\r\n   */\r\n  public unkill() {\r\n    this.active = true;\r\n  }\r\n\r\n  /**\r\n   * Indicates wether the actor has been killed.\r\n   */\r\n  public isKilled(): boolean {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Sets the current drawing of the actor to the drawing corresponding to\r\n   * the key.\r\n   * @param key The key of the drawing\r\n   * @deprecated Use [[GraphicsComponent.show|Actor.graphics.show]] or [[GraphicsComponent.use|Actor.graphics.use]]\r\n   */\r\n  public setDrawing(key: string): void;\r\n  /**\r\n   * Sets the current drawing of the actor to the drawing corresponding to\r\n   * an `enum` key (e.g. `Animations.Left`)\r\n   * @param key The `enum` key of the drawing\r\n   * @deprecated Use [[GraphicsComponent.show|Actor.graphics.show]] or [[GraphicsComponent.use|Actor.graphics.use]]\r\n   */\r\n  public setDrawing(key: number): void;\r\n  @obsolete({\r\n    message: 'Actor.setDrawing will be removed in v0.26.0',\r\n    alternateMethod: 'Use Actor.graphics.show() or Actor.graphics.use()'\r\n  })\r\n  public setDrawing(key: any): void {\r\n    key = key.toString();\r\n    if (this.currentDrawing !== this.frames[<string>key]) {\r\n      if (this.frames[key] != null) {\r\n        this.frames[key].reset();\r\n        this.currentDrawing = this.frames[key];\r\n      } else {\r\n        Logger.getInstance().error(`the specified drawing key ${key} does not exist`);\r\n      }\r\n    }\r\n    if (this.currentDrawing && this.currentDrawing instanceof Animation) {\r\n      this.currentDrawing.tick(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a whole texture as the \"default\" drawing. Set a drawing using [[setDrawing]].\r\n   * @deprecated Use [[GraphicsComponent.add|Actor.graphics.add]]\r\n   */\r\n  public addDrawing(texture: Texture): void;\r\n  /**\r\n   * Adds a whole sprite as the \"default\" drawing. Set a drawing using [[setDrawing]].\r\n   * @deprecated Use [[GraphicsComponent.add|Actor.graphics.add]]\r\n   */\r\n  public addDrawing(sprite: Sprite): void;\r\n  /**\r\n   * Adds a drawing to the list of available drawings for an actor. Set a drawing using [[setDrawing]].\r\n   * @param key     The key to associate with a drawing for this actor\r\n   * @param drawing This can be an [[Animation]], [[Sprite]], or [[Polygon]].\r\n   * @deprecated Use [[GraphicsComponent.add|Actor.graphics.add]]\r\n   */\r\n  public addDrawing(key: any, drawing: Drawable): void;\r\n  @obsolete({\r\n    message: 'Actor.addDrawing will be removed in v0.26.0',\r\n    alternateMethod: 'Use Actor.graphics.add()'\r\n  })\r\n  public addDrawing(): void {\r\n    if (arguments.length === 2) {\r\n      this.frames[<string>arguments[0]] = arguments[1];\r\n      if (!this.currentDrawing) {\r\n        this.currentDrawing = arguments[1];\r\n      }\r\n    } else {\r\n      if (arguments[0] instanceof Sprite) {\r\n        this.addDrawing('default', arguments[0]);\r\n      }\r\n      if (arguments[0] instanceof Texture) {\r\n        this.addDrawing('default', arguments[0].asSprite());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   */\r\n  public get z(): number {\r\n    return this.get(TransformComponent).z;\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use [[Actor.z]]\r\n   */\r\n  @obsolete({\r\n    message: 'Actor.getZIndex will be removed in v0.26.0',\r\n    alternateMethod: 'Use Actor.transform.z or Actor.z'\r\n  })\r\n  public getZIndex(): number {\r\n    return this.get(TransformComponent).z;\r\n  }\r\n\r\n  /**\r\n   * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n   * The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   * @param newZ new z-index to assign\r\n   */\r\n  public set z(newZ: number) {\r\n    this.get(TransformComponent).z = newZ;\r\n  }\r\n\r\n  /**\r\n   * @param newIndex new z-index to assign\r\n   * @deprecated Use [[Actor.z]]\r\n   */\r\n  @obsolete({\r\n    message: 'Actor.setZIndex will be removed in v0.26.0',\r\n    alternateMethod: 'Use Actor.transform.z or Actor.z'\r\n  })\r\n  public setZIndex(newIndex: number) {\r\n    this.get(TransformComponent).z = newIndex;\r\n  }\r\n\r\n  /**\r\n   * Get the center point of an actor\r\n   */\r\n  public get center(): Vector {\r\n    return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  public get width() {\r\n    return this.collider.localBounds.width * this.getGlobalScale().x;\r\n  }\r\n\r\n  public get height() {\r\n    return this.collider.localBounds.height * this.getGlobalScale().y;\r\n  }\r\n\r\n  /**\r\n   * Gets this actor's rotation taking into account any parent relationships\r\n   *\r\n   * @returns Rotation angle in radians\r\n   */\r\n  public getGlobalRotation(): number {\r\n    return this.get(TransformComponent).globalRotation;\r\n  }\r\n\r\n  /**\r\n   * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation\r\n   *\r\n   * @returns Position in world coordinates\r\n   */\r\n  public getGlobalPos(): Vector {\r\n    return this.get(TransformComponent).globalPos;\r\n  }\r\n\r\n  /**\r\n   * Gets the global scale of the Actor\r\n   */\r\n  public getGlobalScale(): Vector {\r\n    return this.get(TransformComponent).globalScale;\r\n  }\r\n\r\n  // #region Collision\r\n\r\n  /**\r\n   * Tests whether the x/y specified are contained in the actor\r\n   * @param x  X coordinate to test (in world coordinates)\r\n   * @param y  Y coordinate to test (in world coordinates)\r\n   * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n   */\r\n  public contains(x: number, y: number, recurse: boolean = false): boolean {\r\n    const point = vec(x, y);\r\n    const collider = this.get(ColliderComponent);\r\n    collider.update();\r\n    const geom = collider.get();\r\n    if (!geom) {\r\n      return false;\r\n    }\r\n    const containment = geom.contains(point);\r\n\r\n    if (recurse) {\r\n      return (\r\n        containment ||\r\n        this.children.some((child: Actor) => {\r\n          return child.contains(x, y, true);\r\n        })\r\n      );\r\n    }\r\n\r\n    return containment;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other\r\n   * @param actor     Actor to test\r\n   * @param distance  Distance in pixels to test\r\n   */\r\n  public within(actor: Actor, distance: number): boolean {\r\n    const collider = this.get(ColliderComponent);\r\n    const otherCollider = actor.get(ColliderComponent);\r\n    const me = collider.get();\r\n    const other = otherCollider.get();\r\n    if (me && other) {\r\n      return me.getClosestLineBetween(other).getLength() <= distance;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // #endregion\r\n\r\n  // #region Update\r\n\r\n  /**\r\n   * Called by the Engine, updates the state of the actor\r\n   * @internal\r\n   * @param engine The reference to the current game engine\r\n   * @param delta  The time elapsed since the last update in milliseconds\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n\r\n    // Tick animations\r\n    const drawing = this.currentDrawing;\r\n    if (drawing && drawing instanceof Animation) {\r\n      drawing.tick(delta, engine.stats.currFrame.id);\r\n    }\r\n\r\n    // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)\r\n    for (const trait of this.traits) {\r\n      trait.update(this, engine, delta);\r\n    }\r\n\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an actor is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an actor is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  // endregion\r\n\r\n  // #region Drawing\r\n  /**\r\n   * Called by the Engine, draws the actor to the screen\r\n   * @param ctx   The rendering context\r\n   * @param delta The time since the last draw in milliseconds\r\n   *\r\n   * **Warning** only works with Flags.useLegacyDrawing() enabled\r\n   * @deprecated Use Actor.graphics, will be removed in v0.26.0\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D, delta: number) {\r\n    // translate canvas by anchor offset\r\n    ctx.save();\r\n\r\n    if (this.currentDrawing) {\r\n      ctx.translate(-(this.width * this.anchor.x), -(this.height * this.anchor.y));\r\n\r\n      this._predraw(ctx, delta);\r\n      const drawing = this.currentDrawing;\r\n      // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\r\n      const offsetX = (this.width - drawing.width * drawing.scale.x) * this.anchor.x;\r\n      const offsetY = (this.height - drawing.height * drawing.scale.y) * this.anchor.y;\r\n\r\n      this.currentDrawing.draw({ ctx, x: offsetX, y: offsetY, opacity: this.graphics.opacity });\r\n    } else {\r\n      this._predraw(ctx, delta);\r\n      if (this.color && this.collider) {\r\n        // update collider geometry based on transform\r\n        const collider = this.get(ColliderComponent);\r\n        collider.update();\r\n        if (collider && !collider.bounds.hasZeroDimensions()) {\r\n          // Colliders are already shifted by anchor, unshift\r\n          ctx.globalAlpha = this.graphics.opacity;\r\n          collider.get()?.draw(ctx, this.color, vec(0, 0));\r\n        }\r\n      }\r\n    }\r\n    ctx.restore();\r\n    this._postdraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('predraw', (evt) =>{...})`\r\n   *\r\n   * `onPreDraw` is called directly before an actor is drawn, but after local transforms are made.\r\n   *\r\n   * **Warning** only works with Flags.useLegacyDrawing() enabled\r\n   * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0\r\n   */\r\n  public onPreDraw(_ctx: CanvasRenderingContext2D, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('postdraw', (evt) =>{...})`\r\n   *\r\n   * `onPostDraw` is called directly after an actor is drawn, and before local transforms are removed.\r\n   *\r\n   * **Warning** only works with Flags.useLegacyDrawing() enabled\r\n   * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0\r\n   */\r\n  public onPostDraw(_ctx: CanvasRenderingContext2D, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n   *\r\n   * **Warning** only works with Flags.useLegacyDrawing() enabled\r\n   * @deprecated Use Actor.graphics.onPreDraw, will be removed in v0.26.0\r\n   * @internal\r\n   */\r\n  public _predraw(ctx: CanvasRenderingContext2D, delta: number): void {\r\n    this.emit('predraw', new PreDrawEvent(ctx, delta, this));\r\n    this.onPreDraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n   *\r\n   * **Warning** only works with Flags.useLegacyDrawing() enabled\r\n   * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0\r\n   * @internal\r\n   */\r\n  public _postdraw(ctx: CanvasRenderingContext2D, delta: number): void {\r\n    this.emit('postdraw', new PreDrawEvent(ctx, delta, this));\r\n    this.onPostDraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * Called by the Engine, draws the actors debugging to the screen\r\n   * @param ctx The rendering context\r\n   *\r\n   *\r\n   * **Warning** only works with Flags.useLegacyDrawing() enabled\r\n   * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0\r\n   * @internal\r\n   */\r\n  /* istanbul ignore next */\r\n  public debugDraw(_ctx: CanvasRenderingContext2D) {\r\n    // pass\r\n  }\r\n  // #endregion\r\n}\r\n","import { Vector, vec } from './Math/vector';\r\nimport { Engine } from './Engine';\r\nimport { Actor, ActorArgs } from './Actor';\r\nimport * as Traits from './Traits/Index';\r\nimport { CoordPlane, TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { CollisionType } from './Collision/CollisionType';\r\n\r\n/**\r\n * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does\r\n * not participate in collisions. Drawn on top of all other actors.\r\n */\r\nexport class ScreenElement extends Actor {\r\n  protected _engine: Engine;\r\n\r\n  constructor();\r\n  constructor(config?: ActorArgs);\r\n\r\n  constructor(config?: ActorArgs) {\r\n    super({ ...config });\r\n    this.get(TransformComponent).coordPlane = CoordPlane.Screen;\r\n    this.traits = [];\r\n    this.traits.push(new Traits.CapturePointer());\r\n    this.anchor = vec(0, 0);\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n    this.collider.useBoxCollider(this.width, this.height, this.anchor);\r\n    this.enableCapturePointer = true;\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    this._engine = engine;\r\n    super._initialize(engine);\r\n  }\r\n\r\n  public contains(x: number, y: number, useWorld: boolean = true) {\r\n    if (useWorld) {\r\n      return super.contains(x, y);\r\n    }\r\n\r\n    const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));\r\n    return super.contains(coords.x, coords.y);\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { obsolete } from './Util/Decorators';\r\nimport { Logger } from './Util/Log';\r\n\r\nexport interface TimerOptions {\r\n  repeats?: boolean;\r\n  numberOfRepeats?: number;\r\n  fcn?: () => void;\r\n  interval: number;\r\n}\r\n\r\n/**\r\n * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n * after a certain interval, optionally repeating.\r\n */\r\nexport class Timer {\r\n  private _logger = Logger.getInstance();\r\n  private static _MAX_ID: number = 0;\r\n  public id: number = 0;\r\n\r\n  private _elapsedTime: number = 0;\r\n  private _totalTimeAlive: number = 0;\r\n\r\n  private _running = false;\r\n\r\n  private _numberOfTicks: number = 0;\r\n  private _callbacks: Array<() => void>;\r\n\r\n  public interval: number = 10;\r\n  public repeats: boolean = false;\r\n  public maxNumberOfRepeats: number = -1;\r\n\r\n  private _complete = false;\r\n  public get complete() {\r\n    return this._complete;\r\n  }\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * @param options    Options - repeats, numberOfRepeats, fcn, interval\r\n   * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.\r\n   * @param numberOfRepeats Specifies a maximum number of times that this timer will execute.\r\n   * @param fcn        The callback to be fired after the interval is complete.\r\n   */\r\n  constructor(options: TimerOptions);\r\n  constructor(fcn: TimerOptions | (() => void), interval?: number, repeats?: boolean, numberOfRepeats?: number) {\r\n    if (typeof fcn !== 'function') {\r\n      const options = fcn;\r\n      fcn = options.fcn;\r\n      interval = options.interval;\r\n      repeats = options.repeats;\r\n      numberOfRepeats = options.numberOfRepeats;\r\n    }\r\n\r\n    if (!!numberOfRepeats && numberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = numberOfRepeats;\r\n      if (!repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this.id = Timer._MAX_ID++;\r\n    this.interval = interval || this.interval;\r\n    this.repeats = repeats || this.repeats;\r\n\r\n    this._callbacks = [];\r\n\r\n    if (fcn) {\r\n      this.on(fcn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new callback to be fired after the interval is complete\r\n   * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.\r\n   */\r\n  public on(fcn: () => void) {\r\n    this._callbacks.push(fcn);\r\n  }\r\n\r\n  /**\r\n   * Removes a callback from the callback list to be fired after the interval is complete.\r\n   * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.\r\n   */\r\n  public off(fcn: () => void) {\r\n    const index = this._callbacks.indexOf(fcn);\r\n    this._callbacks.splice(index, 1);\r\n  }\r\n\r\n  /**\r\n   * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n   * @param delta  Number of elapsed milliseconds since the last update.\r\n   */\r\n  public update(delta: number) {\r\n    if (this._running) {\r\n      this._totalTimeAlive += delta;\r\n      this._elapsedTime += delta;\r\n\r\n      if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {\r\n        this._complete = true;\r\n        this._running = false;\r\n        this._elapsedTime = 0;\r\n      }\r\n\r\n      if (!this.complete && this._elapsedTime >= this.interval) {\r\n        this._callbacks.forEach((c) => {\r\n          c.call(this);\r\n        });\r\n\r\n        this._numberOfTicks++;\r\n        if (this.repeats) {\r\n          this._elapsedTime = 0;\r\n        } else {\r\n          this._complete = true;\r\n          this._running = false;\r\n          this._elapsedTime = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n   *\r\n   * Warning** you may need to call `timer.start()` again if the timer had completed\r\n   * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n   * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes\r\n   */\r\n  public reset(newInterval?: number, newNumberOfRepeats?: number) {\r\n    if (!!newInterval && newInterval >= 0) {\r\n      this.interval = newInterval;\r\n    }\r\n\r\n    if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = newNumberOfRepeats;\r\n      if (!this.repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this._complete = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n  }\r\n\r\n  public get timesRepeated(): number {\r\n    return this._numberOfTicks;\r\n  }\r\n\r\n  public getTimeRunning(): number {\r\n    return this._totalTimeAlive;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds until the next action callback, if complete will return 0\r\n   */\r\n  public get timeToNextAction() {\r\n    if (this.complete) {\r\n      return 0;\r\n    }\r\n    return this.interval - this._elapsedTime;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds elapsed toward the next action\r\n   */\r\n  public get timeElapsedTowardNextAction() {\r\n    return this._elapsedTime;\r\n  }\r\n\r\n  public get isRunning() {\r\n    return this._running;\r\n  }\r\n\r\n  /**\r\n   * Pauses the timer, time will no longer increment towards the next call\r\n   */\r\n  public pause(): Timer {\r\n    this._running = false;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unpauses the timer. Time will now increment towards the next call\r\n   * @deprecated Will be removed in v0.26.0\r\n   */\r\n  @obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'Use Timer.resume()' })\r\n  public unpause() {\r\n    this._running = true;\r\n  }\r\n\r\n  /**\r\n   * Resumes the timer, time will now increment towards the next call.\r\n   */\r\n  public resume(): Timer {\r\n    this._running = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter\r\n   */\r\n  public start(): Timer {\r\n    if (!this.scene) {\r\n      this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');\r\n    }\r\n\r\n    this._running = true;\r\n    if (this.complete) {\r\n      this._complete = false;\r\n      this._elapsedTime = 0;\r\n      this._numberOfTicks = 0;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops the timer and resets the elapsed time counter towards the next action invocation\r\n   */\r\n  public stop(): Timer {\r\n    this._running = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cancels the timer, preventing any further executions.\r\n   */\r\n  public cancel() {\r\n    this.pause();\r\n    if (this.scene) {\r\n      this.scene.cancelTimer(this);\r\n    }\r\n  }\r\n}\r\n","import { BoundingBox } from './Collision/BoundingBox';\r\nimport { Engine } from './Engine';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { Logger } from './Util/Log';\r\nimport { SpriteSheet } from './Drawing/SpriteSheet';\r\nimport * as Events from './Events';\r\nimport { Configurable } from './Configurable';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { Shape } from './Collision/Colliders/Shape';\r\nimport { ExcaliburGraphicsContext, GraphicsComponent, hasGraphicsTick } from './Graphics';\r\nimport * as Graphics from './Graphics';\r\nimport { CanvasDrawComponent, Sprite } from './Drawing/Index';\r\nimport { Sprite as LegacySprite } from './Drawing/Index';\r\nimport { removeItemFromArray } from './Util/Util';\r\nimport { obsolete } from './Util/Decorators';\r\nimport { MotionComponent } from './EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from './Collision/ColliderComponent';\r\nimport { CompositeCollider } from './Collision/Colliders/CompositeCollider';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class TileMapImpl extends Entity {\r\n  private _token = 0;\r\n  private _onScreenXStart: number = 0;\r\n  private _onScreenXEnd: number = 9999;\r\n  private _onScreenYStart: number = 0;\r\n  private _onScreenYEnd: number = 9999;\r\n  private _spriteSheets: { [key: string]: Graphics.SpriteSheet } = {};\r\n\r\n  private _legacySpriteMap = new Map<Graphics.Sprite, Sprite>();\r\n  public logger: Logger = Logger.getInstance();\r\n  public readonly data: Cell[] = [];\r\n  private _rows: Cell[][] = [];\r\n  private _cols: Cell[][] = [];\r\n  public visible = true;\r\n  public isOffscreen = false;\r\n  public readonly cellWidth: number;\r\n  public readonly cellHeight: number;\r\n  public readonly rows: number;\r\n  public readonly cols: number;\r\n\r\n  private _dirty = true;\r\n  public flagDirty() {\r\n    this._dirty = true;\r\n  }\r\n  private _transform: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _collider: ColliderComponent;\r\n  private _composite: CompositeCollider;\r\n\r\n  public get x(): number {\r\n    return this._transform.pos.x ?? 0;\r\n  }\r\n\r\n  public set x(val: number) {\r\n    if (this._transform?.pos) {\r\n      this.get(TransformComponent).pos = vec(val, this.y);\r\n    }\r\n  }\r\n\r\n  public get y(): number {\r\n    return this._transform?.pos.y ?? 0;\r\n  }\r\n\r\n  public set y(val: number) {\r\n    if (this._transform?.pos) {\r\n      this._transform.pos = vec(this.x, val);\r\n    }\r\n  }\r\n\r\n  public get z(): number {\r\n    return this._transform.z ?? 0;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    if (this._transform) {\r\n      this._transform.z = val;\r\n    }\r\n  }\r\n\r\n  public get rotation(): number {\r\n    return this._transform?.rotation ?? 0;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    if (this._transform?.rotation) {\r\n      this._transform.rotation = val;\r\n    }\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this._transform?.scale ?? Vector.One;\r\n  }\r\n  public set scale(val: Vector) {\r\n    if (this._transform?.scale) {\r\n      this._transform.scale = val;\r\n    }\r\n  }\r\n\r\n  public get pos(): Vector {\r\n    return this._transform.pos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this._transform.pos = val;\r\n  }\r\n\r\n  public get vel(): Vector {\r\n    return this._motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this._motion.vel = val;\r\n  }\r\n\r\n  public on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * @param xOrConfig     The x coordinate to anchor the TileMap's upper left corner (should not be changed once set) or TileMap option bag\r\n   * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)\r\n   * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)\r\n   * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)\r\n   * @param rows          The number of rows in the TileMap (should not be changed once set)\r\n   * @param cols          The number of cols in the TileMap (should not be changed once set)\r\n   */\r\n  constructor(xOrConfig: number | TileMapArgs, y: number, cellWidth: number, cellHeight: number, rows: number, cols: number) {\r\n    super();\r\n    if (xOrConfig && typeof xOrConfig === 'object') {\r\n      const config = xOrConfig;\r\n      xOrConfig = config.x;\r\n      y = config.y;\r\n      cellWidth = config.cellWidth;\r\n      cellHeight = config.cellHeight;\r\n      rows = config.rows;\r\n      cols = config.cols;\r\n    }\r\n    this.addComponent(new TransformComponent());\r\n    this.addComponent(new MotionComponent());\r\n    this.addComponent(\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      })\r\n    );\r\n    this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));\r\n    this.addComponent(\r\n      new GraphicsComponent({\r\n        onPostDraw: (ctx, delta) => this.draw(ctx, delta)\r\n      })\r\n    );\r\n    this.addComponent(new ColliderComponent());\r\n    this._transform = this.get(TransformComponent);\r\n    this._motion = this.get(MotionComponent);\r\n    this._collider = this.get(ColliderComponent);\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n\r\n    this.x = <number>xOrConfig;\r\n    this.y = y;\r\n    this.cellWidth = cellWidth;\r\n    this.cellHeight = cellHeight;\r\n    this.rows = rows;\r\n    this.cols = cols;\r\n    this.data = new Array<Cell>(rows * cols);\r\n    this._rows = new Array(rows);\r\n    this._cols = new Array(cols);\r\n    let currentCol: Cell[] = [];\r\n    for (let i = 0; i < cols; i++) {\r\n      for (let j = 0; j < rows; j++) {\r\n        const cd = new Cell(i * cellWidth + <number>xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);\r\n        cd.map = this;\r\n        this.data[i + j * cols] = cd;\r\n        currentCol.push(cd);\r\n        if (!this._rows[j]) {\r\n          this._rows[j] = [];\r\n        }\r\n        this._rows[j].push(cd);\r\n      }\r\n      this._cols[i] = currentCol;\r\n      currentCol = [];\r\n    }\r\n\r\n    this.get(GraphicsComponent).localBounds = new BoundingBox({\r\n      left: 0,\r\n      top: 0,\r\n      right: this.cols * this.cellWidth,\r\n      bottom: this.rows * this.cellHeight\r\n    });\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param key\r\n   * @param spriteSheet\r\n   * @deprecated No longer used, will be removed in v0.26.0\r\n   */\r\n  public registerSpriteSheet(key: string, spriteSheet: SpriteSheet): void;\r\n  public registerSpriteSheet(key: string, spriteSheet: Graphics.SpriteSheet): void;\r\n  @obsolete({ message: 'No longer used, will be removed in v0.26.0' })\r\n  public registerSpriteSheet(key: string, spriteSheet: SpriteSheet | Graphics.SpriteSheet): void {\r\n    if (spriteSheet instanceof Graphics.SpriteSheet) {\r\n      this._spriteSheets[key] = spriteSheet;\r\n    } else {\r\n      this._spriteSheets[key] = Graphics.SpriteSheet.fromLegacySpriteSheet(spriteSheet);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tiles colliders based on the solid tiles in the tilemap.\r\n   */\r\n  private _updateColliders(): void {\r\n    this._composite.clearColliders();\r\n    const colliders: BoundingBox[] = [];\r\n    let current: BoundingBox;\r\n    // Bad square tessalation algo\r\n    for (let i = 0; i < this.cols; i++) {\r\n      // Scan column for colliders\r\n      for (let j = 0; j < this.rows; j++) {\r\n        // Columns start with a new collider\r\n        if (j === 0) {\r\n          current = null;\r\n        }\r\n        const tile = this.data[i + j * this.cols];\r\n        // Current tile in column is solid build up current collider\r\n        if (tile.solid) {\r\n          if (!current) {\r\n            current = tile.bounds;\r\n          } else {\r\n            current = current.combine(tile.bounds);\r\n          }\r\n        } else {\r\n          // Not solid skip and cut off the current collider\r\n          if (current) {\r\n            colliders.push(current);\r\n          }\r\n          current = null;\r\n        }\r\n      }\r\n      // After a column is complete check to see if it can be merged into the last one\r\n      if (current) {\r\n        // if previous is the same combine it\r\n        const prev = colliders[colliders.length - 1];\r\n        if (prev && prev.top === current.top && prev.bottom === current.bottom) {\r\n          colliders[colliders.length - 1] = prev.combine(current);\r\n        } else {\r\n          // else new collider\r\n          colliders.push(current);\r\n        }\r\n      }\r\n    }\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n    for (const c of colliders) {\r\n      const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));\r\n      collider.owner = this;\r\n      this._composite.addCollider(collider);\r\n    }\r\n    this._collider.update();\r\n  }\r\n\r\n  /**\r\n   * Returns the [[Cell]] by index (row major order)\r\n   */\r\n  public getCellByIndex(index: number): Cell {\r\n    return this.data[index];\r\n  }\r\n  /**\r\n   * Returns the [[Cell]] by its x and y coordinates\r\n   */\r\n  public getCell(x: number, y: number): Cell {\r\n    if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.data[x + y * this.cols];\r\n  }\r\n  /**\r\n   * Returns the [[Cell]] by testing a point in global coordinates,\r\n   * returns `null` if no cell was found.\r\n   */\r\n  public getCellByPoint(x: number, y: number): Cell {\r\n    x = Math.floor((x - this.pos.x) / this.cellWidth);\r\n    y = Math.floor((y - this.pos.y) / this.cellHeight);\r\n    const cell = this.getCell(x, y);\r\n    if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {\r\n      return cell;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public getRows(): readonly Cell[][] {\r\n    return this._rows;\r\n  }\r\n\r\n  public getColumns(): readonly Cell[][] {\r\n    return this._cols;\r\n  }\r\n\r\n  public onPreUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  public onPostUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    this.onPreUpdate(engine, delta);\r\n    this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));\r\n    if (this._dirty) {\r\n      this._dirty = false;\r\n      this._updateColliders();\r\n    }\r\n\r\n    this._token++;\r\n    const worldBounds = engine.getWorldBounds();\r\n    const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);\r\n    const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);\r\n\r\n    this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - this.x) / this.cellWidth) - 2, 0);\r\n    this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);\r\n    this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - this.x) / this.cellWidth) + 2, 0);\r\n    this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);\r\n    this._transform.pos = vec(this.x, this.y);\r\n\r\n    this.onPostUpdate(engine, delta);\r\n    this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));\r\n  }\r\n\r\n  /**\r\n   * Draws the tile map to the screen. Called by the [[Scene]].\r\n   * @param ctx CanvasRenderingContext2D or ExcaliburGraphicsContext\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D | ExcaliburGraphicsContext, delta: number): void {\r\n    this.emit('predraw', new Events.PreDrawEvent(ctx as any, delta, this)); // TODO fix event\r\n\r\n    let x = this._onScreenXStart;\r\n    const xEnd = Math.min(this._onScreenXEnd, this.cols);\r\n    let y = this._onScreenYStart;\r\n    const yEnd = Math.min(this._onScreenYEnd, this.rows);\r\n\r\n    let graphics: Graphics.Graphic[], graphicsIndex: number, graphicsLen: number;\r\n\r\n    for (x; x < xEnd; x++) {\r\n      for (y; y < yEnd; y++) {\r\n        // get non-negative tile sprites\r\n        graphics = this.getCell(x, y).graphics;\r\n\r\n        for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {\r\n          // draw sprite, warning if sprite doesn't exist\r\n          const graphic = graphics[graphicsIndex];\r\n          if (graphic) {\r\n            if (!(ctx instanceof CanvasRenderingContext2D)) {\r\n              if (hasGraphicsTick(graphic)) {\r\n                graphic?.tick(delta, this._token);\r\n              }\r\n              graphic.draw(ctx, x * this.cellWidth, y * this.cellHeight);\r\n            } else if (graphic instanceof Graphics.Sprite) {\r\n              // TODO legacy drawing mode\r\n              if (!this._legacySpriteMap.has(graphic)) {\r\n                this._legacySpriteMap.set(graphic, Graphics.Sprite.toLegacySprite(graphic));\r\n              }\r\n              this._legacySpriteMap.get(graphic).draw(ctx, x * this.cellWidth, y * this.cellHeight);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      y = this._onScreenYStart;\r\n    }\r\n\r\n    this.emit('postdraw', new Events.PostDrawEvent(ctx as any, delta, this));\r\n  }\r\n}\r\n\r\nexport interface TileMapArgs extends Partial<TileMapImpl> {\r\n  x: number;\r\n  y: number;\r\n  cellWidth: number;\r\n  cellHeight: number;\r\n  rows: number;\r\n  cols: number;\r\n}\r\n\r\n/**\r\n * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision\r\n * without the overhead of actors.\r\n */\r\nexport class TileMap extends Configurable(TileMapImpl) {\r\n  constructor(config: TileMapArgs);\r\n  constructor(x: number, y: number, cellWidth: number, cellHeight: number, rows: number, cols: number);\r\n  constructor(xOrConfig: number | TileMapArgs, y?: number, cellWidth?: number, cellHeight?: number, rows?: number, cols?: number) {\r\n    super(xOrConfig, y, cellWidth, cellHeight, rows, cols);\r\n  }\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class CellImpl extends Entity {\r\n  private _bounds: BoundingBox;\r\n  /**\r\n   * World space x coordinate of the left of the cell\r\n   */\r\n  public readonly x: number;\r\n  /**\r\n   * World space y coordinate of the top of the cell\r\n   */\r\n  public readonly y: number;\r\n  /**\r\n   * Width of the cell in pixels\r\n   */\r\n  public readonly width: number;\r\n  /**\r\n   * Height of the cell in pixels\r\n   */\r\n  public readonly height: number;\r\n  /**\r\n   * Current index in the tilemap\r\n   */\r\n  public readonly index: number;\r\n\r\n  /**\r\n   * Reference to the TileMap this Cell is associated with\r\n   */\r\n  public map: TileMap;\r\n\r\n  private _solid = false;\r\n  /**\r\n   * Wether this cell should be treated as solid by the tilemap\r\n   */\r\n  public get solid(): boolean {\r\n    return this._solid;\r\n  }\r\n  /**\r\n   * Wether this cell should be treated as solid by the tilemap\r\n   */\r\n  public set solid(val: boolean) {\r\n    this.map?.flagDirty();\r\n    this._solid = val;\r\n  }\r\n  /**\r\n   * Current list of graphics for this cell\r\n   */\r\n  public readonly graphics: Graphics.Graphic[] = [];\r\n  /**\r\n   * Abitrary data storage per cell, useful for any game specific data\r\n   */\r\n  public data = new Map<string, any>();\r\n\r\n  /**\r\n   * @param xOrConfig Gets or sets x coordinate of the cell in world coordinates or cell option bag\r\n   * @param y       Gets or sets y coordinate of the cell in world coordinates\r\n   * @param width   Gets or sets the width of the cell\r\n   * @param height  Gets or sets the height of the cell\r\n   * @param index   The index of the cell in row major order\r\n   * @param solid   Gets or sets whether this cell is solid\r\n   * @param graphics The list of tile graphics to use to draw in this cell (in order)\r\n   */\r\n  constructor(\r\n    xOrConfig: number | CellArgs,\r\n    y: number,\r\n    width: number,\r\n    height: number,\r\n    index: number,\r\n    solid: boolean = false,\r\n    graphics: Graphics.Graphic[] = []\r\n  ) {\r\n    super();\r\n    if (xOrConfig && typeof xOrConfig === 'object') {\r\n      const config = xOrConfig;\r\n      xOrConfig = config.x;\r\n      y = config.y;\r\n      width = config.width;\r\n      height = config.height;\r\n      index = config.index;\r\n      solid = config.solid;\r\n      graphics = config.sprites;\r\n    }\r\n    this.x = <number>xOrConfig;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.index = index;\r\n    this.solid = solid;\r\n    this.graphics = graphics;\r\n    this._bounds = new BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);\r\n  }\r\n\r\n  public get bounds() {\r\n    return this._bounds;\r\n  }\r\n\r\n  public get center(): Vector {\r\n    return new Vector(this.x + this.width / 2, this.y + this.height / 2);\r\n  }\r\n\r\n  /**\r\n   * Add another [[Sprite]] to this cell\r\n   * @deprecated Use addSprite, will be removed in v0.26.0\r\n   */\r\n  @obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'addSprite' })\r\n  public pushSprite(sprite: Graphics.Sprite | LegacySprite) {\r\n    this.addGraphic(sprite);\r\n  }\r\n\r\n  /**\r\n   * Add another [[Graphic]] to this TileMap cell\r\n   * @param graphic\r\n   */\r\n  public addGraphic(graphic: Graphics.Graphic | LegacySprite) {\r\n    if (graphic instanceof LegacySprite) {\r\n      this.graphics.push(Graphics.Sprite.fromLegacySprite(graphic));\r\n    } else {\r\n      this.graphics.push(graphic);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an instance of a [[Graphic]] from this cell\r\n   */\r\n  public removeGraphic(graphic: Graphics.Graphic | LegacySprite) {\r\n    removeItemFromArray(graphic, this.graphics);\r\n  }\r\n\r\n  /**\r\n   * Clear all graphis from this cell\r\n   */\r\n  public clearGraphics() {\r\n    this.graphics.length = 0;\r\n  }\r\n}\r\n\r\nexport interface CellArgs extends Partial<CellImpl> {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n  index: number;\r\n  solid?: boolean;\r\n  sprites?: Graphics.Sprite[];\r\n}\r\n\r\n/**\r\n * TileMap Cell\r\n *\r\n * A light-weight object that occupies a space in a collision map. Generally\r\n * created by a [[TileMap]].\r\n *\r\n * Cells can draw multiple sprites. Note that the order of drawing is the order\r\n * of the sprites in the array so the last one will be drawn on top. You can\r\n * use transparency to create layers this way.\r\n */\r\nexport class Cell extends Configurable(CellImpl) {\r\n  constructor(config: CellArgs);\r\n  constructor(x: number, y: number, width: number, height: number, index: number, solid?: boolean, sprites?: Graphics.Sprite[]);\r\n  constructor(\r\n    xOrConfig: number | CellArgs,\r\n    y?: number,\r\n    width?: number,\r\n    height?: number,\r\n    index?: number,\r\n    solid?: boolean,\r\n    sprites?: Graphics.Sprite[]\r\n  ) {\r\n    super(xOrConfig, y, width, height, index, solid, sprites);\r\n  }\r\n}\r\n","import { Engine } from './Engine';\r\nimport { EasingFunction, EasingFunctions } from './Util/EasingFunctions';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { removeItemFromArray } from './Util/Util';\r\nimport { CanUpdate, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { PreUpdateEvent, PostUpdateEvent, GameEvent, InitializeEvent } from './Events';\r\nimport { Class } from './Class';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { Logger } from './Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { watchAny } from './Util/Watch';\r\n\r\n/**\r\n * Interface that describes a custom camera strategy for tracking targets\r\n */\r\nexport interface CameraStrategy<T> {\r\n  /**\r\n   * Target of the camera strategy that will be passed to the action\r\n   */\r\n  target: T;\r\n\r\n  /**\r\n   * Camera strategies perform an action to calculate a new focus returned out of the strategy\r\n   * @param target The target object to apply this camera strategy (if any)\r\n   * @param camera The current camera implementation in excalibur running the game\r\n   * @param engine The current engine running the game\r\n   * @param delta The elapsed time in milliseconds since the last frame\r\n   */\r\n  action: (target: T, camera: Camera, engine: Engine, delta: number) => Vector;\r\n}\r\n\r\n/**\r\n * Container to house convenience strategy methods\r\n * @internal\r\n */\r\nexport class StrategyContainer {\r\n  constructor(public camera: Camera) {}\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n   * @param actor The actor to lock the camera to\r\n   */\r\n  public lockToActor(actor: Actor) {\r\n    this.camera.addStrategy(new LockCameraToActorStrategy(actor));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n   * @param actor The actor to lock the camera to\r\n   * @param axis The axis to follow the actor on\r\n   */\r\n  public lockToActorAxis(actor: Actor, axis: Axis) {\r\n    this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param actor Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  public elasticToActor(actor: Actor, cameraElasticity: number, cameraFriction: number) {\r\n    this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n   * @param actor Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  public radiusAroundActor(actor: Actor, radius: number) {\r\n    this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera\r\n   * @param box The bounding box to limit the camera to.\r\n   */\r\n  public limitCameraBounds(box: BoundingBox) {\r\n    this.camera.addStrategy(new LimitCameraBoundsStrategy(box));\r\n  }\r\n}\r\n\r\n/**\r\n * Camera axis enum\r\n */\r\nexport enum Axis {\r\n  X,\r\n  Y\r\n}\r\n\r\n/**\r\n * Lock a camera to the exact x/y position of an actor.\r\n */\r\nexport class LockCameraToActorStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor) {}\r\n  public action = (target: Actor, _cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    return center;\r\n  };\r\n}\r\n\r\n/**\r\n * Lock a camera to a specific axis around an actor.\r\n */\r\nexport class LockCameraToActorAxisStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor, public axis: Axis) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    const currentFocus = cam.getFocus();\r\n    if (this.axis === Axis.X) {\r\n      return new Vector(center.x, currentFocus.y);\r\n    } else {\r\n      return new Vector(currentFocus.x, center.y);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.\r\n */\r\nexport class ElasticToActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param target Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  constructor(public target: Actor, public cameraElasticity: number, public cameraFriction: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    let focus = cam.getFocus();\r\n    let cameraVel = cam.vel.clone();\r\n\r\n    // Calculate the stretch vector, using the spring equation\r\n    // F = kX\r\n    // https://en.wikipedia.org/wiki/Hooke's_law\r\n    // Apply to the current camera velocity\r\n    const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X\r\n    cameraVel = cameraVel.add(stretch);\r\n\r\n    // Calculate the friction (-1 to apply a force in the opposition of motion)\r\n    // Apply to the current camera velocity\r\n    const friction = cameraVel.scale(-1).scale(this.cameraFriction);\r\n    cameraVel = cameraVel.add(friction);\r\n\r\n    // Update position by velocity deltas\r\n    focus = focus.add(cameraVel);\r\n\r\n    return focus;\r\n  };\r\n}\r\n\r\nexport class RadiusAroundActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   *\r\n   * @param target Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  constructor(public target: Actor, public radius: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    const focus = cam.getFocus();\r\n\r\n    const direction = position.sub(focus);\r\n    const distance = direction.size;\r\n    if (distance >= this.radius) {\r\n      const offset = distance - this.radius;\r\n      return focus.add(direction.normalize().scale(offset));\r\n    }\r\n    return focus;\r\n  };\r\n}\r\n\r\n/**\r\n * Prevent a camera from going beyond the given camera dimensions.\r\n */\r\nexport class LimitCameraBoundsStrategy implements CameraStrategy<BoundingBox> {\r\n  /**\r\n   * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.\r\n   *\r\n   * Note that this strategy does not perform any movement by itself.\r\n   * It only sets the camera position to within the given bounds when the camera has gone beyond them.\r\n   * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.\r\n   *\r\n   * Make sure that the camera bounds are at least as large as the viewport size.\r\n   *\r\n   * @param target The bounding box to limit the camera to\r\n   */\r\n\r\n  boundSizeChecked: boolean = false; // Check and warn only once\r\n\r\n  constructor(public target: BoundingBox) {}\r\n\r\n  public action = (target: BoundingBox, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const focus = cam.getFocus();\r\n\r\n    if (!this.boundSizeChecked) {\r\n      if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {\r\n        Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');\r\n      }\r\n      this.boundSizeChecked = true;\r\n    }\r\n\r\n    let focusX = focus.x;\r\n    let focusY = focus.y;\r\n    if (focus.x < target.left + _eng.halfDrawWidth) {\r\n      focusX = target.left + _eng.halfDrawWidth;\r\n    } else if (focus.x > target.right - _eng.halfDrawWidth) {\r\n      focusX = target.right - _eng.halfDrawWidth;\r\n    }\r\n\r\n    if (focus.y < target.top + _eng.halfDrawHeight) {\r\n      focusY = target.top + _eng.halfDrawHeight;\r\n    } else if (focus.y > target.bottom - _eng.halfDrawHeight) {\r\n      focusY = target.bottom - _eng.halfDrawHeight;\r\n    }\r\n\r\n    return vec(focusX, focusY);\r\n  };\r\n}\r\n\r\n/**\r\n * Cameras\r\n *\r\n * [[Camera]] is the base class for all Excalibur cameras. Cameras are used\r\n * to move around your game and set focus. They are used to determine\r\n * what is \"off screen\" and can be used to scale the game.\r\n *\r\n */\r\nexport class Camera extends Class implements CanUpdate, CanInitialize {\r\n  protected _follow: Actor;\r\n\r\n  private _cameraStrategies: CameraStrategy<any>[] = [];\r\n\r\n  public strategy: StrategyContainer = new StrategyContainer(this);\r\n\r\n  /**\r\n   * Get or set current zoom of the camera, defaults to 1\r\n   */\r\n  private _z = 1;\r\n  public get zoom(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set zoom(val: number) {\r\n    this._z = val;\r\n    if (this._engine) {\r\n      this._halfWidth = this._engine.halfDrawWidth;\r\n      this._halfHeight = this._engine.halfDrawHeight;\r\n    }\r\n  }\r\n  /**\r\n   * Get or set rate of change in zoom, defaults to 0\r\n   */\r\n  public dz: number = 0;\r\n  /**\r\n   * Get or set zoom acceleration\r\n   */\r\n  public az: number = 0;\r\n\r\n  /**\r\n   * Current rotation of the camera\r\n   */\r\n  public rotation: number = 0;\r\n\r\n  /**\r\n   * Current angular velocity\r\n   */\r\n  public rx: number = 0;\r\n\r\n  /**\r\n   * Get or set the camera's angular velocity\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.rx;\r\n  }\r\n\r\n  public set angularVelocity(value: number) {\r\n    this.rx = value;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's position\r\n   */\r\n  private _posChanged = false;\r\n  private _pos: Vector = watchAny(Vector.Zero, () => (this._posChanged = true));\r\n  public get pos(): Vector {\r\n    return this._pos;\r\n  }\r\n  public set pos(vec: Vector) {\r\n    this._pos = watchAny(vec, () => (this._posChanged = true));\r\n    this._posChanged = true;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's velocity\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * GEt or set the camera's acceleration\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  private _cameraMoving: boolean = false;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1000; // 1 second\r\n  private _lerpStart: Vector = null;\r\n  private _lerpEnd: Vector = null;\r\n  private _lerpResolve: (value: Vector) => void;\r\n  private _lerpPromise: Promise<Vector>;\r\n\r\n  //camera effects\r\n  protected _isShaking: boolean = false;\r\n  private _shakeMagnitudeX: number = 0;\r\n  private _shakeMagnitudeY: number = 0;\r\n  private _shakeDuration: number = 0;\r\n  private _elapsedShakeTime: number = 0;\r\n  private _xShake: number = 0;\r\n  private _yShake: number = 0;\r\n\r\n  protected _isZooming: boolean = false;\r\n  private _zoomStart: number = 1;\r\n  private _zoomEnd: number = 1;\r\n  private _currentZoomTime: number = 0;\r\n  private _zoomDuration: number = 0;\r\n\r\n  private _zoomResolve: (val: boolean) => void;\r\n  private _zoomPromise: Promise<boolean>;\r\n  private _zoomEasing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n  private _easing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n\r\n  private _halfWidth: number = 0;\r\n  private _halfHeight: number = 0;\r\n\r\n  /**\r\n   * Get the camera's x position\r\n   */\r\n  public get x() {\r\n    return this.pos.x;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set x(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(value, this.pos.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the camera's y position\r\n   */\r\n  public get y() {\r\n    return this.pos.y;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set y(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(this.pos.x, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x velocity\r\n   */\r\n  public get dx() {\r\n    return this.vel.x;\r\n  }\r\n\r\n  public set dx(value: number) {\r\n    this.vel = vec(value, this.vel.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y velocity\r\n   */\r\n  public get dy() {\r\n    return this.vel.y;\r\n  }\r\n\r\n  public set dy(value: number) {\r\n    this.vel = vec(this.vel.x, value);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x acceleration\r\n   */\r\n  public get ax() {\r\n    return this.acc.x;\r\n  }\r\n\r\n  public set ax(value: number) {\r\n    this.acc = vec(value, this.acc.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y acceleration\r\n   */\r\n  public get ay() {\r\n    return this.acc.y;\r\n  }\r\n\r\n  public set ay(value: number) {\r\n    this.acc = vec(this.acc.x, value);\r\n  }\r\n\r\n  /**\r\n   * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n   */\r\n  public getFocus() {\r\n    return this.pos;\r\n  }\r\n\r\n  /**\r\n   * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n   *\r\n   * @param pos The target position to move to\r\n   * @param duration The duration in milliseconds the move should last\r\n   * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n   * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.\r\n   *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n   */\r\n  public move(pos: Vector, duration: number, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<Vector> {\r\n    if (typeof easingFn !== 'function') {\r\n      throw 'Please specify an EasingFunction';\r\n    }\r\n\r\n    // cannot move when following an actor\r\n    if (this._follow) {\r\n      return Promise.reject(pos);\r\n    }\r\n\r\n    // resolve existing promise, if any\r\n    if (this._lerpPromise && this._lerpResolve) {\r\n      this._lerpResolve(pos);\r\n    }\r\n\r\n    this._lerpPromise = new Promise<Vector>((resolve) => {\r\n      this._lerpResolve = resolve;\r\n    });\r\n    this._lerpStart = this.getFocus().clone();\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = pos;\r\n    this._currentLerpTime = 0;\r\n    this._cameraMoving = true;\r\n    this._easing = easingFn;\r\n\r\n    return this._lerpPromise;\r\n  }\r\n\r\n  /**\r\n   * Sets the camera to shake at the specified magnitudes for the specified duration\r\n   * @param magnitudeX  The x magnitude of the shake\r\n   * @param magnitudeY  The y magnitude of the shake\r\n   * @param duration    The duration of the shake in milliseconds\r\n   */\r\n  public shake(magnitudeX: number, magnitudeY: number, duration: number) {\r\n    this._isShaking = true;\r\n    this._shakeMagnitudeX = magnitudeX;\r\n    this._shakeMagnitudeY = magnitudeY;\r\n    this._shakeDuration = duration;\r\n  }\r\n\r\n  /**\r\n   * Zooms the camera in or out by the specified scale over the specified duration.\r\n   * If no duration is specified, it take effect immediately.\r\n   * @param scale    The scale of the zoom\r\n   * @param duration The duration of the zoom in milliseconds\r\n   */\r\n  public zoomOverTime(scale: number, duration: number = 0, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<boolean> {\r\n    this._zoomPromise = new Promise<boolean>((resolve) => {\r\n      this._zoomResolve = resolve;\r\n    });\r\n\r\n    if (duration) {\r\n      this._isZooming = true;\r\n      this._zoomEasing = easingFn;\r\n      this._currentZoomTime = 0;\r\n      this._zoomDuration = duration;\r\n      this._zoomStart = this.zoom;\r\n      this._zoomEnd = scale;\r\n    } else {\r\n      this._isZooming = false;\r\n      this.zoom = scale;\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    return this._zoomPromise;\r\n  }\r\n\r\n  private _viewport: BoundingBox = null;\r\n  /**\r\n   * Gets the bounding box of the viewport of this camera in world coordinates\r\n   */\r\n  public get viewport(): BoundingBox {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n\r\n    return new BoundingBox(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Adds a new camera strategy to this camera\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public addStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    this._cameraStrategies.push(cameraStrategy);\r\n  }\r\n\r\n  /**\r\n   * Removes a camera strategy by reference\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public removeStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    removeItemFromArray(cameraStrategy, this._cameraStrategies);\r\n  }\r\n\r\n  /**\r\n   * Clears all camera strategies from the camera\r\n   */\r\n  public clearAllStrategies() {\r\n    this._cameraStrategies.length = 0;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  private _engine: Engine;\r\n  private _isInitialized = false;\r\n  public get isInitialized() {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public _initialize(_engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this._engine = _engine;\r\n\r\n      const currentRes = this._engine.screen.resolution;\r\n      let center = vec(currentRes.width / 2, currentRes.height / 2);\r\n      if (!this._engine.loadingComplete) {\r\n        // If there was a loading screen, we peek the configured resolution\r\n        const res = this._engine.screen.peekResolution();\r\n        if (res) {\r\n          center = vec(res.width / 2, res.height / 2);\r\n        }\r\n      }\r\n      this._halfWidth = center.x;\r\n      this._halfHeight = center.x;\r\n\r\n      // If the user has not set the camera pos, apply default center screen position\r\n      if (!this._posChanged) {\r\n        this.pos = center;\r\n      }\r\n\r\n      this.onInitialize(_engine);\r\n      super.emit('initialize', new InitializeEvent(_engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onInitialize(_engine: Engine) {\r\n    // Overridable\r\n  }\r\n\r\n  public on(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public on(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public on(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public on(eventName: any, handler: any) {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'initialize', handler?: (event: InitializeEvent) => void): void;\r\n  public off(eventName: 'preupdate', handler?: (event: PreUpdateEvent) => void): void;\r\n  public off(eventName: 'postupdate', handler?: (event: PostUpdateEvent) => void): void;\r\n  public off(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public off(eventName: string, handler: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public once(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public once(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this._initialize(_engine);\r\n    this._preupdate(_engine, delta);\r\n\r\n    // Update placements based on linear algebra\r\n    this.pos = this.pos.add(this.vel.scale(delta / 1000));\r\n    this.zoom += (this.dz * delta) / 1000;\r\n\r\n    this.vel = this.vel.add(this.acc.scale(delta / 1000));\r\n    this.dz += (this.az * delta) / 1000;\r\n\r\n    this.rotation += (this.angularVelocity * delta) / 1000;\r\n\r\n    if (this._isZooming) {\r\n      if (this._currentZoomTime < this._zoomDuration) {\r\n        const zoomEasing = this._zoomEasing;\r\n        const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);\r\n\r\n        this.zoom = newZoom;\r\n        this._currentZoomTime += delta;\r\n      } else {\r\n        this._isZooming = false;\r\n        this.zoom = this._zoomEnd;\r\n        this._currentZoomTime = 0;\r\n        this._zoomResolve(true);\r\n      }\r\n    }\r\n\r\n    if (this._cameraMoving) {\r\n      if (this._currentLerpTime < this._lerpDuration) {\r\n        const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);\r\n\r\n        const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);\r\n\r\n        this.pos = lerpPoint;\r\n\r\n        this._currentLerpTime += delta;\r\n      } else {\r\n        this.pos = this._lerpEnd;\r\n        const end = this._lerpEnd.clone();\r\n\r\n        this._lerpStart = null;\r\n        this._lerpEnd = null;\r\n        this._currentLerpTime = 0;\r\n        this._cameraMoving = false;\r\n        // Order matters here, resolve should be last so any chain promises have a clean slate\r\n        this._lerpResolve(end);\r\n      }\r\n    }\r\n\r\n    if (this._isDoneShaking()) {\r\n      this._isShaking = false;\r\n      this._elapsedShakeTime = 0;\r\n      this._shakeMagnitudeX = 0;\r\n      this._shakeMagnitudeY = 0;\r\n      this._shakeDuration = 0;\r\n      this._xShake = 0;\r\n      this._yShake = 0;\r\n    } else {\r\n      this._elapsedShakeTime += delta;\r\n      this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;\r\n      this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;\r\n    }\r\n\r\n    for (const s of this._cameraStrategies) {\r\n      this.pos = s.action.call(s, s.target, this, _engine, delta);\r\n    }\r\n\r\n    this._viewport = new BoundingBox(\r\n      this.x - this._halfWidth,\r\n      this.y - this._halfHeight,\r\n      this.x + this._halfWidth,\r\n      this.y + this._halfHeight\r\n    );\r\n\r\n    this._postupdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Applies the relevant transformations to the game canvas to \"move\" or apply effects to the Camera\r\n   * @param ctx    Canvas context to apply transformations\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D): void;\r\n  public draw(ctx: ExcaliburGraphicsContext): void;\r\n  public draw(ctx: CanvasRenderingContext2D | ExcaliburGraphicsContext): void {\r\n    let canvasWidth = 0;\r\n    let canvasHeight = 0;\r\n    if (ctx instanceof CanvasRenderingContext2D) {\r\n      canvasWidth = ctx.canvas.width;\r\n      canvasHeight = ctx.canvas.height;\r\n    } else {\r\n      canvasWidth = ctx.width;\r\n      canvasHeight = ctx.height;\r\n    }\r\n    const focus = this.getFocus();\r\n    const pixelRatio = this._engine ? this._engine.pixelRatio : 1;\r\n    const zoom = this.zoom;\r\n\r\n    const newCanvasWidth = canvasWidth / zoom / pixelRatio;\r\n    const newCanvasHeight = canvasHeight / zoom / pixelRatio;\r\n\r\n    ctx.scale(zoom, zoom);\r\n    ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public debugDraw(_ctx: CanvasRenderingContext2D) {\r\n    // pass\r\n  }\r\n\r\n  private _isDoneShaking(): boolean {\r\n    return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;\r\n  }\r\n}\r\n","import { Actor } from '../Actor';\r\nimport { ScreenElement } from '../ScreenElement';\r\nimport { Label } from '../Label';\r\nimport { Trigger } from '../Trigger';\r\n\r\n/**\r\n * Type guard to detect if something is an actor\r\n * @deprecated Will be removed in v0.26.0\r\n * @param actor\r\n */\r\nexport function isVanillaActor(actor: Actor) {\r\n  return !(actor instanceof ScreenElement) && !(actor instanceof Trigger) && !(actor instanceof Label);\r\n}\r\n\r\n/**\r\n * Type guard to detect a screen element\r\n * @todo move to ScreenElement\r\n */\r\nexport function isScreenElement(actor: Actor) {\r\n  return actor instanceof ScreenElement;\r\n}\r\n","import { Color } from './Color';\nimport { Engine } from './Engine';\nimport { EventDispatcher } from './EventDispatcher';\nimport { Vector } from './Math/vector';\nimport { ExitTriggerEvent, EnterTriggerEvent, CollisionEndEvent, CollisionStartEvent } from './Events';\nimport * as Util from './Util/Util';\nimport { CollisionType } from './Collision/CollisionType';\nimport { Entity } from './EntityComponentSystem';\nimport { Actor } from './Actor';\n\n/**\n * ITriggerOptions\n */\nexport interface TriggerOptions {\n  // position of the trigger\n  pos: Vector;\n  // width of the trigger\n  width: number;\n  // height of the trigger\n  height: number;\n  // whether the trigger is visible or not\n  visible: boolean;\n  // action to take when triggered\n  action: () => void;\n  // if specified the trigger will only fire on a specific actor and overrides any filter\n  target: Entity;\n  // Returns true if the triggers should fire on the collided actor\n  filter: (actor: Entity) => boolean;\n  // -1 if it should repeat forever\n  repeat: number;\n}\n\nconst triggerDefaults: Partial<TriggerOptions> = {\n  pos: Vector.Zero,\n  width: 10,\n  height: 10,\n  visible: false,\n  action: () => {\n    return;\n  },\n  filter: () => true,\n  repeat: -1\n};\n\n/**\n * Triggers are a method of firing arbitrary code on collision. These are useful\n * as 'buttons', 'switches', or to trigger effects in a game. By default triggers\n * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\n */\nexport class Trigger extends Actor {\n  private _target: Entity;\n  /**\n   * Action to fire when triggered by collision\n   */\n  public action: () => void = () => {\n    return;\n  };\n  /**\n   * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\n   * filter return true for the collided actor.\n   */\n  public filter: (actor: Entity) => boolean = () => true;\n  /**\n   * Number of times to repeat before killing the trigger,\n   */\n  public repeat: number = -1;\n\n  /**\n   *\n   * @param opts Trigger options\n   */\n  constructor(opts: Partial<TriggerOptions>) {\n    super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });\n    opts = Util.extend({}, triggerDefaults, opts);\n\n    this.filter = opts.filter || this.filter;\n    this.repeat = opts.repeat || this.repeat;\n    this.action = opts.action || this.action;\n    if (opts.target) {\n      this.target = opts.target;\n    }\n\n    this.graphics.visible = opts.visible;\n    this.body.collisionType = CollisionType.Passive;\n    this.eventDispatcher = new EventDispatcher(this);\n\n    this.events.on('collisionstart', (evt: CollisionStartEvent<Actor>) => {\n      if (this.filter(evt.other)) {\n        this.emit('enter', new EnterTriggerEvent(this, evt.other));\n        this._dispatchAction();\n        // remove trigger if its done, -1 repeat forever\n        if (this.repeat === 0) {\n          this.kill();\n        }\n      }\n    });\n\n    this.events.on('collisionend', (evt: CollisionEndEvent<Actor>) => {\n      if (this.filter(evt.other)) {\n        this.emit('exit', new ExitTriggerEvent(this, evt.other));\n      }\n    });\n  }\n\n  public set target(target: Entity) {\n    this._target = target;\n    this.filter = (actor: Entity) => actor === target;\n  }\n\n  public get target() {\n    return this._target;\n  }\n\n  public _initialize(engine: Engine) {\n    super._initialize(engine);\n  }\n\n  private _dispatchAction() {\n    if (this.repeat !== 0) {\n      this.action.call(this);\n      this.repeat--;\n    }\n  }\n\n  /* istanbul ignore next */\n  public debugDraw(ctx: CanvasRenderingContext2D) {\n    super.debugDraw(ctx);\n    // Meant to draw debug information about actors\n    ctx.save();\n    ctx.translate(this.pos.x, this.pos.y);\n\n    const bb = this.collider.bounds;\n    const wp = this.getGlobalPos();\n    bb.left = bb.left - wp.x;\n    bb.right = bb.right - wp.x;\n    bb.top = bb.top - wp.y;\n    bb.bottom = bb.bottom - wp.y;\n\n    ctx.fillStyle = Color.Violet.toString();\n    ctx.strokeStyle = Color.Violet.toString();\n    ctx.fillText('Trigger', 10, 10);\n    bb.debugDraw(ctx);\n\n    ctx.restore();\n  }\n}\n","import { Entity } from './Entity';\r\nimport { Message, Observer } from '../Util/Observable';\r\nimport { Component } from './Component';\r\nimport { Scene } from '../Scene';\r\n\r\n/**\r\n * Enum that determines whether to run the system in the update or draw phase\r\n */\r\nexport enum SystemType {\r\n  Update = 'update',\r\n  Draw = 'draw'\r\n}\r\n\r\nexport type SystemTypes<ComponentTypes> = ComponentTypes extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * An Excalibur [[System]] that updates entities of certain types.\r\n * Systems are scene specific\r\n *\r\n * Excalibur Systems currently require at least 1 Component type to operated\r\n *\r\n * Multiple types are declared as a type union\r\n * For example:\r\n *\r\n * ```typescript\r\n * class MySystem extends System<ComponentA | ComponentB> {\r\n *   public readonly types = ['a', 'b'] as const;\r\n *   public readonly systemType = SystemType.Update;\r\n *   public update(entities: Entity<ComponentA | ComponentB>) {\r\n *      ...\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport abstract class System<ComponentTypeUnion extends Component = Component, ContextType = Scene>\r\nimplements Observer<AddedEntity | RemovedEntity> {\r\n  /**\r\n   * The types of entities that this system operates on\r\n   * For example ['transform', 'motion']\r\n   */\r\n  abstract readonly types: readonly SystemTypes<ComponentTypeUnion>[];\r\n\r\n  /**\r\n   * Determine whether the system is called in the [[SystemType.Update]] or the [[SystemType.Draw]] phase. Update is first, then Draw.\r\n   */\r\n  abstract readonly systemType: SystemType;\r\n\r\n  /**\r\n   * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.\r\n   * For a system to execute before all other a lower priority value (-1 for example) must be set.\r\n   * For a system to exectue after all other a higher priority value (10 for example) must be set.\r\n   */\r\n  public priority: number = 0;\r\n\r\n  /**\r\n   * Optionally specify a sort order for entities passed to the your system\r\n   * @param a The left entity\r\n   * @param b The right entity\r\n   */\r\n  sort?(a: Entity, b: Entity): number;\r\n\r\n  /**\r\n   * Optionally specify an initialize handler\r\n   * @param scene\r\n   */\r\n  initialize?(engine: ContextType): void;\r\n\r\n  /**\r\n   * Update all entities that match this system's types\r\n   * @param entities Entities to update that match this system's types\r\n   * @param delta Time in milliseconds\r\n   */\r\n  abstract update(entities: Entity[], delta: number): void;\r\n\r\n  /**\r\n   * Optionally run a preupdate before the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  preupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Optionally run a postupdate after the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  postupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Systems observe when entities match their types or no longer match their types, override\r\n   * @param _entityAddedOrRemoved\r\n   */\r\n  public notify(_entityAddedOrRemoved: AddedEntity | RemovedEntity) {\r\n    // Override me\r\n  }\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.\r\n */\r\nexport class AddedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Added' = 'Entity Added';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * Type guard to check for AddedEntity messages\r\n * @param x\r\n */\r\nexport function isAddedSystemEntity(x: Message<Entity>): x is AddedEntity {\r\n  return !!x && x.type === 'Entity Added';\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.\r\n */\r\nexport class RemovedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Removed' = 'Entity Removed';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * type guard to check for the RemovedEntity message\r\n */\r\nexport function isRemoveSystemEntity(x: Message<Entity>): x is RemovedEntity {\r\n  return !!x && x.type === 'Entity Removed';\r\n}\r\n","import { Entity, RemovedComponent, AddedComponent, isAddedComponent, isRemovedComponent } from './Entity';\r\nimport { Observer } from '../Util/Observable';\r\nimport { World } from './World';\r\nimport { Util } from '..';\r\n\r\n// Add/Remove entitys and components\r\n\r\nexport class EntityManager<ContextType = any> implements Observer<RemovedComponent | AddedComponent> {\r\n  public entities: Entity[] = [];\r\n  public _entityIndex: { [entityId: string]: Entity } = {};\r\n\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Runs the entity lifecycle\r\n   * @param _context\r\n   */\r\n  public updateEntities(_context: ContextType, elapsed: number) {\r\n    for (const entity of this.entities) {\r\n      // TODO is this right?\r\n      entity.update((_context as any).engine, elapsed);\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  public findEntitiesForRemoval() {\r\n    for (const entity of this.entities) {\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EntityManager observes changes on entities\r\n   * @param message\r\n   */\r\n  public notify(message: RemovedComponent | AddedComponent): void {\r\n    if (isAddedComponent(message)) {\r\n      // we don't need the component, it's already on the entity\r\n      this._world.queryManager.addEntity(message.data.entity);\r\n    }\r\n\r\n    if (isRemovedComponent(message)) {\r\n      this._world.queryManager.removeComponent(message.data.entity, message.data.component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be tracked by the EntityManager\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    entity.active = true;\r\n    if (entity && !this._entityIndex[entity.id]) {\r\n      this._entityIndex[entity.id] = entity;\r\n      this.entities.push(entity);\r\n      this._world.queryManager.addEntity(entity);\r\n      entity.componentAdded$.register(this);\r\n      entity.componentRemoved$.register(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.addEntity(c));\r\n      entity.childrenAdded$.register({\r\n        notify: (e) => {\r\n          this.addEntity(e);\r\n        }\r\n      });\r\n      entity.childrenRemoved$.register({\r\n        notify: (e) => {\r\n          this.removeEntity(e, false);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  public removeEntity(entity: Entity, deferred?: boolean): void;\r\n  public removeEntity(id: number, deferred?: boolean): void;\r\n  public removeEntity(idOrEntity: number | Entity, deferred = true): void {\r\n    let id = 0;\r\n    if (idOrEntity instanceof Entity) {\r\n      id = idOrEntity.id;\r\n    } else {\r\n      id = idOrEntity;\r\n    }\r\n    const entity = this._entityIndex[id];\r\n    if (entity && entity.active) {\r\n      entity.kill();\r\n    }\r\n\r\n    if (entity && deferred) {\r\n      this._entitiesToRemove.push(entity);\r\n      return;\r\n    }\r\n\r\n    delete this._entityIndex[id];\r\n    if (entity) {\r\n      Util.removeItemFromArray(entity, this.entities);\r\n      this._world.queryManager.removeEntity(entity);\r\n      entity.componentAdded$.unregister(this);\r\n      entity.componentRemoved$.unregister(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.removeEntity(c, deferred));\r\n      entity.childrenAdded$.clear();\r\n      entity.childrenRemoved$.clear();\r\n\r\n      // stats\r\n      if ((this._world.context as any)?.engine) {\r\n        (this._world.context as any).engine.stats.currFrame.actors.killed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _entitiesToRemove: Entity[] = [];\r\n  public processEntityRemovals(): void {\r\n    for (const entity of this._entitiesToRemove) {\r\n      if (entity.active) {\r\n        continue;\r\n      }\r\n      this.removeEntity(entity, false);\r\n    }\r\n  }\r\n\r\n  public processComponentRemovals(): void {\r\n    for (const entity of this.entities) {\r\n      entity.processComponentRemoval();\r\n    }\r\n  }\r\n\r\n  public getById(id: number): Entity {\r\n    return this._entityIndex[id];\r\n  }\r\n\r\n  public getByName(name: string): Entity[]{\r\n    return this.entities.filter(e => e.name === name);\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const entity of this.entities) {\r\n      this.removeEntity(entity);\r\n    }\r\n  }\r\n}\r\n","import { PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Side } from '../Side';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,\r\n * and negates velocity along the collision normal.\r\n *\r\n * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.\r\n *\r\n */\r\nexport class ArcadeSolver extends CollisionSolver {\r\n  public preSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n      }\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public solvePosition(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      let mtv = contact.mtv;\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {\r\n          // split overlaps if both are Active\r\n          mtv = mtv.scale(0.5);\r\n        }\r\n\r\n        // Resolve overlaps\r\n        if (bodyA.collisionType === CollisionType.Active) {\r\n          bodyA.pos.x -= mtv.x;\r\n          bodyA.pos.y -= mtv.y;\r\n        }\r\n\r\n        if (bodyB.collisionType === CollisionType.Active) {\r\n          bodyB.pos.x += mtv.x;\r\n          bodyB.pos.y += mtv.y;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public solveVelocity(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n\r\n      if (bodyA && bodyB) {\r\n\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        const normal = contact.normal;\r\n        const opposite = normal.negate();\r\n\r\n        // Cancel out velocity opposite direction of collision normal\r\n        if (bodyA.collisionType === CollisionType.Active) {\r\n          const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));\r\n          bodyA.vel = bodyA.vel.add(velAdj);\r\n        }\r\n\r\n        if (bodyB.collisionType === CollisionType.Active) {\r\n          const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));\r\n          bodyB.vel = bodyB.vel.add(velAdj);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","export const buildTypeKey = (types: readonly string[]) => {\r\n  const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');\r\n  return key;\r\n};\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Observable } from '../Util/Observable';\r\nimport { Util, Component, ComponentCtor } from '..';\r\nimport { AddedEntity, RemovedEntity } from './System';\r\n\r\n/**\r\n * Represents query for entities that match a list of types that is cached and observable\r\n *\r\n * Queries can be strongly typed by supplying a type union in the optional type parameter\r\n * ```typescript\r\n * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);\r\n * ```\r\n */\r\nexport class Query<T extends Component = Component> extends Observable<AddedEntity | RemovedEntity> {\r\n  public types: readonly string[];\r\n  private _entities: Entity[] = [];\r\n  private _key: string;\r\n  public get key(): string {\r\n    if (this._key) {\r\n      return this._key;\r\n    }\r\n    return (this._key = buildTypeKey(this.types));\r\n  }\r\n\r\n  constructor(types: readonly string[]);\r\n  constructor(types: readonly ComponentCtor<T>[]);\r\n  constructor(types: readonly string[] | readonly ComponentCtor<T>[]) {\r\n    super();\r\n    if (types[0] instanceof Function) {\r\n      this.types = (types as ComponentCtor<T>[]).map(T =>  (new T).type);\r\n    } else {\r\n      this.types = types as string[];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a list of entities that match the query\r\n   *\r\n   * @param sort Optional sorting function to sort entities returned from the query\r\n   */\r\n  public getEntities(sort?: (a: Entity, b: Entity) => number): Entity[] {\r\n    if (sort) {\r\n      this._entities.sort(sort);\r\n    }\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the query, will only be added if the entity matches the query types\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    if (!Util.contains(this._entities, entity) && this.matches(entity)) {\r\n      this._entities.push(entity);\r\n      this.notifyAll(new AddedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the entity is part of the query it will be removed regardless of types\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity): void {\r\n    if (Util.removeItemFromArray(entity, this._entities)) {\r\n      this.notifyAll(new RemovedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and observers from the query\r\n   */\r\n  public clear(): void {\r\n    this._entities.length = 0;\r\n    for (const observer of this.observers) {\r\n      this.unregister(observer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether the entity's types match query\r\n   * @param entity\r\n   */\r\n  public matches(entity: Entity): boolean;\r\n\r\n  /**\r\n   * Returns whether the list of ComponentTypes have at least the same types as the query\r\n   * @param types\r\n   */\r\n  public matches(types: string[]): boolean;\r\n  public matches(typesOrEntity: string[] | Entity): boolean {\r\n    let types: string[] = [];\r\n    if (typesOrEntity instanceof Entity) {\r\n      types = typesOrEntity.types;\r\n    } else {\r\n      types = typesOrEntity;\r\n    }\r\n\r\n    let matches = true;\r\n    for (const type of this.types) {\r\n      matches = matches && types.indexOf(type) > -1;\r\n      if (!matches) {\r\n        return false;\r\n      }\r\n    }\r\n    return matches;\r\n  }\r\n\r\n  public contain(type: string) {\r\n    return this.types.indexOf(type) > -1;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Query } from './Query';\r\nimport { Component } from './Component';\r\nimport { World } from './World';\r\n\r\n/**\r\n * The query manager is responsible for updating all queries when entities/components change\r\n */\r\nexport class QueryManager {\r\n  private _queries: { [entityComponentKey: string]: Query<any> } = {};\r\n\r\n  constructor(private _world: World<any>) {}\r\n\r\n  /**\r\n   * Adds a query to the manager and populates with any entities that match\r\n   * @param query\r\n   */\r\n  private _addQuery(query: Query<any>) {\r\n    this._queries[buildTypeKey(query.types)] = query;\r\n    for (const entity of this._world.entityManager.entities) {\r\n      query.addEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the query if there are no observers left\r\n   * @param query\r\n   */\r\n  public maybeRemoveQuery(query: Query): void {\r\n    if (query.observers.length === 0) {\r\n      query.clear();\r\n      delete this._queries[buildTypeKey(query.types)];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the entity to any matching query in the query manage\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      if (this._queries[queryType]) {\r\n        this._queries[queryType].addEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from queries if the removed component disqualifies it\r\n   * @param entity\r\n   * @param component\r\n   */\r\n  public removeComponent(entity: Entity, component: Component) {\r\n    for (const queryType in this._queries) {\r\n      // If the component being removed from an entity is a part of a query,\r\n      // it is now disqualified from that query, remove it\r\n      if (this._queries[queryType].contain(component.type)) {\r\n        this._queries[queryType].removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from all queries it is currently a part of\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      this._queries[queryType].removeEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance\r\n   * @param types\r\n   */\r\n  public createQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const maybeExistingQuery = this.getQuery<T>(types);\r\n    if (maybeExistingQuery) {\r\n      return maybeExistingQuery;\r\n    }\r\n    const query = new Query<T>(types);\r\n    this._addQuery(query);\r\n    return query;\r\n  }\r\n\r\n  /**\r\n   * Retrieves an existing query by types if it exists otherwise returns null\r\n   * @param types\r\n   */\r\n  public getQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const key = buildTypeKey(types);\r\n    if (this._queries[key]) {\r\n      return this._queries[key] as Query<T>;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","import { System, SystemType } from './System';\r\nimport { Scene, Util } from '..';\r\nimport { World } from './World';\r\n\r\nexport interface SystemCtor<T extends System> {\r\n  new (): T;\r\n}\r\n\r\n/**\r\n * The SystemManager is responsible for keeping track of all systems in a scene.\r\n * Systems are scene specific\r\n */\r\nexport class SystemManager<ContextType> {\r\n  /**\r\n   * List of systems, to add a new system call [[SystemManager.addSystem]]\r\n   */\r\n  public systems: System<any, ContextType>[] = [];\r\n  public _keyToSystem: { [key: string]: System<any, ContextType> };\r\n  public initialized = false;\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Get a system registered in the manager by type\r\n   * @param systemType\r\n   * @returns\r\n   */\r\n  public get<T extends System>(systemType: SystemCtor<T>): T | null {\r\n    return this.systems.find((s) => s instanceof systemType) as unknown as T;\r\n  }\r\n\r\n  /**\r\n   * Adds a system to the manager, it will now be updated every frame\r\n   * @param system\r\n   */\r\n  public addSystem(system: System<any, ContextType>): void {\r\n    // validate system has types\r\n    if (!system.types || system.types.length === 0) {\r\n      throw new Error(`Attempted to add a System without any types`);\r\n    }\r\n\r\n    const query = this._world.queryManager.createQuery(system.types);\r\n    this.systems.push(system);\r\n    this.systems.sort((a, b) => a.priority - b.priority);\r\n    query.register(system);\r\n    if (this.initialized && system.initialize) {\r\n      system.initialize(this._world.context);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a system from the manager, it will no longer be updated\r\n   * @param system\r\n   */\r\n  public removeSystem(system: System<any, ContextType>) {\r\n    Util.removeItemFromArray(system, this.systems);\r\n    const query = this._world.queryManager.getQuery(system.types);\r\n    if (query) {\r\n      query.unregister(system);\r\n      this._world.queryManager.maybeRemoveQuery(query);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates all systems\r\n   * @param type whether this is an update or draw system\r\n   * @param context context reference\r\n   * @param delta time in milliseconds\r\n   */\r\n  public updateSystems(type: SystemType, context: ContextType, delta: number) {\r\n    if (!this.initialized) {\r\n      this.initialized = true;\r\n      for (const s of this.systems) {\r\n        if (s.initialize) {\r\n          s.initialize(this._world.context);\r\n        }\r\n      }\r\n    }\r\n\r\n    const systems = this.systems.filter((s) => s.systemType === type);\r\n    for (const s of systems) {\r\n      if (s.preupdate) {\r\n        s.preupdate(context, delta);\r\n      }\r\n    }\r\n\r\n    for (const s of systems) {\r\n      // Get entities that match the system types, pre-sort\r\n      const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);\r\n      // Initialize entities if needed\r\n      if (context instanceof Scene) {\r\n        for (const entity of entities) {\r\n          entity._initialize(context?.engine);\r\n        }\r\n      }\r\n      s.update(entities, delta);\r\n    }\r\n\r\n    for (const s of systems) {\r\n      if (s.postupdate) {\r\n        s.postupdate(context, delta);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const system of this.systems) {\r\n      this.removeSystem(system);\r\n    }\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { EntityManager } from './EntityManager';\r\nimport { QueryManager } from './QueryManager';\r\nimport { System, SystemType } from './System';\r\nimport { SystemManager } from './SystemManager';\r\n\r\n/**\r\n * The World is a self-contained entity component system for a particular context.\r\n */\r\nexport class World<ContextType> {\r\n  public queryManager: QueryManager = new QueryManager(this);\r\n  public entityManager: EntityManager<ContextType> = new EntityManager<ContextType>(this);\r\n  public systemManager: SystemManager<ContextType> = new SystemManager<ContextType>(this);\r\n\r\n  /**\r\n   * The context type is passed to the system updates\r\n   * @param context\r\n   */\r\n  constructor(public context: ContextType) {}\r\n\r\n  /**\r\n   * Update systems by type and time elapsed in milliseconds\r\n   */\r\n  update(type: SystemType, delta: number) {\r\n    if (type === SystemType.Update) {\r\n      this.entityManager.updateEntities(this.context, delta);\r\n    }\r\n    this.systemManager.updateSystems(type, this.context, delta);\r\n    this.entityManager.findEntitiesForRemoval();\r\n    this.entityManager.processComponentRemovals();\r\n    this.entityManager.processEntityRemovals();\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the ECS world\r\n   * @param entity\r\n   */\r\n  add(entity: Entity): void;\r\n  /**\r\n   * Add a system to the ECS world\r\n   * @param system\r\n   */\r\n  add(system: System<any, ContextType>): void;\r\n  add(entityOrSystem: Entity | System<any, ContextType>): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.addEntity(entityOrSystem);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.addSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from the ECS world\r\n   * @param entity\r\n   */\r\n  remove(entity: Entity, deferred?: boolean): void;\r\n  /**\r\n   * Remove a system from the ECS world\r\n   * @param system\r\n   */\r\n  remove(system: System<any, ContextType>): void;\r\n  remove(entityOrSystem: Entity | System<any, ContextType>, deferred = true): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.removeEntity(entityOrSystem, deferred);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.removeSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  clearEntities(): void {\r\n    this.entityManager.clear();\r\n  }\r\n\r\n  clearSystems(): void {\r\n    this.systemManager.clear();\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\nimport { TransformComponent } from '../EntityComponentSystem';\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\n\nexport class EulerIntegrator {\n  static integrate(transform: TransformComponent, motion: MotionComponent, totalAcc: Vector, elapsedMs: number): void {\n    const seconds = elapsedMs / 1000;\n    motion.vel.addEqual(totalAcc.scale(seconds));\n    transform.pos.addEqual(motion.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));\n\n    motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;\n    transform.rotation += motion.angularVelocity * seconds;\n\n    transform.scale.addEqual(motion.scaleFactor.scale(seconds));\n  }\n}\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Physics } from './Physics';\r\nimport { BodyComponent } from './BodyComponent';\r\nimport { CollisionType } from './CollisionType';\r\nimport { EulerIntegrator } from './Integrator';\r\n\r\nexport class MotionSystem extends System<TransformComponent | MotionComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  update(_entities: Entity[], elapsedMs: number): void {\r\n    let transform: TransformComponent;\r\n    let motion: MotionComponent;\r\n    for (const entity of _entities) {\r\n      transform = entity.get(TransformComponent);\r\n      motion = entity.get(MotionComponent);\r\n\r\n      const optionalBody = entity.get(BodyComponent);\r\n      if (optionalBody?.sleeping) {\r\n        continue;\r\n      }\r\n\r\n      const totalAcc = motion.acc.clone();\r\n      if (optionalBody?.collisionType === CollisionType.Active && optionalBody?.useGravity) {\r\n        totalAcc.addEqual(Physics.gravity);\r\n      }\r\n      optionalBody?.captureOldTransform();\r\n\r\n      // Update transform and motion based on Euler linear algebra\r\n      EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);\r\n    }\r\n  }\r\n\r\n  debugDraw(_ctx: CanvasRenderingContext2D) {\r\n    // pass\r\n  }\r\n}\r\n","import { CollisionContact } from '../Detection/CollisionContact';\r\n\r\n/**\r\n * A collision solver figures out how to position colliders such that they are no longer overlapping\r\n *\r\n * Solvers are executed in the order\r\n *\r\n * 1. preSolve\r\n * 2. solveVelocity\r\n * 3. solvePosition\r\n * 4. postSolve\r\n * @inheritdoc\r\n */\r\nexport abstract class CollisionSolver {\r\n  /**\r\n   * Pre-solve is fired on contacts before any resolution is started. It is used for any setup work before collision resolution\r\n   * can proceed. Optionally contacts can be \"opted out\" of any collision processing by calling `contact.cancel()`\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract preSolve(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Post-solve is fired after all resolution is complete\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract postSolve(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Solve velocity adjusts the velocity of colliders so that they are not overlapping or will not be overlapping from velocity\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract solveVelocity(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Solve position adjust the position of collders so that they are not overlapping\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract solvePosition(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Solves overlapping contact in\r\n   *\r\n   * Solvers are executed in the order\r\n   * 1. preSolve\r\n   * 2. solveVelocity\r\n   * 3. solvePosition\r\n   * 4. postSolve\r\n   * @param contacts\r\n   */\r\n  public solve(contacts: CollisionContact[]): CollisionContact[] {\r\n    // Events and init\r\n    this.preSolve(contacts);\r\n\r\n    // Remove any canceled contacts\r\n    contacts = contacts.filter(c => !c.isCanceled());\r\n\r\n    // Solve velocity first\r\n    this.solveVelocity(contacts);\r\n\r\n    // Solve position last because non-overlap is the most important\r\n    this.solvePosition(contacts);\r\n\r\n    // Events and any contact house-keeping the solver needs\r\n    this.postSolve(contacts);\r\n\r\n    return contacts;\r\n  }\r\n}","import { Vector } from '../../Math/vector';\nimport { BodyComponent } from '../BodyComponent';\nimport { CollisionContact } from '../Detection/CollisionContact';\n\n/**\n * Holds information about contact points, meant to be reused over multiple frames of contact\n */\nexport class ContactConstraintPoint {\n  constructor(public point: Vector, public local: Vector, public contact: CollisionContact) {\n    this.update();\n  }\n\n  /**\n   * Updates the contact information\n   */\n  update() {\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\n\n    if (bodyA && bodyB) {\n      const normal = this.contact.normal;\n      const tangent = this.contact.tangent;\n\n      this.aToContact = this.point.sub(bodyA.pos);\n      this.bToContact = this.point.sub(bodyB.pos);\n\n      const aToContactNormal = this.aToContact.cross(normal);\n      const bToContactNormal = this.bToContact.cross(normal);\n\n      this.normalMass =\n        bodyA.inverseMass +\n        bodyB.inverseMass +\n        bodyA.inverseInertia * aToContactNormal * aToContactNormal +\n        bodyB.inverseInertia * bToContactNormal * bToContactNormal;\n\n      const aToContactTangent = this.aToContact.cross(tangent);\n      const bToContactTangent = this.bToContact.cross(tangent);\n\n      this.tangentMass =\n        bodyA.inverseMass +\n        bodyB.inverseMass +\n        bodyA.inverseInertia * aToContactTangent * aToContactTangent +\n        bodyB.inverseInertia * bToContactTangent * bToContactTangent;\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the relative velocity betwen bodyA and bodyB\n   */\n  public getRelativeVelocity() {\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\n    if (bodyA && bodyB) {\n      // Relative velocity in linear terms\n      // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\n      const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));\n      const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));\n      return velB.sub(velA);\n    }\n    return Vector.Zero;\n  }\n\n  /**\n   * Impulse accumulated over time in normal direction\n   */\n  public normalImpulse: number = 0;\n\n  /**\n   * Impulse accumulated over time in the tangent direction\n   */\n  public tangentImpulse: number = 0;\n\n  /**\n   * Effective mass seen in the normal direction\n   */\n  public normalMass: number = 0;\n\n  /**\n   * Effective mass seen in the tangent direction\n   */\n  public tangentMass: number = 0;\n\n  /**\n   * Direction from center of mass of bodyA to contact point\n   */\n  public aToContact: Vector = new Vector(0, 0);\n\n  /**\n   * Direction from center of mass of bodyB to contact point\n   */\n  public bToContact: Vector = new Vector(0, 0);\n}\n","import { CollisionPostSolveEvent, CollisionPreSolveEvent, PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { clamp } from '../../Util/Util';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { ContactConstraintPoint } from './ContactConstraintPoint';\r\nimport { Side } from '../Side';\r\nimport { Physics } from '../Physics';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CollisionJumpTable } from '../Colliders/CollisionJumpTable';\r\n\r\nexport class RealisticSolver extends CollisionSolver {\r\n  lastFrameContacts: Map<string, CollisionContact> = new Map();\r\n\r\n  // map contact id to contact points\r\n  idToContactConstraint: Map<string, ContactConstraintPoint[]> = new Map();\r\n\r\n  getContactConstraints(id: string) {\r\n    return this.idToContactConstraint.get(id) ?? [];\r\n  }\r\n\r\n  preSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n\r\n      // Match awake state for sleeping\r\n      contact.matchAwake();\r\n    }\r\n\r\n    // Keep track of contacts that done\r\n    const finishedContactIds = Array.from(this.idToContactConstraint.keys());\r\n    for (const contact of contacts) {\r\n      // Remove all current contacts that are not done\r\n      const index = finishedContactIds.indexOf(contact.id);\r\n      if (index > -1) {\r\n        finishedContactIds.splice(index, 1);\r\n      }\r\n      const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n      let pointIndex = 0;\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        for (const point of contact.points) {\r\n          const normal = contact.normal;\r\n          const tangent = contact.tangent;\r\n\r\n          const aToContact = point.sub(bodyA.pos);\r\n          const bToContact = point.sub(bodyB.pos);\r\n\r\n          const aToContactNormal = aToContact.cross(normal);\r\n          const bToContactNormal = bToContact.cross(normal);\r\n\r\n          const normalMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n            bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n          const aToContactTangent = aToContact.cross(tangent);\r\n          const bToContactTangent = bToContact.cross(tangent);\r\n\r\n          const tangentMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n            bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n\r\n          // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n          if (contactPoints[pointIndex] && contactPoints[pointIndex]?.point?.squareDistance(point) < 4) {\r\n            contactPoints[pointIndex].point = point;\r\n            contactPoints[pointIndex].local = contact.localPoints[pointIndex];\r\n          } else {\r\n            // new contact if it's not close or doesn't exist\r\n            contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);\r\n          }\r\n\r\n          // Update contact point calculations\r\n          contactPoints[pointIndex].aToContact = aToContact;\r\n          contactPoints[pointIndex].bToContact = bToContact;\r\n          contactPoints[pointIndex].normalMass = normalMass;\r\n          contactPoints[pointIndex].tangentMass = tangentMass;\r\n\r\n          pointIndex++;\r\n        }\r\n      }\r\n      this.idToContactConstraint.set(contact.id, contactPoints);\r\n    }\r\n\r\n    // Clean up any contacts that did not occur last frame\r\n    for (const id of finishedContactIds) {\r\n      this.idToContactConstraint.delete(id);\r\n    }\r\n\r\n    // Warm contacts with accumulated impulse\r\n    // Useful for tall stacks\r\n    if (Physics.warmStart) {\r\n      this.warmStart(contacts);\r\n    } else {\r\n      for (const contact of contacts) {\r\n        const contactPoints = this.getContactConstraints(contact.id);\r\n        for (const point of contactPoints) {\r\n          point.normalImpulse = 0;\r\n          point.tangentImpulse = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n\r\n      if (bodyA && bodyB) {\r\n        // Skip post solve for active+passive collisions\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        // Update motion values for sleeping\r\n        bodyA.updateMotion();\r\n        bodyB.updateMotion();\r\n      }\r\n\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n    }\r\n\r\n    // Store contacts\r\n    this.lastFrameContacts.clear();\r\n    for (const c of contacts) {\r\n      this.lastFrameContacts.set(c.id, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warm up body's based on previous frame contact points\r\n   * @param contacts\r\n   */\r\n  warmStart(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n        for (const point of contactPoints) {\r\n          if (Physics.warmStart) {\r\n            const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n            const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\r\n            const impulse = normalImpulse.add(tangentImpulse);\r\n\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          } else {\r\n            point.normalImpulse = 0;\r\n            point.tangentImpulse = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iteratively solve the position overlap constraint\r\n   * @param contacts\r\n   */\r\n  solvePosition(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.positionIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n          for (const point of constraints) {\r\n            const normal = contact.normal;\r\n            const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);\r\n\r\n            const steeringConstant = Physics.steeringFactor; //0.2;\r\n            const maxCorrection = -5;\r\n            const slop = Physics.slop; //1;\r\n\r\n            // Clamp to avoid over-correction\r\n            // Remember that we are shooting for 0 overlap in the end\r\n            const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n            const impulse = normal.scale(-steeringForce / point.normalMass);\r\n\r\n            // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n            // We adjust position and rotation instead of doing the velocity\r\n            if (bodyA.collisionType === CollisionType.Active) {\r\n              bodyA.pos = bodyA.pos.add(impulse.negate().scale(bodyA.inverseMass));\r\n              bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n            }\r\n\r\n            if (bodyB.collisionType === CollisionType.Active) {\r\n              bodyB.pos = bodyB.pos.add(impulse.scale(bodyB.inverseMass));\r\n              bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  solveVelocity(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.velocityIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const restitution = bodyA.bounciness * bodyB.bounciness;\r\n          const friction = Math.min(bodyA.friction, bodyB.friction);\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n          for (const point of constraints) {\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Negate velocity in tangent direction to simulate friction\r\n            const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n            let impulseDelta = tangentVelocity / point.tangentMass;\r\n\r\n            // Clamping based in Erin Catto's GDC 2006 talk\r\n            // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n            // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n            // But deltas can vary\r\n            const maxFriction = friction * point.normalImpulse;\r\n            const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n            impulseDelta = newImpulse - point.tangentImpulse;\r\n            point.tangentImpulse = newImpulse;\r\n\r\n            const impulse = contact.tangent.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n\r\n          for (const point of constraints) {\r\n            // Need to recalc relative velocity because the previous step could have changed vel\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Compute impulse in normal direction\r\n            const normalVelocity = relativeVelocity.dot(contact.normal);\r\n            // See https://en.wikipedia.org/wiki/Collision_response\r\n            let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;\r\n\r\n            // Clamping based in Erin Catto's GDC 2014 talk\r\n            // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n            // But deltas can be negative\r\n            const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n            impulseDelta = newImpulse - point.normalImpulse;\r\n            point.normalImpulse = newImpulse;\r\n\r\n            const impulse = contact.normal.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { CollisionEndEvent, CollisionStartEvent, ContactEndEvent, ContactStartEvent } from '../Events';\r\nimport { CollisionResolutionStrategy, Physics } from './Physics';\r\nimport { ArcadeSolver } from './Solver/ArcadeSolver';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { DynamicTreeCollisionProcessor } from './Detection/DynamicTreeCollisionProcessor';\r\nimport { RealisticSolver } from './Solver/RealisticSolver';\r\nimport { CollisionSolver } from './Solver/Solver';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { Engine, ExcaliburGraphicsContext, Scene } from '..';\r\n\r\nexport class CollisionSystem extends System<TransformComponent | MotionComponent | ColliderComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion', 'ex.collider'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _realisticSolver = new RealisticSolver();\r\n  private _arcadeSolver = new ArcadeSolver();\r\n  private _processor = new DynamicTreeCollisionProcessor();\r\n  private _lastFrameContacts = new Map<string, CollisionContact>();\r\n  private _currentFrameContacts = new Map<string, CollisionContact>();\r\n\r\n  private _trackCollider = (c: Collider) => this._processor.track(c);\r\n  private _untrackCollider = (c: Collider) => this._processor.untrack(c);\r\n\r\n  notify(message: AddedEntity | RemovedEntity) {\r\n    if (isAddedSystemEntity(message)) {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      colliderComponent.$colliderAdded.subscribe(this._trackCollider);\r\n      colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);\r\n      const collider = colliderComponent.get();\r\n      if (collider) {\r\n        this._processor.track(collider);\r\n      }\r\n    } else {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      const collider = colliderComponent.get();\r\n      if (colliderComponent && collider) {\r\n        this._processor.untrack(collider);\r\n      }\r\n    }\r\n  }\r\n\r\n  initialize(scene: Scene) {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  update(_entities: Entity[], elapsedMs: number): void {\r\n    if (!Physics.enabled) {\r\n      return;\r\n    }\r\n\r\n    // Collect up all the colliders\r\n    let colliders: Collider[] = [];\r\n    for (const entity of _entities) {\r\n      const colliderComp = entity.get(ColliderComponent);\r\n      const collider = colliderComp?.get();\r\n      if (colliderComp && colliderComp.owner?.active && collider) {\r\n        colliderComp.update();\r\n        if (collider instanceof CompositeCollider) {\r\n          colliders = colliders.concat(collider.getColliders());\r\n        } else {\r\n          colliders.push(collider);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update the spatial partitioning data structures\r\n    // TODO if collider invalid it will break the processor\r\n    // TODO rename \"update\" to something more specific\r\n    this._processor.update(colliders);\r\n\r\n    // Run broadphase on all colliders and locates potential collisions\r\n    const pairs = this._processor.broadphase(colliders, elapsedMs);\r\n\r\n    this._currentFrameContacts.clear();\r\n\r\n    // Given possible pairs find actual contacts\r\n    let contacts = this._processor.narrowphase(pairs, this._engine.debug.stats.currFrame);\r\n\r\n    const solver: CollisionSolver = this.getSolver();\r\n\r\n    // Solve, this resolves the position/velocity so entities arent overlapping\r\n    contacts = solver.solve(contacts);\r\n\r\n    // Record contacts\r\n    contacts.forEach((c) => this._currentFrameContacts.set(c.id, c));\r\n\r\n    // Emit contact start/end events\r\n    this.runContactStartEnd();\r\n\r\n    // reset the last frame cache\r\n    this._lastFrameContacts.clear();\r\n\r\n    // Keep track of collisions contacts that have started or ended\r\n    this._lastFrameContacts = new Map(this._currentFrameContacts);\r\n  }\r\n\r\n  getSolver(): CollisionSolver {\r\n    return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;\r\n  }\r\n\r\n  debug(ex: ExcaliburGraphicsContext) {\r\n    this._processor.debug(ex);\r\n  }\r\n\r\n  public runContactStartEnd() {\r\n    for (const [id, c] of this._currentFrameContacts) {\r\n      // find all new contacts\r\n      if (!this._lastFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));\r\n        colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c) as any);\r\n        colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));\r\n        colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c) as any);\r\n      }\r\n    }\r\n\r\n    // find all contacts taht have ceased\r\n    for (const [id, c] of this._lastFrameContacts) {\r\n      if (!this._currentFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));\r\n        colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB) as any);\r\n        colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));\r\n        colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA) as any);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { clamp } from '../Util/Util';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { Logger } from '../Util/Log';\r\nimport { Engine, LegacyDrawing } from '..';\r\nimport { Sprite } from '.';\r\n\r\nexport interface HasTick {\r\n  /**\r\n   *\r\n   * @param elapsedMilliseconds The amount of real world time in milliseconds that has elapsed that must be updated in the animation\r\n   * @param idempotencyToken Optional idempotencyToken prevents a ticking animation from updating twice per frame\r\n   */\r\n  tick(elapsedMilliseconds: number, idempotencyToken?: number): void;\r\n}\r\n\r\nexport enum AnimationDirection {\r\n  /**\r\n   * Animation is playing forwards\r\n   */\r\n  Forward = 'forward',\r\n  /**\r\n   * Animation is play backwards\r\n   */\r\n  Backward = 'backward'\r\n}\r\n\r\nexport enum AnimationStrategy {\r\n  /**\r\n   * Animation ends without displaying anything\r\n   */\r\n  End = 'end',\r\n  /**\r\n   * Animation loops to the first frame after the last frame\r\n   */\r\n  Loop = 'loop',\r\n  /**\r\n   * Animation plays to the last frame, then backwards to the first frame, then repeats\r\n   */\r\n  PingPong = 'pingpong',\r\n  /**\r\n   * Animation ends stopping on the last frame\r\n   */\r\n  Freeze = 'freeze'\r\n}\r\n\r\n/**\r\n * Frame of animation\r\n */\r\nexport interface Frame {\r\n  /**\r\n   * Optionally specify a graphic to show, no graphic shows an empty frame\r\n   */\r\n  graphic?: Graphic;\r\n  /**\r\n   * Optionally specify the number of ms the frame should be visible, overrids the animation duration (default 100 ms)\r\n   */\r\n  duration?: number;\r\n}\r\n\r\n/**\r\n * Animation options for building an animation via constructor.\r\n */\r\nexport interface AnimationOptions {\r\n  /**\r\n   * List of frames in the order you wish to play them\r\n   */\r\n  frames: Frame[];\r\n  /**\r\n   * Optionally reverse the direction of play\r\n   */\r\n  reverse?: boolean;\r\n  /**\r\n   * Optionally specify a default frame duration in ms (Default is 1000)\r\n   */\r\n  frameDuration?: number;\r\n  /**\r\n   * Optionally specify a total duration of the animation in ms to calculate each frame's duration\r\n   */\r\n  totalDuration?: number;\r\n  /**\r\n   * Optionally specify the [[AnimationStrategy]] for the Animation\r\n   */\r\n  strategy?: AnimationStrategy;\r\n}\r\n\r\n// TODO wire up to new Emitter\r\nexport type AnimationEvents = {\r\n  frame: Frame;\r\n  loop: Animation;\r\n  ended: Animation;\r\n};\r\n\r\n/**\r\n * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]\r\n *\r\n * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]\r\n */\r\nexport class Animation extends Graphic implements HasTick {\r\n  private static _LOGGER = Logger.getInstance();\r\n  public events = new EventDispatcher<any>(this); // TODO replace with new Emitter\r\n  public frames: Frame[] = [];\r\n  public strategy: AnimationStrategy = AnimationStrategy.Loop;\r\n  public frameDuration: number = 100;\r\n  public timeScale: number = 1;\r\n\r\n  private _idempotencyToken = -1;\r\n\r\n  private _firstTick = true;\r\n  private _currentFrame = 0;\r\n  private _timeLeftInFrame = 0;\r\n  private _direction = 1; // TODO only used in ping-pong\r\n  private _done = false;\r\n  private _playing = true;\r\n\r\n  constructor(options: GraphicOptions & AnimationOptions) {\r\n    super(options);\r\n    this.frames = options.frames;\r\n    this.strategy = options.strategy ?? this.strategy;\r\n    this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : options.frameDuration ?? this.frameDuration;\r\n    if (options.reverse) {\r\n      this.reverse();\r\n    }\r\n    this.goToFrame(0);\r\n  }\r\n\r\n  public clone(): Animation {\r\n    return new Animation({\r\n      frames: this.frames.map((f) => ({ ...f })),\r\n      frameDuration: this.frameDuration,\r\n      reverse: this._reversed,\r\n      strategy: this.strategy,\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame\r\n   * and optional [[AnimationStrategy]]\r\n   *\r\n   * Example:\r\n   * ```typescript\r\n   * const spriteSheet = SpriteSheet.fromImageSource({...});\r\n   *\r\n   * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);\r\n   * ```\r\n   *\r\n   * @param spriteSheet\r\n   * @param frameIndices\r\n   * @param durationPerFrameMs\r\n   * @param strategy\r\n   */\r\n  public static fromSpriteSheet(\r\n    spriteSheet: SpriteSheet,\r\n    frameIndices: number[],\r\n    durationPerFrameMs: number,\r\n    strategy: AnimationStrategy = AnimationStrategy.Loop\r\n  ): Animation {\r\n    const maxIndex = spriteSheet.sprites.length - 1;\r\n    const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);\r\n    if (invalidIndices.length) {\r\n      Animation._LOGGER.warn(\r\n        `Indices into SpriteSheet were provided that don\\'t exist: ${invalidIndices.join(',')} no frame will be shown`\r\n      );\r\n    }\r\n    return new Animation({\r\n      frames: spriteSheet.sprites\r\n        .filter((_, index) => frameIndices.indexOf(index) > -1)\r\n        .map((f) => ({\r\n          graphic: f,\r\n          duration: durationPerFrameMs\r\n        })),\r\n      strategy: strategy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Converts an animation to a legacy animation\r\n   * @deprecated\r\n   * @param engine\r\n   * @param animation\r\n   * @returns LegacyDrawing.Animation\r\n   */\r\n  public static toLegacyAnimation(engine: Engine, animation: Animation): LegacyDrawing.Animation {\r\n    const legacySprites = animation.frames.map(f => Sprite.toLegacySprite(f.graphic as Sprite));\r\n    return new LegacyDrawing.Animation({\r\n      sprites: legacySprites,\r\n      loop: animation.strategy === AnimationStrategy.Loop,\r\n      freezeFrame: animation.strategy === AnimationStrategy.Freeze ? legacySprites.length - 1 : undefined,\r\n      speed: animation.frameDuration,\r\n      engine: engine\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the current Frame of the animation\r\n   */\r\n  public get currentFrame(): Frame | null {\r\n    if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {\r\n      return this.frames[this._currentFrame];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the current frame index of the animation\r\n   */\r\n  public get currentFrameIndex(): number {\r\n    return this._currentFrame;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is playing\r\n   */\r\n  public get isPlaying(): boolean {\r\n    return this._playing;\r\n  }\r\n\r\n  private _reversed = false;\r\n  /**\r\n   * Reverses the play direction of the Animation, this preserves the current frame\r\n   */\r\n  public reverse(): void {\r\n    // Don't mutate with the original frame list, create a copy\r\n    this.frames = this.frames.slice().reverse();\r\n    this._reversed = !this._reversed;\r\n  }\r\n\r\n  /**\r\n   * Returns the current play direction of the animation\r\n   */\r\n  public get direction(): AnimationDirection {\r\n    // Keep logically consistent with ping-pong direction\r\n    // If ping-pong is forward = 1 and reversed is true then we are logically reversed\r\n    const reversed = (this._reversed && this._direction === 1) ? true : false;\r\n    return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;\r\n  }\r\n\r\n  /**\r\n   * Plays or resumes the animation from the current frame\r\n   */\r\n  public play(): void {\r\n    this._playing = true;\r\n  }\r\n\r\n  /**\r\n   * Pauses the animation on the current frame\r\n   */\r\n  public pause(): void {\r\n    this._playing = false;\r\n    this._firstTick = true; // firstTick must be set to emit the proper frame event\r\n  }\r\n\r\n  /**\r\n   * Reset the animation back to the beginning, including if the animation were done\r\n   */\r\n  public reset(): void {\r\n    this._done = false;\r\n    this._firstTick = true;\r\n    this._currentFrame = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation can end\r\n   */\r\n  public get canFinish(): boolean {\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.End:\r\n      case AnimationStrategy.Freeze: {\r\n        return true;\r\n      }\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is done, for looping type animations\r\n   * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`\r\n   *\r\n   * See the `ex.Animation.canFinish()` method to know if an animation type can end\r\n   */\r\n  public get done(): boolean {\r\n    return this._done;\r\n  }\r\n\r\n  /**\r\n   * Jump the animation immediately to a specific frame if it exists\r\n   * @param frameNumber\r\n   */\r\n  public goToFrame(frameNumber: number) {\r\n    this._currentFrame = frameNumber;\r\n    this._timeLeftInFrame = this.frameDuration;\r\n    const maybeFrame = this.frames[this._currentFrame];\r\n    if (maybeFrame && !this._done) {\r\n      this._timeLeftInFrame = maybeFrame?.duration || this.frameDuration;\r\n      this.width = maybeFrame.graphic?.width;\r\n      this.height = maybeFrame.graphic?.height;\r\n      this.events.emit('frame', maybeFrame as any);\r\n    }\r\n  }\r\n\r\n  private _nextFrame(): number {\r\n    const currentFrame = this._currentFrame;\r\n    if (this._done) {\r\n      return currentFrame;\r\n    }\r\n    let next = -1;\r\n\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.Loop: {\r\n        next = (currentFrame + 1) % this.frames.length;\r\n        if (next === 0) {\r\n          this.events.emit('loop', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.End: {\r\n        next = currentFrame + 1;\r\n        if (next >= this.frames.length) {\r\n          this._done = true;\r\n          this._currentFrame = this.frames.length;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.Freeze: {\r\n        next = clamp(currentFrame + 1, 0, this.frames.length - 1);\r\n        if (next >= this.frames.length - 1) {\r\n          this._done = true;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.PingPong: {\r\n        if (currentFrame + this._direction >= this.frames.length) {\r\n          this._direction = -1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        if (currentFrame + this._direction < 0) {\r\n          this._direction = 1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        next = currentFrame + (this._direction % this.frames.length);\r\n        break;\r\n      }\r\n    }\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * Called internally by Excalibur to update the state of the animation potential update the current frame\r\n   * @param elapsedMilliseconds Milliseconds elapsed\r\n   * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame\r\n   */\r\n  public tick(elapsedMilliseconds: number, idempotencyToken: number = 0): void {\r\n    if (this._idempotencyToken === idempotencyToken) {\r\n      return;\r\n    }\r\n    this._idempotencyToken = idempotencyToken;\r\n    if (!this._playing) {\r\n      return;\r\n    }\r\n\r\n    // if it's the first frame emit frame event\r\n    if (this._firstTick) {\r\n      this._firstTick = false;\r\n      this.events.emit('frame', this.currentFrame as any);\r\n    }\r\n\r\n    this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;\r\n    if (this._timeLeftInFrame <= 0) {\r\n      this.goToFrame(this._nextFrame());\r\n    }\r\n    this._updateDimensions();\r\n  }\r\n\r\n  private _updateDimensions() {\r\n    if (this.currentFrame) {\r\n      this.width = this.currentFrame.graphic?.width;\r\n      this.height = this.currentFrame.graphic?.height;\r\n    }\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this.currentFrame) {\r\n      this.currentFrame.graphic.draw(ctx, x, y);\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\nimport { Graphic, GraphicOptions } from './Graphic';\nimport { Animation, HasTick } from './Animation';\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\nimport { BoundingBox } from '../Collision/Index';\n\nexport interface GraphicsGroupingOptions {\n  members: GraphicsGrouping[];\n}\n\nexport interface GraphicsGrouping {\n  pos: Vector;\n  graphic: Graphic;\n}\n\nexport class GraphicsGroup extends Graphic implements HasTick {\n  public members: GraphicsGrouping[] = [];\n\n  constructor(options: GraphicsGroupingOptions & GraphicOptions) {\n    super(options);\n    this.members = options.members;\n    this._updateDimensions();\n  }\n\n  public clone(): GraphicsGroup {\n    return new GraphicsGroup({\n      members: [...this.members],\n      ...this.cloneGraphicOptions()\n    });\n  }\n\n  private _updateDimensions(): BoundingBox {\n    let bb = new BoundingBox();\n    for (const { graphic, pos } of this.members) {\n      bb = graphic.localBounds.translate(pos).combine(bb);\n    }\n\n    this.width = bb.width;\n    this.height = bb.height;\n\n    return bb;\n  }\n\n  public get localBounds(): BoundingBox {\n    let bb = new BoundingBox();\n    for (const { graphic, pos } of this.members) {\n      bb = graphic.localBounds.translate(pos).combine(bb);\n    }\n    return bb;\n  }\n\n  private _isAnimationOrGroup(graphic: Graphic): graphic is Animation | GraphicsGroup {\n    return graphic instanceof Animation || graphic instanceof GraphicsGroup;\n  }\n\n  public tick(elapsedMilliseconds: number, idempotencyToken?: number) {\n    for (const member of this.members) {\n      const maybeAnimation = member.graphic;\n      if (this._isAnimationOrGroup(maybeAnimation)) {\n        maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);\n      }\n    }\n  }\n\n  public reset() {\n    for (const member of this.members) {\n      const maybeAnimation = member.graphic;\n      if (this._isAnimationOrGroup(maybeAnimation)) {\n        maybeAnimation.reset();\n      }\n    }\n  }\n\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number) {\n    this._updateDimensions();\n    super._preDraw(ex, x, y);\n  }\n\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\n    for (const member of this.members) {\n      ex.save();\n      ex.translate(x, y);\n      member.graphic.draw(ex, member.pos.x, member.pos.y);\n      if (this.showDebug) {\n        /* istanbul ignore next */\n        ex.debug.drawRect(0, 0, this.width, this.height);\n      }\n      ex.restore();\n    }\n  }\n}\n","import { Engine } from './Engine';\r\nimport { Actor } from './Actor';\r\nimport { Color } from './Color';\r\nimport { Vector, vec } from './Math/vector';\r\nimport * as Util from './Util/Util';\r\nimport * as DrawUtil from './Util/DrawUtil';\r\nimport * as Traits from './Traits/Index';\r\nimport { Configurable } from './Configurable';\r\nimport { Random } from './Math/Random';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { CanvasDrawComponent } from './Drawing/Index';\r\nimport { Sprite } from './Graphics/Sprite';\r\nimport { LegacyDrawing } from '.';\r\n\r\n/**\r\n * An enum that represents the types of emitter nozzles\r\n */\r\nexport enum EmitterType {\r\n  /**\r\n   * Constant for the circular emitter type\r\n   */\r\n  Circle,\r\n  /**\r\n   * Constant for the rectangular emitter type\r\n   */\r\n  Rectangle\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ParticleImpl extends Entity {\r\n  public position: Vector = new Vector(0, 0);\r\n  public velocity: Vector = new Vector(0, 0);\r\n  public acceleration: Vector = new Vector(0, 0);\r\n  public particleRotationalVelocity: number = 0;\r\n  public currentRotation: number = 0;\r\n\r\n  public focus: Vector = null;\r\n  public focusAccel: number = 0;\r\n  public opacity: number = 1;\r\n  public beginColor: Color = Color.White;\r\n  public endColor: Color = Color.White;\r\n\r\n  // Life is counted in ms\r\n  public life: number = 300;\r\n  public fadeFlag: boolean = false;\r\n\r\n  // Color transitions\r\n  private _rRate: number = 1;\r\n  private _gRate: number = 1;\r\n  private _bRate: number = 1;\r\n  private _aRate: number = 0;\r\n  private _currentColor: Color = Color.White;\r\n\r\n  public emitter: ParticleEmitter = null;\r\n  public particleSize: number = 5;\r\n  public particleSprite: LegacyDrawing.Sprite = null;\r\n\r\n  public startSize: number;\r\n  public endSize: number;\r\n  public sizeRate: number = 0;\r\n  public elapsedMultiplier: number = 0;\r\n\r\n  public visible = true;\r\n  public isOffscreen = false;\r\n\r\n  public transform: TransformComponent;\r\n  public graphics: GraphicsComponent;\r\n\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super();\r\n    let emitter = emitterOrConfig;\r\n    if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {\r\n      const config = emitterOrConfig;\r\n      emitter = config.emitter;\r\n      life = config.life;\r\n      opacity = config.opacity;\r\n      endColor = config.endColor;\r\n      beginColor = config.beginColor;\r\n      position = config.position;\r\n      velocity = config.velocity;\r\n      acceleration = config.acceleration;\r\n      startSize = config.startSize;\r\n      endSize = config.endSize;\r\n    }\r\n    this.emitter = <ParticleEmitter>emitter;\r\n    this.life = life || this.life;\r\n    this.opacity = opacity || this.opacity;\r\n    this.endColor = endColor || this.endColor.clone();\r\n    this.beginColor = beginColor || this.beginColor.clone();\r\n    this._currentColor = this.beginColor.clone();\r\n    this.position = (position || this.position).add(this.emitter.pos);\r\n    this.velocity = velocity || this.velocity;\r\n    this.acceleration = acceleration || this.acceleration;\r\n    this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\r\n    this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\r\n    this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\r\n    this._aRate = this.opacity / this.life;\r\n\r\n    this.startSize = startSize || 0;\r\n    this.endSize = endSize || 0;\r\n\r\n    if (this.endSize > 0 && this.startSize > 0) {\r\n      this.sizeRate = (this.endSize - this.startSize) / this.life;\r\n      this.particleSize = this.startSize;\r\n    }\r\n\r\n    this.addComponent((this.transform = new TransformComponent()));\r\n    this.addComponent(new CanvasDrawComponent((ctx) => this.draw(ctx)));\r\n    this.addComponent((this.graphics = new GraphicsComponent()));\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // TODO wut\r\n    if (this.particleSprite) {\r\n      this.graphics.opacity = this.opacity;\r\n      this.graphics.use(Sprite.fromLegacySprite(this.particleSprite));\r\n    } else {\r\n      this.graphics.onPostDraw = (ctx) => {\r\n        ctx.save();\r\n        this.graphics.opacity = this.opacity;\r\n        const tmpColor = this._currentColor.clone();\r\n        tmpColor.a = 1;\r\n        ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });\r\n        ctx.restore();\r\n      };\r\n    }\r\n  }\r\n\r\n  public kill() {\r\n    this.emitter.removeParticle(this);\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this.life = this.life - delta;\r\n    this.elapsedMultiplier = this.elapsedMultiplier + delta;\r\n\r\n    if (this.life < 0) {\r\n      this.kill();\r\n    }\r\n\r\n    if (this.fadeFlag) {\r\n      this.opacity = Util.clamp(this._aRate * this.life, 0.0001, 1);\r\n    }\r\n\r\n    if (this.startSize > 0 && this.endSize > 0) {\r\n      this.particleSize = Util.clamp(\r\n        this.sizeRate * delta + this.particleSize,\r\n        Math.min(this.startSize, this.endSize),\r\n        Math.max(this.startSize, this.endSize)\r\n      );\r\n    }\r\n\r\n    this._currentColor.r = Util.clamp(this._currentColor.r + this._rRate * delta, 0, 255);\r\n    this._currentColor.g = Util.clamp(this._currentColor.g + this._gRate * delta, 0, 255);\r\n    this._currentColor.b = Util.clamp(this._currentColor.b + this._bRate * delta, 0, 255);\r\n    this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);\r\n\r\n    if (this.focus) {\r\n      const accel = this.focus\r\n        .sub(this.position)\r\n        .normalize()\r\n        .scale(this.focusAccel)\r\n        .scale(delta / 1000);\r\n      this.velocity = this.velocity.add(accel);\r\n    } else {\r\n      this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\r\n    }\r\n    this.position = this.position.add(this.velocity.scale(delta / 1000));\r\n\r\n    if (this.particleRotationalVelocity) {\r\n      this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);\r\n    }\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // todo wut\r\n    this.graphics.opacity = this.opacity;\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D) {\r\n    if (this.particleSprite) {\r\n      this.particleSprite.opacity(this.opacity);\r\n      this.particleSprite.draw(ctx, 0, 0);\r\n      return;\r\n    }\r\n\r\n    ctx.save();\r\n    this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);\r\n    ctx.fillStyle = this._currentColor.toString();\r\n    ctx.beginPath();\r\n    ctx.arc(0, 0, this.particleSize, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.closePath();\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nexport interface ParticleArgs extends Partial<ParticleImpl> {\r\n  emitter: ParticleEmitter;\r\n  position?: Vector;\r\n  velocity?: Vector;\r\n  acceleration?: Vector;\r\n  particleRotationalVelocity?: number;\r\n  currentRotation?: number;\r\n  particleSize?: number;\r\n  particleSprite?: LegacyDrawing.Sprite;\r\n}\r\n\r\n/**\r\n * Particle is used in a [[ParticleEmitter]]\r\n */\r\nexport class Particle extends Configurable(ParticleImpl) {\r\n  constructor(config: ParticleArgs);\r\n  constructor(\r\n    emitter: ParticleEmitter,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  );\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);\r\n  }\r\n}\r\n\r\nexport interface ParticleEmitterArgs {\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  width?: number;\r\n  height?: number;\r\n  isEmitting?: boolean;\r\n  minVel?: number;\r\n  maxVel?: number;\r\n  acceleration?: Vector;\r\n  minAngle?: number;\r\n  maxAngle?: number;\r\n  emitRate?: number;\r\n  particleLife?: number;\r\n  opacity?: number;\r\n  fadeFlag?: boolean;\r\n  focus?: Vector;\r\n  focusAccel?: number;\r\n  startSize?: number;\r\n  endSize?: number;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  beginColor?: Color;\r\n  endColor?: Color;\r\n  particleSprite?: LegacyDrawing.Sprite;\r\n  emitterType?: EmitterType;\r\n  radius?: number;\r\n  particleRotationalVelocity?: number;\r\n  randomRotation?: boolean;\r\n  random?: Random;\r\n}\r\n\r\n/**\r\n * Using a particle emitter is a great way to create interesting effects\r\n * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n * extend [[Actor]] allowing you to use all of the features that come with.\r\n */\r\nexport class ParticleEmitter extends Actor {\r\n  private _particlesToEmit: number = 0;\r\n\r\n  public numParticles: number = 0;\r\n\r\n  /**\r\n   * Random number generator\r\n   */\r\n  public random: Random;\r\n\r\n  /**\r\n   * Gets or sets the isEmitting flag\r\n   */\r\n  public isEmitting: boolean = true;\r\n  /**\r\n   * Gets or sets the backing particle collection\r\n   */\r\n  public particles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the backing deadParticle collection\r\n   */\r\n  public deadParticles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the minimum particle velocity\r\n   */\r\n  public minVel: number = 0;\r\n  /**\r\n   * Gets or sets the maximum particle velocity\r\n   */\r\n  public maxVel: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the acceleration vector for all particles\r\n   */\r\n  public acceleration: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Gets or sets the minimum angle in radians\r\n   */\r\n  public minAngle: number = 0;\r\n  /**\r\n   * Gets or sets the maximum angle in radians\r\n   */\r\n  public maxAngle: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the emission rate for particles (particles/sec)\r\n   */\r\n  public emitRate: number = 1; //particles/sec\r\n  /**\r\n   * Gets or sets the life of each particle in milliseconds\r\n   */\r\n  public particleLife: number = 2000;\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public get opacity(): number {\r\n    return super.graphics.opacity;\r\n  }\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public set opacity(opacity: number) {\r\n    super.graphics.opacity = opacity;\r\n  }\r\n  /**\r\n   * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n   */\r\n  public fadeFlag: boolean = false;\r\n\r\n  /**\r\n   * Gets or sets the optional focus where all particles should accelerate towards\r\n   */\r\n  public focus: Vector = null;\r\n  /**\r\n   * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n   */\r\n  public focusAccel: number = null;\r\n  /**\r\n   * Gets or sets the optional starting size for the particles\r\n   */\r\n  public startSize: number = null;\r\n  /**\r\n   * Gets or sets the optional ending size for the particles\r\n   */\r\n  public endSize: number = null;\r\n\r\n  /**\r\n   * Gets or sets the minimum size of all particles\r\n   */\r\n  public minSize: number = 5;\r\n  /**\r\n   * Gets or sets the maximum size of all particles\r\n   */\r\n  public maxSize: number = 5;\r\n\r\n  /**\r\n   * Gets or sets the beginning color of all particles\r\n   */\r\n  public beginColor: Color = Color.White;\r\n  /**\r\n   * Gets or sets the ending color of all particles\r\n   */\r\n  public endColor: Color = Color.White;\r\n\r\n  private _og: LegacyDrawing.Sprite = null;\r\n  private _sprite: Sprite = null;\r\n  /**\r\n   * Gets or sets the sprite that a particle should use\r\n   */\r\n  public get particleSprite(): LegacyDrawing.Sprite {\r\n    return this._og;\r\n  }\r\n\r\n  public set particleSprite(val: LegacyDrawing.Sprite) {\r\n    this._og = val;\r\n    if (val) {\r\n      this._sprite = Sprite.fromLegacySprite(val);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the emitter type for the particle emitter\r\n   */\r\n  public emitterType: EmitterType = EmitterType.Rectangle;\r\n\r\n  /**\r\n   * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n   */\r\n  public radius: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the particle rotational speed velocity\r\n   */\r\n  public particleRotationalVelocity: number = 0;\r\n\r\n  /**\r\n   * Indicates whether particles should start with a random rotation\r\n   */\r\n  public randomRotation: boolean = false;\r\n\r\n  /**\r\n   * @param config particle emitter options bag\r\n   */\r\n  constructor(config: ParticleEmitterArgs) {\r\n    super({ width: config.width ?? 0, height: config.height ?? 0 });\r\n\r\n    const {\r\n      x,\r\n      y,\r\n      pos,\r\n      isEmitting,\r\n      minVel,\r\n      maxVel,\r\n      acceleration,\r\n      minAngle,\r\n      maxAngle,\r\n      emitRate,\r\n      particleLife,\r\n      opacity,\r\n      fadeFlag,\r\n      focus,\r\n      focusAccel,\r\n      startSize,\r\n      endSize,\r\n      minSize,\r\n      maxSize,\r\n      beginColor,\r\n      endColor,\r\n      particleSprite,\r\n      emitterType,\r\n      radius,\r\n      particleRotationalVelocity,\r\n      randomRotation,\r\n      random\r\n    } = { ...config };\r\n\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.isEmitting = isEmitting ?? this.isEmitting;\r\n    this.minVel = minVel ?? this.minVel;\r\n    this.maxVel = maxVel ?? this.maxVel;\r\n    this.acceleration = acceleration ?? this.acceleration;\r\n    this.minAngle = minAngle ?? this.minAngle;\r\n    this.maxAngle = maxAngle ?? this.maxAngle;\r\n    this.emitRate = emitRate ?? this.emitRate;\r\n    this.particleLife = particleLife ?? this.particleLife;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.fadeFlag = fadeFlag ?? this.fadeFlag;\r\n    this.focus = focus ?? this.focus;\r\n    this.focusAccel = focusAccel ?? this.focusAccel;\r\n    this.startSize = startSize ?? this.startSize;\r\n    this.endSize = endSize ?? this.endSize;\r\n    this.minSize = minSize ?? this.minSize;\r\n    this.maxSize = maxSize ?? this.maxSize;\r\n    this.beginColor = beginColor ?? this.beginColor;\r\n    this.endColor = endColor ?? this.endColor;\r\n    this.particleSprite = particleSprite ?? this.particleSprite;\r\n    this.emitterType = emitterType ?? this.emitterType;\r\n    this.radius = radius ?? this.radius;\r\n    this.particleRotationalVelocity = particleRotationalVelocity ?? this.particleRotationalVelocity;\r\n    this.randomRotation = randomRotation ?? this.randomRotation;\r\n\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n\r\n    this.random = random ?? new Random();\r\n\r\n    // Remove offscreen culling from particle emitters\r\n    for (let i = 0; i < this.traits.length; i++) {\r\n      if (this.traits[i] instanceof Traits.OffscreenCulling) {\r\n        this.traits.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public removeParticle(particle: Particle) {\r\n    this.deadParticles.push(particle);\r\n  }\r\n\r\n  /**\r\n   * Causes the emitter to emit particles\r\n   * @param particleCount  Number of particles to emit right now\r\n   */\r\n  public emitParticles(particleCount: number) {\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const p = this._createParticle();\r\n      this.particles.push(p);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.add(p);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clearParticles() {\r\n    this.particles.length = 0;\r\n  }\r\n\r\n  // Creates a new particle given the constraints of the emitter\r\n  private _createParticle(): Particle {\r\n    // todo implement emitter constraints;\r\n    let ranX = 0;\r\n    let ranY = 0;\r\n\r\n    const angle = Util.randomInRange(this.minAngle, this.maxAngle, this.random);\r\n    const vel = Util.randomInRange(this.minVel, this.maxVel, this.random);\r\n    const size = this.startSize || Util.randomInRange(this.minSize, this.maxSize, this.random);\r\n    const dx = vel * Math.cos(angle);\r\n    const dy = vel * Math.sin(angle);\r\n\r\n    if (this.emitterType === EmitterType.Rectangle) {\r\n      ranX = Util.randomInRange(0, this.width, this.random);\r\n      ranY = Util.randomInRange(0, this.height, this.random);\r\n    } else if (this.emitterType === EmitterType.Circle) {\r\n      const radius = Util.randomInRange(0, this.radius, this.random);\r\n      ranX = radius * Math.cos(angle);\r\n      ranY = radius * Math.sin(angle);\r\n    }\r\n\r\n    const p = new Particle(\r\n      this,\r\n      this.particleLife,\r\n      this.opacity,\r\n      this.beginColor,\r\n      this.endColor,\r\n      new Vector(ranX, ranY),\r\n      new Vector(dx, dy),\r\n      this.acceleration,\r\n      this.startSize,\r\n      this.endSize\r\n    );\r\n    p.fadeFlag = this.fadeFlag;\r\n    p.particleSize = size;\r\n    if (this.particleSprite) {\r\n      p.particleSprite = this.particleSprite;\r\n      p.graphics.opacity = this.opacity;\r\n      p.graphics.use(this._sprite);\r\n    }\r\n    p.particleRotationalVelocity = this.particleRotationalVelocity;\r\n    if (this.randomRotation) {\r\n      p.currentRotation = Util.randomInRange(0, Math.PI * 2, this.random);\r\n    }\r\n    if (this.focus) {\r\n      p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));\r\n      p.focusAccel = this.focusAccel;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    super.update(engine, delta);\r\n\r\n    if (this.isEmitting) {\r\n      this._particlesToEmit += this.emitRate * (delta / 1000);\r\n      if (this._particlesToEmit > 1.0) {\r\n        this.emitParticles(Math.floor(this._particlesToEmit));\r\n        this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\r\n      }\r\n    }\r\n\r\n    // deferred removal\r\n    for (let i = 0; i < this.deadParticles.length; i++) {\r\n      Util.removeItemFromArray(this.deadParticles[i], this.particles);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.remove(this.deadParticles[i], false);\r\n      }\r\n    }\r\n    this.deadParticles.length = 0;\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D) {\r\n    // todo is there a more efficient to draw\r\n    // possibly use a webgl offscreen canvas and shaders to do particles?\r\n    this.particles.forEach((p) => p.draw(ctx));\r\n  }\r\n\r\n  public debugDraw(ctx: CanvasRenderingContext2D) {\r\n    super.debugDraw(ctx);\r\n    ctx.fillStyle = Color.Black.toString();\r\n    ctx.fillText('Particles: ' + this.particles.length, this.pos.x, this.pos.y + 20);\r\n\r\n    if (this.focus) {\r\n      ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);\r\n      DrawUtil.line(ctx, Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, this.center.x, this.center.y);\r\n      ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);\r\n    }\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Scene } from '../Scene';\r\nimport { GraphicsComponent } from './GraphicsComponent';\r\nimport { vec } from '../Math/vector';\r\nimport { CoordPlane, TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Camera } from '../Camera';\r\nimport { System, SystemType, TagComponent } from '../EntityComponentSystem';\r\nimport { Engine } from '../Engine';\r\nimport { GraphicsDiagnostics } from './GraphicsDiagnostics';\r\nimport { EnterViewPortEvent, ExitViewPortEvent } from '../Events';\r\nimport { GraphicsGroup } from '.';\r\nimport { Particle } from '../Particles';\r\n\r\nexport class GraphicsSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 0;\r\n  private _token = 0;\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._graphicsContext = scene.engine.graphicsContext;\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  public sort(a: Entity, b: Entity) {\r\n    return a.get(TransformComponent).z - b.get(TransformComponent).z;\r\n  }\r\n\r\n  public update(entities: Entity[], delta: number): void {\r\n    this._clearScreen();\r\n    this._token++;\r\n    let transform: TransformComponent;\r\n    let graphics: GraphicsComponent;\r\n\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      graphics = entity.get(GraphicsComponent);\r\n\r\n      // Figure out if entities are offscreen\r\n      const entityOffscreen = this._isOffscreen(transform, graphics);\r\n      if (entityOffscreen && !entity.hasTag('offscreen')) {\r\n        entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));\r\n        entity.addComponent(new TagComponent('offscreen'));\r\n      }\r\n\r\n      if (!entityOffscreen && entity.hasTag('offscreen')) {\r\n        entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));\r\n        entity.removeComponent('offscreen');\r\n      }\r\n      // Skip entities that have graphics offscreen\r\n      if (entityOffscreen) {\r\n        continue;\r\n      }\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      this._pushCameraTransform(transform);\r\n\r\n      this._graphicsContext.save();\r\n\r\n      // Tick any graphics state (but only once) for animations and graphics groups\r\n      graphics.update(delta, this._token);\r\n\r\n      // Position the entity\r\n      this._applyTransform(entity);\r\n\r\n      // Optionally run the onPreDraw graphics lifecycle draw\r\n      if (graphics.onPreDraw) {\r\n        graphics.onPreDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      // TODO remove this hack on the particle redo\r\n      const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;\r\n      this._graphicsContext.opacity = graphics.opacity * particleOpacity;\r\n\r\n      // Draw the graphics component\r\n      this._drawGraphicsComponent(graphics);\r\n\r\n      // Optionally run the onPostDraw graphics lifecycle draw\r\n      if (graphics.onPostDraw) {\r\n        graphics.onPostDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      // Reset the transform back to the original\r\n      this._popCameraTransform(transform);\r\n    }\r\n\r\n    this._graphicsContext.flush();\r\n    this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\r\n    this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\r\n  }\r\n\r\n  private _clearScreen(): void {\r\n    this._graphicsContext.clear();\r\n  }\r\n\r\n  private _isOffscreen(transform: TransformComponent, graphics: GraphicsComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      const graphicsOffscreen = !this._camera.viewport.intersect(graphics.localBounds.transform(transform.getGlobalMatrix()));\r\n      return graphicsOffscreen;\r\n    } else {\r\n      // TODO sceen coordinates\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private _drawGraphicsComponent(graphicsComponent: GraphicsComponent) {\r\n    if (graphicsComponent.visible) {\r\n      // this should be moved to the graphics system\r\n      for (const layer of graphicsComponent.layers.get()) {\r\n        for (const { graphic, options } of layer.graphics) {\r\n          let anchor = graphicsComponent.anchor;\r\n          let offset = graphicsComponent.offset;\r\n          if (options?.anchor) {\r\n            anchor = options.anchor;\r\n          }\r\n          if (options?.offset) {\r\n            offset = options.offset;\r\n          }\r\n          // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\r\n          const offsetX = -graphic.width * anchor.x + offset.x;\r\n          const offsetY = -graphic.height * anchor.y + offset.y;\r\n\r\n          graphic?.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n\r\n          if (this._engine?.isDebug && this._engine.debug.graphics.showBounds) {\r\n            const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n            if (graphic instanceof GraphicsGroup) {\r\n              for (const g of graphic.members) {\r\n                g.graphic?.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n              }\r\n            } else {\r\n              /* istanbul ignore next */\r\n              graphic?.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n        this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n        this._graphicsContext.rotate(transform.rotation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _pushCameraTransform(transform: TransformComponent) {\r\n    // Establish camera offset per entity\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      this._graphicsContext.save();\r\n      if (this._camera) {\r\n        this._camera.draw(this._graphicsContext);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _popCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Apply camera world offset\r\n      this._graphicsContext.restore();\r\n    }\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Actor } from '../Actor';\r\nimport { Entity, System, SystemType } from '../EntityComponentSystem';\r\nimport { CanvasDrawComponent } from './CanvasDrawComponent';\r\nimport { Scene } from '../Scene';\r\nimport { Camera } from '../Camera';\r\nimport { CoordPlane, TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { GraphicsDiagnostics } from '../Graphics/GraphicsDiagnostics';\r\n\r\n/**\r\n * Draws anything with a transform and a \"draw\" method\r\n * @deprecated Shim for canvas drawing, will be removed v0.26.0\r\n */\r\nexport class CanvasDrawingSystem extends System<TransformComponent | CanvasDrawComponent> {\r\n  public readonly types = ['ex.transform', 'ex.canvas'] as const;\r\n  public systemType = SystemType.Draw;\r\n  public priority = -1;\r\n\r\n  private _ctx: CanvasRenderingContext2D;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._ctx = scene.engine.ctx;\r\n    this._engine = scene.engine;\r\n    this._camera = scene.camera;\r\n  }\r\n\r\n  public sort(a: Entity, b: Entity) {\r\n    return a.get(TransformComponent).z - b.get(TransformComponent).z;\r\n  }\r\n\r\n  public update(entities: Entity[], delta: number) {\r\n    this._clearScreen();\r\n\r\n    let transform: TransformComponent;\r\n    let canvasdraw: CanvasDrawComponent;\r\n    const length = entities.length;\r\n    for (let i = 0; i < length; i++) {\r\n      const visible = (entities[i] as Actor)?.graphics?.visible ?? true;\r\n      const offscreen = (entities[i] as Actor).isOffScreen;\r\n      if (visible && !offscreen) {\r\n        transform = entities[i].get(TransformComponent);\r\n        canvasdraw = entities[i].get(CanvasDrawComponent);\r\n\r\n        this._ctx.save();\r\n        this._pushCameraTransform(transform);\r\n\r\n        this._ctx.save();\r\n        this._applyTransform(entities[i]);\r\n        canvasdraw.draw(this._ctx, delta);\r\n        this._ctx.restore();\r\n\r\n        this._popCameraTransform(transform);\r\n        this._ctx.restore();\r\n      }\r\n\r\n      if (this._engine.isDebug) {\r\n        this._ctx.save();\r\n        this._pushCameraTransform(transform);\r\n        this._ctx.strokeStyle = 'yellow';\r\n        (entities[i] as unknown as Actor).debugDraw(this._ctx);\r\n        this._popCameraTransform(transform);\r\n        this._ctx.restore();\r\n      }\r\n    }\r\n    if (this._engine.isDebug) {\r\n      this._ctx.save();\r\n      this._camera.draw(this._ctx);\r\n      this._camera.debugDraw(this._ctx);\r\n      this._ctx.restore();\r\n    }\r\n\r\n    this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\r\n    this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\r\n  }\r\n\r\n  private _applyTransform(entity: Entity) {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._ctx.translate(transform.pos.x, transform.pos.y);\r\n        this._ctx.rotate(transform.rotation);\r\n        this._ctx.scale(transform.scale.x, transform.scale.y);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _clearScreen(): void {\r\n    this._ctx.clearRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);\r\n    this._ctx.fillStyle = this._engine.backgroundColor.toString();\r\n    this._ctx.fillRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);\r\n  }\r\n\r\n  private _pushCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Apply camera transform to place entity in world space\r\n      this._ctx.save();\r\n      if (this._camera) {\r\n        this._camera.draw(this._ctx);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _popCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Restore back to screen space from world space if we were drawing an entity there\r\n      this._ctx.restore();\r\n    }\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Scene } from '../Scene';\r\nimport { Camera } from '../Camera';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { CoordPlane, Entity, TransformComponent } from '../EntityComponentSystem';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { BodyComponent, CollisionSystem, CompositeCollider, GraphicsComponent, Particle, Util } from '..';\r\n\r\nexport class DebugSystem extends System<TransformComponent> {\r\n  public readonly types = ['ex.transform'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 999; // lowest priority\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _collisionSystem: CollisionSystem;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._graphicsContext = scene.engine.graphicsContext;\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n    this._collisionSystem = scene.world.systemManager.get(CollisionSystem);\r\n  }\r\n\r\n  update(entities: Entity[], _delta: number): void {\r\n    if (!this._engine.isDebug) {\r\n      return;\r\n    }\r\n\r\n    const filterSettings = this._engine.debug.filter;\r\n\r\n    let id: number;\r\n    let name: string;\r\n    const entitySettings = this._engine.debug.entity;\r\n\r\n    let tx: TransformComponent;\r\n    const txSettings = this._engine.debug.transform;\r\n\r\n    let motion: MotionComponent;\r\n    const motionSettings = this._engine.debug.motion;\r\n\r\n    let colliderComp: ColliderComponent;\r\n    const colliderSettings = this._engine.debug.collider;\r\n\r\n    const physicsSettings = this._engine.debug.physics;\r\n\r\n    let graphics: GraphicsComponent;\r\n    const graphicsSettings = this._engine.debug.graphics;\r\n\r\n    let body: BodyComponent;\r\n    const bodySettings = this._engine.debug.body;\r\n\r\n    const cameraSettings = this._engine.debug.camera;\r\n    for (const entity of entities) {\r\n      if (entity.hasTag('offscreen')) {\r\n        // skip offscreen entities\r\n        continue;\r\n      }\r\n      if (entity instanceof Particle) {\r\n        // Particles crush the renderer :(\r\n        continue;\r\n      }\r\n      if (filterSettings.useFilter) {\r\n        const allIds = filterSettings.ids.length === 0;\r\n        const idMatch = allIds || filterSettings.ids.includes(entity.id);\r\n        if (!idMatch) {\r\n          continue;\r\n        }\r\n        const allNames = filterSettings.nameQuery === '';\r\n        const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);\r\n        if (!nameMatch) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      let cursor = Vector.Zero;\r\n      const lineHeight = vec(0, 16);\r\n      id = entity.id;\r\n      name = entity.name;\r\n      tx = entity.get(TransformComponent);\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      this._pushCameraTransform(tx);\r\n\r\n      this._graphicsContext.save();\r\n\r\n      this._applyTransform(entity);\r\n      if (tx) {\r\n        if (txSettings.showAll || txSettings.showPosition) {\r\n          this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 2, color: txSettings.positionColor });\r\n          this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showId) {\r\n          this._graphicsContext.debug.drawText(`id(${id}) ${tx.parent ? 'child of id(' + tx.parent?.owner?.id + ')' : ''}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showName) {\r\n          this._graphicsContext.debug.drawText(`name(${name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showRotation) {\r\n          this._graphicsContext.drawLine(\r\n            Vector.Zero,\r\n            Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero),\r\n            txSettings.rotationColor,\r\n            2\r\n          );\r\n          this._graphicsContext.debug.drawText(`rot deg(${Util.toDegrees(tx.rotation).toFixed(2)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showScale) {\r\n          this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);\r\n        }\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics) {\r\n        if (graphicsSettings.showAll || graphicsSettings.showBounds) {\r\n          const bounds = graphics.localBounds;\r\n          bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);\r\n        }\r\n      }\r\n\r\n      body = entity.get(BodyComponent);\r\n      if (body) {\r\n        if (bodySettings.showAll || bodySettings.showCollisionGroup) {\r\n          this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showCollisionType) {\r\n          this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMass) {\r\n          this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMotion) {\r\n          this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showSleeping) {\r\n          this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping: 'cant sleep'})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      motion = entity.get(MotionComponent);\r\n      if (motion) {\r\n        if (motionSettings.showAll || motionSettings.showVelocity) {\r\n          this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (motionSettings.showAll || motionSettings.showAcceleration) {\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);\r\n        }\r\n      }\r\n\r\n      // Colliders live in world space already so after the restore()\r\n      colliderComp = entity.get(ColliderComponent);\r\n      if (colliderComp) {\r\n        const collider = colliderComp.get();\r\n        if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {\r\n          collider.debug(this._graphicsContext, colliderSettings.geometryColor);\r\n        }\r\n        if (colliderSettings.showAll || colliderSettings.showBounds) {\r\n          if (collider instanceof CompositeCollider) {\r\n            const colliders = collider.getColliders();\r\n            for (const collider of colliders) {\r\n              const bounds = collider.bounds;\r\n              const pos = vec(bounds.left, bounds.top);\r\n              this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n              if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);\r\n              }\r\n            }\r\n            colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);\r\n          } else if (collider) {\r\n            const bounds = colliderComp.bounds;\r\n            const pos = vec(bounds.left, bounds.top);\r\n            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n            if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n              this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      this._popCameraTransform(tx);\r\n    }\r\n\r\n    this._graphicsContext.save();\r\n    this._camera.draw(this._graphicsContext);\r\n    if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {\r\n      this._collisionSystem.debug(this._graphicsContext);\r\n    }\r\n    if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {\r\n      for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });\r\n          }\r\n        }\r\n\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {\r\n              color: physicsSettings.collisionNormalColor\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n\r\n    if (cameraSettings) {\r\n      this._graphicsContext.save();\r\n      this._camera.draw(this._graphicsContext);\r\n      if (cameraSettings.showAll || cameraSettings.showFocus) {\r\n        this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);\r\n      }\r\n      if (cameraSettings.showAll || cameraSettings.showZoom) {\r\n        this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);\r\n      }\r\n      this._graphicsContext.restore();\r\n    }\r\n\r\n    this._graphicsContext.flush();\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n        this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n        this._graphicsContext.rotate(transform.rotation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _pushCameraTransform(transform: TransformComponent) {\r\n    // Establish camera offset per entity\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      this._graphicsContext.save();\r\n      if (this._camera) {\r\n        this._camera.draw(this._graphicsContext);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _popCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Apply camera world offset\r\n      this._graphicsContext.restore();\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ActionsComponent } from './ActionsComponent';\r\n\r\n\r\nexport class ActionsSystem extends System<ActionsComponent> {\r\n  public readonly types = ['ex.actions'] as const;\r\n  systemType = SystemType.Update;\r\n  priority = -1;\r\n\r\n  update(entities: Entity[], delta: number): void {\r\n    let actions: ActionsComponent;\r\n    for (const entity of entities) {\r\n      actions = entity.get(ActionsComponent);\r\n      actions.update(delta);\r\n    }\r\n  }\r\n}","import { ScreenElement } from './ScreenElement';\r\nimport {\r\n  InitializeEvent,\r\n  ActivateEvent,\r\n  DeactivateEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  PreDebugDrawEvent,\r\n  PostDebugDrawEvent,\r\n  GameEvent\r\n} from './Events';\r\nimport { Logger } from './Util/Log';\r\nimport { Timer } from './Timer';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Camera } from './Camera';\r\nimport { Actor } from './Actor';\r\nimport { Class } from './Class';\r\nimport { CanInitialize, CanActivate, CanDeactivate, CanUpdate, CanDraw } from './Interfaces/LifecycleEvents';\r\nimport * as Util from './Util/Util';\r\nimport * as Events from './Events';\r\nimport * as ActorUtils from './Util/Actors';\r\nimport { Trigger } from './Trigger';\r\nimport { SystemType } from './EntityComponentSystem/System';\r\nimport { obsolete } from './Util/Decorators';\r\nimport { World } from './EntityComponentSystem/World';\r\nimport { MotionSystem } from './Collision/MotionSystem';\r\nimport { CollisionSystem } from './Collision/CollisionSystem';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { GraphicsSystem } from './Graphics/GraphicsSystem';\r\nimport { CanvasDrawingSystem } from './Drawing/CanvasDrawingSystem';\r\nimport { Flags, Legacy } from './Flags';\r\nimport { DebugSystem } from './Debug/DebugSystem';\r\nimport { ActionsSystem } from './Actions/ActionsSystem';\r\n/**\r\n * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n * Excalibur. The metaphor models the same idea behind real world\r\n * actors in a scene. Only actors in scenes will be updated and drawn.\r\n *\r\n * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n */\r\nexport class Scene extends Class implements CanInitialize, CanActivate, CanDeactivate, CanUpdate, CanDraw {\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Gets or sets the current camera for the scene\r\n   */\r\n  public camera: Camera = new Camera();\r\n\r\n  /**\r\n   * The ECS world for the scene\r\n   */\r\n  public world = new World(this);\r\n\r\n  /**\r\n   * The actors in the current scene\r\n   */\r\n  public get actors(): Actor[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Actor;\r\n    }) as Actor[];\r\n  }\r\n\r\n  /**\r\n   * The entities in the current scene\r\n   */\r\n  public get entities(): Entity[] {\r\n    return this.world.entityManager.entities;\r\n  }\r\n\r\n  /**\r\n   * The triggers in the current scene\r\n   */\r\n  public get triggers(): Trigger[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Trigger;\r\n    }) as Trigger[];\r\n  }\r\n\r\n  /**\r\n   * The [[TileMap]]s in the scene, if any\r\n   */\r\n  public get tileMaps(): TileMap[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof TileMap;\r\n    }) as TileMap[];\r\n  }\r\n\r\n  /**\r\n   * Access to the Excalibur engine\r\n   */\r\n  public engine: Engine;\r\n\r\n  /**\r\n   * The [[ScreenElement]]s in a scene, if any; these are drawn last\r\n   * @deprecated Use [[Scene.actors]]\r\n   */\r\n  @obsolete({\r\n    message: 'Will be removed in excalibur v0.26.0',\r\n    alternateMethod: 'ScreenElements now are normal actors with a Transform Coordinate Plane of Screen'\r\n  })\r\n  public get screenElements(): ScreenElement[] {\r\n    return this.actors.filter((a) => a instanceof ScreenElement) as ScreenElement[];\r\n  }\r\n\r\n  private _isInitialized: boolean = false;\r\n  private _timers: Timer[] = [];\r\n  private _cancelQueue: Timer[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n    // TODO how to people do there own systems\r\n    // Initialize systems\r\n    this.world.add(new ActionsSystem());\r\n    this.world.add(new MotionSystem());\r\n    this.world.add(new CollisionSystem());\r\n    if (Flags.isEnabled(Legacy.LegacyDrawing)) {\r\n      this.world.add(new CanvasDrawingSystem());\r\n    } else {\r\n      this.world.add(new GraphicsSystem());\r\n    }\r\n    this.world.add(new DebugSystem());\r\n  }\r\n\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public on(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public on(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public on(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public once(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public once(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public once(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.initialize, handler?: (event: InitializeEvent<Scene>) => void): void;\r\n  public off(eventName: Events.activate, handler?: (event: ActivateEvent) => void): void;\r\n  public off(eventName: Events.deactivate, handler?: (event: DeactivateEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: Events.predebugdraw, handler?: (event: PreDebugDrawEvent) => void): void;\r\n  public off(eventName: Events.postdebugdraw, handler?: (event: PostDebugDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made active and started. It is meant to be overridden,\r\n   * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onActivate(_oldScene: Scene, _newScene: Scene): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,\r\n   * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onDeactivate(_oldScene: Scene, _newScene: Scene): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreDraw` is called directly before a scene is drawn.\r\n   */\r\n  public onPreDraw(_ctx: CanvasRenderingContext2D, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostDraw` is called directly after a scene is drawn.\r\n   */\r\n  public onPostDraw(_ctx: CanvasRenderingContext2D, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Initializes actors in the scene\r\n   */\r\n  private _initializeChildren(): void {\r\n    for (const child of this.entities) {\r\n      child._initialize(this.engine);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the [[Scene]] has been initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Initializes the scene before the first update, meant to be called by engine not by users of\r\n   * Excalibur\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.engine = engine;\r\n      // Initialize camera first\r\n      this.camera._initialize(engine);\r\n\r\n      // This order is important! we want to be sure any custom init that add actors\r\n      // fire before the actor init\r\n      this.onInitialize.call(this, engine);\r\n      this._initializeChildren();\r\n\r\n      this._logger.debug('Scene.onInitialize', this, engine);\r\n      this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.\r\n   * @internal\r\n   */\r\n  public _activate(oldScene: Scene, newScene: Scene): void {\r\n    this._logger.debug('Scene.onActivate', this);\r\n    this.onActivate(oldScene, newScene);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.\r\n   * @internal\r\n   */\r\n  public _deactivate(oldScene: Scene, newScene: Scene): void {\r\n    this._logger.debug('Scene.onDeactivate', this);\r\n    this.onDeactivate(oldScene, newScene);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(_engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));\r\n    this.onPreUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(_engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));\r\n    this.onPostUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: CanvasRenderingContext2D, _delta: number): void {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));\r\n    this.onPreDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: CanvasRenderingContext2D, _delta: number): void {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));\r\n    this.onPostDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n   * @param engine  Reference to the current Engine\r\n   * @param delta   The number of milliseconds since the last update\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._preupdate(engine, delta);\r\n    if (this.camera) {\r\n      this.camera.update(engine, delta);\r\n    }\r\n    // TODO differed entity removal for timers\r\n    let i: number, len: number;\r\n    // Remove timers in the cancel queue before updating them\r\n    for (i = 0, len = this._cancelQueue.length; i < len; i++) {\r\n      this.removeTimer(this._cancelQueue[i]);\r\n    }\r\n    this._cancelQueue.length = 0;\r\n\r\n    // Cycle through timers updating timers\r\n    for (const timer of this._timers) {\r\n      timer.update(delta);\r\n    }\r\n\r\n    this.world.update(SystemType.Update, delta);\r\n\r\n    this._collectActorStats(engine);\r\n\r\n    engine.input.pointers.dispatchPointerEvents();\r\n\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors in the Scene. Called by the [[Engine]].\r\n   * @param ctx    The current rendering context\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D, delta: number) {\r\n    this._predraw(ctx, delta);\r\n\r\n    this.world.update(SystemType.Draw, delta);\r\n\r\n    if (this.engine?.isDebug) {\r\n      this.debugDraw(ctx);\r\n    }\r\n    this._postdraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors' debug information in the Scene. Called by the [[Engine]].\r\n   * @param ctx  The current rendering context\r\n   * @deprecated\r\n   */\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: CanvasRenderingContext2D) {\r\n    this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));\r\n    // pass\r\n    this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));\r\n  }\r\n\r\n  /**\r\n   * Checks whether an actor is contained in this scene or not\r\n   */\r\n  public contains(actor: Actor): boolean {\r\n    return this.actors.indexOf(actor) > -1;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the current [[Scene]].\r\n   * @param timer  The timer to add to the current [[Scene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n\r\n  /**\r\n   * Adds a [[TileMap]] to the [[Scene]], once this is done the [[TileMap]] will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Adds a [[Trigger]] to the [[Scene]], once this is done the [[Trigger]] will listen for interactions with other actors.\r\n   * @param trigger\r\n   */\r\n  public add(trigger: Trigger): void;\r\n\r\n  /**\r\n   * Adds an actor to the scene, once this is done the [[Actor]] will be drawn and updated.\r\n   * @param actor  The actor to add to the current scene\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the scene.\r\n   * @param screenElement  The ScreenElement to add to the current scene\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    this.emit('entityadded', { target: entity } as any);\r\n    this.world.add(entity);\r\n    entity.scene = this;\r\n    if (entity instanceof Timer) {\r\n      if (!Util.contains(this._timers, entity)) {\r\n        this.addTimer(entity);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the current scene, it will no longer be updated.\r\n   * @param timer  The timer to remove to the current scene.\r\n   */\r\n  public remove(timer: Timer): void;\r\n\r\n  /**\r\n   * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.\r\n   * @param tileMap {TileMap}\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Removes an actor from the scene, it will no longer be drawn or updated.\r\n   * @param actor  The actor to remove from the current scene.\r\n   */\r\n  public remove(actor: Actor): void;\r\n\r\n  public remove(entity: Entity): void;\r\n\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the current scene\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.emit('entityremoved', { target: entity } as any);\r\n      this.world.remove(entity);\r\n    }\r\n    if (entity instanceof Timer) {\r\n      this.removeTimer(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds (any) actor to act as a piece of UI, meaning it is always positioned\r\n   * in screen coordinates. UI actors do not participate in collisions.\r\n   * @todo Should this be `ScreenElement` only?\r\n   * @deprecated Use [[Scene.add]]\r\n   */\r\n  @obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })\r\n  public addScreenElement(actor: Actor) {\r\n    this.add(actor);\r\n  }\r\n\r\n  /**\r\n   * Removes an actor as a piece of UI\r\n   * @deprecated Use [[Scene.remove]]\r\n   */\r\n  @obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })\r\n  public removeScreenElement(actor: Actor) {\r\n    this.remove(actor);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.\r\n   * @deprecated Use [[Scene.add]]\r\n   */\r\n  @obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })\r\n  public addTileMap(tileMap: TileMap) {\r\n    this.world.add(tileMap);\r\n  }\r\n\r\n  /**\r\n   * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.\r\n   * @deprecated Use [[Scene.remove]]\r\n   */\r\n  @obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })\r\n  public removeTileMap(tileMap: TileMap) {\r\n    this.world.remove(tileMap);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the scene\r\n   * @param timer  The timer to add\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    this._timers.push(timer);\r\n    timer.scene = this;\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the scene.\r\n   * @warning Can be dangerous, use [[cancelTimer]] instead\r\n   * @param timer  The timer to remove\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    const i = this._timers.indexOf(timer);\r\n    if (i !== -1) {\r\n      this._timers.splice(i, 1);\r\n    }\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Cancels a [[Timer]], removing it from the scene nicely\r\n   * @param timer  The timer to cancel\r\n   */\r\n  public cancelTimer(timer: Timer): Timer {\r\n    this._cancelQueue.push(timer);\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a [[Timer]] is active in the scene\r\n   */\r\n  public isTimerActive(timer: Timer): boolean {\r\n    return this._timers.indexOf(timer) > -1 && !timer.complete;\r\n  }\r\n\r\n  public isCurrentScene(): boolean {\r\n    if (this.engine) {\r\n      return this.engine.currentScene === this;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _collectActorStats(engine: Engine) {\r\n    const screenElements = this.actors.filter((a) => a instanceof ScreenElement) as ScreenElement[];\r\n    for (const _ui of screenElements) {\r\n      engine.stats.currFrame.actors.ui++;\r\n    }\r\n\r\n    for (const actor of this.actors) {\r\n      engine.stats.currFrame.actors.alive++;\r\n      for (const child of actor.children) {\r\n        if (ActorUtils.isScreenElement(child as Actor)) {\r\n          // TODO not true\r\n          engine.stats.currFrame.actors.ui++;\r\n        } else {\r\n          engine.stats.currFrame.actors.alive++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Logger } from './../Util/Log';\r\nimport { PostProcessor } from './PostProcessor';\r\nimport { Engine } from '../Engine';\r\n\r\nexport enum ColorBlindness {\r\n  Protanope,\r\n  Deuteranope,\r\n  Tritanope\r\n}\r\n\r\n/**\r\n * This post processor can correct colors and simulate color blindness.\r\n * It is possible to use this on every game, but the game's performance\r\n * will suffer measurably. It's better to use it as a helpful tool while developing your game.\r\n * Remember, the best practice is to design with color blindness in mind.\r\n */\r\nexport class ColorBlindCorrector implements PostProcessor {\r\n  /*eslint-disable */\r\n  private _vertexShader =\r\n    '' +\r\n    'attribute vec2 a_position;' +\r\n    'attribute vec2 a_texCoord;' +\r\n    'uniform vec2 u_resolution;' +\r\n    'varying vec2 v_texCoord;' +\r\n    'void main() {' +\r\n    // convert the rectangle from pixels to 0.0 to 1.0\r\n    'vec2 zeroToOne = a_position / u_resolution;' +\r\n    // convert from 0->1 to 0->2\r\n    'vec2 zeroToTwo = zeroToOne * 2.0;' +\r\n    // convert from 0->2 to -1->+1 (clipspace)\r\n    'vec2 clipSpace = zeroToTwo - 1.0;' +\r\n    'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +\r\n    // pass the texCoord to the fragment shader\r\n    // The GPU will interpolate this value between points.\r\n    'v_texCoord = a_texCoord;' +\r\n    '}';\r\n\r\n  private _fragmentShader =\r\n    'precision mediump float;' +\r\n    // our texture\r\n    'uniform sampler2D u_image;' +\r\n    // the texCoords passed in from the vertex shader.\r\n    'varying vec2 v_texCoord;' +\r\n    // Color blind conversions\r\n    /*'mat3 m[9] =' +\r\n   '{' +\r\n      'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal\r\n      'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia\r\n      'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly\r\n      'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia\r\n      'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly\r\n      'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia\r\n      'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly\r\n      'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia\r\n      'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly\r\n   '};' +*/\r\n\r\n    'void main() {' +\r\n    'vec4 o =  texture2D(u_image, v_texCoord);' +\r\n    // RGB to LMS matrix conversion\r\n    'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +\r\n    'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +\r\n    'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +\r\n    // Simulate color blindness\r\n\r\n    '//MODE CODE//' +\r\n    /* Deuteranope for testing\r\n      'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +\r\n            'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +\r\n            'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/\r\n\r\n    // LMS to RGB matrix conversion\r\n    'vec4 error;' +\r\n    'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +\r\n    'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +\r\n    'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +\r\n    'error.a = 1.0;' +\r\n    'vec4 diff = o - error;' +\r\n    'vec4 correction;' +\r\n    'correction.r = 0.0;' +\r\n    'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +\r\n    'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +\r\n    'correction = o + correction;' +\r\n    'correction.a = o.a;' +\r\n    '//SIMULATE//' +\r\n    '}';\r\n\r\n  /*eslint-enable */\r\n  private _internalCanvas: HTMLCanvasElement;\r\n  private _gl: WebGLRenderingContext;\r\n  private _program: WebGLProgram;\r\n\r\n  constructor(public engine: Engine, public simulate: boolean = false, public colorMode: ColorBlindness = ColorBlindness.Protanope) {\r\n    this._internalCanvas = document.createElement('canvas');\r\n    this._internalCanvas.width = engine.drawWidth;\r\n    this._internalCanvas.height = engine.drawHeight;\r\n\r\n    // eslint-disable-next-line\r\n    this._gl = <WebGLRenderingContext>this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });\r\n\r\n    this._program = this._gl.createProgram();\r\n    const fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));\r\n    const vertextShader = this._getShader('Vertex', this._vertexShader);\r\n\r\n    this._gl.attachShader(this._program, vertextShader);\r\n    this._gl.attachShader(this._program, fragmentShader);\r\n    this._gl.linkProgram(this._program);\r\n\r\n    if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {\r\n      Logger.getInstance().error('Unable to link shader program!');\r\n    }\r\n\r\n    this._gl.useProgram(this._program);\r\n  }\r\n\r\n  private _getFragmentShaderByMode(colorMode: ColorBlindness) {\r\n    let code = '';\r\n    if (colorMode === ColorBlindness.Protanope) {\r\n      code =\r\n        'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +\r\n        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +\r\n        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';\r\n    } else if (colorMode === ColorBlindness.Deuteranope) {\r\n      code =\r\n        'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +\r\n        'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +\r\n        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';\r\n    } else if (colorMode === ColorBlindness.Tritanope) {\r\n      code =\r\n        'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +\r\n        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +\r\n        'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';\r\n    }\r\n\r\n    if (this.simulate) {\r\n      this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');\r\n    } else {\r\n      this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');\r\n    }\r\n\r\n    return this._fragmentShader.replace('//MODE CODE//', code);\r\n  }\r\n\r\n  private _setRectangle(x: number, y: number, width: number, height: number) {\r\n    const x1 = x;\r\n    const x2 = x + width;\r\n    const y1 = y;\r\n    const y2 = y + height;\r\n    this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this._gl.STATIC_DRAW);\r\n  }\r\n\r\n  private _getShader(type: string, program: string): WebGLShader {\r\n    let shader: WebGLShader;\r\n    if (type === 'Fragment') {\r\n      shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);\r\n    } else if (type === 'Vertex') {\r\n      shader = this._gl.createShader(this._gl.VERTEX_SHADER);\r\n    } else {\r\n      Logger.getInstance().error('Error unknown shader type', type);\r\n    }\r\n\r\n    this._gl.shaderSource(shader, program);\r\n    this._gl.compileShader(shader);\r\n\r\n    if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {\r\n      Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));\r\n      return null;\r\n    }\r\n\r\n    return shader;\r\n  }\r\n\r\n  public process(image: ImageData, out: CanvasRenderingContext2D) {\r\n    // look up where the vertex data needs to go.\r\n    const positionLocation = this._gl.getAttribLocation(this._program, 'a_position');\r\n    const texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');\r\n\r\n    const texCoordBuffer = this._gl.createBuffer();\r\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);\r\n    this._gl.bufferData(\r\n      this._gl.ARRAY_BUFFER,\r\n      new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]),\r\n      this._gl.STATIC_DRAW\r\n    );\r\n    this._gl.enableVertexAttribArray(texCoordLocation);\r\n    this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);\r\n\r\n    // Create a texture.\r\n    const texture = this._gl.createTexture();\r\n    this._gl.bindTexture(this._gl.TEXTURE_2D, texture);\r\n\r\n    // Set the parameters so we can render any size image.\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\r\n    // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/\r\n    this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);\r\n    // Upload the image into the texture.\r\n    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);\r\n\r\n    // lookup uniforms\r\n    const resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');\r\n\r\n    // set the resolution\r\n    this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);\r\n\r\n    // Create a buffer for the position of the rectangle corners.\r\n    const positionBuffer = this._gl.createBuffer();\r\n    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);\r\n    this._gl.enableVertexAttribArray(positionLocation);\r\n    this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);\r\n\r\n    // Set a rectangle the same size as the image.\r\n    this._setRectangle(0, 0, image.width, image.height);\r\n\r\n    // Draw the rectangle.\r\n    this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);\r\n\r\n    // Grab transformed image from internal canvas\r\n    const pixelData = new Uint8Array(image.width * image.height * 4);\r\n    this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);\r\n\r\n    (<any>image.data).set(pixelData);\r\n\r\n    out.putImageData(image, 0, 0);\r\n  }\r\n}\r\n","import { DebugFlags, ColorBlindFlags } from './DebugFlags';\r\nimport { Engine } from '../Engine';\r\nimport { Color } from '../Color';\r\nimport { CollisionContact } from '../Collision/Detection/CollisionContact';\r\n\r\n/**\r\n * Debug stats containing current and previous frame statistics\r\n */\r\nexport interface DebugStats {\r\n  currFrame: FrameStats;\r\n  prevFrame: FrameStats;\r\n}\r\n\r\n/**\r\n * Represents a frame's individual statistics\r\n */\r\nexport interface FrameStatistics {\r\n  /**\r\n   * The number of the frame\r\n   */\r\n  id: number;\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame scaled by [[Engine.timescale]]) (in ms)\r\n   */\r\n  delta: number;\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  fps: number;\r\n\r\n  /**\r\n   * Duration statistics (in ms)\r\n   */\r\n  duration: FrameDurationStats;\r\n\r\n  /**\r\n   * Actor statistics\r\n   */\r\n  actors: FrameActorStats;\r\n\r\n  /**\r\n   * Physics statistics\r\n   */\r\n  physics: PhysicsStatistics;\r\n\r\n  /**\r\n   * Graphics statistics\r\n   */\r\n  graphics: GraphicsStatistics;\r\n}\r\n\r\n/**\r\n * Represents actor stats for a frame\r\n */\r\nexport interface FrameActorStats {\r\n  /**\r\n   * Gets the frame's number of actors (alive)\r\n   */\r\n  alive: number;\r\n\r\n  /**\r\n   * Gets the frame's number of actors (killed)\r\n   */\r\n  killed: number;\r\n\r\n  /**\r\n   * Gets the frame's number of remaining actors (alive - killed)\r\n   */\r\n  remaining: number;\r\n\r\n  /**\r\n   * Gets the frame's number of UI actors\r\n   */\r\n  ui: number;\r\n\r\n  /**\r\n   * Gets the frame's number of total actors (remaining + UI)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents duration stats for a frame\r\n */\r\nexport interface FrameDurationStats {\r\n  /**\r\n   * Gets the frame's total time to run the update function (in ms)\r\n   */\r\n  update: number;\r\n\r\n  /**\r\n   * Gets the frame's total time to run the draw function (in ms)\r\n   */\r\n  draw: number;\r\n\r\n  /**\r\n   * Gets the frame's total render duration (update + draw duration) (in ms)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents physics stats for the current frame\r\n */\r\nexport interface PhysicsStatistics {\r\n  /**\r\n   * Gets the number of broadphase collision pairs which\r\n   */\r\n  pairs: number;\r\n\r\n  /**\r\n   * Gets the number of actual collisions\r\n   */\r\n  collisions: number;\r\n\r\n  /**\r\n   * Copy of the current frame contacts (only updated if debug is toggled on)\r\n   */\r\n  contacts: Map<string, CollisionContact>;\r\n\r\n  /**\r\n   * Gets the number of fast moving bodies using raycast continuous collisions in the scene\r\n   */\r\n  fastBodies: number;\r\n\r\n  /**\r\n   * Gets the number of bodies that had a fast body collision resolution\r\n   */\r\n  fastBodyCollisions: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the broadphase pairs\r\n   */\r\n  broadphase: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the narrowphase\r\n   */\r\n  narrowphase: number;\r\n}\r\n\r\nexport interface GraphicsStatistics {\r\n  drawCalls: number;\r\n  drawnImages: number;\r\n}\r\n\r\n/**\r\n * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n * updated during a frame.\r\n */\r\nexport class Debug implements DebugFlags {\r\n  private _engine: Engine;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n\r\n    this.colorBlindMode = new ColorBlindFlags(this._engine);\r\n  }\r\n\r\n  /**\r\n   * Performance statistics\r\n   */\r\n  public stats: DebugStats = {\r\n    /**\r\n     * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[postframe]] event. See [[FrameStats]]\r\n     */\r\n    currFrame: new FrameStats(),\r\n\r\n    /**\r\n     * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]\r\n     */\r\n    prevFrame: new FrameStats()\r\n  };\r\n\r\n  /**\r\n   * Correct or simulate color blindness using [[ColorBlindness]] post processor.\r\n   * @warning Will reduce FPS.\r\n   */\r\n  public colorBlindMode: ColorBlindFlags;\r\n\r\n  /**\r\n   * Filter debug context to named entities or entity ids\r\n   */\r\n  public filter: { useFilter: boolean; nameQuery: string; ids: number[] } = {\r\n    /**\r\n     * Toggle filter on or off (default off) must be on for DebugDraw to use filters\r\n     */\r\n    useFilter: false,\r\n    /**\r\n     * Query for entities by name, if the entity name contains `nameQuery` it will be included\r\n     */\r\n    nameQuery: '',\r\n    /**\r\n     * Query for Entity ids, if the id matches it will be included\r\n     */\r\n    ids: []\r\n  };\r\n\r\n  /**\r\n   * Entity debug settings\r\n   */\r\n  public entity = {\r\n    showAll: false,\r\n    showId: true,\r\n    showName: false\r\n  };\r\n\r\n  /**\r\n   * Transform component debug settings\r\n   */\r\n  public transform = {\r\n    showAll: false,\r\n\r\n    showPosition: false,\r\n    positionColor: Color.Yellow,\r\n\r\n    showScale: false,\r\n    scaleColor: Color.Green,\r\n\r\n    showRotation: false,\r\n    rotationColor: Color.Blue\r\n  };\r\n\r\n  /**\r\n   * Graphics component debug settings\r\n   */\r\n  public graphics = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Yellow\r\n  };\r\n\r\n  /**\r\n   * Collider component debug settings\r\n   */\r\n  public collider = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Blue,\r\n\r\n    showOwner: false,\r\n\r\n    showGeometry: true,\r\n    geometryColor: Color.Green\r\n  };\r\n\r\n  /**\r\n   * Physics simulation debug settings\r\n   */\r\n  public physics = {\r\n    showAll: false,\r\n\r\n    showBroadphaseSpacePartitionDebug: false,\r\n\r\n    showCollisionNormals: false,\r\n    collisionNormalColor: Color.Cyan,\r\n\r\n    showCollisionContacts: true,\r\n    collisionContactColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Motion component debug settings\r\n   */\r\n  public motion = {\r\n    showAll: false,\r\n\r\n    showVelocity: false,\r\n    velocityColor: Color.Yellow,\r\n\r\n    showAcceleration: false,\r\n    accelerationColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Body component debug settings\r\n   */\r\n  public body = {\r\n    showAll: false,\r\n\r\n    showCollisionGroup: false,\r\n    showCollisionType: false,\r\n    showSleeping: false,\r\n    showMotion: false,\r\n    showMass: false\r\n  };\r\n\r\n  /**\r\n   * Camera debug settings\r\n   */\r\n  public camera = {\r\n    showAll: false,\r\n\r\n    showFocus: false,\r\n    focusColor: Color.Red,\r\n\r\n    showZoom: false\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n * creating instances of this every frame.\r\n */\r\nexport class FrameStats implements FrameStatistics {\r\n  private _id: number = 0;\r\n  private _delta: number = 0;\r\n  private _fps: number = 0;\r\n  private _actorStats: FrameActorStats = {\r\n    alive: 0,\r\n    killed: 0,\r\n    ui: 0,\r\n    get remaining() {\r\n      return this.alive - this.killed;\r\n    },\r\n    get total() {\r\n      return this.remaining + this.ui;\r\n    }\r\n  };\r\n  private _durationStats: FrameDurationStats = {\r\n    update: 0,\r\n    draw: 0,\r\n    get total() {\r\n      return this.update + this.draw;\r\n    }\r\n  };\r\n\r\n  private _physicsStats: PhysicsStats = new PhysicsStats();\r\n\r\n  private _graphicsStats: GraphicsStatistics = {\r\n    drawCalls: 0,\r\n    drawnImages: 0\r\n  };\r\n\r\n  /**\r\n   * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: FrameStatistics) {\r\n    if (otherStats) {\r\n      this.id = otherStats.id;\r\n      this.delta = otherStats.delta;\r\n      this.fps = otherStats.fps;\r\n      this.actors.alive = otherStats.actors.alive;\r\n      this.actors.killed = otherStats.actors.killed;\r\n      this.actors.ui = otherStats.actors.ui;\r\n      this.duration.update = otherStats.duration.update;\r\n      this.duration.draw = otherStats.duration.draw;\r\n      this._physicsStats.reset(otherStats.physics);\r\n      this.graphics.drawCalls = otherStats.graphics.drawCalls;\r\n      this.graphics.drawnImages = otherStats.graphics.drawnImages;\r\n    } else {\r\n      this.id = this.delta = this.fps = 0;\r\n      this.actors.alive = this.actors.killed = this.actors.ui = 0;\r\n      this.duration.update = this.duration.draw = 0;\r\n      this._physicsStats.reset();\r\n      this.graphics.drawnImages = this.graphics.drawCalls = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): FrameStats {\r\n    const fs = new FrameStats();\r\n\r\n    fs.reset(this);\r\n\r\n    return fs;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's id\r\n   */\r\n  public get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's id\r\n   */\r\n  public set id(value: number) {\r\n    this._id = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame)\r\n   */\r\n  public get delta() {\r\n    return this._delta;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's delta (time since last frame). Internal use only.\r\n   * @internal\r\n   */\r\n  public set delta(value: number) {\r\n    this._delta = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  public get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's frames-per-second (FPS). Internal use only.\r\n   * @internal\r\n   */\r\n  public set fps(value: number) {\r\n    this._fps = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's actor statistics\r\n   */\r\n  public get actors() {\r\n    return this._actorStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's duration statistics\r\n   */\r\n  public get duration() {\r\n    return this._durationStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's physics statistics\r\n   */\r\n  public get physics() {\r\n    return this._physicsStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's graphics statistics\r\n   */\r\n  public get graphics() {\r\n    return this._graphicsStats;\r\n  }\r\n}\r\n\r\nexport class PhysicsStats implements PhysicsStatistics {\r\n  private _pairs: number = 0;\r\n  private _collisions: number = 0;\r\n  private _contacts: Map<string, CollisionContact> = new Map();\r\n  private _fastBodies: number = 0;\r\n  private _fastBodyCollisions: number = 0;\r\n  private _broadphase: number = 0;\r\n  private _narrowphase: number = 0;\r\n\r\n  /**\r\n   * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: PhysicsStatistics) {\r\n    if (otherStats) {\r\n      this.pairs = otherStats.pairs;\r\n      this.collisions = otherStats.collisions;\r\n      this.contacts = otherStats.contacts;\r\n      this.fastBodies = otherStats.fastBodies;\r\n      this.fastBodyCollisions = otherStats.fastBodyCollisions;\r\n      this.broadphase = otherStats.broadphase;\r\n      this.narrowphase = otherStats.narrowphase;\r\n    } else {\r\n      this.pairs = this.collisions = this.fastBodies = 0;\r\n      this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\r\n      this.contacts.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): PhysicsStatistics {\r\n    const ps = new PhysicsStats();\r\n\r\n    ps.reset(this);\r\n\r\n    return ps;\r\n  }\r\n\r\n  public get pairs(): number {\r\n    return this._pairs;\r\n  }\r\n\r\n  public set pairs(value: number) {\r\n    this._pairs = value;\r\n  }\r\n\r\n  public get collisions(): number {\r\n    return this._collisions;\r\n  }\r\n\r\n  public set collisions(value: number) {\r\n    this._collisions = value;\r\n  }\r\n\r\n  public get contacts(): Map<string, CollisionContact> {\r\n    return this._contacts;\r\n  }\r\n\r\n  public set contacts(contacts: Map<string, CollisionContact>) {\r\n    this._contacts = contacts;\r\n  }\r\n\r\n  public get fastBodies(): number {\r\n    return this._fastBodies;\r\n  }\r\n\r\n  public set fastBodies(value: number) {\r\n    this._fastBodies = value;\r\n  }\r\n\r\n  public get fastBodyCollisions(): number {\r\n    return this._fastBodyCollisions;\r\n  }\r\n\r\n  public set fastBodyCollisions(value: number) {\r\n    this._fastBodyCollisions = value;\r\n  }\r\n\r\n  public get broadphase(): number {\r\n    return this._broadphase;\r\n  }\r\n\r\n  public set broadphase(value: number) {\r\n    this._broadphase = value;\r\n  }\r\n\r\n  public get narrowphase(): number {\r\n    return this._narrowphase;\r\n  }\r\n\r\n  public set narrowphase(value: number) {\r\n    this._narrowphase = value;\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { ColorBlindCorrector, ColorBlindness } from '../PostProcessing/Index';\r\n\r\nexport interface DebugFlags {\r\n  colorBlindMode: ColorBlindFlags;\r\n}\r\n\r\nexport class ColorBlindFlags {\r\n  private _engine: Engine;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n  }\r\n\r\n  public correct(colorBlindness: ColorBlindness) {\r\n    this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, false, colorBlindness));\r\n  }\r\n\r\n  public simulate(colorBlindness: ColorBlindness) {\r\n    this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, true, colorBlindness));\r\n  }\r\n}\r\n","import { Actor } from '../Actor';\r\nimport { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { Vector } from '../Math/vector';\r\nimport { Pointer, PointerType } from './Pointer';\r\nimport { GameEvent } from '../Events';\r\n\r\n/**\r\n * Native browser button enumeration\r\n */\r\nexport enum NativePointerButton {\r\n  NoButton = -1,\r\n  Left = 0,\r\n  Middle = 1,\r\n  Right = 2,\r\n  Unknown = 3\r\n}\r\n\r\n/**\r\n * The mouse button being pressed.\r\n */\r\nexport enum PointerButton {\r\n  Left = 'Left',\r\n  Middle = 'Middle',\r\n  Right = 'Right',\r\n  Unknown = 'Unknown',\r\n  NoButton = 'NoButton'\r\n}\r\n\r\nexport enum WheelDeltaMode {\r\n  Pixel = 'Pixel',\r\n  Line = 'Line',\r\n  Page = 'Page'\r\n}\r\n\r\n/**\r\n * Type that indicates Excalibur's valid synthetic pointer events\r\n */\r\nexport type PointerEventName =\r\n  | 'pointerdragstart'\r\n  | 'pointerdragend'\r\n  | 'pointerdragmove'\r\n  | 'pointerdragenter'\r\n  | 'pointerdragleave'\r\n  | 'pointermove'\r\n  | 'pointerenter'\r\n  | 'pointerleave'\r\n  | 'pointerup'\r\n  | 'pointerdown';\r\n\r\n/**\r\n * Pointer events\r\n *\r\n * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on\r\n * handling pointer input.\r\n *\r\n * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.\r\n */\r\nexport class PointerEvent extends GameEvent<Actor> {\r\n  protected _name: string;\r\n\r\n  public get name() {\r\n    return this._name;\r\n  }\r\n\r\n  /** The world coordinates of the event. */\r\n  public get worldPos(): Vector {\r\n    return this.coordinates.worldPos.clone();\r\n  }\r\n\r\n  /** The page coordinates of the event. */\r\n  public get pagePos(): Vector {\r\n    return this.coordinates.pagePos.clone();\r\n  }\r\n\r\n  /** The screen coordinates of the event. */\r\n  public get screenPos(): Vector {\r\n    return this.coordinates.screenPos.clone();\r\n  }\r\n\r\n  /**\r\n   * @param coordinates         The [[GlobalCoordinates]] of the event\r\n   * @param pointer             The [[Pointer]] of the event\r\n   * @param index               The index of the pointer (zero-based)\r\n   * @param pointerType         The type of pointer\r\n   * @param button              The button pressed (if [[PointerType.Mouse]])\r\n   * @param ev                  The raw DOM event being handled\r\n   */\r\n  constructor(\r\n    protected coordinates: GlobalCoordinates,\r\n    public pointer: Pointer,\r\n    public index: number,\r\n    public pointerType: PointerType,\r\n    public button: PointerButton,\r\n    public ev: any\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  public get pos(): Vector {\r\n    return this.coordinates.worldPos.clone();\r\n  }\r\n\r\n  public _canceled = false;\r\n\r\n  /**\r\n   * Cancels pointer event propogation, event will not be transmitted to any other actors\r\n   */\r\n  public cancel() {\r\n    this._canceled = true;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns If the event is canceled it will no longer be transmitted to any other actors\r\n   */\r\n  public isCanceled() {\r\n    return this._canceled;\r\n  }\r\n\r\n  public propagate(actor: Actor): void {\r\n    this.doAction(actor);\r\n\r\n    if (this.bubbles && !this.isCanceled() && actor.parent) {\r\n      this.propagate(actor.parent as Actor); // TODO not true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Action, that calls when event happens\r\n   */\r\n  public doAction(actor: Actor): void {\r\n    if (actor) {\r\n      this._onActionStart(actor);\r\n      actor.emit(this._name, this);\r\n      this._onActionEnd(actor);\r\n    }\r\n  }\r\n\r\n  protected _onActionStart(_actor?: Actor) {\r\n    // to be rewritten\r\n  }\r\n\r\n  protected _onActionEnd(_actor?: Actor) {\r\n    // to be rewritten\r\n  }\r\n}\r\n\r\nexport class PointerEventFactory<T extends PointerEvent> {\r\n  constructor(\r\n    protected _pointerEventType: new (\r\n      coordinates: GlobalCoordinates,\r\n      pointer: Pointer,\r\n      index: number,\r\n      pointerType: PointerType,\r\n      button: PointerButton,\r\n      ev: any\r\n    ) => T\r\n  ) {}\r\n\r\n  /**\r\n   * Create specific PointerEvent\r\n   */\r\n  public create(\r\n    coordinates: GlobalCoordinates,\r\n    pointer: Pointer,\r\n    index: number,\r\n    pointerType: PointerType,\r\n    button: PointerButton,\r\n    ev: any\r\n  ): T {\r\n    return new this._pointerEventType(coordinates, pointer, index, pointerType, button, ev);\r\n  }\r\n}\r\n\r\nexport class PointerDragEvent extends PointerEvent {}\r\n\r\nexport class PointerUpEvent extends PointerEvent {\r\n  protected _name = 'pointerup';\r\n\r\n  protected _onActionEnd(actor: Actor) {\r\n    const pointer = this.pointer;\r\n\r\n    if (pointer.isDragEnd && actor.capturePointer.captureDragEvents) {\r\n      actor.eventDispatcher.emit('pointerdragend', this);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PointerDownEvent extends PointerEvent {\r\n  protected _name = 'pointerdown';\r\n\r\n  protected _onActionEnd(actor: Actor) {\r\n    if (this.pointer.isDragStart && actor.capturePointer.captureDragEvents) {\r\n      actor.eventDispatcher.emit('pointerdragstart', this);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PointerMoveEvent extends PointerEvent {\r\n  protected _name = 'pointermove';\r\n\r\n  public propagate(actor: Actor): void {\r\n    // If the actor was under the pointer last frame, but not this one it left\r\n    // if (this.pointer.wasActorUnderPointer(actor) && !this.pointer.isActorUnderPointer(actor)) {\r\n    //   this._onActorLeave(actor);\r\n    //   return;\r\n    // }\r\n\r\n    if (this.pointer.isActorAliveUnderPointer(actor)) {\r\n      this.doAction(actor);\r\n\r\n      if (this.bubbles && !this.isCanceled() && actor.parent) {\r\n        this.propagate(actor.parent as Actor); // TODO not true\r\n      }\r\n    }\r\n  }\r\n\r\n  protected _onActionStart(actor: Actor) {\r\n    if (!actor.capturePointer.captureMoveEvents) {\r\n      return;\r\n    }\r\n\r\n    // In the case this is new\r\n    // if (this.pointer.checkActorUnderPointer(actor) && !this.pointer.wasActorUnderPointer(actor)) {\r\n    //   this._onActorEnter(actor);\r\n    // }\r\n\r\n    if (this.pointer.isDragging && actor.capturePointer.captureDragEvents) {\r\n      actor.eventDispatcher.emit('pointerdragmove', this);\r\n    }\r\n  }\r\n\r\n  // private _onActorEnter(actor: Actor) {\r\n  //   const pe = createPointerEventByName('enter', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);\r\n  //   pe.propagate(actor);\r\n  //   this.pointer.addActorUnderPointer(actor);\r\n\r\n  //   if (this.pointer.isDragging) {\r\n  //     this.pointer.dragTarget = actor;\r\n  //   }\r\n  // }\r\n\r\n  // private _onActorLeave(actor: Actor) {\r\n  //   const pe = createPointerEventByName('leave', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);\r\n  //   pe.propagate(actor);\r\n  //   this.pointer.removeActorUnderPointer(actor);\r\n  // }\r\n}\r\n\r\nexport class PointerEnterEvent extends PointerEvent {\r\n  protected _name = 'pointerenter';\r\n\r\n  protected _onActionStart(actor: Actor) {\r\n    if (!actor.capturePointer.captureMoveEvents) {\r\n      return;\r\n    }\r\n  }\r\n\r\n  protected _onActionEnd(actor: Actor) {\r\n    const pointer = this.pointer;\r\n\r\n    if (pointer.isDragging && actor.capturePointer.captureDragEvents) {\r\n      actor.eventDispatcher.emit('pointerdragenter', this);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PointerLeaveEvent extends PointerEvent {\r\n  protected _name = 'pointerleave';\r\n\r\n  protected _onActionStart(actor: Actor) {\r\n    if (!actor.capturePointer.captureMoveEvents) {\r\n      return;\r\n    }\r\n  }\r\n\r\n  protected _onActionEnd(actor: Actor) {\r\n    const pointer = this.pointer;\r\n\r\n    if (pointer.isDragging && actor.capturePointer.captureDragEvents) {\r\n      actor.eventDispatcher.emit('pointerdragleave', this);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PointerCancelEvent extends PointerEvent {\r\n  protected _name = 'pointercancel';\r\n}\r\n/**\r\n * Wheel Events\r\n *\r\n * Represents a mouse wheel event. See [[Pointers]] for more information on\r\n * handling point input.\r\n */\r\nexport class WheelEvent extends GameEvent<Actor> {\r\n  /**\r\n   * @param x            The `x` coordinate of the event (in world coordinates)\r\n   * @param y            The `y` coordinate of the event (in world coordinates)\r\n   * @param pageX        The `x` coordinate of the event (in document coordinates)\r\n   * @param pageY        The `y` coordinate of the event (in document coordinates)\r\n   * @param screenX      The `x` coordinate of the event (in screen coordinates)\r\n   * @param screenY      The `y` coordinate of the event (in screen coordinates)\r\n   * @param index        The index of the pointer (zero-based)\r\n   * @param deltaX       The type of pointer\r\n   * @param deltaY       The type of pointer\r\n   * @param deltaZ       The type of pointer\r\n   * @param deltaMode    The type of movement [[WheelDeltaMode]]\r\n   * @param ev           The raw DOM event being handled\r\n   */\r\n  constructor(\r\n    public x: number,\r\n    public y: number,\r\n    public pageX: number,\r\n    public pageY: number,\r\n    public screenX: number,\r\n    public screenY: number,\r\n    public index: number,\r\n    public deltaX: number,\r\n    public deltaY: number,\r\n    public deltaZ: number,\r\n    public deltaMode: WheelDeltaMode,\r\n    public ev: any\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  private _isCanceled = false;\r\n\r\n  /**\r\n   * Cancels pointer event propogation, event will not be transmitted to any other actors\r\n   */\r\n  public cancel() {\r\n    this._isCanceled = true;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns If the event is canceled it will no longer be transmitted to any other actors\r\n   */\r\n  public isCanceled() {\r\n    return this._isCanceled;\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function createPointerEventByName(\r\n  eventName: string,\r\n  coordinates: GlobalCoordinates,\r\n  pointer: Pointer,\r\n  index: number,\r\n  pointerType: PointerType,\r\n  button: PointerButton,\r\n  ev: any\r\n) {\r\n  let factory: PointerEventFactory<PointerEvent>;\r\n\r\n  switch (eventName) {\r\n    case 'up':\r\n      factory = new PointerEventFactory(<any>PointerUpEvent);\r\n      break;\r\n    case 'down':\r\n      factory = new PointerEventFactory(<any>PointerDownEvent);\r\n      break;\r\n    case 'move':\r\n      factory = new PointerEventFactory(<any>PointerMoveEvent);\r\n      break;\r\n    case 'cancel':\r\n      factory = new PointerEventFactory(<any>PointerCancelEvent);\r\n      break;\r\n    case 'enter':\r\n      factory = new PointerEventFactory(<any>PointerEnterEvent);\r\n      break;\r\n    case 'leave':\r\n      factory = new PointerEventFactory(<any>PointerLeaveEvent);\r\n      break;\r\n  }\r\n\r\n  return factory.create(coordinates, pointer, index, pointerType, button, ev);\r\n}\r\n","import { Logger } from '../Util/Log';\r\nimport { Class } from '../Class';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Enum representing physical input key codes\r\n */\r\nexport enum Keys {\r\n  // NUMPAD\r\n  Num0 = 'Numpad0',\r\n  Num1 = 'Numpad1',\r\n  Num2 = 'Numpad2',\r\n  Num3 = 'Numpad3',\r\n  Num4 = 'Numpad4',\r\n  Num5 = 'Numpad5',\r\n  Num6 = 'Numpad6',\r\n  Num7 = 'Numpad7',\r\n  Num8 = 'Numpad8',\r\n  Num9 = 'Numpad9',\r\n  NumAdd = 'NumpadAdd',\r\n  NumSubtract = 'NumpadSubtract',\r\n  NumMultiply = 'NumpadMultiply',\r\n  NumDivide = 'NumpadDivide',\r\n  // NumComma = 'NumpadComma', // not x-browser\r\n  NumDecimal = 'NumpadDecimal',\r\n  Numpad0 = 'Numpad0',\r\n  Numpad1 = 'Numpad1',\r\n  Numpad2 = 'Numpad2',\r\n  Numpad3 = 'Numpad3',\r\n  Numpad4 = 'Numpad4',\r\n  Numpad5 = 'Numpad5',\r\n  Numpad6 = 'Numpad6',\r\n  Numpad7 = 'Numpad7',\r\n  Numpad8 = 'Numpad8',\r\n  Numpad9 = 'Numpad9',\r\n  NumpadAdd = 'NumpadAdd',\r\n  NumpadSubtract = 'NumpadSubtract',\r\n  NumpadMultiply = 'NumpadMultiply',\r\n  NumpadDivide = 'NumpadDivide',\r\n  // NumpadComma = 'NumpadComma', // not x-browser\r\n  NumpadDecimal = 'NumpadDecimal',\r\n\r\n  // MODIFIERS\r\n  NumLock = 'NumLock',\r\n  ShiftLeft = 'ShiftLeft',\r\n  ShiftRight = 'ShiftRight',\r\n  AltLeft = 'AltLeft',\r\n  AltRight = 'AltRight',\r\n\r\n  // NUMBERS\r\n  Key0 = 'Digit0',\r\n  Key1 = 'Digit1',\r\n  Key2 = 'Digit2',\r\n  Key3 = 'Digit3',\r\n  Key4 = 'Digit4',\r\n  Key5 = 'Digit5',\r\n  Key6 = 'Digit6',\r\n  Key7 = 'Digit7',\r\n  Key8 = 'Digit8',\r\n  Key9 = 'Digit9',\r\n  Digit0 = 'Digit0',\r\n  Digit1 = 'Digit1',\r\n  Digit2 = 'Digit2',\r\n  Digit3 = 'Digit3',\r\n  Digit4 = 'Digit4',\r\n  Digit5 = 'Digit5',\r\n  Digit6 = 'Digit6',\r\n  Digit7 = 'Digit7',\r\n  Digit8 = 'Digit8',\r\n  Digit9 = 'Digit9',\r\n\r\n  // LETTERS\r\n  A = 'KeyA',\r\n  B = 'KeyB',\r\n  C = 'KeyC',\r\n  D = 'KeyD',\r\n  E = 'KeyE',\r\n  F = 'KeyF',\r\n  G = 'KeyG',\r\n  H = 'KeyH',\r\n  I = 'KeyI',\r\n  J = 'KeyJ',\r\n  K = 'KeyK',\r\n  L = 'KeyL',\r\n  M = 'KeyM',\r\n  N = 'KeyN',\r\n  O = 'KeyO',\r\n  P = 'KeyP',\r\n  Q = 'KeyQ',\r\n  R = 'KeyR',\r\n  S = 'KeyS',\r\n  T = 'KeyT',\r\n  U = 'KeyU',\r\n  V = 'KeyV',\r\n  W = 'KeyW',\r\n  X = 'KeyX',\r\n  Y = 'KeyY',\r\n  Z = 'KeyZ',\r\n  KeyA = 'KeyA',\r\n  KeyB = 'KeyB',\r\n  KeyC = 'KeyC',\r\n  KeyD = 'KeyD',\r\n  KeyE = 'KeyE',\r\n  KeyF = 'KeyF',\r\n  KeyG = 'KeyG',\r\n  KeyH = 'KeyH',\r\n  KeyI = 'KeyI',\r\n  KeyJ = 'KeyJ',\r\n  KeyK = 'KeyK',\r\n  KeyL = 'KeyL',\r\n  KeyM = 'KeyM',\r\n  KeyN = 'KeyN',\r\n  KeyO = 'KeyO',\r\n  KeyP = 'KeyP',\r\n  KeyQ = 'KeyQ',\r\n  KeyR = 'KeyR',\r\n  KeyS = 'KeyS',\r\n  KeyT = 'KeyT',\r\n  KeyU = 'KeyU',\r\n  KeyV = 'KeyV',\r\n  KeyW = 'KeyW',\r\n  KeyX = 'KeyX',\r\n  KeyY = 'KeyY',\r\n  KeyZ = 'KeyZ',\r\n\r\n  // SYMBOLS\r\n  Semicolon = 'Semicolon',\r\n  Quote = 'Quote',\r\n  Comma = 'Comma',\r\n  Minus = 'Minus',\r\n  Period = 'Period',\r\n  Slash = 'Slash',\r\n  Equal = 'Equal',\r\n  BracketLeft = 'BracketLeft',\r\n  Backslash = 'Backslash',\r\n  BracketRight = 'BracketRight',\r\n  Backquote = 'Backquote',\r\n\r\n  // DIRECTIONS\r\n  Up = 'ArrowUp',\r\n  Down = 'ArrowDown',\r\n  Left = 'ArrowLeft',\r\n  Right = 'ArrowRight',\r\n  ArrowUp = 'ArrowUp',\r\n  ArrowDown = 'ArrowDown',\r\n  ArrowLeft = 'ArrowLeft',\r\n  ArrowRight = 'ArrowRight',\r\n\r\n  // OTHER\r\n  Space = 'Space',\r\n  Esc = 'Escape',\r\n  Escape = 'Escape'\r\n}\r\n\r\n/**\r\n * Event thrown on a game object for a key event\r\n */\r\nexport class KeyEvent extends Events.GameEvent<any> {\r\n  /**\r\n   * @param key  The key responsible for throwing the event\r\n   * @param value The key's typed value the browser detected\r\n   * @param originalEvent The original keyboard event that Excalibur handled\r\n   */\r\n  constructor(public key: Keys, public value?: string, public originalEvent?: KeyboardEvent) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Provides keyboard support for Excalibur.\r\n */\r\nexport class Keyboard extends Class {\r\n  private _keys: Keys[] = [];\r\n  private _keysUp: Keys[] = [];\r\n  private _keysDown: Keys[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public on(eventName: Events.press, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.release, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.hold, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Initialize Keyboard event listeners\r\n   */\r\n  init(global?: GlobalEventHandlers): void {\r\n    if (!global) {\r\n      try {\r\n        // Try and listen to events on top window frame if within an iframe.\r\n        //\r\n        // See https://github.com/excaliburjs/Excalibur/issues/1294\r\n        //\r\n        // Attempt to add an event listener, which triggers a DOMException on\r\n        // cross-origin iframes\r\n        const noop = () => {\r\n          return;\r\n        };\r\n        window.top.addEventListener('blur', noop);\r\n        window.top.removeEventListener('blur', noop);\r\n\r\n        // this will be the same as window if not embedded within an iframe\r\n        global = window.top;\r\n      } catch {\r\n        // fallback to current frame\r\n        global = window;\r\n\r\n        Logger.getInstance().warn(\r\n          'Failed to bind to keyboard events to top frame. ' +\r\n            'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.'\r\n        );\r\n      }\r\n    }\r\n\r\n    global.addEventListener('blur', () => {\r\n      this._keys.length = 0; // empties array efficiently\r\n    });\r\n\r\n    // key up is on window because canvas cannot have focus\r\n    global.addEventListener('keyup', (ev: KeyboardEvent) => {\r\n      const code = ev.code as Keys;\r\n      const key = this._keys.indexOf(code);\r\n      this._keys.splice(key, 1);\r\n      this._keysUp.push(code);\r\n      const keyEvent = new KeyEvent(code, ev.key, ev);\r\n\r\n      // alias the old api, we may want to deprecate this in the future\r\n      this.eventDispatcher.emit('up', keyEvent);\r\n      this.eventDispatcher.emit('release', keyEvent);\r\n    });\r\n\r\n    // key down is on window because canvas cannot have focus\r\n    global.addEventListener('keydown', (ev: KeyboardEvent) => {\r\n      const code = ev.code as Keys;\r\n      if (this._keys.indexOf(code) === -1) {\r\n        this._keys.push(code);\r\n        this._keysDown.push(code);\r\n        const keyEvent = new KeyEvent(code, ev.key, ev);\r\n        this.eventDispatcher.emit('down', keyEvent);\r\n        this.eventDispatcher.emit('press', keyEvent);\r\n      }\r\n    });\r\n  }\r\n\r\n  public update() {\r\n    // Reset keysDown and keysUp after update is complete\r\n    this._keysDown.length = 0;\r\n    this._keysUp.length = 0;\r\n\r\n    // Emit synthetic \"hold\" event\r\n    for (let i = 0; i < this._keys.length; i++) {\r\n      this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets list of keys being pressed down\r\n   */\r\n  public getKeys(): Keys[] {\r\n    return this._keys;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n   * @param key Test whether a key was just pressed\r\n   */\r\n  public wasPressed(key: Keys): boolean {\r\n    return this._keysDown.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key is held down. This is persisted between frames.\r\n   * @param key  Test whether a key is held down\r\n   */\r\n  public isHeld(key: Keys): boolean {\r\n    return this._keys.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n   * @param key  Test whether a key was just released\r\n   */\r\n  public wasReleased(key: Keys): boolean {\r\n    return this._keysUp.indexOf(key) > -1;\r\n  }\r\n}\r\n","import { Actor } from '../Actor';\r\nimport { Vector } from '../Math/vector';\r\nimport { Class } from '../Class';\r\nimport * as Actors from '../Util/Actors';\r\nimport { removeItemFromArray } from '../Util/Util';\r\nimport { PointerMoveEvent, PointerDownEvent, PointerUpEvent, WheelEvent } from './PointerEvents';\r\n\r\nexport interface ActorsUnderPointer {\r\n  [ActorId: number]: Actor;\r\n  length: number;\r\n}\r\n\r\n/**\r\n * The type of pointer for a [[PointerEvent]].\r\n */\r\nexport enum PointerType {\r\n  Touch = 'Touch',\r\n  Mouse = 'Mouse',\r\n  Pen = 'Pen',\r\n  Unknown = 'Unknown'\r\n}\r\n\r\n/**\r\n * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.\r\n */\r\nexport enum PointerScope {\r\n  /**\r\n   * Handle events on the `canvas` element only. Events originating outside the\r\n   * `canvas` will not be handled.\r\n   */\r\n  Canvas = 'Canvas',\r\n\r\n  /**\r\n   * Handles events on the entire document. All events will be handled by Excalibur.\r\n   */\r\n  Document = 'Document'\r\n}\r\n\r\n/**\r\n * Captures and dispatches PointerEvents\r\n */\r\nexport class Pointer extends Class {\r\n  private static _MAX_ID = 0;\r\n  public readonly id = Pointer._MAX_ID++;\r\n  private _isDown: boolean = false;\r\n  private _wasDown: boolean = false;\r\n\r\n  private _actorsUnderPointer: ActorsUnderPointer = { length: 0 };\r\n\r\n  private _actors: Actor[] = [];\r\n  private _actorsLastFrame: Actor[] = [];\r\n  private _actorsNoLongerUnderPointer: Actor[] = [];\r\n\r\n  private _actorSortingFcn = (a: Actor, b: Actor) => {\r\n    if (a.z === b.z) {\r\n      return b.id - a.id;\r\n    }\r\n    return b.z - a.z;\r\n  };\r\n\r\n  /**\r\n   * Whether the Pointer is currently dragging.\r\n   */\r\n  public get isDragging(): boolean {\r\n    return this._isDown;\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just started dragging.\r\n   */\r\n  public get isDragStart(): boolean {\r\n    return !this._wasDown && this._isDown;\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just ended dragging.\r\n   */\r\n  public get isDragEnd(): boolean {\r\n    return this._wasDown && !this._isDown;\r\n  }\r\n\r\n  /**\r\n   * Returns true if pointer has any actors under\r\n   */\r\n  public get hasActorsUnderPointer(): boolean {\r\n    return !!this._actorsUnderPointer.length;\r\n  }\r\n\r\n  /**\r\n   * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastPagePos: Vector = null;\r\n\r\n  /**\r\n   * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastScreenPos: Vector = null;\r\n\r\n  /**\r\n   * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastWorldPos: Vector = null;\r\n\r\n  /**\r\n   * Returns the currently dragging target or null if it isn't exist\r\n   */\r\n  public dragTarget: Actor = null;\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    this.on('move', this._onPointerMove);\r\n    this.on('down', this._onPointerDown);\r\n    this.on('up', this._onPointerUp);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerMoveEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerDownEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerUpEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerMoveEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerDownEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerUpEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerMoveEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerDownEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerUpEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  /**\r\n   * Update the state of current pointer, meant to be called a the end of frame\r\n   */\r\n  public update(): void {\r\n    if (this._wasDown && !this._isDown) {\r\n      this._wasDown = false;\r\n    } else if (!this._wasDown && this._isDown) {\r\n      this._wasDown = true;\r\n    }\r\n    this._actorsLastFrame = [...this._actors];\r\n    this._actorsNoLongerUnderPointer = [];\r\n  }\r\n\r\n  /**\r\n   * Adds an Actor to actorsUnderPointer object.\r\n   * @param actor An Actor to be added;\r\n   */\r\n  public addActorUnderPointer(actor: Actor): void {\r\n    if (!this.isActorAliveUnderPointer(actor)) {\r\n      this._actorsUnderPointer[actor.id] = actor;\r\n      this._actorsUnderPointer.length += 1;\r\n      this._actors.push(actor);\r\n    }\r\n\r\n    // Actors are processed in z-order highest z to lowest\r\n    // ties are broken by id highest id (newest) to lowest id (oldest)\r\n    this._actors.sort(this._actorSortingFcn);\r\n  }\r\n\r\n  /**\r\n   * Removes an Actor from actorsUnderPointer object.\r\n   * @param actor An Actor to be removed;\r\n   */\r\n  public removeActorUnderPointer(actor: Actor): void {\r\n    if (this.isActorAliveUnderPointer(actor)) {\r\n      delete this._actorsUnderPointer[actor.id];\r\n      this._actorsUnderPointer.length -= 1;\r\n      removeItemFromArray(actor, this._actors);\r\n      this._actorsNoLongerUnderPointer.push(actor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns all actors under this pointer this frame\r\n   */\r\n  public getActorsUnderPointer(): Actor[] {\r\n    return this._actors;\r\n  }\r\n\r\n  /**\r\n   * Returns all actors that are no longer under the pointer this frame\r\n   */\r\n  public getActorsUnderPointerLastFrame(): Actor[] {\r\n    return this._actorsLastFrame;\r\n  }\r\n\r\n  /**\r\n   * Returns all actors relevant for events to pointer this frame\r\n   */\r\n  public getActorsForEvents(): Actor[] {\r\n    return this._actors\r\n      .concat(this._actorsLastFrame)\r\n      .filter((actor, i, self) => {\r\n        return self.indexOf(actor) === i; // de-dup\r\n      })\r\n      .sort(this._actorSortingFcn); // sort by z\r\n  }\r\n\r\n  /**\r\n   * Checks if Pointer location has a specific Actor bounds contained underneath.\r\n   * @param actor An Actor for check;\r\n   */\r\n  public checkActorUnderPointer(actor: Actor): boolean {\r\n    if (this.lastWorldPos) {\r\n      return actor.contains(this.lastWorldPos.x, this.lastWorldPos.y, !Actors.isScreenElement(actor));\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Checks if an actor was under the pointer last frame\r\n   * @param actor\r\n   */\r\n  public wasActorUnderPointer(actor: Actor): boolean {\r\n    return this._actorsLastFrame.indexOf(actor) > -1;\r\n  }\r\n\r\n  /**\r\n   * Checks if Pointer has a specific Actor in ActorsUnderPointer list.\r\n   * @param actor An Actor for check;\r\n   */\r\n  public isActorAliveUnderPointer(actor: Actor): boolean {\r\n    return !!(!actor.isKilled() && actor.scene && this._actorsUnderPointer.hasOwnProperty(actor.id.toString()));\r\n  }\r\n\r\n  private _onPointerMove(ev: PointerMoveEvent): void {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  }\r\n\r\n  private _onPointerDown(ev: PointerDownEvent): void {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n    this._isDown = true;\r\n  }\r\n\r\n  private _onPointerUp(_ev: PointerUpEvent): void {\r\n    this._isDown = false;\r\n    this.dragTarget = null;\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\nimport { Vector } from './vector';\n\nexport class GlobalCoordinates {\n  public static fromPagePosition(x: number, y: number, engine: Engine): GlobalCoordinates;\n  public static fromPagePosition(pos: Vector, engine: Engine): GlobalCoordinates;\n  public static fromPagePosition(xOrPos: number | Vector, yOrEngine: number | Engine, engineOrUndefined?: Engine): GlobalCoordinates {\n    let pageX: number;\n    let pageY: number;\n    let pagePos: Vector;\n    let engine: Engine;\n\n    if (arguments.length === 3) {\n      pageX = <number>xOrPos;\n      pageY = <number>yOrEngine;\n      pagePos = new Vector(pageX, pageY);\n      engine = engineOrUndefined;\n    } else {\n      pagePos = <Vector>xOrPos;\n      pageX = pagePos.x;\n      pageY = pagePos.y;\n      engine = <Engine>yOrEngine;\n    }\n\n    const screenPos = engine.screen.pageToScreenCoordinates(pagePos);\n    const worldPos = engine.screen.screenToWorldCoordinates(screenPos);\n\n    return new GlobalCoordinates(worldPos, pagePos, screenPos);\n  }\n\n  constructor(public worldPos: Vector, public pagePos: Vector, public screenPos: Vector) {}\n}\n","import { Class } from '../Class';\r\nimport { Engine, ScrollPreventionMode } from '../Engine';\r\nimport { Pointer, PointerType } from './Pointer';\r\nimport {\r\n  PointerEvent,\r\n  WheelEvent,\r\n  NativePointerButton,\r\n  PointerButton,\r\n  WheelDeltaMode,\r\n  createPointerEventByName,\r\n  PointerLeaveEvent,\r\n  PointerEnterEvent\r\n} from './PointerEvents';\r\nimport { GameEvent } from '../Events';\r\n\r\nimport * as Events from '../Events';\r\nimport * as Util from '../Util/Util';\r\nimport { vec } from '../Math/vector';\r\nimport { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { Vector } from '../Math/vector';\r\nimport { CapturePointer } from '../Traits/CapturePointer';\r\nimport { Actor } from '../Actor';\r\n\r\nexport type DOMPointerEvent = globalThis.PointerEvent;\r\nexport type DOMWheelEvent = globalThis.WheelEvent;\r\n\r\ninterface TouchEvent extends Event {\r\n  altKey: boolean;\r\n  changedTouches: Touch[];\r\n  ctrlKey: boolean;\r\n  metaKey: boolean;\r\n  shiftKey: boolean;\r\n  targetTouches: Touch[];\r\n  touches: Touch[];\r\n  type: string;\r\n  target: Element;\r\n}\r\n\r\ninterface Touch {\r\n  identifier: number;\r\n  screenX: number;\r\n  screenY: number;\r\n  clientX: number;\r\n  clientY: number;\r\n  pageX: number;\r\n  pageY: number;\r\n  radiusX: number;\r\n  radiusY: number;\r\n  rotationAngle: number;\r\n  force: number;\r\n  target: Element;\r\n}\r\n\r\n/**\r\n * A constant used to normalize wheel events across different browsers\r\n *\r\n * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n */\r\nconst ScrollWheelNormalizationFactor = -1 / 40;\r\n\r\n/**\r\n * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to\r\n * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).\r\n */\r\nexport class Pointers extends Class {\r\n  private _engine: Engine;\r\n\r\n  private _pointerDown: PointerEvent[] = [];\r\n  private _pointerUp: PointerEvent[] = [];\r\n  private _pointerMove: PointerEvent[] = [];\r\n  private _pointerCancel: PointerEvent[] = [];\r\n  private _wheel: WheelEvent[] = [];\r\n  private _pointers: Pointer[] = [];\r\n  private _activePointers: number[] = [];\r\n\r\n  constructor(engine: Engine) {\r\n    super();\r\n\r\n    this._engine = engine;\r\n    this._pointers.push(new Pointer());\r\n    this._activePointers = [-1];\r\n    this.primary = this._pointers[0];\r\n  }\r\n\r\n  public on(eventName: Events.up, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.down, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.move, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.enter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.leave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.cancel, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.wheel, handler: (event: WheelEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Primary pointer (mouse, 1 finger, stylus, etc.)\r\n   */\r\n  public primary: Pointer;\r\n\r\n  /**\r\n   * Initializes pointer event listeners\r\n   */\r\n  public init(target?: GlobalEventHandlers): void {\r\n    target = target || this._engine.canvas;\r\n\r\n    // Touch Events\r\n    target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));\r\n    target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));\r\n    target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));\r\n    target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));\r\n\r\n    // W3C Pointer Events\r\n    // Current: IE11, IE10\r\n    if ((<any>window).PointerEvent) {\r\n      // IE11\r\n      this._engine.canvas.style.touchAction = 'none';\r\n      target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));\r\n      target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));\r\n      target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));\r\n      target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerCancel));\r\n    } else if ((<any>window).MSPointerEvent) {\r\n      // IE10\r\n      (this._engine.canvas.style as any).msTouchAction = 'none';\r\n      target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));\r\n      target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));\r\n      target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));\r\n      target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerCancel));\r\n    } else {\r\n      // Mouse Events\r\n      target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));\r\n      target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));\r\n      target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));\r\n    }\r\n\r\n    // MDN MouseWheelEvent\r\n    const wheelOptions = {\r\n      passive: !(\r\n        this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n        this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas\r\n      )\r\n    };\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel), wheelOptions);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synthesize a pointer event that looks like a real browser event to excalibur\r\n   * @param eventName\r\n   * @param pos\r\n   */\r\n  public triggerEvent(\r\n    eventName: 'up' | 'down' | 'move' | 'cancel' | 'wheel',\r\n    pos: Vector | GlobalCoordinates,\r\n    button: NativePointerButton = NativePointerButton.Left,\r\n    pointerType: 'mouse' | 'touch' | 'pen' = 'mouse',\r\n    pointerId: number = 0\r\n  ): void {\r\n    let x = 0;\r\n    let y = 0;\r\n    let coords: GlobalCoordinates;\r\n    if (pos instanceof GlobalCoordinates) {\r\n      x = pos.pagePos.x;\r\n      y = pos.pagePos.y;\r\n      coords = pos;\r\n    } else {\r\n      x = pos.x;\r\n      y = pos.y;\r\n      coords = new GlobalCoordinates(pos.clone(), pos.clone(), pos.clone());\r\n    }\r\n\r\n    const eventish = {\r\n      pageX: x,\r\n      pageY: y,\r\n      pointerId: pointerId,\r\n      pointerType: pointerType,\r\n      button: button,\r\n      preventDefault: () => {\r\n        /* do nothing */\r\n      }\r\n    };\r\n\r\n    switch (eventName) {\r\n      case 'move':\r\n        this._handlePointerEvent(eventName, this._pointerMove, coords)(eventish as DOMPointerEvent);\r\n        break;\r\n      case 'down':\r\n        this._handlePointerEvent(eventName, this._pointerDown, coords)(eventish as DOMPointerEvent);\r\n        break;\r\n      case 'up':\r\n        this._handlePointerEvent(eventName, this._pointerUp, coords)(eventish as DOMPointerEvent);\r\n        break;\r\n      case 'cancel':\r\n        this._handlePointerEvent(eventName, this._pointerCancel, coords)(eventish as DOMPointerEvent);\r\n        break;\r\n    }\r\n    for (const actor of this._engine.currentScene.actors) {\r\n      const capturePointer = actor.traits.filter((t) => t instanceof CapturePointer)[0];\r\n      if (capturePointer) {\r\n        capturePointer.update(actor, this._engine, 1);\r\n      }\r\n    }\r\n    this.dispatchPointerEvents();\r\n    this.update();\r\n  }\r\n\r\n  /**\r\n   * Update all pointer events and pointers, meant to be called at the end of frame\r\n   */\r\n  public update(): void {\r\n    this._pointerUp.length = 0;\r\n    this._pointerDown.length = 0;\r\n    this._pointerMove.length = 0;\r\n    this._pointerCancel.length = 0;\r\n    this._wheel.length = 0;\r\n\r\n    for (let i = 0; i < this._pointers.length; i++) {\r\n      this._pointers[i].update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist\r\n   * @param index  The pointer index to retrieve\r\n   */\r\n  public at(index: number): Pointer {\r\n    if (index >= this._pointers.length) {\r\n      // Ensure there is a pointer to retrieve\r\n      for (let i = this._pointers.length - 1, max = index; i < max; i++) {\r\n        this._pointers.push(new Pointer());\r\n        this._activePointers.push(-1);\r\n      }\r\n    }\r\n\r\n    return this._pointers[index];\r\n  }\r\n\r\n  /**\r\n   * Get number of pointers being watched\r\n   */\r\n  public count(): number {\r\n    return this._pointers.length;\r\n  }\r\n\r\n  public checkAndUpdateActorUnderPointer(actor: Actor) {\r\n    for (const pointer of this._pointers) {\r\n      if (pointer.checkActorUnderPointer(actor)) {\r\n        pointer.addActorUnderPointer(actor);\r\n      } else {\r\n        pointer.removeActorUnderPointer(actor);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _dispatchWithBubble(events: PointerEvent[]) {\r\n    for (const evt of events) {\r\n      for (const actor of evt.pointer.getActorsForEvents()) {\r\n        if (!evt.isCanceled()) {\r\n          evt.propagate(actor);\r\n        }\r\n        if (!evt.bubbles || evt.isCanceled()) {\r\n          // if the event stops bubbling part way stop processing\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _dispatchPointerLeaveEvents() {\r\n    const lastMoveEventPerPointerPerActor: { [pointerId: string]: PointerEvent } = {};\r\n    const pointerLeave: PointerLeaveEvent[] = [];\r\n\r\n    for (const evt of this._pointerMove) {\r\n      for (const actor of evt.pointer.getActorsForEvents()) {\r\n        // If the actor was under the pointer last frame, but not this this frame, pointer left\r\n        if (\r\n          !lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] &&\r\n          evt.pointer.wasActorUnderPointer(actor) &&\r\n          !evt.pointer.isActorAliveUnderPointer(actor) &&\r\n          !evt.isCanceled()\r\n        ) {\r\n          lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] = evt;\r\n          const pe = createPointerEventByName(\r\n            'leave',\r\n            new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos),\r\n            evt.pointer,\r\n            evt.index,\r\n            evt.pointerType,\r\n            evt.button,\r\n            evt.ev\r\n          );\r\n\r\n          pe.propagate(actor);\r\n          pointerLeave.push(<PointerLeaveEvent>pe);\r\n        }\r\n      }\r\n    }\r\n    return pointerLeave;\r\n  }\r\n\r\n  private _dispatchPointerEnterEvents() {\r\n    const lastMoveEventPerPointer: { [pointerId: number]: PointerEvent } = {};\r\n    const pointerEnter: PointerEnterEvent[] = [];\r\n\r\n    for (const evt of this._pointerMove) {\r\n      for (const actor of evt.pointer.getActorsForEvents()) {\r\n        // If the actor was not under the pointer last frame, but it is this frame, pointer entered\r\n        if (\r\n          !lastMoveEventPerPointer[evt.pointer.id] &&\r\n          !evt.pointer.wasActorUnderPointer(actor) &&\r\n          evt.pointer.isActorAliveUnderPointer(actor) &&\r\n          !evt.isCanceled()\r\n        ) {\r\n          lastMoveEventPerPointer[evt.pointer.id] = evt;\r\n          const pe = createPointerEventByName(\r\n            'enter',\r\n            new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos),\r\n            evt.pointer,\r\n            evt.index,\r\n            evt.pointerType,\r\n            evt.button,\r\n            evt.ev\r\n          );\r\n          pe.propagate(actor);\r\n          pointerEnter.push(<PointerEnterEvent>pe);\r\n          // if pointer is dragging set the drag target\r\n          if (evt.pointer.isDragging) {\r\n            evt.pointer.dragTarget = actor;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return pointerEnter;\r\n  }\r\n\r\n  public dispatchPointerEvents() {\r\n    this._dispatchWithBubble(this._pointerDown);\r\n    this._dispatchWithBubble(this._pointerUp);\r\n    this._dispatchWithBubble(this._pointerMove);\r\n    this._dispatchPointerLeaveEvents();\r\n    this._dispatchPointerEnterEvents();\r\n    this._dispatchWithBubble(this._pointerCancel);\r\n\r\n    // TODO some duplication here\r\n    for (const evt of this._wheel) {\r\n      for (const actor of this._pointers[evt.index].getActorsUnderPointer()) {\r\n        this._propagateWheelPointerEvent(actor, evt);\r\n        if (!evt.bubbles || evt.isCanceled()) {\r\n          // if the event stops bubbling part way stop processing\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _propagateWheelPointerEvent(actor: Actor, wheelEvent: WheelEvent) {\r\n    actor.emit('pointerwheel', wheelEvent);\r\n\r\n    // Recurse and propagate\r\n    if (wheelEvent.bubbles && !wheelEvent.isCanceled() && actor.parent) {\r\n      this._propagateWheelPointerEvent(actor.parent as Actor, wheelEvent); // TODO not true\r\n    }\r\n  }\r\n\r\n  private _handleMouseEvent(eventName: string, eventArr: PointerEvent[]) {\r\n    return (e: MouseEvent) => {\r\n      e.preventDefault();\r\n\r\n      const pointer = this.at(0);\r\n      const coordinates = GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);\r\n      const pe = createPointerEventByName(\r\n        eventName,\r\n        coordinates,\r\n        pointer,\r\n        0,\r\n        PointerType.Mouse,\r\n        this._nativeButtonToPointerButton(e.button),\r\n        e\r\n      );\r\n\r\n      eventArr.push(pe);\r\n      pointer.eventDispatcher.emit(eventName, pe);\r\n    };\r\n  }\r\n\r\n  private _handleTouchEvent(eventName: string, eventArr: PointerEvent[]) {\r\n    return (e: TouchEvent) => {\r\n      e.preventDefault();\r\n      for (let i = 0, len = e.changedTouches.length; i < len; i++) {\r\n        const index = this._pointers.length > 1 ? this._getPointerIndex(e.changedTouches[i].identifier) : 0;\r\n        if (index === -1) {\r\n          continue;\r\n        }\r\n\r\n        const pointer = this.at(index);\r\n        const coordinates = GlobalCoordinates.fromPagePosition(e.changedTouches[i].pageX, e.changedTouches[i].pageY, this._engine);\r\n        const pe = createPointerEventByName(eventName, coordinates, pointer, index, PointerType.Touch, PointerButton.Unknown, e);\r\n\r\n        eventArr.push(pe);\r\n        pointer.eventDispatcher.emit(eventName, pe);\r\n        this.emit(eventName, pe);\r\n        // only with multi-pointer\r\n        if (this._pointers.length > 1) {\r\n          if (eventName === 'up') {\r\n            // remove pointer ID from pool when pointer is lifted\r\n            this._activePointers[index] = -1;\r\n          } else if (eventName === 'down') {\r\n            // set pointer ID to given index\r\n            this._activePointers[index] = e.changedTouches[i].identifier;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  private _handlePointerEvent(eventName: string, eventArr: PointerEvent[], coords?: GlobalCoordinates) {\r\n    return (e: DOMPointerEvent) => {\r\n      e.preventDefault();\r\n\r\n      // get the index for this pointer ID if multi-pointer is asked for\r\n      const index = this._pointers.length > 1 ? this._getPointerIndex(e.pointerId) : 0;\r\n      if (index === -1) {\r\n        return;\r\n      }\r\n\r\n      const pointer = this.at(index);\r\n      const coordinates = coords || GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);\r\n      const pe = createPointerEventByName(\r\n        eventName,\r\n        coordinates,\r\n        pointer,\r\n        index,\r\n        this._stringToPointerType(e.pointerType),\r\n        this._nativeButtonToPointerButton(e.button),\r\n        e\r\n      );\r\n\r\n      eventArr.push(pe);\r\n      pointer.eventDispatcher.emit(eventName, pe);\r\n      this.emit(eventName, pe);\r\n\r\n      // only with multi-pointer\r\n      if (this._pointers.length > 1) {\r\n        if (eventName === 'up') {\r\n          // remove pointer ID from pool when pointer is lifted\r\n          this._activePointers[index] = -1;\r\n        } else if (eventName === 'down') {\r\n          // set pointer ID to given index\r\n          this._activePointers[index] = e.pointerId;\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  private _handleWheelEvent(eventName: string, eventArr: WheelEvent[]) {\r\n    return (e: DOMWheelEvent) => {\r\n      // Should we prevent page scroll because of this event\r\n      if (\r\n        this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n        (this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && e.target === this._engine.canvas)\r\n      ) {\r\n        e.preventDefault();\r\n      }\r\n      const screen = this._engine.screen.pageToScreenCoordinates(vec(e.pageX, e.pageY));\r\n      const world = this._engine.screen.screenToWorldCoordinates(screen);\r\n\r\n      // deltaX, deltaY, and deltaZ are the standard modern properties\r\n      // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE\r\n      // e.detail is only used in opera\r\n\r\n      const deltaX = e.deltaX || e.wheelDeltaX * ScrollWheelNormalizationFactor || 0;\r\n      const deltaY =\r\n        e.deltaY || e.wheelDeltaY * ScrollWheelNormalizationFactor || e.wheelDelta * ScrollWheelNormalizationFactor || e.detail || 0;\r\n      const deltaZ = e.deltaZ || 0;\r\n      let deltaMode = WheelDeltaMode.Pixel;\r\n\r\n      if (e.deltaMode) {\r\n        if (e.deltaMode === 1) {\r\n          deltaMode = WheelDeltaMode.Line;\r\n        } else if (e.deltaMode === 2) {\r\n          deltaMode = WheelDeltaMode.Page;\r\n        }\r\n      }\r\n\r\n      const we = new WheelEvent(world.x, world.y, e.pageX, e.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, e);\r\n\r\n      eventArr.push(we);\r\n      this.at(0).eventDispatcher.emit(eventName, we);\r\n      this.emit(eventName, we);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.\r\n   * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx\r\n   */\r\n  private _getPointerIndex(pointerId: number) {\r\n    let idx;\r\n    if ((idx = this._activePointers.indexOf(pointerId)) > -1) {\r\n      return idx;\r\n    }\r\n\r\n    for (let i = 0; i < this._activePointers.length; i++) {\r\n      if (this._activePointers[i] === -1) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    // ignore pointer because game isn't watching\r\n    return -1;\r\n  }\r\n\r\n  private _nativeButtonToPointerButton(s: NativePointerButton): PointerButton {\r\n    switch (s) {\r\n      case NativePointerButton.NoButton:\r\n        return PointerButton.NoButton;\r\n      case NativePointerButton.Left:\r\n        return PointerButton.Left;\r\n      case NativePointerButton.Middle:\r\n        return PointerButton.Middle;\r\n      case NativePointerButton.Right:\r\n        return PointerButton.Right;\r\n      case NativePointerButton.Unknown:\r\n        return PointerButton.Unknown;\r\n      default:\r\n        return Util.fail(s);\r\n    }\r\n  }\r\n\r\n  private _stringToPointerType(s: string) {\r\n    switch (s) {\r\n      case 'touch':\r\n        return PointerType.Touch;\r\n      case 'mouse':\r\n        return PointerType.Mouse;\r\n      case 'pen':\r\n        return PointerType.Pen;\r\n      default:\r\n        return PointerType.Unknown;\r\n    }\r\n  }\r\n}\r\n","import { Class } from './../Class';\r\nimport { GameEvent, GamepadConnectEvent, GamepadDisconnectEvent, GamepadButtonEvent, GamepadAxisEvent } from '../Events';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n * to provide controller support for your games.\r\n */\r\nexport class Gamepads extends Class {\r\n  /**\r\n   * Whether or not to poll for Gamepad input (default: `false`)\r\n   */\r\n  public enabled = false;\r\n\r\n  /**\r\n   * Whether or not Gamepad API is supported\r\n   */\r\n  public supported = !!(<any>navigator).getGamepads;\r\n\r\n  /**\r\n   * The minimum value an axis has to move before considering it a change\r\n   */\r\n  public static MinAxisMoveThreshold = 0.05;\r\n\r\n  private _gamePadTimeStamps = [0, 0, 0, 0];\r\n  private _oldPads: Gamepad[] = [];\r\n  private _pads: Gamepad[] = [];\r\n  private _initSuccess: boolean = false;\r\n  private _navigator: NavigatorGamepads = <any>navigator;\r\n  private _minimumConfiguration: GamepadConfiguration = null;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public init() {\r\n    if (!this.supported) {\r\n      return;\r\n    }\r\n    if (this._initSuccess) {\r\n      return;\r\n    }\r\n\r\n    // In Chrome, this will return 4 undefined items until a button is pressed\r\n    // In FF, this will not return any items until a button is pressed\r\n    this._oldPads = this._clonePads(this._navigator.getGamepads());\r\n    if (this._oldPads.length && this._oldPads[0]) {\r\n      this._initSuccess = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n   * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n   * all other controllers with more axis or buttons are valid as well. If no minimum\r\n   * configuration is set all pads are valid.\r\n   */\r\n  public setMinimumGamepadConfiguration(config: GamepadConfiguration): void {\r\n    this._enableAndUpdate(); // if config is used, implicitly enable\r\n    this._minimumConfiguration = config;\r\n  }\r\n\r\n  /**\r\n   * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n   */\r\n  private _enableAndUpdate() {\r\n    if (!this.enabled) {\r\n      this.enabled = true;\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks a navigator gamepad against the minimum configuration if present.\r\n   */\r\n  private _isGamepadValid(pad: NavigatorGamepad): boolean {\r\n    if (!this._minimumConfiguration) {\r\n      return true;\r\n    }\r\n    if (!pad) {\r\n      return false;\r\n    }\r\n    const axesLength = pad.axes.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n\r\n    const buttonLength = pad.buttons.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n    return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;\r\n  }\r\n\r\n  public on(eventName: Events.connect, handler: (event: GamepadConnectEvent) => void): void;\r\n  public on(eventName: Events.disconnect, handler: (event: GamepadDisconnectEvent) => void): void;\r\n  public on(eventName: Events.button, handler: (event: GamepadButtonEvent) => void): void;\r\n  public on(eventName: Events.axis, handler: (event: GamepadAxisEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void) {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Updates Gamepad state and publishes Gamepad events\r\n   */\r\n  public update() {\r\n    if (!this.enabled || !this.supported) {\r\n      return;\r\n    }\r\n    this.init();\r\n\r\n    const gamepads = this._navigator.getGamepads();\r\n\r\n    for (let i = 0; i < gamepads.length; i++) {\r\n      if (!gamepads[i]) {\r\n        const gamepad = this.at(i);\r\n        // If was connected, but now isn't emit the disconnect event\r\n        if (gamepad.connected) {\r\n          this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));\r\n        }\r\n        // Reset connection status\r\n        gamepad.connected = false;\r\n        continue;\r\n      } else {\r\n        if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {\r\n          this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));\r\n        }\r\n        // Set connection status\r\n        this.at(i).connected = true;\r\n      }\r\n\r\n      // Only supported in Chrome\r\n      if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {\r\n        continue;\r\n      }\r\n\r\n      this._gamePadTimeStamps[i] = gamepads[i].timestamp;\r\n\r\n      // Add reference to navigator gamepad\r\n      this.at(i).navigatorGamepad = gamepads[i];\r\n\r\n      // Buttons\r\n      let b: string, bi: number, a: string, ai: number, value: number;\r\n\r\n      for (b in Buttons) {\r\n        bi = <any>Buttons[b];\r\n        if (typeof bi === 'number') {\r\n          if (gamepads[i].buttons[bi]) {\r\n            value = gamepads[i].buttons[bi].value;\r\n            if (value !== this._oldPads[i].getButton(bi)) {\r\n              if (gamepads[i].buttons[bi].pressed) {\r\n                this.at(i).updateButton(bi, value);\r\n                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));\r\n              } else {\r\n                this.at(i).updateButton(bi, 0);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Axes\r\n      for (a in Axes) {\r\n        ai = <any>Axes[a];\r\n        if (typeof ai === 'number') {\r\n          value = gamepads[i].axes[ai];\r\n          if (value !== this._oldPads[i].getAxes(ai)) {\r\n            this.at(i).updateAxes(ai, value);\r\n            this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));\r\n          }\r\n        }\r\n      }\r\n\r\n      this._oldPads[i] = this._clonePad(gamepads[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist\r\n   */\r\n  public at(index: number): Gamepad {\r\n    this._enableAndUpdate(); // implicitly enable gamepads when at() is called\r\n    if (index >= this._pads.length) {\r\n      // Ensure there is a pad to retrieve\r\n      for (let i = this._pads.length - 1, max = index; i < max; i++) {\r\n        this._pads.push(new Gamepad());\r\n        this._oldPads.push(new Gamepad());\r\n      }\r\n    }\r\n\r\n    return this._pads[index];\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n   */\r\n  public getValidGamepads(): Gamepad[] {\r\n    this._enableAndUpdate();\r\n    const result: Gamepad[] = [];\r\n    for (let i = 0; i < this._pads.length; i++) {\r\n      if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {\r\n        result.push(this.at(i));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of connected gamepads\r\n   */\r\n  public count() {\r\n    return this._pads.filter((p) => p.connected).length;\r\n  }\r\n\r\n  private _clonePads(pads: NavigatorGamepad[]): Gamepad[] {\r\n    const arr = [];\r\n    for (let i = 0, len = pads.length; i < len; i++) {\r\n      arr.push(this._clonePad(pads[i]));\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Fastest way to clone a known object is to do it yourself\r\n   */\r\n  private _clonePad(pad: NavigatorGamepad): Gamepad {\r\n    let i, len;\r\n    const clonedPad = new Gamepad();\r\n\r\n    if (!pad) {\r\n      return clonedPad;\r\n    }\r\n\r\n    for (i = 0, len = pad.buttons.length; i < len; i++) {\r\n      if (pad.buttons[i]) {\r\n        clonedPad.updateButton(i, pad.buttons[i].value);\r\n      }\r\n    }\r\n    for (i = 0, len = pad.axes.length; i < len; i++) {\r\n      clonedPad.updateAxes(i, pad.axes[i]);\r\n    }\r\n\r\n    return clonedPad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n * for more information on handling controller input.\r\n */\r\nexport class Gamepad extends Class {\r\n  public connected = false;\r\n  public navigatorGamepad: NavigatorGamepad;\r\n  private _buttons: number[] = new Array(16);\r\n  private _axes: number[] = new Array(4);\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    for (let i = 0; i < this._buttons.length; i++) {\r\n      this._buttons[i] = 0;\r\n    }\r\n    for (let i = 0; i < this._axes.length; i++) {\r\n      this._axes[i] = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given button is pressed\r\n   * @param button     The button to query\r\n   * @param threshold  The threshold over which the button is considered to be pressed\r\n   */\r\n  public isButtonPressed(button: Buttons, threshold: number = 1) {\r\n    return this._buttons[button] >= threshold;\r\n  }\r\n\r\n  /**\r\n   * Gets the given button value between 0 and 1\r\n   */\r\n  public getButton(button: Buttons) {\r\n    return this._buttons[button];\r\n  }\r\n\r\n  /**\r\n   * Gets the given axis value between -1 and 1. Values below\r\n   * [[MinAxisMoveThreshold]] are considered 0.\r\n   */\r\n  public getAxes(axes: Axes) {\r\n    const value = this._axes[axes];\r\n\r\n    if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {\r\n      return 0;\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  public updateButton(buttonIndex: number, value: number) {\r\n    this._buttons[buttonIndex] = value;\r\n  }\r\n\r\n  public updateAxes(axesIndex: number, value: number) {\r\n    this._axes[axesIndex] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad Buttons enumeration\r\n */\r\nexport enum Buttons {\r\n  /**\r\n   * Face 1 button (e.g. A)\r\n   */\r\n  Face1 = 0,\r\n  /**\r\n   * Face 2 button (e.g. B)\r\n   */\r\n  Face2 = 1,\r\n  /**\r\n   * Face 3 button (e.g. X)\r\n   */\r\n  Face3 = 2,\r\n  /**\r\n   * Face 4 button (e.g. Y)\r\n   */\r\n  Face4 = 3,\r\n  /**\r\n   * Left bumper button\r\n   */\r\n  LeftBumper = 4,\r\n  /**\r\n   * Right bumper button\r\n   */\r\n  RightBumper = 5,\r\n  /**\r\n   * Left trigger button\r\n   */\r\n  LeftTrigger = 6,\r\n  /**\r\n   * Right trigger button\r\n   */\r\n  RightTrigger = 7,\r\n  /**\r\n   * Select button\r\n   */\r\n  Select = 8,\r\n  /**\r\n   * Start button\r\n   */\r\n  Start = 9,\r\n  /**\r\n   * Left analog stick press (e.g. L3)\r\n   */\r\n  LeftStick = 10,\r\n  /**\r\n   * Right analog stick press (e.g. R3)\r\n   */\r\n  RightStick = 11,\r\n  /**\r\n   * D-pad up\r\n   */\r\n  DpadUp = 12,\r\n  /**\r\n   * D-pad down\r\n   */\r\n  DpadDown = 13,\r\n  /**\r\n   * D-pad left\r\n   */\r\n  DpadLeft = 14,\r\n  /**\r\n   * D-pad right\r\n   */\r\n  DpadRight = 15\r\n}\r\n\r\n/**\r\n * Gamepad Axes enumeration\r\n */\r\nexport enum Axes {\r\n  /**\r\n   * Left analogue stick X direction\r\n   */\r\n  LeftStickX = 0,\r\n  /**\r\n   * Left analogue stick Y direction\r\n   */\r\n  LeftStickY = 1,\r\n  /**\r\n   * Right analogue stick X direction\r\n   */\r\n  RightStickX = 2,\r\n  /**\r\n   * Right analogue stick Y direction\r\n   */\r\n  RightStickY = 3\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepads {\r\n  getGamepads(): NavigatorGamepad[];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepad {\r\n  axes: number[];\r\n  buttons: NavigatorGamepadButton[];\r\n  connected: boolean;\r\n  id: string;\r\n  index: number;\r\n  mapping: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadButton {\r\n  pressed: boolean;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadEvent {\r\n  gamepad: NavigatorGamepad;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface GamepadConfiguration {\r\n  axis: number;\r\n  buttons: number;\r\n}\r\n","export interface NativeEventable {\r\n  addEventListener(name: string, handler: (...any: any[]) => any): any;\r\n  removeEventListener(name: string, handler: (...any: any[]) => any): any;\r\n}\r\n\r\nexport class BrowserComponent<T extends NativeEventable> {\r\n  private _paused = false;\r\n  private _nativeHandlers: { [key: string]: (handler: any) => void } = {};\r\n\r\n  on(eventName: string, handler: (evt: any) => void): void {\r\n    if (this._nativeHandlers[eventName]) {\r\n      this.off(eventName, this._nativeHandlers[eventName]);\r\n    }\r\n    this._nativeHandlers[eventName] = this._decorate(handler);\r\n    this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);\r\n  }\r\n  off(eventName: string, handler?: (event: any) => void): void {\r\n    if (!handler) {\r\n      handler = this._nativeHandlers[eventName];\r\n    }\r\n    this.nativeComponent.removeEventListener(eventName, handler);\r\n    this._nativeHandlers[eventName] = null;\r\n  }\r\n\r\n  private _decorate(handler: (evt: any) => void): (evt: any) => void {\r\n    return (evt: any) => {\r\n      if (!this._paused) {\r\n        handler(evt);\r\n      }\r\n    };\r\n  }\r\n\r\n  public pause() {\r\n    this._paused = true;\r\n  }\r\n\r\n  public resume() {\r\n    this._paused = false;\r\n  }\r\n\r\n  public clear() {\r\n    for (const event in this._nativeHandlers) {\r\n      this.off(event);\r\n    }\r\n  }\r\n\r\n  constructor(public nativeComponent: T) {}\r\n}\r\n\r\nexport class BrowserEvents {\r\n  private _windowComponent: BrowserComponent<Window>;\r\n  private _documentComponent: BrowserComponent<Document>;\r\n  constructor(private _windowGlobal: Window, private _documentGlobal: Document) {\r\n    this._windowComponent = new BrowserComponent(this._windowGlobal);\r\n    this._documentComponent = new BrowserComponent(this._documentGlobal);\r\n  }\r\n\r\n  public get window(): BrowserComponent<Window> {\r\n    return this._windowComponent;\r\n  }\r\n\r\n  public get document(): BrowserComponent<Document> {\r\n    return this._documentComponent;\r\n  }\r\n\r\n  public pause() {\r\n    this.window.pause();\r\n    this.document.pause();\r\n  }\r\n\r\n  public resume() {\r\n    this.window.resume();\r\n    this.document.resume();\r\n  }\r\n\r\n  public clear() {\r\n    this.window.clear();\r\n    this.document.clear();\r\n  }\r\n}\r\n","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { GraphicsDiagnostics } from '../GraphicsDiagnostics';\r\nimport { DebugText } from './debug-text';\r\n\r\nclass ExcaliburGraphicsContext2DCanvasDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _ex: ExcaliburGraphicsContext2DCanvas) {}\r\n  /**\r\n   * Draw a debug rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.strokeStyle = 'red';\r\n    this._ex.__ctx.strokeRect(\r\n      this._ex.snapToPixel ? ~~x : x,\r\n      this._ex.snapToPixel ? ~~y : y,\r\n      this._ex.snapToPixel ? ~~width : width,\r\n      this._ex.snapToPixel ? ~~height : height\r\n    );\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.strokeStyle = lineOptions.color.toString();\r\n    this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~start.x : start.x, this._ex.snapToPixel ? ~~start.y : start.y);\r\n    this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~end.x : end.x, this._ex.snapToPixel ? ~~end.y : end.y);\r\n    this._ex.__ctx.lineWidth = 2;\r\n    this._ex.__ctx.stroke();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.fillStyle = pointOptions.color.toString();\r\n    this._ex.__ctx.arc(\r\n      this._ex.snapToPixel ? ~~point.x : point.x,\r\n      this._ex.snapToPixel ? ~~point.y : point.y,\r\n      pointOptions.size,\r\n      0,\r\n      Math.PI * 2\r\n    );\r\n    this._ex.__ctx.fill();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._ex, text, pos);\r\n  }\r\n}\r\n\r\nexport class ExcaliburGraphicsContext2DCanvas implements ExcaliburGraphicsContext {\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __ctx: CanvasRenderingContext2D;\r\n  public get width() {\r\n    return this.__ctx.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__ctx.canvas.height;\r\n  }\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  private _state = new StateStack();\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public snapToPixel: boolean = true;\r\n\r\n  public get smoothing(): boolean {\r\n    return this.__ctx.imageSmoothingEnabled;\r\n  }\r\n\r\n  public set smoothing(value: boolean) {\r\n    this.__ctx.imageSmoothingEnabled = value;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;\r\n    this.__ctx = canvasElement.getContext('2d', {\r\n      alpha: enableTransparency ?? true\r\n    });\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this.__ctx.resetTransform();\r\n  }\r\n\r\n  public updateViewport(): void {\r\n    // pass\r\n  }\r\n\r\n  /**\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate using the images width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate with a specific width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context specifying the source image coordinates (sx, sy, swidth, sheight)\r\n   * and to a specific destination on the context (dx, dy, dwidth, dheight)\r\n   */\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    this.__ctx.globalAlpha = this.opacity;\r\n    const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]\r\n      .filter((a) => a !== undefined)\r\n      .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));\r\n    this.__ctx.drawImage.apply(this.__ctx, args);\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n    GraphicsDiagnostics.DrawnImagesCount = 1;\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    this.__ctx.strokeStyle = color.toString();\r\n    this.__ctx.moveTo(this.snapToPixel ? ~~start.x : start.x, this.snapToPixel ? ~~start.y : start.y);\r\n    this.__ctx.lineTo(this.snapToPixel ? ~~end.x : end.x, this.snapToPixel ? ~~end.y : end.y);\r\n    this.__ctx.lineWidth = thickness;\r\n    this.__ctx.stroke();\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color) {\r\n    this.__ctx.save();\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.fillRect(\r\n      this.snapToPixel ? ~~pos.x : pos.x,\r\n      this.snapToPixel ? ~~pos.y : pos.y,\r\n      this.snapToPixel ? ~~width : width,\r\n      this.snapToPixel ? ~~height : height\r\n    );\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.arc(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, radius, 0, Math.PI * 2);\r\n    this.__ctx.fill();\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContext2DCanvasDebug(this);\r\n\r\n  /**\r\n   * Save the current state of the canvas to the stack (transforms and opacity)\r\n   */\r\n  save(): void {\r\n    this.__ctx.save();\r\n  }\r\n\r\n  /**\r\n   * Restore the state of the canvas from the stack\r\n   */\r\n  restore(): void {\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Translate the origin of the context by an x and y\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number): void {\r\n    this.__ctx.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);\r\n  }\r\n\r\n  /**\r\n   * Rotate the context about the current origin\r\n   */\r\n  rotate(angle: number): void {\r\n    this.__ctx.rotate(angle);\r\n  }\r\n\r\n  /**\r\n   * Scale the context by an x and y factor\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number): void {\r\n    this.__ctx.scale(x, y);\r\n  }\r\n\r\n  clear(): void {\r\n    // Clear frame\r\n    this.__ctx.clearRect(0, 0, this.width, this.height);\r\n    this.__ctx.fillStyle = this.backgroundColor.toString();\r\n    this.__ctx.fillRect(0, 0, this.width, this.height);\r\n    GraphicsDiagnostics.clear();\r\n  }\r\n\r\n  /**\r\n   * Flushes the batched draw calls to the screen\r\n   */\r\n  flush(): void {\r\n    // pass\r\n  }\r\n}\r\n","import { EX_VERSION } from './';\r\nimport { Flags, Legacy } from './Flags';\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\nimport { CanUpdate, CanDraw, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Vector } from './Math/vector';\r\nimport { Screen, DisplayMode, AbsolutePosition, ScreenDimension, Resolution } from './Screen';\r\nimport { ScreenElement } from './ScreenElement';\r\nimport { Actor } from './Actor';\r\nimport { Timer } from './Timer';\r\nimport { TileMap } from './TileMap';\r\nimport { Animation } from './Drawing/Animation';\r\nimport { Loader } from './Loader';\r\nimport { Detector } from './Util/Detector';\r\nimport {\r\n  VisibleEvent,\r\n  HiddenEvent,\r\n  GameStartEvent,\r\n  GameStopEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreFrameEvent,\r\n  PostFrameEvent,\r\n  GameEvent,\r\n  DeactivateEvent,\r\n  ActivateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  InitializeEvent\r\n} from './Events';\r\nimport { Logger, LogLevel } from './Util/Log';\r\nimport { Color } from './Color';\r\nimport { Scene } from './Scene';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { PostProcessor } from './PostProcessing/PostProcessor';\r\nimport { Debug, DebugStats } from './Debug/Debug';\r\nimport { Class } from './Class';\r\nimport * as Input from './Input/Index';\r\nimport * as Events from './Events';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { obsolete } from './Util/Decorators';\r\nimport { ExcaliburGraphicsContext, ExcaliburGraphicsContext2DCanvas, ExcaliburGraphicsContextWebGL } from './Graphics';\r\n\r\n/**\r\n * Enum representing the different mousewheel event bubble prevention\r\n */\r\nexport enum ScrollPreventionMode {\r\n  /**\r\n   * Do not prevent any page scrolling\r\n   */\r\n  None,\r\n  /**\r\n   * Prevent page scroll if mouse is over the game canvas\r\n   */\r\n  Canvas,\r\n  /**\r\n   * Prevent all page scrolling via mouse wheel\r\n   */\r\n  All\r\n}\r\n\r\n/**\r\n * Defines the available options to configure the Excalibur engine at constructor time.\r\n */\r\nexport interface EngineOptions {\r\n  /**\r\n   * Optionally configure the width of the viewport in css pixels\r\n   */\r\n  width?: number;\r\n\r\n  /**\r\n   * Optionally configure the height of the viewport in css pixels\r\n   */\r\n  height?: number;\r\n\r\n  /**\r\n   * Optionally configure the width & height of the viewport in css pixels.\r\n   * Use `viewport` instead of [[EngineOptions.width]] and [[EngineOptions.height]], or vice versa.\r\n   */\r\n  viewport?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify the size the logical pixel resolution, if not specified it will be width x height.\r\n   * See [[Resolution]] for common presets.\r\n   */\r\n  resolution?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify antialiasing (smoothing), by default true (smooth pixels)\r\n   */\r\n  antialiasing?: boolean;\r\n\r\n  /**\r\n   * Optionally configure the native canvas transparent backdrop\r\n   */\r\n  enableCanvasTransparency?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element to render the game in\r\n   */\r\n  canvasElementId?: string;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element directly\r\n   */\r\n  canvasElement?: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Optionally snap drawings to nearest pixel\r\n   */\r\n  snapToPixel?: boolean;\r\n\r\n  /**\r\n   * The [[DisplayMode]] of the game, by default [[DisplayMode.FitScreen]] with aspect ratio 4:3 (800x600).\r\n   * Depending on this value, [[width]] and [[height]] may be ignored.\r\n   */\r\n  displayMode?: DisplayMode;\r\n\r\n  /**\r\n   * Configures the pointer scope. Pointers scoped to the 'Canvas' can only fire events within the canvas viewport; whereas, 'Document'\r\n   * (default) scoped will fire anywhere on the page.\r\n   */\r\n  pointerScope?: Input.PointerScope;\r\n\r\n  /**\r\n   * Suppress boot up console message, which contains the \"powered by Excalibur message\"\r\n   */\r\n  suppressConsoleBootMessage?: boolean;\r\n\r\n  /**\r\n   * Suppress minimum browser feature detection, it is not recommended users of excalibur switch this off. This feature ensures that\r\n   * the currently running browser meets the minimum requirements for running excalibur. This can be useful if running on non-standard\r\n   * browsers or if there is a bug in excalibur preventing execution.\r\n   */\r\n  suppressMinimumBrowserFeatureDetection?: boolean;\r\n\r\n  /**\r\n   * Suppress HiDPI auto detection and scaling, it is not recommended users of excalibur switch off this feature. This feature detects\r\n   * and scales the drawing canvas appropriately to accommodate HiDPI screens.\r\n   */\r\n  suppressHiDPIScaling?: boolean;\r\n\r\n  /**\r\n   * Suppress play button, it is not recommended users of excalibur switch this feature. Some browsers require a user gesture (like a click)\r\n   * for certain browser features to work like web audio.\r\n   */\r\n  suppressPlayButton?: boolean;\r\n\r\n  /**\r\n   * Specify how the game window is to be positioned when the [[DisplayMode.Position]] is chosen. This option MUST be specified\r\n   * if the DisplayMode is set as [[DisplayMode.Position]]. The position can be either a string or an [[AbsolutePosition]].\r\n   * String must be in the format of css style background-position. The vertical position must precede the horizontal position in strings.\r\n   *\r\n   * Valid String examples: \"top left\", \"top\", \"bottom\", \"middle\", \"middle center\", \"bottom right\"\r\n   * Valid [[AbsolutePosition]] examples: `{top: 5, right: 10%}`, `{bottom: 49em, left: 10px}`, `{left: 10, bottom: 40}`\r\n   */\r\n  position?: string | AbsolutePosition;\r\n\r\n  /**\r\n   * Scroll prevention method.\r\n   */\r\n  scrollPreventionMode?: ScrollPreventionMode;\r\n\r\n  /**\r\n   * Optionally set the background color\r\n   */\r\n  backgroundColor?: Color;\r\n}\r\n\r\n/**\r\n * The Excalibur Engine\r\n *\r\n * The [[Engine]] is the main driver for a game. It is responsible for\r\n * starting/stopping the game, maintaining state, transmitting events,\r\n * loading resources, and managing the scene.\r\n */\r\nexport class Engine extends Class implements CanInitialize, CanUpdate, CanDraw {\r\n  /**\r\n   *\r\n   */\r\n  public browser: BrowserEvents;\r\n\r\n  /**\r\n   * Screen abstraction\r\n   */\r\n  public screen: Screen;\r\n\r\n  /**\r\n   * Direct access to the engine's canvas element\r\n   */\r\n  public canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Direct access to the engine's 2D rendering context\r\n   */\r\n  public ctx: CanvasRenderingContext2D;\r\n\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Direct access to the canvas element ID, if an ID exists\r\n   */\r\n  public canvasElementId: string;\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.screen.canvasWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.screen.halfCanvasWidth;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.screen.canvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.screen.halfCanvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    return this.screen.drawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.screen.halfDrawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    return this.screen.drawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.screen.halfDrawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns whether excalibur detects the current screen to be HiDPI\r\n   */\r\n  public get isHiDpi(): boolean {\r\n    return this.screen.isHiDpi;\r\n  }\r\n\r\n  /**\r\n   * Access engine input like pointer, keyboard, or gamepad\r\n   */\r\n  public input: Input.EngineInput;\r\n\r\n  private _hasStarted: boolean = false;\r\n\r\n  /**\r\n   * Access Excalibur debugging functionality.\r\n   */\r\n  public debug: Debug;\r\n\r\n  /**\r\n   * Access [[stats]] that holds frame statistics.\r\n   */\r\n  public get stats(): DebugStats {\r\n    return this.debug.stats;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])\r\n   */\r\n  public postProcessors: PostProcessor[] = [];\r\n\r\n  /**\r\n   * The current [[Scene]] being drawn and updated on screen\r\n   */\r\n  public currentScene: Scene;\r\n\r\n  /**\r\n   * The default [[Scene]] of the game, use [[Engine.goToScene]] to transition to different scenes.\r\n   */\r\n  public readonly rootScene: Scene;\r\n\r\n  /**\r\n   * Contains all the scenes currently registered with Excalibur\r\n   */\r\n  public readonly scenes: { [key: string]: Scene } = {};\r\n\r\n  /**\r\n   * @hidden\r\n   * @deprecated\r\n   */\r\n  private _animations: AnimationNode[] = [];\r\n\r\n  /**\r\n   * Indicates whether the engine is set to fullscreen or not\r\n   */\r\n  public get isFullscreen(): boolean {\r\n    return this.screen.isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Indicates the current [[DisplayMode]] of the engine.\r\n   */\r\n  public get displayMode(): DisplayMode {\r\n    return this.screen.displayMode;\r\n  }\r\n\r\n  private _suppressPlayButton: boolean = false;\r\n  /**\r\n   * Returns the calculated pixel ration for use in rendering\r\n   */\r\n  public get pixelRatio(): number {\r\n    return this.screen.pixelRatio;\r\n  }\r\n\r\n  /**\r\n   * Indicates the current position of the engine. Valid only when DisplayMode is DisplayMode.Position\r\n   */\r\n  public position: string | AbsolutePosition;\r\n  /**\r\n   * Indicates whether audio should be paused when the game is no longer visible.\r\n   */\r\n  public pauseAudioWhenHidden: boolean = true;\r\n\r\n  /**\r\n   * Indicates whether the engine should draw with debug information\r\n   */\r\n  private _isDebug: boolean = false;\r\n  public get isDebug(): boolean {\r\n    return this._isDebug;\r\n  }\r\n  public debugColor: Color = new Color(255, 255, 255);\r\n  /**\r\n   * Sets the background color for the engine.\r\n   */\r\n  public backgroundColor: Color;\r\n\r\n  /**\r\n   * Sets the Transparency for the engine.\r\n   */\r\n  public enableCanvasTransparency: boolean = true;\r\n\r\n  /**\r\n   * The action to take when a fatal exception is thrown\r\n   */\r\n  public onFatalException = (e: any) => {\r\n    Logger.getInstance().fatal(e);\r\n  };\r\n\r\n  /**\r\n   * The mouse wheel scroll prevention mode\r\n   */\r\n  public pageScrollPreventionMode: ScrollPreventionMode;\r\n\r\n  private _logger: Logger;\r\n\r\n  // this is a reference to the current requestAnimationFrame return value\r\n  private _requestId: number;\r\n\r\n  // this determines whether excalibur is compatible with your browser\r\n  private _compatible: boolean;\r\n\r\n  private _timescale: number = 1.0;\r\n\r\n  // loading\r\n  private _loader: Loader;\r\n  private _isLoading: boolean = false;\r\n\r\n  private _isInitialized: boolean = false;\r\n\r\n  private _deferredGoTo: string = null;\r\n\r\n  public on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public on(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public on(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public on(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public on(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public on(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public once(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public once(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public once(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public once(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public once(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public off(eventName: Events.visible, handler?: (event: VisibleEvent) => void): void;\r\n  public off(eventName: Events.hidden, handler?: (event: HiddenEvent) => void): void;\r\n  public off(eventName: Events.start, handler?: (event: GameStartEvent) => void): void;\r\n  public off(eventName: Events.stop, handler?: (event: GameStopEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.preframe, handler?: (event: PreFrameEvent) => void): void;\r\n  public off(eventName: Events.postframe, handler?: (event: PostFrameEvent) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Default [[EngineOptions]]\r\n   */\r\n  private static _DEFAULT_ENGINE_OPTIONS: EngineOptions = {\r\n    width: 0,\r\n    height: 0,\r\n    enableCanvasTransparency: true,\r\n    canvasElementId: '',\r\n    canvasElement: undefined,\r\n    snapToPixel: false,\r\n    pointerScope: Input.PointerScope.Canvas,\r\n    suppressConsoleBootMessage: null,\r\n    suppressMinimumBrowserFeatureDetection: null,\r\n    suppressHiDPIScaling: null,\r\n    suppressPlayButton: null,\r\n    scrollPreventionMode: ScrollPreventionMode.Canvas,\r\n    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue\r\n  };\r\n\r\n  /**\r\n   * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,\r\n   * the game will be rendered full screen (taking up all available browser window space).\r\n   * You can customize the game rendering through [[EngineOptions]].\r\n   *\r\n   * Example:\r\n   *\r\n   * ```js\r\n   * var game = new ex.Engine({\r\n   *   width: 0, // the width of the canvas\r\n   *   height: 0, // the height of the canvas\r\n   *   enableCanvasTransparency: true, // the transparencySection of the canvas\r\n   *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own\r\n   *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n   *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n   *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine\r\n   * });\r\n   *\r\n   * // call game.start, which is a Promise\r\n   * game.start().then(function () {\r\n   *   // ready, set, go!\r\n   * });\r\n   * ```\r\n   */\r\n  constructor(options?: EngineOptions) {\r\n    super();\r\n\r\n    options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };\r\n\r\n    Flags.freeze();\r\n\r\n    // Initialize browser events facade\r\n    this.browser = new BrowserEvents(window, document);\r\n\r\n    // Check compatibility\r\n    const detector = new Detector();\r\n    if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {\r\n      const message = document.createElement('div');\r\n      message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';\r\n      document.body.appendChild(message);\r\n\r\n      detector.failedTests.forEach(function (test) {\r\n        const testMessage = document.createElement('div');\r\n        testMessage.innerText = 'Browser feature missing ' + test;\r\n        document.body.appendChild(testMessage);\r\n      });\r\n\r\n      if (options.canvasElementId) {\r\n        const canvas = document.getElementById(options.canvasElementId);\r\n        if (canvas) {\r\n          canvas.parentElement.removeChild(canvas);\r\n        }\r\n      }\r\n\r\n      return;\r\n    } else {\r\n      this._compatible = true;\r\n    }\r\n\r\n    // Use native console API for color fun\r\n    // eslint-disable-next-line no-console\r\n    if (console.log && !options.suppressConsoleBootMessage) {\r\n      // eslint-disable-next-line no-console\r\n      console.log(\r\n        `%cPowered by Excalibur.js (v${EX_VERSION})`,\r\n        'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;'\r\n      );\r\n      // eslint-disable-next-line no-console\r\n      console.log('\\n\\\r\n      /| ________________\\n\\\r\nO|===|* >________________>\\n\\\r\n      \\\\|');\r\n      // eslint-disable-next-line no-console\r\n      console.log('Visit', 'http://excaliburjs.com', 'for more information');\r\n    }\r\n\r\n    // Suppress play button\r\n    if (options.suppressPlayButton) {\r\n      this._suppressPlayButton = true;\r\n    }\r\n\r\n    this._logger = Logger.getInstance();\r\n\r\n    // If debug is enabled, let's log browser features to the console.\r\n    if (this._logger.defaultLevel === LogLevel.Debug) {\r\n      detector.logBrowserFeatures();\r\n    }\r\n\r\n    this._logger.debug('Building engine...');\r\n\r\n    this.canvasElementId = options.canvasElementId;\r\n\r\n    if (options.canvasElementId) {\r\n      this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);\r\n      this.canvas = <HTMLCanvasElement>document.getElementById(options.canvasElementId);\r\n    } else if (options.canvasElement) {\r\n      this._logger.debug('Using Canvas element specified:', options.canvasElement);\r\n      this.canvas = options.canvasElement;\r\n    } else {\r\n      this._logger.debug('Using generated canvas element');\r\n      this.canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    }\r\n\r\n    let displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    if ((options.width && options.height) || options.viewport) {\r\n      if (options.displayMode === undefined) {\r\n        displayMode = DisplayMode.Fixed;\r\n      }\r\n      this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);\r\n    } else if (!options.displayMode) {\r\n      this._logger.debug('Engine viewport is fit');\r\n      displayMode = DisplayMode.FitScreen;\r\n    }\r\n\r\n    if (Flags.isEnabled(Legacy.Canvas)) {\r\n      const ex2dCtx = new ExcaliburGraphicsContext2DCanvas({\r\n        canvasElement: this.canvas,\r\n        enableTransparency: this.enableCanvasTransparency,\r\n        smoothing: options.antialiasing,\r\n        backgroundColor: options.backgroundColor,\r\n        snapToPixel: options.snapToPixel\r\n      });\r\n      this.graphicsContext = ex2dCtx;\r\n      this.ctx = ex2dCtx.__ctx;\r\n    } else {\r\n      const exWebglCtx = new ExcaliburGraphicsContextWebGL({\r\n        canvasElement: this.canvas,\r\n        enableTransparency: this.enableCanvasTransparency,\r\n        smoothing: options.antialiasing,\r\n        backgroundColor: options.backgroundColor,\r\n        snapToPixel: options.snapToPixel\r\n      });\r\n      this.graphicsContext = exWebglCtx;\r\n      this.ctx = exWebglCtx.__ctx;\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      position: options.position,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : null\r\n    });\r\n\r\n    if (options.backgroundColor) {\r\n      this.backgroundColor = options.backgroundColor.clone();\r\n    }\r\n\r\n    this.enableCanvasTransparency = options.enableCanvasTransparency;\r\n\r\n    this._loader = new Loader();\r\n    this.debug = new Debug(this);\r\n\r\n    this._initialize(options);\r\n\r\n    this.rootScene = this.currentScene = new Scene();\r\n\r\n    this.addScene('root', this.rootScene);\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   */\r\n  public getWorldBounds() {\r\n    return this.screen.getWorldBounds();\r\n  }\r\n\r\n  /**\r\n   * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n   */\r\n  public get timescale() {\r\n    return this._timescale;\r\n  }\r\n\r\n  /**\r\n   * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n   * when using time-based movement.\r\n   */\r\n  public set timescale(value: number) {\r\n    if (value <= 0) {\r\n      Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');\r\n      return;\r\n    }\r\n\r\n    this._timescale = value;\r\n  }\r\n\r\n  /**\r\n   * Plays a sprite animation on the screen at the specified `x` and `y`\r\n   * (in game coordinates, not screen pixels). These animations play\r\n   * independent of actors, and will be cleaned up internally as soon\r\n   * as they are complete. Note animations that loop will never be\r\n   * cleaned up.\r\n   *\r\n   * @param animation  Animation to play\r\n   * @param x          x game coordinate to play the animation\r\n   * @param y          y game coordinate to play the animation\r\n   * @deprecated\r\n   */\r\n  @obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Actor.graphics' })\r\n  public playAnimation(animation: Animation, x: number, y: number) {\r\n    this._animations.push(new AnimationNode(animation, x, y));\r\n  }\r\n\r\n  /**\r\n   * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap\r\n   * will be drawn and updated.\r\n   */\r\n  public addTileMap(tileMap: TileMap) {\r\n    this.currentScene.addTileMap(tileMap);\r\n  }\r\n\r\n  /**\r\n   * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.\r\n   */\r\n  public removeTileMap(tileMap: TileMap) {\r\n    this.currentScene.removeTileMap(tileMap);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    return this.currentScene.addTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    return this.currentScene.removeTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   *\r\n   * @param key  The name of the scene, must be unique\r\n   * @param scene The scene to add to the engine\r\n   */\r\n  public addScene(key: string, scene: Scene) {\r\n    if (this.scenes[key]) {\r\n      this._logger.warn('Scene', key, 'already exists overwriting');\r\n    }\r\n    this.scenes[key] = scene;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Scene]] instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public removeScene(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param key  The scene key to remove\r\n   */\r\n  public removeScene(key: string): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  public removeScene(entity: any): void {\r\n    if (entity instanceof Scene) {\r\n      // remove scene\r\n      for (const key in this.scenes) {\r\n        if (this.scenes.hasOwnProperty(key)) {\r\n          if (this.scenes[key] === entity) {\r\n            delete this.scenes[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      // remove scene\r\n      delete this.scenes[entity];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   * @param sceneKey  The key of the scene, must be unique\r\n   * @param scene     The scene to add to the engine\r\n   */\r\n  public add(sceneKey: string, scene: Scene): void;\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n  /**\r\n   * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap\r\n   * will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n  /**\r\n   * Adds an actor to the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.add(actor)`.\r\n   *\r\n   * Actors can only be drawn if they are a member of a scene, and only\r\n   * the [[currentScene]] may be drawn or updated.\r\n   *\r\n   * @param actor  The actor to add to the [[currentScene]]\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the [[currentScene]] of the game,\r\n   * ScreenElements do not participate in collisions, instead the\r\n   * remain in the same place on the screen.\r\n   * @param screenElement  The ScreenElement to add to the [[currentScene]]\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    if (arguments.length === 2) {\r\n      this.addScene(<string>arguments[0], <Scene>arguments[1]);\r\n      return;\r\n    }\r\n    if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {\r\n      this.scenes[this._deferredGoTo].add(entity);\r\n    } else {\r\n      this.currentScene.add(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a scene instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public remove(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param sceneKey  The scene to remove\r\n   */\r\n  public remove(sceneKey: string): void;\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public remove(timer: Timer): void;\r\n  /**\r\n   * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n  /**\r\n   * Removes an actor from the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.removeChild(actor)`.\r\n   * Actors that are removed from a scene will no longer be drawn or updated.\r\n   *\r\n   * @param actor  The actor to remove from the [[currentScene]].\r\n   */\r\n  public remove(actor: Actor): void;\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the [[currentScene]]\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.currentScene.remove(entity);\r\n    }\r\n\r\n    if (entity instanceof Scene) {\r\n      this.removeScene(entity);\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      this.removeScene(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Changes the currently updating and drawing scene to a different,\r\n   * named scene. Calls the [[Scene]] lifecycle events.\r\n   * @param key  The key of the scene to transition to.\r\n   */\r\n  public goToScene(key: string): void {\r\n    // if not yet initialized defer goToScene\r\n    if (!this.isInitialized) {\r\n      this._deferredGoTo = key;\r\n      return;\r\n    }\r\n\r\n    if (this.scenes[key]) {\r\n      const oldScene = this.currentScene;\r\n      const newScene = this.scenes[key];\r\n\r\n      this._logger.debug('Going to scene:', key);\r\n\r\n      // only deactivate when initialized\r\n      if (this.currentScene.isInitialized) {\r\n        this.currentScene._deactivate.apply(this.currentScene, [oldScene, newScene]);\r\n        this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(newScene, this.currentScene));\r\n      }\r\n\r\n      // set current scene to new one\r\n      this.currentScene = newScene;\r\n      this.screen.setCurrentCamera(newScene.camera);\r\n\r\n      // initialize the current scene if has not been already\r\n      this.currentScene._initialize(this);\r\n\r\n      this.currentScene._activate.apply(this.currentScene, [oldScene, newScene]);\r\n      this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(oldScene, this.currentScene));\r\n    } else {\r\n      this._logger.error('Scene', key, 'does not exist!');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms the current x, y from screen coordinates to world coordinates\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    return this.screen.screenToWorldCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Transforms a world coordinate, to a screen coordinate\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    return this.screen.worldToScreenCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Initializes the internal canvas, rendering context, display mode, and native event listeners\r\n   */\r\n  private _initialize(options?: EngineOptions) {\r\n    this.pageScrollPreventionMode = options.scrollPreventionMode;\r\n\r\n    // initialize inputs\r\n    this.input = {\r\n      keyboard: new Input.Keyboard(),\r\n      pointers: new Input.Pointers(this),\r\n      gamepads: new Input.Gamepads()\r\n    };\r\n    this.input.keyboard.init();\r\n    this.input.pointers.init(options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas);\r\n    this.input.gamepads.init();\r\n\r\n    // Issue #385 make use of the visibility api\r\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\r\n\r\n    let hidden: keyof HTMLDocument, visibilityChange: string;\r\n    if (typeof document.hidden !== 'undefined') {\r\n      // Opera 12.10 and Firefox 18 and later support\r\n      hidden = 'hidden';\r\n      visibilityChange = 'visibilitychange';\r\n    } else if ('msHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'msHidden';\r\n      visibilityChange = 'msvisibilitychange';\r\n    } else if ('webkitHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'webkitHidden';\r\n      visibilityChange = 'webkitvisibilitychange';\r\n    }\r\n\r\n    this.browser.document.on(visibilityChange, () => {\r\n      if (document[hidden]) {\r\n        this.eventDispatcher.emit('hidden', new HiddenEvent(this));\r\n        this._logger.debug('Window hidden');\r\n      } else {\r\n        this.eventDispatcher.emit('visible', new VisibleEvent(this));\r\n        this._logger.debug('Window visible');\r\n      }\r\n    });\r\n\r\n    if (!this.canvasElementId && !options.canvasElement) {\r\n      document.body.appendChild(this.canvas);\r\n    }\r\n  }\r\n\r\n  public onInitialize(_engine: Engine) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If supported by the browser, this will set the antialiasing flag on the\r\n   * canvas. Set this to `false` if you want a 'jagged' pixel art look to your\r\n   * image resources.\r\n   * @param isSmooth  Set smoothing to true or false\r\n   */\r\n  public setAntialiasing(isSmooth: boolean) {\r\n    this.screen.antialiasing = isSmooth;\r\n  }\r\n\r\n  /**\r\n   * Return the current smoothing status of the canvas\r\n   */\r\n  public getAntialiasing(): boolean {\r\n    return this.screen.antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  private _overrideInitialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n      if (this._deferredGoTo) {\r\n        this.goToScene(this._deferredGoTo);\r\n      } else {\r\n        this.goToScene('root');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the entire state of the game\r\n   * @param delta  Number of milliseconds elapsed since the last update.\r\n   */\r\n  private _update(delta: number) {\r\n    if (this._isLoading) {\r\n      // suspend updates until loading is finished\r\n      this._loader.update(this, delta);\r\n      // Update input listeners\r\n      this.input.keyboard.update();\r\n      this.input.pointers.update();\r\n      this.input.gamepads.update();\r\n      return;\r\n    }\r\n\r\n    this._overrideInitialize(this);\r\n\r\n    // Publish preupdate events\r\n    this._preupdate(delta);\r\n\r\n    // process engine level events\r\n    this.currentScene.update(this, delta);\r\n\r\n    // update animations\r\n    // TODO remove\r\n    this._animations = this._animations.filter(function (a) {\r\n      return !a.animation.isDone();\r\n    });\r\n\r\n    // Update input listeners\r\n    this.input.keyboard.update();\r\n    this.input.pointers.update();\r\n    this.input.gamepads.update();\r\n\r\n    // Publish update event\r\n    this._postupdate(delta);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _preupdate(delta: number) {\r\n    this.emit('preupdate', new PreUpdateEvent(this, delta, this));\r\n    this.onPreUpdate(this, delta);\r\n  }\r\n\r\n  public onPreUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postupdate(delta: number) {\r\n    this.emit('postupdate', new PostUpdateEvent(this, delta, this));\r\n    this.onPostUpdate(this, delta);\r\n  }\r\n\r\n  public onPostUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Draws the entire game\r\n   * @param delta  Number of milliseconds elapsed since the last draw.\r\n   */\r\n  private _draw(delta: number) {\r\n    const ctx = this.ctx;\r\n    this._predraw(ctx, delta);\r\n\r\n    if (this._isLoading) {\r\n      this._loader.canvas.draw(this.graphicsContext, 0, 0);\r\n      this.graphicsContext.flush();\r\n      // Drawing nothing else while loading\r\n      return;\r\n    }\r\n\r\n    // TODO move to graphics systems?\r\n    this.graphicsContext.backgroundColor = this.backgroundColor;\r\n\r\n    this.currentScene.draw(this.ctx, delta);\r\n\r\n    // todo needs to be a better way of doing this\r\n    let a = 0;\r\n    const len = this._animations.length;\r\n    for (a; a < len; a++) {\r\n      this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);\r\n    }\r\n\r\n    // Draw debug information\r\n    // TODO don't access ctx directly\r\n    if (this.isDebug) {\r\n      this.ctx.font = 'Consolas';\r\n      this.ctx.fillStyle = this.debugColor.toString();\r\n      const keys = this.input.keyboard.getKeys();\r\n      for (let j = 0; j < keys.length; j++) {\r\n        this.ctx.fillText(keys[j].toString() + ' : ' + (Input.Keys[keys[j]] ? Input.Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);\r\n      }\r\n\r\n      this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);\r\n    }\r\n\r\n    // Post processing\r\n    for (let i = 0; i < this.postProcessors.length; i++) {\r\n      this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);\r\n    }\r\n\r\n    this._postdraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: CanvasRenderingContext2D, delta: number) {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, delta, this));\r\n    this.onPreDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPreDraw(_ctx: CanvasRenderingContext2D, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: CanvasRenderingContext2D, delta: number) {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));\r\n    this.onPostDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPostDraw(_ctx: CanvasRenderingContext2D, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Enable or disable Excalibur debugging functionality.\r\n   * @param toggle a value that debug drawing will be changed to\r\n   */\r\n  public showDebug(toggle: boolean): void {\r\n    this._isDebug = toggle;\r\n  }\r\n\r\n  /**\r\n   * Toggle Excalibur debugging functionality.\r\n   */\r\n  public toggleDebug(): boolean {\r\n    this._isDebug = !this._isDebug;\r\n    return this._isDebug;\r\n  }\r\n\r\n  private _loadingComplete: boolean = false;\r\n  /**\r\n   * Returns true when loading is totally complete and the player has clicked start\r\n   */\r\n  public get loadingComplete() {\r\n    return this._loadingComplete;\r\n  }\r\n  /**\r\n   * Starts the internal game loop for Excalibur after loading\r\n   * any provided assets.\r\n   * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n   * custom loader.\r\n   */\r\n  public start(loader?: Loader): Promise<void> {\r\n    if (!this._compatible) {\r\n      return Promise.reject('Excalibur is incompatible with your browser');\r\n    }\r\n    let loadingComplete: Promise<void>;\r\n    // Push the current user entered resolution/viewport\r\n    this.screen.pushResolutionAndViewport();\r\n    // Configure resolution for loader\r\n    this.screen.resolution = this.screen.viewport;\r\n    this.screen.applyResolutionAndViewport();\r\n    this.graphicsContext.updateViewport();\r\n    if (loader) {\r\n      this._loader = loader;\r\n      this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;\r\n      this._loader.wireEngine(this);\r\n      loadingComplete = this.load(this._loader);\r\n    } else {\r\n      loadingComplete = Promise.resolve();\r\n    }\r\n\r\n    loadingComplete.then(() => {\r\n      this.screen.popResolutionAndViewport();\r\n      this.screen.applyResolutionAndViewport();\r\n      this.graphicsContext.updateViewport();\r\n      this.emit('start', new GameStartEvent(this));\r\n      this._loadingComplete = true;\r\n    });\r\n\r\n    if (!this._hasStarted) {\r\n      // has started is a slight misnomer, it's really mainloop started\r\n      this._hasStarted = true;\r\n      this._logger.debug('Starting game...');\r\n      this.browser.resume();\r\n      Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();\r\n      this._logger.debug('Game started');\r\n    } else {\r\n      // Game already started;\r\n    }\r\n    return loadingComplete;\r\n  }\r\n\r\n  public static createMainLoop(game: Engine, raf: (func: Function) => number, nowFn: () => number) {\r\n    let lastTime = nowFn();\r\n\r\n    return function mainloop() {\r\n      if (!game._hasStarted) {\r\n        return;\r\n      }\r\n      try {\r\n        game._requestId = raf(mainloop);\r\n        game.emit('preframe', new PreFrameEvent(game, game.stats.prevFrame));\r\n\r\n        // Get the time to calculate time-elapsed\r\n        const now = nowFn();\r\n        let elapsed = Math.floor(now - lastTime) || 1;\r\n        // Resolves issue #138 if the game has been paused, or blurred for\r\n        // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability\r\n        // and provides more expected behavior when the engine comes back\r\n        // into focus\r\n        if (elapsed > 200) {\r\n          elapsed = 1;\r\n        }\r\n        const delta = elapsed * game.timescale;\r\n\r\n        // reset frame stats (reuse existing instances)\r\n        const frameId = game.stats.prevFrame.id + 1;\r\n        game.stats.currFrame.reset();\r\n        game.stats.currFrame.id = frameId;\r\n        game.stats.currFrame.delta = delta;\r\n        game.stats.currFrame.fps = 1.0 / (delta / 1000);\r\n\r\n        const beforeUpdate = nowFn();\r\n        game._update(delta);\r\n        const afterUpdate = nowFn();\r\n        game._draw(delta);\r\n        const afterDraw = nowFn();\r\n\r\n        game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\r\n        game.stats.currFrame.duration.draw = afterDraw - afterUpdate;\r\n\r\n        lastTime = now;\r\n\r\n        game.emit('postframe', new PostFrameEvent(game, game.stats.currFrame));\r\n        game.stats.prevFrame.reset(game.stats.currFrame);\r\n      } catch (e) {\r\n        window.cancelAnimationFrame(game._requestId);\r\n        game.stop();\r\n        game.onFatalException(e);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Stops Excalibur's main loop, useful for pausing the game.\r\n   */\r\n  public stop() {\r\n    if (this._hasStarted) {\r\n      this.emit('stop', new GameStopEvent(this));\r\n      this.browser.pause();\r\n      this._hasStarted = false;\r\n      this._logger.debug('Game stopped');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the Engine's Running status, Useful for checking whether engine is running or paused.\r\n   */\r\n  public isPaused(): boolean {\r\n    return !this._hasStarted;\r\n  }\r\n\r\n  /**\r\n   * Takes a screen shot of the current viewport and returns it as an\r\n   * HTML Image Element.\r\n   */\r\n  public screenshot(): HTMLImageElement {\r\n    const result = new Image();\r\n    const raw = this.canvas.toDataURL('image/png');\r\n    result.src = raw;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Another option available to you to load resources into the game.\r\n   * Immediately after calling this the game will pause and the loading screen\r\n   * will appear.\r\n   * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n   */\r\n  public load(loader: Loadable<any>): Promise<void> {\r\n    const complete = new Promise<void>((resolve) => {\r\n      this._isLoading = true;\r\n\r\n      loader.load().then(() => {\r\n        if (this._suppressPlayButton) {\r\n          setTimeout(() => {\r\n            this._isLoading = false;\r\n            resolve();\r\n            // Delay is to give the logo a chance to show, otherwise don't delay\r\n          }, 500);\r\n        } else {\r\n          this._isLoading = false;\r\n          resolve();\r\n        }\r\n      });\r\n    });\r\n\r\n    return complete;\r\n  }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\n@obsolete({ message: 'Will be removed in excalibur v0.26.0' })\r\nclass AnimationNode {\r\n  constructor(public animation: Animation, public x: number, public y: number) {}\r\n}\r\n","import { GameEvent } from '../Events';\r\nimport { Sound } from '../Resources/Sound/Sound';\r\nimport { Actor } from '../Actor';\r\nimport { WebAudioInstance } from '../Resources/Sound/WebAudioInstance';\r\n\r\nexport class MediaEvent extends GameEvent<Sound> {\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public set bubbles(_value: boolean) {\r\n    // stubbed\r\n  }\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public get bubbles(): boolean {\r\n    return false;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected get _path(): Actor[] {\r\n    return null;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected set _path(_val: Actor[]) {\r\n    // stubbed\r\n  }\r\n\r\n  constructor(public target: Sound, protected _name: string = 'MediaEvent') {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Action, that calls when event happens\r\n   */\r\n  public action(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Propagate event further through event path\r\n   */\r\n  public propagate(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n\r\n  public layPath(_actor: Actor): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n}\r\n\r\nexport class NativeSoundEvent extends MediaEvent {\r\n  constructor(target: Sound, public track?: WebAudioInstance) {\r\n    super(target, 'NativeSoundEvent');\r\n  }\r\n}\r\n\r\nexport class NativeSoundProcessedEvent extends MediaEvent {\r\n  public data: string | AudioBuffer;\r\n\r\n  constructor(target: Sound, private _processedData: string | AudioBuffer) {\r\n    super(target, 'NativeSoundProcessedEvent');\r\n\r\n    this.data = this._processedData;\r\n  }\r\n}\r\n","import { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { vec, Vector } from './Math/vector';\r\nimport { Text } from './Graphics/Text';\r\nimport { BaseAlign, FontStyle, FontUnit, TextAlign } from './Graphics/FontCommon';\r\nimport { obsolete } from './Util/Decorators';\r\nimport { SpriteFont as LegacySpriteFont } from './Drawing/SpriteSheet';\r\nimport { ExcaliburGraphicsContext, GraphicsComponent, SpriteFont } from './Graphics';\r\nimport { Font } from './Graphics/Font';\r\nimport { Actor } from './Actor';\r\nimport { ActorArgs } from '.';\r\n\r\n/**\r\n * Option for creating a label\r\n */\r\nexport interface LabelOptions {\r\n  /**\r\n   * Specify the label text\r\n   */\r\n  text?: string;\r\n  /**\r\n   * Specify the color of the text (does not apply to SpriteFonts)\r\n   */\r\n  color?: Color;\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally specify a sprite font, will take precedence over any other [[Font]]\r\n   */\r\n  spriteFont?: SpriteFont | LegacySpriteFont;\r\n  /**\r\n   * Specify a custom font\r\n   */\r\n  font?: Font\r\n}\r\n\r\n/**\r\n * Labels are the way to draw small amounts of text to the screen. They are\r\n * actors and inherit all of the benefits and capabilities.\r\n */\r\nexport class Label extends Actor {\r\n  public font: Font = new Font();\r\n  private _text: Text = new Text({ text: '', font: this.font });\r\n\r\n  /**\r\n   * The text to draw.\r\n   */\r\n  public get text(): string {\r\n    return this._text.text;\r\n  }\r\n\r\n  public set text(text: string) {\r\n    this._text.text = text;\r\n  }\r\n\r\n  public get color(): Color {\r\n    return this._text.color;\r\n  }\r\n\r\n  public set color(color: Color) {\r\n    this._text.color = color;\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._text.opacity;\r\n  }\r\n\r\n  public set opacity(opacity: number) {\r\n    this._text.opacity = opacity;\r\n  }\r\n\r\n  /**\r\n   * Sets or gets the bold property of the label's text, by default it's false\r\n   * @deprecated Use [[Font.bold|Label.font.bold]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.bold will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.bold'\r\n  })\r\n  public get bold(): boolean {\r\n    return this.font.bold;\r\n  }\r\n\r\n  public set bold(isBold: boolean) {\r\n    this.font.bold = isBold;\r\n  }\r\n\r\n  /**\r\n   * The CSS font family string (e.g. `sans-serif`, `Droid Sans Pro`). Web fonts\r\n   * are supported, same as in CSS.\r\n   * @deprecated Use [[Font.family|Label.font.family]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.fontFamily will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.family'\r\n  })\r\n  public get fontFamily(): string {\r\n    return this.font.family;\r\n  }\r\n\r\n  public set fontFamily(family: string) {\r\n    this.font.family = family;\r\n  }\r\n\r\n  /**\r\n   * The font size in the selected units, default is 10 (default units is pixel)\r\n   * @deprecated Use [[Font.size|Label.font.size]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.fontSize will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.size'\r\n  })\r\n  public get fontSize(): number {\r\n    return this.font.size;\r\n  }\r\n\r\n  public set fontSize(sizeInUnit: number) {\r\n    this.font.size = sizeInUnit;\r\n  }\r\n\r\n  /**\r\n   * The font style for this label, the default is [[FontStyle.Normal]]\r\n   * @deprecated Use [[Font.style|Label.font.style]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.fontStyle will be removed in v0.26.0',\r\n    alternateMethod: 'Use Lable.font.style'\r\n  })\r\n  public get fontStyle(): FontStyle {\r\n    return this.font.style;\r\n  }\r\n\r\n  public set fontStyle(style: FontStyle) {\r\n    this.font.style = style;\r\n  }\r\n\r\n  /**\r\n   * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';\r\n   * @deprecated Use [[Font.unit|Label.font.unit]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.fontUnit will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.unit'\r\n  })\r\n  public get fontUnit(): FontUnit {\r\n    return this.font.unit;\r\n  }\r\n\r\n  public set fontUnit(unit: FontUnit) {\r\n    this.font.unit = unit;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the horizontal text alignment property for the label.\r\n   * @deprecated Use [[Font.textAlign|Label.font.textAlign]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.textAlign will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.textAlign'\r\n  })\r\n  public get textAlign(): TextAlign {\r\n    return this.font.textAlign;\r\n  }\r\n\r\n  public set textAlign(align: TextAlign) {\r\n    this.font.textAlign = align;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the baseline alignment property for the label.\r\n   * @deprecated Use [[Font.baseAlign|Label.font.baseAlign]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.baseAlign will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.baseAlign'\r\n  })\r\n  public get baseAlign(): BaseAlign {\r\n    return this.font.baseAlign;\r\n  }\r\n\r\n  public set baseAlign(align: BaseAlign) {\r\n    this.font.baseAlign = align;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the maximum width (in pixels) that the label should occupy\r\n   * @deprecated The maxWidth constraint is gone\r\n   */\r\n  public maxWidth: number;\r\n\r\n  private _legacySpriteFont: LegacySpriteFont;\r\n  private _spriteFont: SpriteFont;\r\n  /**\r\n   * The [[LegacyDrawing.SpriteFont]] to use, if any. Overrides [[fontFamily]] if present.\r\n   * @deprecated Use [[SpriteFont]]\r\n   */\r\n  @obsolete()\r\n  public get spriteFont(): LegacySpriteFont {\r\n    return this._legacySpriteFont;\r\n  }\r\n\r\n  public set spriteFont(sf: LegacySpriteFont | SpriteFont) {\r\n    if (sf) {\r\n      if (sf instanceof LegacySpriteFont) {\r\n        this._legacySpriteFont = sf;\r\n        this._spriteFont = SpriteFont.fromLegacySpriteFont(sf);\r\n        this._text.font = this._spriteFont;\r\n        return;\r\n      }\r\n      this._spriteFont = sf;\r\n      this._text.font = this._spriteFont;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.\r\n   * @deprecated Use [[SpriteFont.spacing]]\r\n   */\r\n  public letterSpacing: number = 0; //px\r\n\r\n  /**\r\n   * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.\r\n   * @deprecated Use Graphics.SpriteFont.caseInsensitve\r\n   */\r\n  public caseInsensitive: boolean = true;\r\n\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Build a new label\r\n   * @param options\r\n   */\r\n  constructor(options?: LabelOptions & ActorArgs) {\r\n    super(options);\r\n    const {text, pos, x, y, spriteFont, font, color} = options;\r\n\r\n    this.pos = pos ?? (x && y ? vec(x, y) : this.pos);\r\n    this.text = text ?? this.text;\r\n    this.spriteFont = spriteFont ?? this.spriteFont;\r\n    this.font = font ?? this.font;\r\n    this.color = color ?? this.color;\r\n    const gfx = this.get(GraphicsComponent);\r\n    gfx.anchor = Vector.Zero;\r\n    gfx.use(this._text);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n    this._graphicsContext = engine.graphicsContext;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the text in the label (in pixels);\r\n   */\r\n  public getTextWidth(): number {\r\n    return this._text.width;\r\n  }\r\n\r\n  /**\r\n   * Sets the text shadow for sprite fonts\r\n   * @param offsetX      The x offset in pixels to place the shadow\r\n   * @param offsetY      The y offset in pixels to place the shadow\r\n   * @param shadowColor  The color of the text shadow\r\n   * @deprecated Use [[Font.shadow|Label.font.shadow]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.setTextShadow will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.shadow'\r\n  })\r\n  public setTextShadow(offsetX: number, offsetY: number, shadowColor: Color) {\r\n    this.font.shadow = { offset: vec(offsetX, offsetY), blur: 2, color: shadowColor };\r\n  }\r\n\r\n  /**\r\n   * Toggles text shadows on or off, only applies when using sprite fonts\r\n   * @deprecated Use [[Font.shadow|Label.font.shadow]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.useTextShadow will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.shadow'\r\n  })\r\n  public useTextShadow(on: boolean) {\r\n    if (this.spriteFont) {\r\n      this.spriteFont.useTextShadow(on);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the current text shadow\r\n   * @deprecated Use [[Font.shadow|Label.font.shadow]]\r\n   */\r\n  @obsolete({\r\n    message: 'Label.clearTextShadow will be removed in v0.26.0',\r\n    alternateMethod: 'Use Label.font.shadow'\r\n  })\r\n  public clearTextShadow() {\r\n    this.font.shadow = null;\r\n  }\r\n\r\n  public draw(_ctx: CanvasRenderingContext2D, _delta: number) {\r\n    const exctx = this._graphicsContext;\r\n    this._text.draw(exctx, 0, 0);\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\nimport { BoundingBox } from '../Collision/Index';\nimport { Color } from '../Color';\nimport { line } from '../Util/DrawUtil';\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\nimport { BaseAlign, Direction, FontOptions, FontStyle, FontUnit, TextAlign, FontRenderer } from './FontCommon';\nimport { Raster, RasterOptions } from './Raster';\n\nexport class Font extends Raster implements FontRenderer {\n  constructor(options: FontOptions & RasterOptions = {}) {\n    super(options);\n    this.family = options?.family ?? this.family;\n    this.style = options?.style ?? this.style;\n    this.bold = options?.bold ?? this.bold;\n    this.size = options?.size ?? this.size;\n    this.unit = options?.unit ?? this.unit;\n    this.textAlign = options?.textAlign ?? this.textAlign;\n    this.baseAlign = options?.baseAlign ?? this.baseAlign;\n    this.direction = options?.direction ?? this.direction;\n    this.quality = options?.quality ?? this.quality;\n    if (options?.shadow) {\n      this.shadow = {};\n      this.shadow.blur = options.shadow.blur ?? this.shadow.blur;\n      this.shadow.offset = options.shadow.offset ?? this.shadow.offset;\n      this.shadow.color = options.shadow.color ?? this.shadow.color;\n    }\n    this.flagDirty();\n  }\n\n  public clone() {\n    return new Font({\n      ...this.cloneGraphicOptions(),\n      ...this.cloneRasterOptions(),\n      size: this.size,\n      unit: this.unit,\n      family: this.family,\n      style: this.style,\n      bold: this.bold,\n      textAlign: this.textAlign,\n      baseAlign: this.baseAlign,\n      direction: this.direction,\n      shadow: this.shadow\n        ? {\n          blur: this.shadow.blur,\n          offset: this.shadow.offset,\n          color: this.shadow.color\n        }\n        : null\n    });\n  }\n\n  /**\n   * Font quality determines the size of the underlying rastered text, higher quality means less jagged edges.\n   * If quality is set to 1, then just enough raster bitmap is generated to render the text.\n   *\n   * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.\n   *\n   * (Default 4)\n   */\n  public quality = 2;\n\n  public family: string = 'sans-serif';\n  public style: FontStyle = FontStyle.Normal;\n  public bold: boolean = false;\n  public unit: FontUnit = FontUnit.Px;\n  public textAlign: TextAlign = TextAlign.Left;\n  public baseAlign: BaseAlign = BaseAlign.Alphabetic;\n  public direction: Direction = Direction.LeftToRight;\n  public size: number = 10;\n  public shadow: { blur?: number; offset?: Vector; color?: Color } = null;\n\n  public get fontString() {\n    return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;\n  }\n\n  private _text: string;\n  private _lines: string[];\n  private _textBounds: BoundingBox = new BoundingBox();\n  private _textWidth: number = 0;\n  private _textHeight: number = 0;\n\n  public get width() {\n    return this._textWidth;\n  }\n\n  public set width(value: number) {\n    this._textWidth = value;\n  }\n\n  public get height() {\n    const numLines = this._lines?.length ?? 1;\n    return this._textHeight * numLines;\n  }\n\n  public set height(value: number) {\n    const numLines = this._lines?.length ?? 1;\n    this._textHeight = value / numLines;\n  }\n\n  private get _rasterWidth() {\n    return this._bitmap.width;\n  }\n\n  private get _rasterHeight() {\n    return this._bitmap.height;\n  }\n\n  private get _halfRasterWidth() {\n    return Math.floor(this._bitmap.width / 2);\n  }\n\n  private get _halfRasterHeight() {\n    return Math.floor(this._bitmap.height / 2);\n  }\n\n  public get localBounds(): BoundingBox {\n    return this._textBounds;\n  }\n\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\n    if (this.dirty) {\n      this.rasterize();\n    }\n\n    ex.drawImage(\n      this._bitmap,\n      0,\n      0,\n      this._rasterWidth,\n      this._rasterHeight,\n      x - this._rasterWidth / this.quality / 2,\n      y - this._rasterHeight / this.quality / 2,\n      this._rasterWidth / this.quality,\n      this._rasterHeight / this.quality\n    );\n  }\n\n  protected _rotate(ex: ExcaliburGraphicsContext) {\n    // TODO this needs to change depending on the bounding box...\n    const origin = this.origin ?? this._textBounds.center;\n    ex.translate(origin.x, origin.y);\n    ex.rotate(this.rotation);\n    ex.translate(-origin.x, -origin.y);\n  }\n\n  protected _flip(ex: ExcaliburGraphicsContext) {\n    if (this.flipHorizontal) {\n      ex.translate(this._textBounds.width / this.scale.x, 0);\n      ex.scale(-1, 1);\n    }\n\n    if (this.flipVertical) {\n      ex.translate(0, -this._textBounds.height / 2 / this.scale.y);\n      ex.scale(1, -1);\n    }\n  }\n\n  public updateText(text: string) {\n    if (this._text !== text) {\n      this._text = text;\n      this._lines = this._text.split('\\n');\n      this._updateDimensions();\n      this.flagDirty();\n    }\n  }\n\n  private _updateDimensions() {\n    if (this._text) {\n      this._applyFont(this._ctx);\n      const maxWidthLine = this._lines.reduce((a, b) => {\n        return a.length > b.length ? a : b;\n      });\n      const metrics = this._ctx.measureText(maxWidthLine);\n      this._textWidth = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);\n      this._textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);\n\n      // TODO lineheight makes the text bounds wonky\n      const lineAdjustedHeight = this._textHeight * this._lines.length;\n      // this._textHeight = lineAdjustedHeight;\n      // Changing the width and height clears the context properties\n      // We double the bitmap width to account for alignment\n      // We scale by \"quality\" so we render text without jaggies\n      this._bitmap.width = (this._textWidth + this.padding * 2) * 2 * this.quality;\n      this._bitmap.height = (lineAdjustedHeight + this.padding * 2) * 2 * this.quality;\n\n      // These bounds exist in raster bitmap space where the top left corner is the corder of the bitmap\n      const x = 0;\n      const y = 0;\n      const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);\n      this._textBounds = new BoundingBox({\n        left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,\n        top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,\n        bottom: y + bottomBounds + this.padding,\n        right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding\n      });\n    }\n  }\n\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\n    if (this.dirty) {\n      this._updateDimensions();\n    }\n    super._preDraw(ex, x, y);\n  }\n\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\n    if (this.showDebug) {\n      /* istanbul ignore next */\n      ex.debug.drawRect(-this._halfRasterWidth, -this._halfRasterHeight, this._rasterWidth, this._rasterHeight);\n    }\n    ex.restore();\n  }\n\n  private _applyFont(ctx: CanvasRenderingContext2D) {\n    ctx.translate(this.padding + this._halfRasterWidth, this.padding + this._halfRasterHeight);\n    ctx.scale(this.quality, this.quality);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.baseAlign;\n    ctx.font = this.fontString;\n    ctx.direction = this.direction;\n\n    if (this.shadow) {\n      ctx.shadowColor = this.shadow.color.toString();\n      ctx.shadowBlur = this.shadow.blur;\n      ctx.shadowOffsetX = this.shadow.offset.x;\n      ctx.shadowOffsetY = this.shadow.offset.y;\n    }\n  }\n\n  execute(ctx: CanvasRenderingContext2D): void {\n    if (this._text) {\n      // The reason we need to re-apply the font is setting raster properties (like width/height) can reset the context props\n      this._applyRasterProperites(ctx);\n      this._applyFont(ctx);\n\n      const lineHeight = this._textHeight; // TODO user specified line height\n      for (let i = 0; i < this._lines.length; i++) {\n        const line = this._lines[i];\n        if (this.color) {\n          ctx.fillText(line, 0, i * lineHeight);\n        }\n\n        if (this.strokeColor) {\n          ctx.strokeText(line, 0, i * lineHeight);\n        }\n      }\n\n      if (this.showDebug) {\n        // Horizontal line\n        /* istanbul ignore next */\n        line(ctx, Color.Red, -this._halfRasterWidth, 0, this._halfRasterWidth, 0, 2);\n        // Vertical line\n        /* istanbul ignore next */\n        line(ctx, Color.Red, 0, -this._halfRasterHeight, 0, this._halfRasterHeight, 2);\n      }\n    }\n  }\n\n  public render(ex: ExcaliburGraphicsContext, text: string, x: number, y: number) {\n    this.updateText(text);\n    this.draw(ex, x, y);\n  }\n}\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { SpriteFont } from './SpriteFont';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Color } from '../Color';\r\nimport { Font } from './Font';\r\nimport { watch } from '../Util/Watch';\r\n\r\nexport interface TextOptions {\r\n  text: string;\r\n  color?: Color;\r\n  font?: Font | SpriteFont;\r\n}\r\n\r\nexport class Text extends Graphic {\r\n  constructor(options: TextOptions & GraphicOptions) {\r\n    super(options);\r\n    // This order is important font, color, then text\r\n    this.font = options.font ?? new Font();\r\n    this.color = options.color ?? this.color;\r\n    this.text = options.text;\r\n  }\r\n\r\n  public clone(): Text {\r\n    return new Text({\r\n      text: this.text.slice(),\r\n      color: this.color.clone(),\r\n      font: this.font.clone()\r\n    });\r\n  }\r\n\r\n  private _text: string = '';\r\n  public get text() {\r\n    return this._text;\r\n  }\r\n\r\n  public set text(value: string) {\r\n    this._text = value;\r\n    this.font.updateText(value);\r\n  }\r\n\r\n  // TODO SpriteFont doesn't support a color yet :(\r\n  public get color() {\r\n    if (this.font instanceof Font) {\r\n      return this.font.color;\r\n    }\r\n    return Color.Black;\r\n  }\r\n\r\n  public set color(color: Color) {\r\n    if (this.font instanceof Font) {\r\n      this.font.color = color;\r\n    }\r\n  }\r\n\r\n  private _font: Font | SpriteFont;\r\n  public get font(): Font | SpriteFont {\r\n    return this._font;\r\n  }\r\n  public set font(font: Font | SpriteFont) {\r\n    if (font instanceof Font) {\r\n      this._font = watch(font, (font) => font.flagDirty());\r\n    } else {\r\n      this._font = font;\r\n    }\r\n  }\r\n\r\n  public get width() {\r\n    return this.font.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.font.height;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this.font.localBounds;\r\n  }\r\n\r\n  protected _rotate(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected _flip(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this.font instanceof Font) {\r\n      this.font.color = this.color;\r\n    }\r\n    this.font.flipHorizontal = this.flipHorizontal;\r\n    this.font.flipVertical = this.flipVertical;\r\n    this.font.scale = this.scale;\r\n    this.font.rotation = this.rotation;\r\n    this.font.origin = this.origin;\r\n    this.font.opacity = this.opacity;\r\n    this.font.render(ex, this._text, x, y);\r\n  }\r\n}\r\n","import { CollisionGroup } from './CollisionGroup';\r\n\r\n/**\r\n * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur\r\n */\r\nexport class CollisionGroupManager {\r\n  // using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.\r\n  private static _STARTING_BIT = 0b1 | 0;\r\n  private static _MAX_GROUPS = 32;\r\n  private static _CURRENT_GROUP = 1;\r\n  private static _CURRENT_BIT = CollisionGroupManager._STARTING_BIT;\r\n  private static _GROUPS: Map<string, CollisionGroup> = new Map<string, CollisionGroup>();\r\n\r\n  /**\r\n   * Create a new named collision group up to a max of 32.\r\n   * @param name Name for the collision group\r\n   * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one\r\n   */\r\n  public static create(name: string, mask?: number) {\r\n    if (this._CURRENT_GROUP > this._MAX_GROUPS) {\r\n      throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);\r\n    }\r\n    if (this._GROUPS.get(name)) {\r\n      throw new Error(`Collision group ${name} already exists`);\r\n    }\r\n    const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);\r\n    this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;\r\n    this._CURRENT_GROUP++;\r\n    this._GROUPS.set(name, group);\r\n    return group;\r\n  }\r\n\r\n  /**\r\n   * Get all collision groups currently tracked by excalibur\r\n   */\r\n  public static get groups(): CollisionGroup[] {\r\n    return Array.from(this._GROUPS.values());\r\n  }\r\n\r\n  /**\r\n   * Get a collision group by it's name\r\n   * @param name\r\n   */\r\n  public static groupByName(name: string) {\r\n    return this._GROUPS.get(name);\r\n  }\r\n\r\n  /**\r\n   * Resets the managers internal group management state\r\n   */\r\n  public static reset() {\r\n    this._GROUPS = new Map<string, CollisionGroup>();\r\n    this._CURRENT_BIT = this._STARTING_BIT;\r\n    this._CURRENT_GROUP = 1;\r\n  }\r\n}\r\n","import { Color } from '../Color';\r\nimport * as Effects from './SpriteEffects';\r\n\r\nimport { Drawable, DrawOptions } from '../Interfaces/Drawable';\r\nimport { Vector } from '../Math/vector';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n/**\r\n * Creates a closed polygon drawing given a list of [[Vector]]s.\r\n *\r\n * @deprecated Use [[Polygon]]\r\n * @warning Use sparingly as Polygons are performance intensive\r\n */\r\n@obsolete({\r\n  message: 'Polygon will be removed in v0.26.0',\r\n  alternateMethod: 'Use Graphics.Polygon'\r\n})\r\nexport class Polygon implements Drawable {\r\n  public flipVertical: boolean;\r\n  public flipHorizontal: boolean;\r\n  public drawWidth: number;\r\n  public drawHeight: number;\r\n\r\n  public width: number;\r\n  public height: number;\r\n\r\n  /**\r\n   * The color to use for the lines of the polygon\r\n   */\r\n  public lineColor: Color;\r\n  /**\r\n   * The color to use for the interior of the polygon\r\n   */\r\n  public fillColor: Color;\r\n  /**\r\n   * The width of the lines of the polygon\r\n   */\r\n  public lineWidth: number = 5;\r\n  /**\r\n   * Indicates whether the polygon is filled or not.\r\n   */\r\n  public filled: boolean = false;\r\n\r\n  private _points: Vector[] = [];\r\n  public anchor = Vector.Zero;\r\n  public offset = Vector.Zero;\r\n  public rotation: number = 0;\r\n  public scale = Vector.One;\r\n  public opacity: number = 1;\r\n\r\n  /**\r\n   * @param points  The vectors to use to build the polygon in order\r\n   */\r\n  constructor(points: Vector[]) {\r\n    this._points = points;\r\n\r\n    const minX = this._points.reduce((prev: number, curr: Vector) => {\r\n      return Math.min(prev, curr.x);\r\n    }, 0);\r\n    const maxX = this._points.reduce((prev: number, curr: Vector) => {\r\n      return Math.max(prev, curr.x);\r\n    }, 0);\r\n\r\n    this.drawWidth = maxX - minX;\r\n\r\n    const minY = this._points.reduce((prev: number, curr: Vector) => {\r\n      return Math.min(prev, curr.y);\r\n    }, 0);\r\n    const maxY = this._points.reduce((prev: number, curr: Vector) => {\r\n      return Math.max(prev, curr.y);\r\n    }, 0);\r\n\r\n    this.drawHeight = maxY - minY;\r\n\r\n    this.height = this.drawHeight;\r\n    this.width = this.drawWidth;\r\n  }\r\n\r\n  /**\r\n   * @notimplemented Effects are not supported on `Polygon`\r\n   */\r\n  public addEffect() {\r\n    // not supported on polygons\r\n  }\r\n  /**\r\n   * @notimplemented Effects are not supported on `Polygon`\r\n   */\r\n  public removeEffect(index: number): void;\r\n  /**\r\n   * @notimplemented Effects are not supported on `Polygon`\r\n   */\r\n  public removeEffect(effect: Effects.SpriteEffect): void;\r\n  /**\r\n   * @notimplemented Effects are not supported on `Polygon`\r\n   */\r\n  public removeEffect() {\r\n    // not supported on polygons\r\n  }\r\n\r\n  /**\r\n   * @notimplemented Effects are not supported on `Polygon`\r\n   */\r\n  public clearEffects() {\r\n    // not supported on polygons\r\n  }\r\n\r\n  public reset() {\r\n    //pass\r\n  }\r\n\r\n  /**\r\n   * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.\r\n   * @param ctx  The 2D rendering context\r\n   * @param x    The x coordinate of where to draw\r\n   * @param y    The y coordinate of where to draw\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D, x: number, y: number): void;\r\n  /**\r\n   * Draws the sprite with custom options to override internals without mutating them.\r\n   * @param options\r\n   */\r\n  public draw(options: DrawOptions): void;\r\n  public draw(ctxOrOptions: CanvasRenderingContext2D | DrawOptions, x?: number, y?: number): void {\r\n    if (ctxOrOptions instanceof CanvasRenderingContext2D) {\r\n      this._drawWithOptions({ ctx: ctxOrOptions, x, y });\r\n    } else {\r\n      this._drawWithOptions(ctxOrOptions);\r\n    }\r\n  }\r\n\r\n  private _drawWithOptions(options: DrawOptions) {\r\n    const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = {\r\n      ...options,\r\n      rotation: options.rotation ?? this.rotation,\r\n      drawWidth: options.drawWidth ?? this.drawWidth,\r\n      drawHeight: options.drawHeight ?? this.drawHeight,\r\n      flipHorizontal: options.flipHorizontal ?? this.flipHorizontal,\r\n      flipVertical: options.flipVertical ?? this.flipVertical,\r\n      anchor: options.anchor ?? this.anchor,\r\n      offset: options.offset ?? this.offset,\r\n      opacity: (options.opacity ?? 1) * (this.opacity ?? 1)\r\n    };\r\n\r\n    const xpoint = drawWidth * anchor.x + offset.x + x;\r\n    const ypoint = drawHeight * anchor.y + offset.y + y;\r\n\r\n    ctx.save();\r\n    ctx.translate(xpoint, ypoint);\r\n    ctx.scale(this.scale.x, this.scale.y);\r\n    ctx.rotate(rotation);\r\n    ctx.beginPath();\r\n    ctx.lineWidth = this.lineWidth;\r\n\r\n    // Iterate through the supplied points and construct a 'polygon'\r\n    const firstPoint = this._points[0];\r\n    ctx.moveTo(firstPoint.x, firstPoint.y);\r\n\r\n    let i = 0;\r\n    const len = this._points.length;\r\n\r\n    for (i; i < len; i++) {\r\n      ctx.lineTo(this._points[i].x, this._points[i].y);\r\n    }\r\n\r\n    ctx.lineTo(firstPoint.x, firstPoint.y);\r\n    ctx.closePath();\r\n\r\n    if (this.filled) {\r\n      ctx.fillStyle = this.fillColor.toString();\r\n      ctx.fill();\r\n    }\r\n\r\n    ctx.strokeStyle = this.lineColor.toString();\r\n\r\n    if (flipHorizontal) {\r\n      ctx.translate(drawWidth, 0);\r\n      ctx.scale(-1, 1);\r\n    }\r\n\r\n    if (flipVertical) {\r\n      ctx.translate(0, drawHeight);\r\n      ctx.scale(1, -1);\r\n    }\r\n\r\n    const oldAlpha = ctx.globalAlpha;\r\n    ctx.globalAlpha = opacity;\r\n    ctx.stroke();\r\n    ctx.globalAlpha = oldAlpha;\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n","import { Audio } from './Audio';\r\n\r\nexport type ExResponseType = '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text';\r\n\r\nexport interface ExResponseTypesLookup {\r\n  [name: string]: ExResponseType;\r\n}\r\n\r\nexport class ExResponse {\r\n  public static type: ExResponseTypesLookup = {\r\n    any: '',\r\n    blob: 'blob',\r\n    json: 'json',\r\n    text: 'text',\r\n    document: 'document',\r\n    arraybuffer: 'arraybuffer'\r\n  };\r\n}\r\n\r\n/**\r\n * Represents an audio implementation like [[WebAudioInstance]]\r\n */\r\nexport interface AudioImplementation {\r\n  /**\r\n   * XHR response type\r\n   */\r\n  responseType: ExResponseType;\r\n\r\n  /**\r\n   * Processes raw data and transforms into sound data\r\n   */\r\n  processData(data: Blob | ArrayBuffer): Promise<string | AudioBuffer>;\r\n\r\n  /**\r\n   * Factory method that returns an instance of a played audio track\r\n   */\r\n  createInstance(data: string | AudioBuffer): Audio;\r\n}\r\n","import { Engine } from './../Engine';\r\nimport * as Events from './../Events';\r\nimport { Scene } from '../Scene';\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _initialize {\r\n  _initialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n * Type guard checking for internal initialize method\r\n * @internal\r\n * @param a\r\n */\r\nexport function has_initialize(a: any): a is _initialize {\r\n  return !!a._initialize;\r\n}\r\n\r\nexport interface OnInitialize {\r\n  onInitialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnInitialize(a: any): a is OnInitialize {\r\n  return !!a.onInitialize;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _preupdate {\r\n  _preupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_preupdate(a: any): a is _preupdate {\r\n  return !!a._preupdate;\r\n}\r\n\r\nexport interface OnPreUpdate {\r\n  onPreUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPreUpdate(a: any): a is OnPreUpdate {\r\n  return !!a.onPreUpdate;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _postupdate {\r\n  _postupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_postupdate(a: any): a is _postupdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface OnPostUpdate {\r\n  onPostUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPostUpdate(a: any): a is OnPostUpdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface CanInitialize {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onInitialize(_engine: Engine): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<any>) => void): void;\r\n}\r\n\r\nexport interface CanActivate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onActivate(oldScene: Scene, newScene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  once(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  off(eventName: Events.activate, handler?: (event: Events.ActivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanDeactivate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onDeactivate(oldScene: Scene, newScene: Scene): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  once(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  off(eventName: Events.deactivate, handler?: (event: Events.DeactivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanUpdate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<any>) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<any>) => void): void;\r\n}\r\n\r\nexport interface OnPreDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreDraw(_ctx: CanvasRenderingContext2D, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n}\r\n\r\nexport interface OnPostDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostDraw(_ctx: CanvasRenderingContext2D, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\nexport interface CanDraw extends OnPreDraw, OnPostDraw {\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPreDraw(a: any): a is OnPreDraw {\r\n  return !!a.onPreDraw;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPostDraw(a: any): a is OnPostDraw {\r\n  return !!a.onPostDraw;\r\n}\r\n\r\nexport interface CanBeKilled {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  once(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  off(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  once(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  off(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n}\r\n","import { Audio } from '../../Interfaces/Audio';\r\nimport * as Util from '../../Util/Util';\r\nimport { AudioContextFactory } from './AudioContext';\r\n\r\n/**\r\n * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n */\r\nexport class WebAudioInstance implements Audio {\r\n  private _volume = 1;\r\n  private _duration: number | undefined = undefined;\r\n\r\n  private _playingPromise: Promise<boolean>;\r\n  private _playingResolve: (value: boolean) => void;\r\n\r\n  private _loop = false;\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    if (this._instance) {\r\n      this._instance.loop = value;\r\n      this._wireUpOnEnded();\r\n    }\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    value = Util.clamp(value, 0, 1.0);\r\n\r\n    this._volume = value;\r\n\r\n    if (this._isPlaying && this._volumeNode.gain.setTargetAtTime) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime\r\n      // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.\r\n      // This exponential ramp provides a more pleasant transition in gain\r\n      this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);\r\n    } else {\r\n      this._volumeNode.gain.value = value;\r\n    }\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  public set duration(value: number | undefined) {\r\n    this._duration = value;\r\n  }\r\n\r\n  /**\r\n   * Duration of the sound, in seconds.\r\n   */\r\n  public get duration() {\r\n    return this._duration;\r\n  }\r\n\r\n  private get _playbackRate(): number {\r\n    return this._instance ? 1 / (this._instance.playbackRate.value || 1.0) : null;\r\n  }\r\n\r\n  private _isPlaying = false;\r\n  private _isPaused = false;\r\n  private _instance: AudioBufferSourceNode;\r\n  private _audioContext: AudioContext = AudioContextFactory.create();\r\n  private _volumeNode = this._audioContext.createGain();\r\n  private _startTime: number;\r\n\r\n  /**\r\n   * Current playback offset (in seconds)\r\n   */\r\n  private _currentOffset = 0;\r\n\r\n  constructor(private _src: AudioBuffer) {\r\n    this._createNewBufferSource();\r\n  }\r\n\r\n  public isPlaying() {\r\n    return this._isPlaying;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  public play(playStarted: () => any = () => {}) {\r\n    if (this._isPaused) {\r\n      this._resumePlayBack();\r\n      playStarted();\r\n    }\r\n\r\n    if (!this._isPlaying) {\r\n      this._startPlayBack();\r\n      playStarted();\r\n    }\r\n\r\n    return this._playingPromise;\r\n  }\r\n\r\n  public pause() {\r\n    if (!this._isPlaying) {\r\n      return;\r\n    }\r\n\r\n    this._isPaused = true;\r\n    this._isPlaying = false;\r\n\r\n    this._instance.stop(0);\r\n    // Playback rate will be a scale factor of how fast/slow the audio is being played\r\n    // default is 1.0\r\n    // we need to invert it to get the time scale\r\n\r\n    this._setPauseOffset();\r\n  }\r\n\r\n  public stop() {\r\n    if (!this._isPlaying) {\r\n      return;\r\n    }\r\n\r\n    this._isPlaying = false;\r\n    this._isPaused = false;\r\n\r\n    this._currentOffset = 0;\r\n    this._instance.stop(0);\r\n\r\n    // handler will not be wired up if we were looping\r\n    if (!this._instance.onended) {\r\n      this._handleOnEnded();\r\n    }\r\n  }\r\n\r\n  private _startPlayBack() {\r\n    this._isPlaying = true;\r\n    this._isPaused = false;\r\n    this._playingPromise = new Promise<boolean>((resolve) => {\r\n      this._playingResolve = resolve;\r\n    });\r\n\r\n    if (!this._instance) {\r\n      this._createNewBufferSource();\r\n    }\r\n\r\n    this._rememberStartTime();\r\n\r\n    this._volumeNode.connect(this._audioContext.destination);\r\n    this._instance.start(0, 0);\r\n    this._currentOffset = 0;\r\n\r\n    this._wireUpOnEnded();\r\n  }\r\n\r\n  private _resumePlayBack() {\r\n    if (!this._isPaused) {\r\n      return;\r\n    }\r\n\r\n    this._isPaused = false;\r\n    this._isPlaying = true;\r\n\r\n    // a buffer source can only be started once\r\n    // so we need to dispose of the previous instance before\r\n    // \"resuming\" the next one\r\n    this._instance.onended = null; // dispose of any previous event handler\r\n    this._createNewBufferSource();\r\n\r\n    const duration = this._playbackRate * this._src.duration;\r\n    const restartTime = this._currentOffset % duration;\r\n\r\n    this._rememberStartTime(restartTime * -1000);\r\n    this._instance.start(0, restartTime);\r\n    this._wireUpOnEnded();\r\n  }\r\n\r\n  private _wireUpOnEnded() {\r\n    if (!this.loop) {\r\n      this._instance.onended = () => this._handleOnEnded();\r\n    }\r\n  }\r\n\r\n  private _handleOnEnded() {\r\n    // pausing calls stop(0) which triggers onended event\r\n    // so we don't \"resolve\" yet (when we resume we'll try again)\r\n    if (!this._isPaused) {\r\n      this._isPlaying = false;\r\n      this._playingResolve(true);\r\n    }\r\n  }\r\n\r\n  private _rememberStartTime(amend?: number) {\r\n    this._startTime = new Date().getTime() + (amend | 0);\r\n  }\r\n\r\n  private _setPauseOffset() {\r\n    this._currentOffset = ((new Date().getTime() - this._startTime) * this._playbackRate) / 1000; // in seconds\r\n  }\r\n\r\n  private _createNewBufferSource() {\r\n    this._instance = this._audioContext.createBufferSource();\r\n    this._instance.buffer = this._src;\r\n    this._instance.loop = this.loop;\r\n    this._instance.playbackRate.setValueAtTime(1.0, 0);\r\n\r\n    this._instance.connect(this._volumeNode);\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n\r\n/**\r\n * Whether or not the browser can play this file as HTML5 Audio\r\n */\r\nexport function canPlayFile(file: string): boolean {\r\n  try {\r\n    const a = new Audio();\r\n    const filetype = /.*\\.([A-Za-z0-9]+)$/;\r\n    const type = file.match(filetype)[1];\r\n    if (a.canPlayType('audio/' + type)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  } catch (e) {\r\n    Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);\r\n    return false;\r\n  }\r\n}\r\n","import { ExResponse } from '../../Interfaces/AudioImplementation';\r\nimport { Audio } from '../../Interfaces/Audio';\r\nimport { Engine } from '../../Engine';\r\nimport { Resource } from '../Resource';\r\nimport { WebAudioInstance } from './WebAudioInstance';\r\nimport { AudioContextFactory } from './AudioContext';\r\nimport { NativeSoundEvent, NativeSoundProcessedEvent } from '../../Events/MediaEvents';\r\nimport { canPlayFile } from '../../Util/Sound';\r\nimport { Loadable } from '../../Interfaces/Index';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Class } from '../../Class';\r\n\r\n/**\r\n * The [[Sound]] object allows games built in Excalibur to load audio\r\n * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]\r\n * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n */\r\nexport class Sound extends Class implements Audio, Loadable<AudioBuffer> {\r\n  public logger: Logger = Logger.getInstance();\r\n  public data: AudioBuffer;\r\n  private _resource: Resource<ArrayBuffer>;\r\n  /**\r\n   * Indicates whether the clip should loop when complete\r\n   * @param value  Set the looping flag\r\n   */\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.loop = this._loop;\r\n    }\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    this._volume = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.volume = this._volume;\r\n    }\r\n\r\n    this.emit('volumechange', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  public get duration(): number | undefined {\r\n    return this._duration;\r\n  }\r\n\r\n  /**\r\n   * Return array of Current AudioInstances playing or being paused\r\n   */\r\n  public get instances(): Audio[] {\r\n    return this._tracks;\r\n  }\r\n\r\n  public get path() {\r\n    return this._resource.path;\r\n  }\r\n\r\n  public set path(val: string) {\r\n    this._resource.path = val;\r\n  }\r\n\r\n  private _loop = false;\r\n  private _volume = 1;\r\n  private _duration: number | undefined = undefined;\r\n  private _isStopped = false;\r\n  private _isPaused = false;\r\n  private _tracks: Audio[] = [];\r\n  private _engine: Engine;\r\n  private _wasPlayingOnHidden: boolean = false;\r\n  private _audioContext = AudioContextFactory.create();\r\n\r\n  /**\r\n   * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n   */\r\n  constructor(...paths: string[]) {\r\n    super();\r\n    this._resource = new Resource('', ExResponse.type.arraybuffer);\r\n    /**\r\n     * Chrome : MP3, WAV, Ogg\r\n     * Firefox : WAV, Ogg,\r\n     * IE : MP3, WAV coming soon\r\n     * Safari MP3, WAV, Ogg\r\n     */\r\n    for (const path of paths) {\r\n      if (canPlayFile(path)) {\r\n        this.path = path;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!this.path) {\r\n      this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));\r\n      this.logger.warn('Attempting to use', paths[0]);\r\n      this.path = paths[0]; // select the first specified\r\n    }\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  public async load(): Promise<AudioBuffer> {\r\n    if (this.data) {\r\n      return this.data;\r\n    }\r\n    const arraybuffer = await this._resource.load();\r\n    const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));\r\n    this._duration = typeof audiobuffer === 'object' ? audiobuffer.duration : undefined;\r\n    this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));\r\n    return this.data = audiobuffer;\r\n  }\r\n\r\n  public async decodeAudio(data: ArrayBuffer): Promise<AudioBuffer> {\r\n    try {\r\n      return await this._audioContext.decodeAudioData(data.slice(0));\r\n    } catch (e) {\r\n      this.logger.error(\r\n        'Unable to decode ' +\r\n          ' this browser may not fully support this format, or the file may be corrupt, ' +\r\n          'if this is an mp3 try removing id3 tags and album art from the file.'\r\n      );\r\n      return await Promise.reject();\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    if (engine) {\r\n      this._engine = engine;\r\n\r\n      this._engine.on('hidden', () => {\r\n        if (engine.pauseAudioWhenHidden && this.isPlaying()) {\r\n          this._wasPlayingOnHidden = true;\r\n          this.pause();\r\n        }\r\n      });\r\n\r\n      this._engine.on('visible', () => {\r\n        if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {\r\n          this.play();\r\n          this._wasPlayingOnHidden = false;\r\n        }\r\n      });\r\n\r\n      this._engine.on('start', () => {\r\n        this._isStopped = false;\r\n      });\r\n\r\n      this._engine.on('stop', () => {\r\n        this.stop();\r\n        this._isStopped = true;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns how many instances of the sound are currently playing\r\n   */\r\n  public instanceCount(): number {\r\n    return this._tracks.length;\r\n  }\r\n\r\n  /**\r\n   * Whether or not the sound is playing right now\r\n   */\r\n  public isPlaying(): boolean {\r\n    return this._tracks.some((t) => t.isPlaying());\r\n  }\r\n\r\n  /**\r\n   * Play the sound, returns a promise that resolves when the sound is done playing\r\n   * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n   */\r\n  public play(volume?: number): Promise<boolean> {\r\n    if (!this.isLoaded()) {\r\n      this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');\r\n\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    if (this._isStopped) {\r\n      this.logger.warn('Cannot start playing. Engine is in a stopped state.');\r\n      return Promise.resolve(false);\r\n    }\r\n\r\n    this.volume = volume || this.volume;\r\n\r\n    if (this._isPaused) {\r\n      return this._resumePlayback();\r\n    } else {\r\n      return this._startPlayback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the sound, and do not rewind\r\n   */\r\n  public pause() {\r\n    if (!this.isPlaying()) {\r\n      return;\r\n    }\r\n\r\n    for (const track of this._tracks) {\r\n      track.pause();\r\n    }\r\n\r\n    this._isPaused = true;\r\n\r\n    this.emit('pause', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Paused all instances of sound', this.path);\r\n  }\r\n\r\n  /**\r\n   * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.\r\n   */\r\n  public stop() {\r\n    for (const track of this._tracks) {\r\n      track.stop();\r\n    }\r\n\r\n    this.emit('stop', new NativeSoundEvent(this));\r\n\r\n    this._isPaused = false;\r\n    this._tracks.length = 0;\r\n    this.logger.debug('Stopped all instances of sound', this.path);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get Id of provided AudioInstance in current trackList\r\n   * @param track [[Audio]] which Id is to be given\r\n   */\r\n  public getTrackId(track: Audio): number {\r\n    return this._tracks.indexOf(track);\r\n  }\r\n\r\n  private async _resumePlayback(): Promise<boolean> {\r\n    if (this._isPaused) {\r\n      const resumed: Promise<boolean>[] = [];\r\n      // ensure we resume *current* tracks (if paused)\r\n      for (const track of this._tracks) {\r\n        resumed.push(track.play());\r\n      }\r\n\r\n      this._isPaused = false;\r\n\r\n      this.emit('resume', new NativeSoundEvent(this));\r\n\r\n      this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);\r\n      // resolve when resumed tracks are done\r\n      await Promise.all(resumed);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Starts playback, returns a promise that resolves when playback is complete\r\n   */\r\n  private async _startPlayback(): Promise<boolean> {\r\n    const track = await this._getTrackInstance(this.data);\r\n\r\n    const complete = await track.play(() => {\r\n      this.emit('playbackstart', new NativeSoundEvent(this, track));\r\n      this.logger.debug('Playing new instance for sound', this.path);\r\n    });\r\n\r\n    // when done, remove track\r\n    this.emit('playbackend', new NativeSoundEvent(this, track));\r\n    this._tracks.splice(this.getTrackId(track), 1);\r\n\r\n    return complete;\r\n  }\r\n\r\n  private _getTrackInstance(data: AudioBuffer): WebAudioInstance {\r\n    const newTrack = new WebAudioInstance(data);\r\n\r\n    newTrack.loop = this.loop;\r\n    newTrack.volume = this.volume;\r\n    newTrack.duration = this.duration;\r\n\r\n    this._tracks.push(newTrack);\r\n\r\n    return newTrack;\r\n  }\r\n}\r\n","import { Resource } from './Resource';\r\nimport { Sprite } from '../Graphics/Sprite';\r\nimport { Color } from '../Color';\r\nimport { SpriteSheet } from '../Graphics/SpriteSheet';\r\nimport { Animation } from '../Graphics/Animation';\r\nimport { Engine } from '../Engine';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { ImageSource } from '../Graphics/ImageSource';\r\nimport { LegacyDrawing } from '..';\r\nimport { range } from '../Util/Util';\r\n/**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n */\r\nexport class Gif implements Loadable<ImageSource[]> {\r\n  private _resource: Resource<ArrayBuffer>;\r\n\r\n  /**\r\n   * The width of the texture in pixels\r\n   */\r\n  public width: number;\r\n\r\n  /**\r\n   * The height of the texture in pixels\r\n   */\r\n  public height: number;\r\n\r\n\r\n  private _stream: Stream = null;\r\n  private _gif: ParseGif = null;\r\n  private _textures: ImageSource[] = [];\r\n  private _animation: Animation = null;\r\n  private _transparentColor: Color = null;\r\n\r\n  public data: ImageSource[];\r\n\r\n  /**\r\n   * @param path       Path to the image resource\r\n   * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]\r\n   * @param bustCache  Optionally load texture with cache busting\r\n   */\r\n  constructor(public path: string, public color: Color = Color.Magenta, public bustCache = true) {\r\n    this._resource = new Resource(path, 'arraybuffer', bustCache);\r\n    this._transparentColor = color;\r\n  }\r\n\r\n  /**\r\n   * Begins loading the texture and returns a promise to be resolved on completion\r\n   */\r\n  public async load(): Promise<ImageSource[]> {\r\n    const arraybuffer = await this._resource.load();\r\n    this._stream = new Stream(arraybuffer);\r\n    this._gif = new ParseGif(this._stream, this._transparentColor);\r\n    const images = this._gif.images.map(i => new ImageSource(i.src, false));\r\n\r\n    // Load all textures\r\n    await Promise.all(images.map(t => t.load()));\r\n    return this.data = this._textures = images;\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  /**\r\n   * Return a frame of the gif as a legacy sprite by index\r\n   * @deprecated\r\n   */\r\n  public toLegacySprite(id: number = 0): LegacyDrawing.Sprite {\r\n    return Sprite.toLegacySprite(this.toSprite(id));\r\n  }\r\n\r\n  /**\r\n   * Return the gif as a legacy spritesheet\r\n   * @deprecated\r\n   * @returns\r\n   */\r\n  public toLegacySpriteSheet(): LegacyDrawing.SpriteSheet {\r\n    return SpriteSheet.toLegacySpriteSheet(this.toSpriteSheet());\r\n  }\r\n\r\n  /**\r\n   * Return the gif as a legacy animation\r\n   * @deprecated\r\n   * @param speed\r\n   */\r\n  public toLegacyAnimation(engine: Engine, speed: number): LegacyDrawing.Animation {\r\n    return Animation.toLegacyAnimation(engine, this.toAnimation(speed));\r\n  }\r\n\r\n  /**\r\n   * Return a frame of the gif as a sprite by id\r\n   * @param id\r\n   */\r\n  public toSprite(id: number = 0): Sprite {\r\n    const sprite = this._textures[id].toSprite();\r\n    return sprite;\r\n  }\r\n\r\n  /**\r\n   * Return the gif as a spritesheet\r\n   */\r\n  public toSpriteSheet(): SpriteSheet {\r\n    const sprites: Sprite[] = this._textures.map((image) => {\r\n      return image.toSprite();\r\n    });\r\n    return new SpriteSheet({ sprites });\r\n  }\r\n\r\n  /**\r\n   * Transform the GIF into an animation with duration per frame\r\n   */\r\n  public toAnimation(durationPerFrameMs: number): Animation {\r\n    const spriteSheet: SpriteSheet = this.toSpriteSheet();\r\n    const length = spriteSheet.sprites.length;\r\n    this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);\r\n    return this._animation;\r\n  }\r\n\r\n  public get readCheckBytes(): number[] {\r\n    return this._gif.checkBytes;\r\n  }\r\n}\r\n\r\nexport interface GifFrame {\r\n  sentinel: number;\r\n  type: string;\r\n  leftPos: number;\r\n  topPos: number;\r\n  width: number;\r\n  height: number;\r\n  lctFlag: boolean;\r\n  interlaced: boolean;\r\n  sorted: boolean;\r\n  reserved: boolean[];\r\n  lctSize: number;\r\n  lzwMinCodeSize: number;\r\n  pixels: number[];\r\n}\r\n\r\nconst bitsToNum = (ba: any) => {\r\n  return ba.reduce(function (s: number, n: number) {\r\n    return s * 2 + n;\r\n  }, 0);\r\n};\r\n\r\nconst byteToBitArr = (bite: any) => {\r\n  const a = [];\r\n  for (let i = 7; i >= 0; i--) {\r\n    a.push(!!(bite & (1 << i)));\r\n  }\r\n  return a;\r\n};\r\n\r\nexport class Stream {\r\n  data: any = null;\r\n  len: number = 0;\r\n  position: number = 0;\r\n\r\n  constructor(dataArray: ArrayBuffer) {\r\n    this.data = new Uint8Array(dataArray);\r\n    this.len = this.data.byteLength;\r\n    if (this.len === 0) {\r\n      throw new Error('No data loaded from file');\r\n    }\r\n  }\r\n\r\n  public readByte = () => {\r\n    if (this.position >= this.data.byteLength) {\r\n      throw new Error('Attempted to read past end of stream.');\r\n    }\r\n    return this.data[this.position++];\r\n  };\r\n\r\n  public readBytes = (n: number) => {\r\n    const bytes = [];\r\n    for (let i = 0; i < n; i++) {\r\n      bytes.push(this.readByte());\r\n    }\r\n    return bytes;\r\n  };\r\n\r\n  public read = (n: number) => {\r\n    let s = '';\r\n    for (let i = 0; i < n; i++) {\r\n      s += String.fromCharCode(this.readByte());\r\n    }\r\n    return s;\r\n  };\r\n\r\n  public readUnsigned = () => {\r\n    // Little-endian.\r\n    const a = this.readBytes(2);\r\n    return (a[1] << 8) + a[0];\r\n  };\r\n}\r\n\r\nconst lzwDecode = function (minCodeSize: number, data: any) {\r\n  // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\r\n  let pos = 0; // Maybe this streaming thing should be merged with the Stream?\r\n\r\n  const readCode = function (size: number) {\r\n    let code = 0;\r\n    for (let i = 0; i < size; i++) {\r\n      if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\r\n        code |= 1 << i;\r\n      }\r\n      pos++;\r\n    }\r\n    return code;\r\n  };\r\n\r\n  const output: any[] = [];\r\n\r\n  const clearCode = 1 << minCodeSize;\r\n  const eoiCode = clearCode + 1;\r\n\r\n  let codeSize = minCodeSize + 1;\r\n\r\n  let dict: any[] = [];\r\n\r\n  const clear = function () {\r\n    dict = [];\r\n    codeSize = minCodeSize + 1;\r\n    for (let i = 0; i < clearCode; i++) {\r\n      dict[i] = [i];\r\n    }\r\n    dict[clearCode] = [];\r\n    dict[eoiCode] = null;\r\n  };\r\n\r\n  let code;\r\n  let last;\r\n\r\n  while (true) {\r\n    last = code;\r\n    code = readCode(codeSize);\r\n    if (code === clearCode) {\r\n      clear();\r\n      continue;\r\n    }\r\n    if (code === eoiCode) {\r\n      break;\r\n    }\r\n\r\n    if (code < dict.length) {\r\n      if (last !== clearCode) {\r\n        dict.push(dict[last].concat(dict[code][0]));\r\n      }\r\n    } else {\r\n      if (code !== dict.length) {\r\n        throw new Error('Invalid LZW code.');\r\n      }\r\n      dict.push(dict[last].concat(dict[last][0]));\r\n    }\r\n    output.push.apply(output, dict[code]);\r\n\r\n    if (dict.length === 1 << codeSize && codeSize < 12) {\r\n      // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\r\n      codeSize++;\r\n    }\r\n  }\r\n\r\n  // I don't know if this is technically an error, but some GIFs do it.\r\n  //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\r\n  return output;\r\n};\r\n\r\n// The actual parsing; returns an object with properties.\r\nexport class ParseGif {\r\n  private _st: Stream = null;\r\n  private _handler: any = {};\r\n  private _transparentColor: Color = null;\r\n  public frames: GifFrame[] = [];\r\n  public images: HTMLImageElement[] = [];\r\n  public globalColorTable: any[] = [];\r\n  public checkBytes: number[] = [];\r\n\r\n  constructor(stream: Stream, color: Color = Color.Magenta) {\r\n    this._st = stream;\r\n    this._handler = {};\r\n    this._transparentColor = color;\r\n    this.parseHeader();\r\n    this.parseBlock();\r\n  }\r\n\r\n  // LZW (GIF-specific)\r\n  parseColorTable = (entries: any) => {\r\n    // Each entry is 3 bytes, for RGB.\r\n    const ct = [];\r\n    for (let i = 0; i < entries; i++) {\r\n      const rgb: number[] = this._st.readBytes(3);\r\n      const rgba =\r\n        '#' +\r\n        rgb\r\n          .map((x: any) => {\r\n            const hex = x.toString(16);\r\n            return hex.length === 1 ? '0' + hex : hex;\r\n          })\r\n          .join('');\r\n      ct.push(rgba);\r\n    }\r\n    return ct;\r\n  };\r\n\r\n  readSubBlocks = () => {\r\n    let size, data;\r\n    data = '';\r\n    do {\r\n      size = this._st.readByte();\r\n      data += this._st.read(size);\r\n    } while (size !== 0);\r\n    return data;\r\n  };\r\n\r\n  parseHeader = () => {\r\n    const hdr: any = {\r\n      sig: null,\r\n      ver: null,\r\n      width: null,\r\n      height: null,\r\n      colorRes: null,\r\n      globalColorTableSize: null,\r\n      gctFlag: null,\r\n      sorted: null,\r\n      globalColorTable: [],\r\n      bgColor: null,\r\n      pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n    };\r\n\r\n    hdr.sig = this._st.read(3);\r\n    hdr.ver = this._st.read(3);\r\n    if (hdr.sig !== 'GIF') {\r\n      throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\r\n    }\r\n\r\n    hdr.width = this._st.readUnsigned();\r\n    hdr.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    hdr.gctFlag = bits.shift();\r\n    hdr.colorRes = bitsToNum(bits.splice(0, 3));\r\n    hdr.sorted = bits.shift();\r\n    hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    hdr.bgColor = this._st.readByte();\r\n    hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n\r\n    if (hdr.gctFlag) {\r\n      hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));\r\n      this.globalColorTable = hdr.globalColorTable;\r\n    }\r\n    if (this._handler.hdr && this._handler.hdr(hdr)) {\r\n      this.checkBytes.push(this._handler.hdr);\r\n    }\r\n  };\r\n\r\n  parseExt = (block: any) => {\r\n    const parseGCExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 4\r\n\r\n      const bits = byteToBitArr(this._st.readByte());\r\n      block.reserved = bits.splice(0, 3); // Reserved; should be 000.\r\n      block.disposalMethod = bitsToNum(bits.splice(0, 3));\r\n      block.userInput = bits.shift();\r\n      block.transparencyGiven = bits.shift();\r\n\r\n      block.delayTime = this._st.readUnsigned();\r\n\r\n      block.transparencyIndex = this._st.readByte();\r\n\r\n      block.terminator = this._st.readByte();\r\n\r\n      if (this._handler.gce && this._handler.gce(block)) {\r\n        this.checkBytes.push(this._handler.gce);\r\n      }\r\n    };\r\n\r\n    const parseComExt = (block: any) => {\r\n      block.comment = this.readSubBlocks();\r\n      if (this._handler.com && this._handler.com(block)) {\r\n        this.checkBytes.push(this._handler.com);\r\n      }\r\n    };\r\n\r\n    const parsePTExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 12\r\n      block.ptHeader = this._st.readBytes(12);\r\n      block.ptData = this.readSubBlocks();\r\n      if (this._handler.pte && this._handler.pte(block)) {\r\n        this.checkBytes.push(this._handler.pte);\r\n      }\r\n    };\r\n\r\n    const parseAppExt = (block: any) => {\r\n      const parseNetscapeExt = (block: any) => {\r\n        this.checkBytes.push(this._st.readByte()); // Always 3\r\n        block.unknown = this._st.readByte(); // Q: Always 1? What is this?\r\n        block.iterations = this._st.readUnsigned();\r\n        block.terminator = this._st.readByte();\r\n        if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {\r\n          this.checkBytes.push(this._handler.app);\r\n        }\r\n      };\r\n\r\n      const parseUnknownAppExt = (block: any) => {\r\n        block.appData = this.readSubBlocks();\r\n        // FIXME: This won't work if a handler wants to match on any identifier.\r\n        if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {\r\n          this.checkBytes.push(this._handler.app[block.identifier]);\r\n        }\r\n      };\r\n\r\n      this.checkBytes.push(this._st.readByte()); // Always 11\r\n      block.identifier = this._st.read(8);\r\n      block.authCode = this._st.read(3);\r\n      switch (block.identifier) {\r\n        case 'NETSCAPE':\r\n          parseNetscapeExt(block);\r\n          break;\r\n        default:\r\n          parseUnknownAppExt(block);\r\n          break;\r\n      }\r\n    };\r\n\r\n    const parseUnknownExt = (block: any) => {\r\n      block.data = this.readSubBlocks();\r\n      if (this._handler.unknown && this._handler.unknown(block)) {\r\n        this.checkBytes.push(this._handler.unknown);\r\n      }\r\n    };\r\n\r\n    block.label = this._st.readByte();\r\n    switch (block.label) {\r\n      case 0xf9:\r\n        block.extType = 'gce';\r\n        parseGCExt(block);\r\n        break;\r\n      case 0xfe:\r\n        block.extType = 'com';\r\n        parseComExt(block);\r\n        break;\r\n      case 0x01:\r\n        block.extType = 'pte';\r\n        parsePTExt(block);\r\n        break;\r\n      case 0xff:\r\n        block.extType = 'app';\r\n        parseAppExt(block);\r\n        break;\r\n      default:\r\n        block.extType = 'unknown';\r\n        parseUnknownExt(block);\r\n        break;\r\n    }\r\n  };\r\n\r\n  parseImg = (img: any) => {\r\n    const deinterlace = (pixels: any, width: any) => {\r\n      // Of course this defeats the purpose of interlacing. And it's *probably*\r\n      // the least efficient way it's ever been implemented. But nevertheless...\r\n\r\n      const newPixels = new Array(pixels.length);\r\n      const rows = pixels.length / width;\r\n      const cpRow = (toRow: any, fromRow: any) => {\r\n        const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\r\n        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\r\n      };\r\n\r\n      const offsets = [0, 4, 2, 1];\r\n      const steps = [8, 8, 4, 2];\r\n\r\n      let fromRow = 0;\r\n      for (let pass = 0; pass < 4; pass++) {\r\n        for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\r\n          cpRow(toRow, fromRow);\r\n          fromRow++;\r\n        }\r\n      }\r\n\r\n      return newPixels;\r\n    };\r\n\r\n    img.leftPos = this._st.readUnsigned();\r\n    img.topPos = this._st.readUnsigned();\r\n    img.width = this._st.readUnsigned();\r\n    img.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    img.lctFlag = bits.shift();\r\n    img.interlaced = bits.shift();\r\n    img.sorted = bits.shift();\r\n    img.reserved = bits.splice(0, 2);\r\n    img.lctSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    if (img.lctFlag) {\r\n      img.lct = this.parseColorTable(1 << (img.lctSize + 1));\r\n    }\r\n\r\n    img.lzwMinCodeSize = this._st.readByte();\r\n\r\n    const lzwData = this.readSubBlocks();\r\n\r\n    img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\r\n\r\n    if (img.interlaced) {\r\n      // Move\r\n      img.pixels = deinterlace(img.pixels, img.width);\r\n    }\r\n\r\n    this.frames.push(img);\r\n    this.arrayToImage(img);\r\n    if (this._handler.img && this._handler.img(img)) {\r\n      this.checkBytes.push(this._handler);\r\n    }\r\n  };\r\n\r\n  public parseBlock = () => {\r\n    const block = {\r\n      sentinel: this._st.readByte(),\r\n      type: ''\r\n    };\r\n    const blockChar = String.fromCharCode(block.sentinel);\r\n    switch (blockChar) {\r\n      case '!':\r\n        block.type = 'ext';\r\n        this.parseExt(block);\r\n        break;\r\n      case ',':\r\n        block.type = 'img';\r\n        this.parseImg(block);\r\n        break;\r\n      case ';':\r\n        block.type = 'eof';\r\n        if (this._handler.eof && this._handler.eof(block)) {\r\n          this.checkBytes.push(this._handler.eof);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Unknown block: 0x' + block.sentinel.toString(16));\r\n    }\r\n\r\n    if (block.type !== 'eof') {\r\n      this.parseBlock();\r\n    }\r\n  };\r\n\r\n  arrayToImage = (frame: GifFrame) => {\r\n    let count = 0;\r\n    const c = document.createElement('canvas');\r\n    c.id = count.toString();\r\n    c.width = frame.width;\r\n    c.height = frame.height;\r\n    count++;\r\n    const context = c.getContext('2d');\r\n    const pixSize = 1;\r\n    let y = 0;\r\n    let x = 0;\r\n    for (let i = 0; i < frame.pixels.length; i++) {\r\n      if (x % frame.width === 0) {\r\n        y++;\r\n        x = 0;\r\n      }\r\n      if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {\r\n        context.fillStyle = `rgba(0, 0, 0, 0)`;\r\n      } else {\r\n        context.fillStyle = this.globalColorTable[frame.pixels[i]];\r\n      }\r\n\r\n      context.fillRect(x, y, pixSize, pixSize);\r\n      x++;\r\n    }\r\n    const img = new Image();\r\n    img.src = c.toDataURL();\r\n    this.images.push(img);\r\n  };\r\n}\r\n","import { Vector, vec } from '../Math/vector';\nimport { Raster, RasterOptions } from './Raster';\n\nexport interface PolygonOptions {\n  points: Vector[];\n}\n\n/**\n * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]\n */\nexport class Polygon extends Raster {\n  private _points: Vector[];\n  public get points(): Vector[] {\n    return this._points;\n  }\n  public set points(points: Vector[]) {\n    this._points = points;\n    const min = this.minPoint;\n    this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;\n    this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;\n    this.flagDirty();\n  }\n\n  public get minPoint() {\n    const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);\n    const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);\n    return vec(minX, minY);\n  }\n\n  constructor(options: RasterOptions & PolygonOptions) {\n    super(options);\n    this.points = options.points;\n    this.rasterize();\n  }\n\n  public clone(): Polygon {\n    return new Polygon({\n      points: this.points.map((p) => p.clone()),\n      ...this.cloneGraphicOptions(),\n      ...this.cloneRasterOptions()\n    });\n  }\n\n  execute(ctx: CanvasRenderingContext2D): void {\n    if (this.points && this.points.length) {\n      ctx.beginPath();\n      // Iterate through the supplied points and construct a 'polygon'\n      const min = this.minPoint.negate();\n      const firstPoint = this.points[0].add(min);\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      this.points.forEach((point) => {\n        ctx.lineTo(point.x + min.x, point.y + min.y);\n      });\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n      ctx.closePath();\n      if (this.color) {\n        ctx.fill();\n      }\n      if (this.strokeColor) {\n        ctx.stroke();\n      }\n    }\n  }\n}\n","import { obsolete } from './Decorators';\r\n\r\n/**\r\n * A sorted list implementation. NOTE: this implementation is not self-balancing\r\n * @deprecated WIll be removed in v0.26.0 Use built in JS array.sort\r\n */\r\n@obsolete({message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use built in JS array.sort'})\r\nexport class SortedList<T> {\r\n  private _getComparable: (item: T) => number;\r\n  private _root: BinaryTreeNode<T>;\r\n\r\n  constructor(getComparable: (item: T) => number) {\r\n    this._getComparable = getComparable;\r\n  }\r\n\r\n  public find(element: T): boolean {\r\n    return this._find(this._root, element);\r\n  }\r\n\r\n  private _find(node: BinaryTreeNode<T>, element: any): boolean {\r\n    if (node == null) {\r\n      return false;\r\n    } else if (this._getComparable(element) === node.getKey()) {\r\n      if (node.getData().indexOf(element) > -1) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (this._getComparable(element) < node.getKey()) {\r\n      return this._find(node.getLeft(), element);\r\n    } else {\r\n      return this._find(node.getRight(), element);\r\n    }\r\n  }\r\n\r\n  // returns the array of elements at a specific key value\r\n  public get(key: number): any[] {\r\n    return this._get(this._root, key);\r\n  }\r\n\r\n  private _get(node: BinaryTreeNode<T>, key: number): any[] {\r\n    if (node == null) {\r\n      return [];\r\n    } else if (key === node.getKey()) {\r\n      return node.getData();\r\n    } else if (key < node.getKey()) {\r\n      return this._get(node.getLeft(), key);\r\n    } else {\r\n      return this._get(node.getRight(), key);\r\n    }\r\n  }\r\n\r\n  public add(element: T): boolean {\r\n    if (this._root == null) {\r\n      this._root = new BinaryTreeNode(this._getComparable(element), [element], null, null);\r\n      return true;\r\n    } else {\r\n      return this._insert(this._root, element);\r\n    }\r\n  }\r\n\r\n  private _insert(node: BinaryTreeNode<T>, element: T): boolean {\r\n    if (node != null) {\r\n      if (this._getComparable(element) === node.getKey()) {\r\n        if (node.getData().indexOf(element) > -1) {\r\n          return false; // the element we're trying to insert already exists\r\n        } else {\r\n          node.getData().push(element);\r\n          return true;\r\n        }\r\n      } else if (this._getComparable(element) < node.getKey()) {\r\n        if (node.getLeft() == null) {\r\n          node.setLeft(new BinaryTreeNode(this._getComparable(element), [element], null, null));\r\n          return true;\r\n        } else {\r\n          return this._insert(node.getLeft(), element);\r\n        }\r\n      } else {\r\n        if (node.getRight() == null) {\r\n          node.setRight(new BinaryTreeNode(this._getComparable(element), [element], null, null));\r\n          return true;\r\n        } else {\r\n          return this._insert(node.getRight(), element);\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public removeByComparable(element: T): void {\r\n    this._root = this._remove(this._root, element);\r\n  }\r\n\r\n  private _remove(node: BinaryTreeNode<T>, element: T): BinaryTreeNode<T> {\r\n    if (node == null) {\r\n      return null;\r\n    } else if (this._getComparable(element) === node.getKey()) {\r\n      const elementIndex = node.getData().indexOf(element);\r\n      // if the node contains the element, remove the element\r\n      if (elementIndex > -1) {\r\n        node.getData().splice(elementIndex, 1);\r\n        // if we have removed the last element at this node, remove the node\r\n        if (node.getData().length === 0) {\r\n          // if the node is a leaf\r\n          if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n          } else if (node.getLeft() == null) {\r\n            return node.getRight();\r\n          } else if (node.getRight() == null) {\r\n            return node.getLeft();\r\n          }\r\n          // if node has 2 children\r\n          const temp = this._findMinNode(node.getRight());\r\n          node.setKey(temp.getKey());\r\n          node.setData(temp.getData());\r\n          node.setRight(this._cleanup(node.getRight(), temp)); //\"cleanup nodes\" (move them up recursively)\r\n          return node;\r\n        } else {\r\n          // this prevents the node from being removed since it still contains elements\r\n          return node;\r\n        }\r\n      }\r\n    } else if (this._getComparable(element) < node.getKey()) {\r\n      node.setLeft(this._remove(node.getLeft(), element));\r\n      return node;\r\n    } else {\r\n      node.setRight(this._remove(node.getRight(), element));\r\n      return node;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node\r\n  private _cleanup(node: BinaryTreeNode<T>, element: BinaryTreeNode<T>): BinaryTreeNode<T> {\r\n    const comparable = element.getKey();\r\n    if (node == null) {\r\n      return null;\r\n    } else if (comparable === node.getKey()) {\r\n      // if the node is a leaf\r\n      if (node.getLeft() == null && node.getRight() == null) {\r\n        return null;\r\n      } else if (node.getLeft() == null) {\r\n        return node.getRight();\r\n      } else if (node.getRight() == null) {\r\n        return node.getLeft();\r\n      }\r\n      // if node has 2 children\r\n      const temp = this._findMinNode(node.getRight());\r\n      node.setKey(temp.getKey());\r\n      node.setData(temp.getData());\r\n\r\n      node.setRight(this._cleanup(node.getRight(), temp));\r\n      return node;\r\n    } else if (element.getKey() < node.getKey()) {\r\n      node.setLeft(this._cleanup(node.getLeft(), element));\r\n      return node;\r\n    } else {\r\n      node.setRight(this._cleanup(node.getRight(), element));\r\n      return node;\r\n    }\r\n  }\r\n\r\n  private _findMinNode(node: BinaryTreeNode<T>): BinaryTreeNode<T> {\r\n    let current = node;\r\n    while (current.getLeft() != null) {\r\n      current = current.getLeft();\r\n    }\r\n    return current;\r\n  }\r\n\r\n  public list(): Array<T> {\r\n    const results = new Array<T>();\r\n    this._list(this._root, results);\r\n    return results;\r\n  }\r\n\r\n  private _list(treeNode: BinaryTreeNode<T>, results: Array<T>): void {\r\n    if (treeNode != null) {\r\n      this._list(treeNode.getLeft(), results);\r\n      treeNode.getData().forEach((element) => {\r\n        results.push(element);\r\n      });\r\n      this._list(treeNode.getRight(), results);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * A tree node part of [[SortedList]]\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\n@obsolete({message: 'Will be removed in excalibur v0.26.0'})\r\nexport class BinaryTreeNode<T> {\r\n  private _key: number;\r\n  private _data: Array<T>;\r\n  private _left: BinaryTreeNode<T>;\r\n  private _right: BinaryTreeNode<T>;\r\n\r\n  constructor(key: number, data: Array<T>, left: BinaryTreeNode<T>, right: BinaryTreeNode<T>) {\r\n    this._key = key;\r\n    this._data = data;\r\n    this._left = left;\r\n    this._right = right;\r\n  }\r\n\r\n  public getKey(): number {\r\n    return this._key;\r\n  }\r\n\r\n  public setKey(key: number) {\r\n    this._key = key;\r\n  }\r\n\r\n  public getData(): T[] {\r\n    return this._data;\r\n  }\r\n\r\n  public setData(data: T[]) {\r\n    this._data = data;\r\n  }\r\n\r\n  public getLeft(): BinaryTreeNode<T> {\r\n    return this._left;\r\n  }\r\n\r\n  public setLeft(left: BinaryTreeNode<T>) {\r\n    this._left = left;\r\n  }\r\n\r\n  public getRight(): BinaryTreeNode<T> {\r\n    return this._right;\r\n  }\r\n\r\n  public setRight(right: BinaryTreeNode<T>) {\r\n    this._right = right;\r\n  }\r\n}\r\n\r\n/**\r\n * Mock element for testing\r\n *\r\n * @internal\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport class MockedElement {\r\n  private _key: number = 0;\r\n\r\n  constructor(key: number) {\r\n    this._key = key;\r\n  }\r\n\r\n  public getTheKey() {\r\n    return this._key;\r\n  }\r\n\r\n  public setKey(key: number) {\r\n    this._key = key;\r\n  }\r\n}\r\n","// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/\r\n\r\nimport { obsolete } from './Util/Decorators';\r\n\r\n/**\r\n * Valid states for a promise to be in\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport enum PromiseState {\r\n  Resolved,\r\n  Rejected,\r\n  Pending\r\n}\r\n\r\n/**\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport interface PromiseLike<T> {\r\n  then(successCallback?: (value?: T) => any, rejectCallback?: (value?: T) => any): PromiseLike<T>;\r\n  error(rejectCallback?: (value?: any) => any): PromiseLike<T>;\r\n\r\n  //Cannot define static methods on interfaces\r\n  //wrap<T>(value?: T): IPromise<T>;\r\n\r\n  resolve(value?: T): PromiseLike<T>;\r\n  reject(value?: any): PromiseLike<T>;\r\n\r\n  state(): PromiseState;\r\n}\r\n\r\n/**\r\n * Promises are used to do asynchronous work and they are useful for\r\n * creating a chain of actions. In Excalibur they are used for loading,\r\n * sounds, animation, actions, and more.\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\n@obsolete({\r\n  message: 'ex.Promises are being replaced by native browser promises in v0.26.0',\r\n  alternateMethod: 'Use browser native promises'\r\n})\r\nexport class Promise<T> implements PromiseLike<T> {\r\n  private _state: PromiseState = PromiseState.Pending;\r\n  private _value: T;\r\n  private _successCallbacks: { (value?: T): any }[] = [];\r\n  private _rejectCallback: (value?: any) => any = () => {\r\n    return;\r\n  };\r\n  private _errorCallback: (value?: any) => any;\r\n\r\n  /**\r\n   * Create and resolve a Promise with an optional value\r\n   * @param value  An optional value to wrap in a resolved promise\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public static resolve<T>(value?: T): Promise<T> {\r\n    const promise = new Promise<T>().resolve(value);\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Create and reject a Promise with an optional value\r\n   * @param value  An optional value to wrap in a rejected promise\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public static reject<T>(value?: T): Promise<T> {\r\n    const promise = new Promise<T>().reject(value);\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Returns a new promise that resolves when all the promises passed to it resolve, or rejects\r\n   * when at least 1 promise rejects.\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public static join<T>(promises: Promise<T>[]): Promise<T>;\r\n\r\n  /**\r\n   * Returns a new promise that resolves when all the promises passed to it resolve, or rejects\r\n   * when at least 1 promise rejects.\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public static join<T>(...promises: Promise<T>[]): Promise<T>;\r\n\r\n  public static join<T>() {\r\n    let promises: Promise<T>[] = [];\r\n\r\n    if (arguments.length > 0 && !Array.isArray(arguments[0])) {\r\n      for (let _i = 0; _i < arguments.length; _i++) {\r\n        promises[_i - 0] = arguments[_i];\r\n      }\r\n    } else if (arguments.length === 1 && Array.isArray(arguments[0])) {\r\n      promises = arguments[0];\r\n    }\r\n\r\n    const joinedPromise = new Promise<T>();\r\n    if (!promises || !promises.length) {\r\n      return joinedPromise.resolve();\r\n    }\r\n\r\n    const total = promises.length;\r\n    let successes = 0;\r\n    let rejects = 0;\r\n    const errors: any = [];\r\n\r\n    promises.forEach((p) => {\r\n      p.then(\r\n        () => {\r\n          successes += 1;\r\n          if (successes === total) {\r\n            joinedPromise.resolve();\r\n          } else if (successes + rejects + errors.length === total) {\r\n            joinedPromise.reject(errors);\r\n          }\r\n        },\r\n        () => {\r\n          rejects += 1;\r\n          if (successes + rejects + errors.length === total) {\r\n            joinedPromise.reject(errors);\r\n          }\r\n        }\r\n      ).error((e) => {\r\n        errors.push(e);\r\n        if (errors.length + successes + rejects === total) {\r\n          joinedPromise.reject(errors);\r\n        }\r\n      });\r\n    });\r\n\r\n    return joinedPromise;\r\n  }\r\n\r\n  /**\r\n   * Chain success and reject callbacks after the promise is resolved\r\n   * @param successCallback  Call on resolution of promise\r\n   * @param rejectCallback   Call on rejection of promise\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public then(successCallback?: (value?: T) => any, rejectCallback?: (value?: any) => any) {\r\n    if (successCallback) {\r\n      this._successCallbacks.push(successCallback);\r\n\r\n      // If the promise is already resolved call immediately\r\n      if (this.state() === PromiseState.Resolved) {\r\n        try {\r\n          successCallback.call(this, this._value);\r\n        } catch (e) {\r\n          this._handleError(e);\r\n        }\r\n      }\r\n    }\r\n    if (rejectCallback) {\r\n      this._rejectCallback = rejectCallback;\r\n\r\n      // If the promise is already rejected call immediately\r\n      if (this.state() === PromiseState.Rejected) {\r\n        try {\r\n          rejectCallback.call(this, this._value);\r\n        } catch (e) {\r\n          this._handleError(e);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add an error callback to the promise\r\n   * @param errorCallback  Call if there was an error in a callback\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public error(errorCallback?: (value?: any) => any) {\r\n    if (errorCallback) {\r\n      this._errorCallback = errorCallback;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resolve the promise and pass an option value to the success callbacks\r\n   * @param value  Value to pass to the success callbacks\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public resolve(value?: T): Promise<T> {\r\n    if (this._state === PromiseState.Pending) {\r\n      this._value = value;\r\n      try {\r\n        this._state = PromiseState.Resolved;\r\n        this._successCallbacks.forEach((cb) => {\r\n          cb.call(this, this._value);\r\n        });\r\n      } catch (e) {\r\n        this._handleError(e);\r\n      }\r\n    } else {\r\n      throw new Error('Cannot resolve a promise that is not in a pending state!');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Reject the promise and pass an option value to the reject callbacks\r\n   * @param value  Value to pass to the reject callbacks\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public reject(value?: any) {\r\n    if (this._state === PromiseState.Pending) {\r\n      this._value = value;\r\n      try {\r\n        this._state = PromiseState.Rejected;\r\n        this._rejectCallback.call(this, this._value);\r\n      } catch (e) {\r\n        this._handleError(e);\r\n      }\r\n    } else {\r\n      throw new Error('Cannot reject a promise that is not in a pending state!');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Inspect the current state of a promise\r\n   * @deprecated Use browser native promises\r\n   */\r\n  public state(): PromiseState {\r\n    return this._state;\r\n  }\r\n\r\n  private _handleError(e: any) {\r\n    if (this._errorCallback) {\r\n      this._errorCallback.call(this, e);\r\n    } else {\r\n      // rethrow error\r\n      throw e;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * The current Excalibur version string\r\n * @description `process.env.__EX_VERSION` gets replaced by Webpack on build\r\n */\r\nexport const EX_VERSION = process.env.__EX_VERSION;\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\n\r\n// This file is used as the bundle entry point and exports everything\r\n// that will be exposed as the `ex` global variable.\r\nexport * from './Flags';\r\nexport * from './Id';\r\nexport * from './Engine';\r\nexport * from './Screen';\r\nexport { Actor, ActorArgs } from './Actor';\r\nexport * from './Math/Index';\r\nexport * from './Camera';\r\nexport * from './Class';\r\nexport * from './Configurable';\r\nexport * from './Debug/index';\r\nexport * from './EventDispatcher';\r\nexport * from './Events/MediaEvents';\r\nexport * from './Events';\r\nexport * from './Label';\r\nexport { FontStyle, FontUnit, TextAlign, BaseAlign } from './Graphics/FontCommon';\r\nexport * from './Loader';\r\nexport { Particle, ParticleEmitter, ParticleArgs, ParticleEmitterArgs, EmitterType } from './Particles';\r\nexport * from './Collision/Physics';\r\nexport * from './Scene';\r\nexport { TileMap, Cell, TileMapArgs, CellArgs } from './TileMap';\r\nexport * from './Timer';\r\nexport * from './Trigger';\r\nexport * from './ScreenElement';\r\n\r\nexport * from './Actions/Index';\r\nexport * from './Collision/Index';\r\n\r\n// ex.LegacyDrawing namespace\r\nimport * as legacyDrawing from './Drawing/Index';\r\nexport { legacyDrawing as LegacyDrawing };\r\nexport * from './Interfaces/Index';\r\nexport * from './PostProcessing/Index';\r\nexport * from './Resources/Index';\r\n\r\nexport * from './EntityComponentSystem/index';\r\n\r\nexport * from './Color';\r\n\r\nexport * from './Graphics/index';\r\n\r\n// ex.Events namespace\r\nimport * as events from './Events';\r\nexport { events as Events };\r\n\r\n// ex.Input namespace\r\nimport * as input from './Input/Index';\r\nexport { input as Input };\r\n\r\n// ex.Traits namespace\r\nimport * as traits from './Traits/Index';\r\nexport { traits as Traits };\r\n\r\n// ex.Util namespaces\r\nimport * as util from './Util/Index';\r\nexport { util as Util };\r\nexport {\r\n  clamp,\r\n  range,\r\n  toDegrees,\r\n  toRadians,\r\n  randomInRange,\r\n  randomIntInRange,\r\n  canonicalizeAngle\r\n} from './Util/Index';\r\n\r\nexport * from './Util/Browser';\r\nexport * from './Util/Decorators';\r\nexport * from './Util/Detector';\r\nexport * from './Util/CullingBox';\r\nexport * from './Util/EasingFunctions';\r\nexport * from './Util/Observable';\r\nexport * from './Util/Log';\r\nexport * from './Util/SortedList';\r\nexport * from './Util/Pool';\r\n\r\n// ex.Deprecated\r\nexport * from './Promises';\r\n// import * as deprecated from './Deprecated';\r\n// export { deprecated as Deprecated };\r\n// export * from './Deprecated';\r\n","import { Actor, CollisionType, Color, Engine, vec } from \"excalibur\";\n// game.js\n\n// start-snippet{create-engine}\n// Create an instance of the engine.\n// I'm specifying that the game be 800 pixels wide by 600 pixels tall.\n// If no dimensions are specified the game will fit to the screen.\nconst game = new Engine({\n  width: 800,\n  height: 600,\n});\n// end-snippet{create-engine}\n\n// start-snippet{create-paddle}\n// Create an actor with x position of 150px,\n// y position of 40px from the bottom of the screen,\n// width of 200px, height and a height of 20px\nconst paddle = new Actor({\n  x: 150,\n  y: game.drawHeight - 40,\n  width: 200,\n  height: 20,\n  // Let's give it some color with one of the predefined\n  // color constants\n  color: Color.Chartreuse,\n});\n\n// Make sure the paddle can partipate in collisions, by default excalibur actors do not collide with each other\n// CollisionType.Fixed is like an object with infinite mass, and cannot be moved, but does participate in collision.\npaddle.body.collisionType = CollisionType.Fixed;\n\n// `game.add` is the same as calling\n// `game.currentScene.add`\ngame.add(paddle);\n// end-snippet{create-paddle}\n\n// start-snippet{mouse-move}\n// Add a mouse move listener\ngame.input.pointers.primary.on(\"move\", (evt) => {\n  paddle.pos.x = evt.worldPos.x;\n});\n// end-snippet{mouse-move}\n\n// start-snippet{create-ball}\n// Create a ball at pos (100, 300) to start\nconst ball = new Actor({\n  x: 100,\n  y: 300,\n  // Use a circle collider with radius 10\n  radius: 10,\n  // Set the color\n  color: Color.Red,\n});\n\n// Start the serve after a second\nsetTimeout(() => {\n  // Set the velocity in pixels per second\n  ball.vel = vec(100, 100);\n}, 1000);\n\n// Set the collision Type to passive\n// This means \"tell me when I collide with an emitted event, but don't let excalibur do anything automatically\"\nball.body.collisionType = CollisionType.Passive;\n// Other possible collision types:\n// \"ex.CollisionType.PreventCollision - this means do not participate in any collision notification at all\"\n// \"ex.CollisionType.Active - this means participate and let excalibur resolve the positions/velocities of actors after collision\"\n// \"ex.CollisionType.Fixed - this means participate, but this object is unmovable\"\n\n// Add the ball to the current scene\ngame.add(ball);\n// end-snippet{create-ball}\n\n// start-snippet{screen-collision}\n// Wire up to the postupdate event\nball.on(\"postupdate\", () => {\n  // If the ball collides with the left side\n  // of the screen reverse the x velocity\n  if (ball.pos.x < ball.width / 2) {\n    ball.vel.x *= -1;\n  }\n\n  // If the ball collides with the right side\n  // of the screen reverse the x velocity\n  if (ball.pos.x + ball.width / 2 > game.drawWidth) {\n    ball.vel.x *= -1;\n  }\n\n  // If the ball collides with the top\n  // of the screen reverse the y velocity\n  if (ball.pos.y < ball.height / 2) {\n    ball.vel.y *= -1;\n  }\n});\n// end-snippet{screen-collision}\n\n// start-snippet{create-bricks}\n// Build Bricks\n\n// Padding between bricks\nconst padding = 20; // px\nconst xoffset = 65; // x-offset\nconst yoffset = 20; // y-offset\nconst columns = 5;\nconst rows = 3;\n\nconst brickColor = [Color.Violet, Color.Orange, Color.Yellow];\n\n// Individual brick width with padding factored in\nconst brickWidth = game.drawWidth / columns - padding - padding / columns; // px\nconst brickHeight = 30; // px\nconst bricks: Actor[] = [];\nfor (let j = 0; j < rows; j++) {\n  for (let i = 0; i < columns; i++) {\n    bricks.push(\n      new Actor({\n        x: xoffset + i * (brickWidth + padding) + padding,\n        y: yoffset + j * (brickHeight + padding) + padding,\n        width: brickWidth,\n        height: brickHeight,\n        color: brickColor[j % brickColor.length],\n      })\n    );\n  }\n}\n\nbricks.forEach(function (brick) {\n  // Make sure that bricks can participate in collisions\n  brick.body.collisionType = CollisionType.Active;\n\n  // Add the brick to the current scene to be drawn\n  game.add(brick);\n});\n// end-snippet{create-bricks}\n\n// start-snippet{ball-brick-collision}\n// On collision remove the brick, bounce the ball\nball.on(\"precollision\", function (ev) {\n  if (bricks.indexOf(ev.other) > -1) {\n    // kill removes an actor from the current scene\n    // therefore it will no longer be drawn or updated\n    ev.other.kill();\n  }\n\n  // reverse course after any collision\n  // intersections are the direction body A has to move to not be clipping body B\n  // `ev.intersection` is a vector `normalize()` will make the length of it 1\n  // `negate()` flips the direction of the vector\n  var intersection = ev.intersection.normalize();\n\n  // The largest component of intersection is our axis to flip\n  if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\n    ball.vel.x *= -1;\n  } else {\n    ball.vel.y *= -1;\n  }\n});\n// end-snippet{ball-brick-collision}\n\n// start-snippet{lose-condition}\n// Loss condition\nball.on(\"exitviewport\", () => {\n  alert(\"You lose!\");\n});\n// end-snippet{lose-condition}\n\n// start-snippet{start-game}\n// Start the engine to begin the game.\ngame.start();\n// end-snippet{start-game}\n"],"names":["__webpack_require__","entryUnbind","module","exports","path","Object","keys","isCallable","tryToString","argument","TypeError","isObject","String","toIndexedObject","toLength","toAbsoluteIndex","createMethod","IS_INCLUDES","$this","el","fromIndex","value","O","length","index","includes","indexOf","fails","METHOD_NAME","method","call","floor","Math","mergeSort","array","comparefn","middle","insertionSort","merge","slice","element","j","i","left","right","llength","rlength","lindex","rindex","result","push","toString","it","TO_STRING_TAG_SUPPORT","classofRaw","TO_STRING_TAG","wellKnownSymbol","CORRECT_ARGUMENTS","arguments","tag","undefined","key","error","tryGet","callee","has","ownKeys","getOwnPropertyDescriptorModule","definePropertyModule","target","source","defineProperty","f","getOwnPropertyDescriptor","DESCRIPTORS","createPropertyDescriptor","object","bitmap","enumerable","configurable","writable","get","global","document","EXISTS","createElement","firefox","match","UA","test","getBuiltIn","version","userAgent","process","Deno","versions","v8","split","webkit","bind","Function","CONSTRUCTOR","METHOD","prototype","createNonEnumerableProperty","redefine","setGlobal","copyConstructorProperties","isForced","options","targetProperty","sourceProperty","descriptor","TARGET","GLOBAL","STATIC","stat","noTargetGet","forced","sham","exec","aCallable","fn","that","a","b","c","apply","FunctionPrototype","getDescriptor","PROPER","name","CONFIGURABLE","aFunction","namespace","V","P","func","check","globalThis","window","self","g","this","toObject","hasOwnProperty","hasOwn","classof","propertyIsEnumerable","store","functionToString","inspectSource","set","NATIVE_WEAK_MAP","objectHas","shared","sharedKey","hiddenKeys","OBJECT_ALREADY_INITIALIZED","WeakMap","state","wmget","wmhas","wmset","metadata","facade","STATE","enforce","getterFor","TYPE","type","replacement","feature","detection","data","normalize","POLYFILL","NATIVE","string","replace","toLowerCase","USE_SYMBOL_AS_UID","$Symbol","V8_VERSION","getOwnPropertySymbols","symbol","Symbol","IE8_DOM_DEFINE","anObject","toPropertyKey","$defineProperty","Attributes","propertyIsEnumerableModule","$getOwnPropertyDescriptor","internalObjectKeys","concat","getOwnPropertyNames","names","enumBugKeys","$propertyIsEnumerable","NASHORN_BUG","input","pref","val","valueOf","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","InternalStateModule","CONFIGURABLE_FUNCTION_NAME","getInternalState","enforceInternalState","TEMPLATE","unsafe","simple","join","uid","SHARED","IS_PURE","mode","copyright","toInteger","max","min","integer","IndexedObject","requireObjectCoercible","ceil","isNaN","isSymbol","getMethod","ordinaryToPrimitive","TO_PRIMITIVE","exoticToPrim","toPrimitive","id","postfix","random","NATIVE_SYMBOL","iterator","WellKnownSymbolsStore","createWellKnownSymbol","withoutSetter","$","internalSort","arrayMethodIsStrict","FF","IE_OR_EDGE","V8","WEBKIT","nativeSort","sort","FAILS_ON_UNDEFINED","FAILS_ON_NULL","STRICT_METHOD","STABLE_SORT","code","chr","fromCharCode","k","v","charAt","proto","itemsLength","items","arrayLength","x","y","getSortCompare","nativeKeys","___CSS_LOADER_EXPORT___","_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default","_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default","sources","mappings","sourcesContent","sourceRoot","__WEBPACK_DEFAULT_EXPORT__","cssWithMappingToString","list","map","item","content","needLayer","modules","media","dedupe","supports","layer","alreadyImportedModules","_i","_i2","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","sourceMapping","sourceURLs","$6b1f265fecc08040$var$__webpack_module_cache__","$6b1f265fecc08040$var$__webpack_require__","moduleId","cachedModule","$6b1f265fecc08040$var$__webpack_modules__","n","getter","__esModule","d","definition","o","e","obj","prop","r","toStringTag","Experiments1","Legacy1","Legacy","LogLevel1","LogLevel","polyfill","audioContext","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setInterval","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","AudioContext","webkitAudioContext","replaceMe","decodeAudioData","arrayBuffer","Promise","resolve","reject","mozAudioContext","msAudioContext","oAudioContext","devicePixelRatio","Flags","static","_FROZEN","_FLAGS","enable","WebGL","Canvas","LegacyDrawing","flagName","Error","flagName1","flagName2","createId","Logger","constructor","_appenders","defaultLevel","Info","_INSTANCE","addAppender","ConsoleAppender","appender","level","args8","len","log","args1","_log","Debug","args2","args3","Warn","args4","args5","Fatal","args6","console","warn","consoleArgs","unshift","level1","ScreenAppender","width6","height6","_messages","_canvas","width","innerWidth","height","innerHeight","style","position","_ctx","getContext","body","appendChild","level2","args7","message","clearRect","pos","opacity","fillStyle","toFixed","fillText","seed","_lowerMask","_upperMask","_w","_n","_m","_a","_u","_s","_b","_t","_c","_l","_f","_mt","Array","Date","now","s","_twist","mag01","BITMASK32","_index","nextInt","floating","min3","max3","next","min1","max1","likelihood","pickOne","array5","pickSet","array1","numPicks","allowDuplicates","_pickSetWithDuplicates","_pickSetWithoutDuplicates","array2","numPicks1","currentPick","tempArray","splice","array3","numPicks2","shuffle","array4","swap","randomIndex","range","length1","min2","max2","d6","d8","d10","d20","Side1","Side","getOpposite","side","Top","Bottom","Left","Right","None","fromDirection","direction","directions","Vector","Up","Down","directionEnum","Number","MAX_VALUE","maxIndex","dot","PI","extend","extended","deep","assignExists","assign","base64Encode","inputStr","b64","outputStr","byte2","charCodeAt","byte3","enc1","byte1","enc2","enc3","enc4","nullish","nullishVal","defaultVal","clamp","randomInRange","Random","randomIntInRange","round","canonicalizeAngle","angle","tmpAngle","TwoPI","radians","oTop","parent","offsetLeft","offsetParent","calcOffsetLeft","offsetTop","calcOffsetTop","oLeft","removeItemFromArray","contains","getOppositeSide","getSideFromDirection","initialSize","Collection","DefaultSize","_internalArray","_endPointer","_resize","newSize","newArray","count","element2","pop","elementAt","index9","insert","index1","value3","remove","index2","removed","removeElement","element1","forEach","func1","fail","from","to","_x","delay","milliseconds","setTimeout","obsoleteMessage","suppressObsoleteMessages","isEnabled","maxMessages","getInstance","trace","showStackTrace","obsolete","alternateMethod","showStackTrack","property","SyntaxError","DecoratedClass","args","logMessage","super","x2","y2","_y","Zero","One","Half","cos","sin","vec1","Infinity","vec2","sqrt","pow","val3","val1","x1","y1","vector1","tolerance","abs","v1","distance","scale","newLength","vec3","add","sizeOrScale","v2","v3","v4","setTo","v5","size3","v6","v7","num","vec4","perpendicular","normal","atan2","rotate","angle1","anchor4","cosAngle","sinAngle","clone","fixed","vec","decorators","desc","Reflect","decorate","MatrixLocations1","MatrixLocations","Color_decorate","r3","g3","b3","a5","r1","g1","b1","a1","Color","parseInt","parseFloat","hex1","h","s2","l","a2","HSLColor","toRGBA","temp","fromRGBA","factor4","darken","factor1","saturate","factor2","factor3","color16","newR","newG","newB","newA","color1","multiply","color2","invert","color21","color3","color4","format","toHSLA","toHex","_componentToHex","c1","hex","Black","fromHex","White","Gray","LightGray","DarkGray","Yellow","Orange","Red","Vermilion","Vermillion","Rose","Magenta","Violet","Blue","Azure","Cyan","Viridian","Green","Chartreuse","Transparent","ExcaliburBlue","h1","s1","l1","a3","p1","q","t1","r2","g2","b2","a4","p","hue2rgb","leftOrOptions","top","right2","bottom","intersection","points2","minX","minY","maxX","maxY","BoundingBox","width1","height1","anchor1","pos19","hasZeroDimensions","center","translate","pos1","angle2","point1","points","getPoints","fromPoints","scale3","point2","shifted","matrix3","multv","results","ray","farClipDistance","tmin","tmax","xinv","dir","yinv","tx1","tx2","ty1","ty2","ray1","farClipDistance1","val2","other13","other1","totalBoundingBox","combine","dimensions","equals","overlapX","overlapY","intersectWithSide","bb","getSideFromIntersection","intersect","debugDraw","ctx8","color5","strokeRect","ex","color6","debug","drawRect","color","sign","Float32Array","_scaleSignX","mat","Matrix","right1","left1","top1","bottom1","far","near","x9","y12","identity","sx","sy","angleRadians","other2","dest","a11","a21","a31","a41","a12","a32","a42","a13","a23","a33","a43","a14","a24","a34","a44","b11","other3","b31","b41","b12","b22","b32","b42","b13","b23","b33","b43","b14","b24","b34","b44","b21","a22","getScale","_scaleSignY","y3","x3","x4","y4","angle3","sine","cosine","y5","x5","angle4","currentScale","getScaleY","getScaleX","xscale","size","yscale","val4","scale1","setScaleX","setScaleY","inverseDet","getBasisDeterminant","m","tx","ty","_transforms","_currentTransform","x6","y6","angle5","y7","x7","matrix1","_states","_currentState","_getDefaultState","_cloneState","_gl","_vertexSource","_fragmentSource","program","uniforms","attributes","layout","compile","gl","vertexShader","fragmentShader","createProgram","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","gl1","source2","type1","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","gl2","_compileShader","VERTEX_SHADER","FRAGMENT_SHADER","_createProgram","data8","location","getUniformLocation","name1","data1","name2","size1","glType","normalized","getAttribLocation","vertexSize","vert","totalVertexSizeBytes","typeSize","FLOAT","name3","useProgram","offset","vertexAttribPointer","enableVertexAttribArray","getAttributeSize","uniform","uniformMatrix4fv","uniform1iv","BatchCommand","max10","_pool","commands","isFull","cmd","GraphicsDiagnostics","DrawCallCount","DrawnImagesCount","builder","recycler","maxObjects","totalAllocations","objects","_logger","context5","done","context1","args9","poolIndex","options6","_maxCommandsPerBatch","_batches","command","_verticesPerCommand","verticesPerCommand","maxCommandsPerBatch","batchFactory","Pool","dispose","_batchPool","buildShader","_vertices","vertexAttributeSize","_buffer","createBuffer","ARRAY_BUFFER","DYNAMIC_DRAW","cmd1","lastBatch","canAdd","newBatch","use","drawCallCount","drawnImagesCount","batch","vertexCount","buildBatchVertices","bufferSubData","renderBatch","start","end","BatchRenderer","gl3","_contextInfo","DrawLine","init","gl4","Shader","addAttribute","addUniformMatrix","matrix","start6","end8","color7","transform","current","addCommand","vertexBuffer","gl5","_batch","drawArrays","LINES","DrawCommandType","DrawCommandType1","image6","sx1","sy1","swidth","sheight","dx","dy","dwidth","dheight","snapToPixel","Image","view","_geom","image","image1","swidth1","sheight1","sx2","sy2","dx1","dy1","dwidth1","dheight1","point","color8","start1","width2","height2","Rectangle","start2","end1","thickness3","Line","color9","sub","halfThick","startTop","startBottom","endTop","endBottom","pos2","radius3","color10","Circle","topLeft","topRight","bottomRight","bottomLeft","opacity1","geometry","isPowerOfTwo","nextHighestPowerOfTwo","TextureLoader","context2","_GL","image2","image3","_TEXTURE_MAP","image4","forceUpdate","tex","bindTexture","TEXTURE_2D","toPowerOfTwoImage","texImage2D","RGBA","UNSIGNED_BYTE","createTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","image5","potCanvas","_POT_CANVAS","potCtx","_POT_CTX","ensurePowerOfTwo","imageSmoothingEnabled","drawImage","Map","BatchImage","maxTextures","maxDraws","textures","_graphicMap","_isCommandFull","_wouldAddTexture","command1","_isTextureFull","command2","texture","load","gl6","activeTexture","TEXTURE0","command3","gl7","_contextInfo1","DrawImageCommand","getParameter","MAX_TEXTURE_IMAGE_UNITS","registerContext","gl8","maxGPUTextures","_transformFragmentSource","addUniformIntegerArray","_","source1","maxTextures1","newSource","texturePickerBuilder","addCircle","pos3","radius1","color12","initCircle","applyTransform","color13","pos4","width4","height4","initRect","color14","start3","end2","thickness1","initLine","graphic1","sx3","sy3","swidth2","sheight2","dx2","dy2","dwidth2","dheight2","gl9","batch1","vertexCount1","bindTextures","TRIANGLES","vertexBuffer1","batch2","vertIndex","sh","potHeight","textureId","commandColor","potWidth","getBatchTextureId","uvx0","uvy0","uvy1","uvx1","PointRenderer","gl10","DrawPoint","_contextInfo2","gl11","getExtension","point3","color15","size2","vertexBuffer2","batch3","gl12","_batch1","vertexCount2","POINTS","options1","_d","_e","Graphic","_ID","flipHorizontal","flipVertical","rotation","origin","_width","_height","value1","value2","fromDimension","y9","_preDraw","ex1","x12","_drawImage","_postDraw","ex2","x10","y10","_rotate","_flip","ex3","scaleDirY","scaleDirX","ex4","ex5","showDebug","restore","watch","change","__isProxy","Proxy","watchAny","options2","_g","_dirty","_color","flagDirty","_lineWidth","_lineDash","_padding","strokeColor","smoothing","lineWidth","lineDash","padding","_bitmap","bitmapWidth","bitmapHeight","maybeCtx","cloneRasterOptions","dirty","_getTotalWidth","value14","_originalWidth","value5","_smoothing","value6","equal","_strokeColor","value7","value8","value9","value10","_getTotalHeight","save","_applyRasterProperites","ctx1","_options","cloneGraphicOptions","ctx2","draw","cache","EventTypes","EventTypes1","_bubbles","bubbles","value11","stopPropagation","KillEvent","GameEvent","target27","PreKillEvent","target1","target2","GameStartEvent","target3","target4","ctx3","delta14","target5","ctx","delta","PostDrawEvent","ctx4","delta1","target6","ctx5","target7","ctx6","target8","engine","delta2","target9","engine1","delta3","target10","engine2","prevStats","engine3","stats","GamepadConnectEvent","index3","gamepad","index4","gamepad1","button3","value12","target11","axis","value13","target12","topic","handler","topic1","handler1","VisibleEvent","target13","target14","actor19","other4","side4","intersection1","other","target17","other8","side2","intersection3","contact1","contact","CollisionPostSolveEvent","target18","other9","side3","intersection4","contact2","CollisionStartEvent","actor3","other10","contact3","actor4","actor5","other11","actor","actor6","InitializeEvent","oldScene","target20","newScene","target21","target22","target23","EnterTriggerEvent","target24","actor7","target25","actor8","EventDispatcher","target26","_handlers","_wiredEventDispatchers","_target","eventName20","event1","emit","handler2","eventName1","SubscribeEvent","off","eventName2","handler3","eventHandlers","UnsubscribeEvent","eventName3","handler4","on","event","ev","eventDispatcher","eventDispatcher1","responseType","bustCache","logger","events","isLoaded","_cacheBust","uri","request","XMLHttpRequest","open","addEventListener","status","response","statusText","imageData","pixel","firstPixel","avg","SpriteEffects_decorate","Opacity","updatePixel","factor","fromRGB","lighten","desaturate","thisArg","_arguments","generator","fulfilled","step","rejected","then","Texture","path1","bustCache1","_sprite","loaded","_loadedResolve","_resource","Resource","Sprite_Sprite","__awaiter","url","blob","URL","createObjectURL","src","decode","naturalWidth","naturalHeight","Configurable","base","props","filter","imageOrConfig1","x15","y15","width5","height5","anchor","drawAroundAnchor","effects","_spriteCanvas","_spriteCtx","_pixelData","_pixelsLoaded","_dirtyEffect","_opacity","_initPixelsFromTexture","drawWidth","drawHeight","Sprite_awaiter","_loadPixels","_flushTexture","value15","grayscale","addEffect","Grayscale","Invert","fill","color24","Fill","Colorize","color17","Lighten","Darken","factor5","factor6","Saturate","factor7","Desaturate","effect","_applyEffects","param","indexToRemove","getImageData","putImageData","ctx7","x13","y13","xpoint","ypoint","strokeStyle","ctxOrOptions2","x14","y14","CanvasRenderingContext2D","_drawWithOptions","options3","_h","_j","anchorX","anchorY","oldAlpha","globalAlpha","SpriteImpl","imageOrConfig","Sprite_decorate","options4","sourceView","destSize","_updateSpriteDimensions","ready","image7","Sprite","nativeWidth","nativeHeight","ex7","x19","y19","ex8","x16","y16","sprite2","ImageSource","fromLegacyTexture","sprite1","path2","bustCache2","endsWith","ImageSource_awaiter","engineOrConfig1","sprites","speed1","loop1","loop","freezeFrame","Engine","config","speed","_engine","value17","color18","colorize","color19","factor8","factor9","factor10","factor11","effect1","param1","removeEffect","clearEffects","_setAnchor","point4","scale2","currentFrame","isDone","idempotencyToken","_idempotencyToken","_timeLeftInFrame","elapsed3","_updateValues","skip","frames","x17","y17","ctxOrOptions1","options5","currSprite","animOptions","x18","y18","AnimationImpl","images","FontUnit1","BaseAlign1","FontStyle1","FontStyle","Direction1","Direction","Animation_decorate","FontUnit","TextAlign1","BaseAlign","imageOrConfigOrSprites","columns1","rows1","spWidth1","spHeight1","spacing1","_sprites","_image","_columns","_rows","_spWidth","_spHeight","_spacing","loadFromImage","columns","rows","spWidth","spHeight","spacing","isWidthError","isHeightError","RangeError","getSpacingDimensions","margin","engine5","indices","Animation_Animation","engine6","beginIndex","endIndex","speed2","engine7","speed3","index5","engine8","spriteCoordinates","speed4","maxWidth","maxHeight","coord","anim","alphabet","caseInsensitive","_currentColor","_currentOpacity","_spriteRecord","_textShadowOn","_textShadowDirty","_textShadowColor","_textShadowSprites","_shadowOffsetX","_shadowOffsetY","getTextSprites","char","lookup","setTextShadow","offsetX","offsetY","shadowColor","character","text","_parseOptions","characterShadow","sprite","fontSize","letterSpacing","currX","textAlign","Start","End","Center","currY","baseAlign","Hanging","Ideographic","Alphabetic","Middle","charSprite","options7","options33","x26","y26","spriteIndex","legacySpriteSheet","oldSprite","fromLegacySprite","SpriteSheet","spriteSheet","toLegacySprite","SpriteSheet_SpriteSheet","options8","grid","cols","spriteWidth","spriteHeight","originOffset","offsetDefaults","marginDefaults","options9","_text","shadow","_updateDimensions","spriteFont","SpriteFont_SpriteFont","_getCharacterSprites","toLocaleLowerCase","letterIndex","textToRender","letter","letterSprite","text1","ex9","x20","y20","ex10","x21","y21","cursor","render","ex11","text2","x22","y22","DebugText","fontSheet","_imageSource","_spriteSheet","fromImageSource","_spriteFont","ctx9","text3","pos5","ExcaliburGraphicsContextWebGLDebug","_webglCtx","_debugText","x23","y23","width8","height8","rectOptions","drawLine","start4","end3","lineOptions","__lineRenderer","addLine","drawPoint","point5","pointOptions","__pointRenderer","addPoint","text4","pos6","write","_transform","TransformStack","_state","StateStack","backgroundColor","canvasElement","enableTransparency","options10","__gl","antialias","premultipliedAlpha","depth","value16","canvas","checkIfResolutionSupported","dim","maxDim","MAX_TEXTURE_SIZE","supported","_init","_ortho","ortho","viewport","clearColor","clear","COLOR_BUFFER_BIT","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","LineRenderer","__imageRenderer","ImageRenderer","image10","sx4","sy4","swidth3","sheight3","dx3","dy3","dwidth3","dheight3","addImage","start5","end4","color20","thickness2","pos7","width7","height7","color22","addRectangle","pos8","radius2","color23","x24","y24","angle6","x25","y25","matrix2","DisplayMode1","DisplayMode","Resolution","SVGA","Standard","Atari2600","GameBoy","GameBoyAdvance","NintendoDS","NES","SNES","options11","_antialiasing","_resolutionStack","_viewportStack","_pixelRatioOverride","_isDisposed","_fullscreenChangeHandler","_isFullScreen","_pixelRatioChangeHandler","_devicePixelRatio","_calculateDevicePixelRatio","applyResolutionAndViewport","_resizeHandler","_setResolutionAndViewportByDisplayMode","_alreadyWarned","resolution","displayMode","Fixed","context","antialiasing","_browser","browser","_position","pixelRatio","_applyDisplayMode","_mediaQueryList","nativeComponent","matchMedia","_resizeObserver","disconnect","removeEventListener","isHiDpi","_displayMode","FillContainer","FitContainer","parentElement","_resolution","_viewport","scaledHeight","camera","_camera","scaledWidth","ExcaliburGraphicsContextWebGL","imageRendering","updateViewport","resetTransform","isSmooth","isFullScreen","requestFullscreen","exitFullscreen","point6","getPosition","aspectRatio","screenHeight","newY","newX","screenWidth","point7","screenMarginY","screenMarginX","point8","halfDrawWidth","halfDrawHeight","worldToScreenCoordinates","point9","screenX","screenY","point10","pageToScreenCoordinates","screenToWorldCoordinates","screen","point11","screenToPageCoordinates","getWorldBounds","halfCanvasWidth","canvasHeight","halfCanvasHeight","zoom","overflow","adjustedHeight","aspect","adjustedWidth","clientWidth","clientHeight","Position","_initializeDisplayModePosition","Window","ResizeObserver","observe","FillScreen","FitScreen","_computeFit","_computeFitContainer","position1","display","marginTop","specifiedPosition","marginLeft","AudioContextFactory","WebAudio","_UNLOCKED","create","unlockTimeoutTimer","resume","buffer","createBufferSource","ended","connect","destination","onended","isLegacyWebAudioSource","playbackState","PLAYING_STATE","FINISHED_STATE","clearTimeout","handler5","eventName4","eventName5","handler6","eventName6","eventObject","once","eventName7","handler7","line","thickness","cap","beginPath","lineCap","point12","vector","moveTo","lineTo","stroke","radius","br","defaultRadius","tl","tr","bl","quadraticCurveTo","closePath","circle1","arc","Class","loadables","_resourceList","_playButtonShown","_resourceCount","_progressCounts","_totalCounts","logo","logoWidth","logoHeight","loadingBarColor","suppressPlayButton","_playButtonStyles","Loader_0","Z","playButtonText","startButtonFactory","buttonElement","getElementById","textContent","addResources","_imageElement","playButtonRootElement","_playButtonRootElement","playButtonElement","_playButtonElement","_playButton","existingRoot","_styleBlock","head","engine9","addResource","loadable","loadables1","_numLoaded","_a1","hidePlayButton","resizeHandler","_positionPlayButton","evt","click","startButtonHandler","removeChild","update","_delta","Loader_awaiter","all","finally","showPlayButton","unlock","progress","buttonWidth","buttonHeight","playButtonPosition","ctx21","canvasWidth","fillRect","logoY","logoX","logoPosition","imageHeight","oldAntialias","getAntialiasing","setAntialiasing","loadingX","loadingBarPosition","loadingY","progressWidth","webaudio","gamepadapi","_features","failedTests","_criticalTests","canvasSupport","elem","arrayBufferSupport","xhr","dataUrlSupport","toDataURL","objectUrlSupport","rgbaSupport","cssText","_warningTest","webAudioSupport","webglSupport","_loadBrowserFeatures","msg","getBrowserFeatures","REPORTED_FEATURES","dataurl","objecturl","rgba","navigator","getGamepads","failedCritical","warning","CollisionType","CollisionType1","BroadphaseStrategy","CollisionResolutionStrategy1","BroadphaseStrategy1","Integrator1","Integrator","Physics","gravity","acc","v9","collisionResolutionStrategy","Arcade","Realistic","dynamicTreeVelocityMultiplyer","dynamicTreeVelocityMultiplier","value51","DynamicAABBTree","Euler","slop","steeringFactor","warmStart","surfaceEpsilon","sleepEpsilon","wakeThreshold","options12","_getX","getX","_setX","setX","_setY","setY","val5","_getY","val6","owner","newComponent","Component","type9","value18","CoordPlane","CoordPlane1","X","Y","getY","createPosView","_rotation","_scale","VectorView","createScaleView","coordPlane","World","getRotation","getGlobalMatrix","multm","globalPos","globalScale","z","TransformComponent","_recalculate","val7","setPosition","getAffineInverse","val8","parentTransform","val9","setRotation","globalRotation","val10","val11","setScale","globalScaleX","globalScaleY","val12","point19","point13","MotionComponent","vel","scaleFactor","angularVelocity","torque","inertia","name4","category","mask","_name","_category","_mask","other12","CollisionGroup","collisionGroups","combinedName","combinedCategory","reduce","collisionGroups1","All","observers","subscriptions","observer","func2","observer1","func3","notify","cb","colliderA","colliderB","Pair","calculatePairHash","bodyA","colliderA1","BodyComponent","bodyB","colliderB1","group","canCollide","collisionType","PreventCollision","active","collide","collider8","idA","idB","min4","max4","projection","projection1","overlaps","parent1","bounds","worldBounds","root","nodes","_insert","leaf","leafAABB","currentRoot","isLeaf","area","getPerimeter","combinedArea","cost","inheritanceCost","leftCost","leftCombined","newArea","oldArea","rightCost","rightCombined","oldParent","newParent","TreeNode","currentNode","_balance","leaf1","grandParent","sibling","collider1","node","collider2","untrackCollider","_remove","boundsPadding","multdx","multdy","collider3","node1","balance","query","collider4","helper","rayCastQuery","ray2","max5","callback1","rayCast","ex12","pos9","dir1","line1","numerator","begin","cross","getSlope","divisor","t","u","getLength","line2","time","getPoint","time1","DynamicTreeCollisionProcessor","_dynamicCollisionTree","DynamicTree","_collisions","Set","_colliders","target29","CompositeCollider","colliders","getColliders","trackCollider","target28","colliderA2","colliderB2","hash","localBounds","targets","delta4","stats1","seconds","potentialColliders","collider","_collisionPairCache","_shouldGenerateCollisionPair","pair","physics","pairs","checkForFastBodies","collider5","Active","updateDistance","minDimension","disableMinimumSpeedForFastBody","fastBodies","updateVec","oldPos","centerPoint","furthestPoint","getFurthestPoint","Ray","minCollider","minTranslate","hitPoint","isValid","shift","fastBodyCollisions","stats2","contacts","newContacts","collisions","targets1","updated","updateCollider","ex13","Collider","other16","_collisionProcessor","_dynamicAABBTree","addCollider","collider6","wire","track","unwire","collider7","untrack","worldPos","axes","direction8","furthestPoints","maxDistance","bestPoint","mass","totalInertia","getInertia","other14","otherColliders","potentialCollider","getClosestLineBetween","other15","lines","maybeLine","minLength","minLine","point14","ray3","max6","minPoint","minDistance","axis1","projs","proj","project","newProjection","Projection","transform1","ctx10","pos10","ex14","color25","ctx11","color26","end5","slope","midpoint","point15","sideVector","clipTime","distanceToPoint","point16","signed","x0","y0","point17","aMinusP","x27","y45","intercept","currPoint","threshold","dxc","dyc","ClosestLine","p0","q0","w0","denom","sDenom","tClosestParallel","sClosest","tClosest","tDenom","rayTowardsOther","polygonA","otherDirection","rayTowardsThis","otherWorldPos","thisDirection","thisPoint","otherPoint","polygonB","getClosestFace","otherFace","thisFace","face","getEdge","PolygonEdgeClosestLine","polygon","edge","edgeLine","asLine","PolygonCircleClosestLine","circle","circlex","circley","CircleCircleClosestLine","circleA","circleB","CircleEdgeClosestLine","circleWorlPos","edgeA","edgeB","edgeLineA","edgeLineB","options13","CircleCollider","point18","ray4","max7","orig","discriminant","toi","toi1","toi2","positiveToi","mintoi","shape","ClosestLineJumpTable","PolygonCollider","flip","EdgeCollider","CollisionJumpTable","CollideCircleCircle","CollideCirclePolygon","CollideCircleEdge","direction1","direction2","bodyPos","mass1","transform2","axis2","scalars","dotProduct","ctx12","color27","pos11","newPos","ex15","color28","drawCircle","ctx13","color29","colliderA3","colliderB3","mtv","normal1","tangent1","points1","localPoints1","info1","sleeping","sleepMotion","setSleeping","_canceled","SeparatingAxis","polyA1","polyB1","bestSeparation","bestSide","bestAxis","bestSideIndex","bestOtherPoint","sides","getSides","localSides","getLocalSides","vertB","negate","vertSeparation","separation","localSide","sideId","getFurthestLocalPoint","circle2","polygon1","polyDir","proj1","getOverlap","proj2","overlap","minOverlap","circleAPos","circleBPos","combinedRadius","tangent","mvt","local","CollisionContact","minAxis","findCirclePolygonSeparation","samedir","applyInverse","info","localPoint","findSide","findLocalSide","cc","edgeWorld","asLocalLine","da","dda","db","ddb","den","pointOnEdge","dd","pc","linePoly","CollidePolygonPolygon","polyA","polyB","separationA","findPolygonPolygonSeparation","separationB","incident","reference","refDir","clipRight","clip","clipLeft","below","localPoints","xf","shapeA","txA","shapeB","txB","worldPoint","circlePoint","dist","options14","average","_getBodyPos","_getTransformedBegin","_getTransformedEnd","ray5","max8","shape1","EdgeEdgeClosestLine","shape2","CollidePolygonEdge","CollideEdgeEdge","direction3","transformedBegin","transformedEnd","begin1","end6","_boundsFromBeginEnd","edgeNormal","mass2","transform3","axis3","ctx14","color30","pos12","ex16","color31","ctx15","color32","options15","_transformedPoints","_axes","_sides","_localSides","winding","clockwiseWinding","reverse","_calculateTransformation","getTransformedPoints","currentSide","mostDirection","direction4","direction5","transform4","point21","testRay","accum","collider9","PolygonPolygonClosestLine","collider10","pts","direction6","direction7","point20","POSITIVE_INFINITY","faceIndex","mass3","denominator","iplusone","crossTerm","ray6","max9","contactIndex","contactTime","minContactTime","axis4","scalar","ctx16","color33","pos13","effectiveOffset","firstPoint","ex17","color34","ctx17","color35","Shape","width16","anchor2","offset4","points4","offset1","offset2","begin2","end7","width9","height9","offset3","Box","collider11","$colliderAdded","Observable","$colliderRemoved","_collider","collider12","notifyAll","flipped","entity","precollision","PreCollisionEvent","postcollision","PostCollisionEvent","CollisionEndEvent","useBoxCollider","width10","height10","anchor3","center3","usePolygonCollider","points3","center1","poly","Polygon","radius4","center2","begin3","end9","Edge","colliders1","DegreeOfFreedom1","options16","dependencies","defaultMass","canSleep","bodiesCanSleepByDefault","_sleeping","bounciness","friction","useGravity","limitDegreeOfFreedom","oldVel","oldAcc","oldRotation","inverseMass","currentMotion","bias","sleepBias","ColliderComponent","inverseInertia","motion","val13","val14","val15","val16","val17","val18","xFactor","yFactor","rx","value19","value20","point29","impulse","finalImpulse","addEqual","Rotation","distanceFromCenter","impulse1","point22","impulse2","oldScale","_bottomRight","actor9","engine10","drawingWidth","currentDrawing","drawingHeight","getGlobalPos","_topLeft","_topRight","_bottomLeft","topLeftScreen","topRightScreen","bottomLeftScreen","_xCoords","_yCoords","bottomRightScreen","_xMin","_yMin","_xMax","minWorld","maxWorld","_yMax","_xMinWorld","_xMaxWorld","_yMaxWorld","boundingPoints","ctx18","rect","_yMinWorld","CullingBox","engine11","actor10","isSpriteOffScreen","cullingBox","currentScene","actorBoundsOffscreen","isOffScreen","EnterViewPortEvent","removeComponent","ExitViewPortEvent","addComponent","TagComponent","engine12","actor11","enableCapturePointer","isKilled","pointers","checkAndUpdateActorUnderPointer","AddedComponent","data2","isAddedComponent","data3","isRemovedComponent","components","name5","Entity","_componentsToRemove","_componentTypeToInstance","_componentStringToInstance","_tagsMemo","_typesMemo","component","name6","kill","tags","tag1","tag2","force","types","_rebuildMemos","values","added","componentAdded$","_notifyRemoveComponent","component1","RemovedComponent","componentRemoved$","_parent","children","_children","entity1","getAncestors","childrenAdded$","entity2","childrenRemoved$","queue","curr","newEntity","child","addChild","templateEntity","force1","getComponents","addTemplate","component2","force2","ctor","constuctorType","onAdd","_notifyAddComponent","componentOrType","force3","_removeComponentByType","type2","delete","type3","type4","isInitialized","_isInitialized","engine13","onInitialize","engine14","delta5","onPreUpdate","_postupdate","engine15","delta6","PostUpdateEvent","onPostUpdate","_engine1","_engine2","_delta1","_engine3","_delta2","engine16","delta7","_initialize","_preupdate","hasGraphicsTick","graphic","tick","_options1","_graphics","graphics","nameOrGraphic","gfx","getGraphic","nameOrGraphic1","options17","copyGraphics","getNames","options18","hide","show","nameOrGraphic2","order","value21","currentKeys","_component","_layers","_layerMap","GraphicsLayer","_maybeAddLayer","default","options19","name7","_getLayer","graphicsLayerKeys","name9","options20","visible","_bounds","onPreDraw","onPostDraw","layers","GraphicsLayers","name10","graphicToSet","nameOrGraphic3","nameOrGraphic4","options21","options22","nameOrGraphic5","nameOrGraphic6","bounds1","elapsed1","idempotencyToken1","Raster","options23","rasterize","execute","ctx19","_radius","options24","value22","ctx20","RotationType1","easing","duration","easing1","EasingFunctions","CreateReversibleEasingFunction","easing2","Linear","currentTime","startValue","endValue","EaseInQuad","EaseOutQuad","EaseInCubic","EaseOutCubic","entity3","_actions","_completedActions","_entity","action","action1","_currentAction","stop","hasNext","isComplete","getActions","reset","elapsedMs","Repeat","entity4","repeatBuilder","repeat","_stopped","_repeatContext","ActionContext","_actionQueue","getQueue","_repeat","_originalRepeat","_repeatBuilder","clearActions","delta8","entity5","repeatBuilder1","delta9","MoveBy","entity6","speed5","_started","_tx","_motion","_speed","_offset","_delta3","_start","_end","_distance","_dir","entity7","entity8","destx","desty","speed6","_delta4","entity9","RotationType","entity10","angleRadians1","speed7","rotationType","ShortestPath","_currentNonCannonAngle","distance1","distance2","_shortDistance","_longDistance","_shortestPathIsPositive","_rotationType","_direction","LongestPath","Clockwise","CounterClockwise","_delta5","distanceTravelled","entity11","angleRadiansOffset","speed8","rotationType1","_delta6","entity12","scaleX","scaleY","speedX","speedY","_speedY","_delta7","_startX","_startY","_distanceX","_endX","_distanceY","_endY","directionX","_speedX","directionY","entity13","scaleOffsetX","scaleOffsetY","speed9","_startScale","_endScale","_directionX","_directionY","_hasBeenCalled","entity14","x28","y27","easingFcn","_lerpStart","_lerpEnd","_initialized","delta10","_lerpDuration","_currentLerpTime","actor12","entity15","timeVisible","timeNotVisible","numBlinks","_timeVisible","_timeNotVisible","_elapsedTime","_totalTime","GraphicsComponent","delta11","_duration","entity16","endOpacity","speed10","_multiplier","_endOpacity","delta12","delay1","_delay","delta13","Die","entity17","_delta10","ActionsComponent","entity18","entityToFollow","followDistance","_followTx","_followMotion","_current","_maximumDistance","_delta11","_distanceBetween","actorToFollowSpeed","actor13","actorToMeet","speed11","_speedWasSpecified","_meetTx","_meetMotion","_delta12","actorToMeetSpeed","entity19","_queue","ActionQueue","elapsedMs1","EaseTo","yOrSpeed","speedOrUndefined","xOrPos","MoveTo","xOffsetOrVector","yOffsetOrSpeed","speedOrUndefined1","xOffset","yOffset","angleRadians2","speed12","rotationType2","RotateTo","angleRadiansOffset1","speed13","rotationType3","RotateBy","sizeXOrVector","sizeYOrSpeed","speedXOrUndefined","speedYOrUndefined","sizeX","sizeY","ScaleTo","scaleBy","sizeOffsetXOrVector","sizeOffsetYOrSpeed","speed14","sizeOffsetX","sizeOffsetY","ScaleBy","blink","timeVisible1","timeNotVisible1","numBlinks1","Blink","opacity8","Fade","time2","Delay","method1","CallMethod","repeatBuilder2","times","repeatForever","repeatBuilder3","RepeatForever","follow","entity20","followDistance1","Follow","entity21","speed15","Meet","toPromise","entity22","onRemove","elapsedMs2","args10","easeTo","xOrPos1","yOrSpeed1","speedOrUndefined2","xOffsetOrVector1","yOffsetOrSpeed1","speedOrUndefined3","moveBy","angleRadians3","speed16","rotationType4","rotateTo","angleRadiansOffset2","speed17","rotationType5","rotateBy","sizeXOrVector1","sizeYOrSpeed1","speedXOrUndefined1","speedYOrUndefined1","scaleTo","sizeOffsetXOrVector1","sizeOffsetYOrSpeed1","speed18","timeNotVisible2","numBlinks2","timeVisible2","fade","opacity2","time3","time4","die","method2","callMethod","repeatBuilder4","times1","repeatBuilder5","entity23","followDistance2","entity24","speed19","meet","asPromise","_anchor","_handleAnchorChange","scene","_draggable","_dragging","pe","pointer","lastWorldPos","traits","captureDragEvents","_capturePointerEvents","_captureMoveEvents","_captureDragEvents","collisionGroup","_setName","Actor","defaults","CanvasDrawComponent","Passive","OffscreenCulling","CapturePointer","actions","thePos","thePos1","theVel","theVel1","theAcc","theAcc1","theAngle","vec5","hasTag","isVisible","opacity3","_pointerDragStartHandler","_pointerDragEndHandler","_pointerDragMoveHandler","_pointerDragLeaveHandler","isDraggable","v10","_engine4","engine17","eventName8","capturePointer","captureMoveEvents","eventName9","handler8","_checkForPointerOptIn","eventName10","handler9","eventName11","handler10","_scene","onPreKill","_scene2","PostKillEvent","onPostKill","_scene3","_prekill","_postkill","setDrawing","key1","addDrawing","asSprite","getZIndex","newZ","newIndex","getGlobalScale","x32","y28","recurse","geom","containment","some","actor14","otherCollider","me","engine18","delta21","drawing","currFrame","trait","_engine5","_delta13","_engine6","_delta14","engine19","delta15","PreUpdateEvent","engine20","delta16","ctx24","delta17","_predraw","_postdraw","_ctx1","_delta15","_ctx2","_delta16","ctx22","delta18","PreDrawEvent","ctx23","delta19","_ctx3","config1","Screen","engine21","x29","y29","useWorld","coords","Timer","_totalTimeAlive","_running","_numberOfTicks","interval","repeats","maxNumberOfRepeats","_complete","fcn","numberOfRepeats","_MAX_ID","_callbacks","fcn1","fcn2","delta20","complete","newNumberOfRepeats","newInterval","timesRepeated","cancel","pause","cancelTimer","Axis1","Axis","TileMap_decorate","TileMapImpl","xOrConfig","y30","cellWidth","cellHeight","rows3","_token","_onScreenXStart","_onScreenXEnd","_onScreenYStart","_onScreenYEnd","_spriteSheets","_legacySpriteMap","_cols","isOffscreen","_composite","useCompositeCollider","currentCol","cd","Cell","val19","val20","val21","val22","val23","val24","val25","eventName12","handler11","engine22","registerSpriteSheet","key2","spriteSheet1","fromLegacySpriteSheet","_updateColliders","clearColliders","tile","solid","prev","getCellByIndex","index6","getCell","x30","y31","getCellByPoint","x31","y32","cell","getRows","getColumns","_engine7","_delta17","_engine8","_delta18","engine23","delta43","worldCoordsLowerRight","worldCoordsUpperLeft","delta22","ctx28","xEnd","yEnd","graphicsIndex","graphicsLen","xOrConfig1","y33","cellWidth1","cellHeight1","rows2","cols1","xOrConfig2","y34","width11","height11","index7","_solid","val26","pushSprite","addGraphic","graphic2","removeGraphic","graphic3","clearGraphics","CellImpl","xOrConfig3","y35","width12","height12","index8","solid1","sprites1","StrategyContainer","camera1","actor15","addStrategy","LockCameraToActorStrategy","lockToActorAxis","actor16","axis5","LockCameraToActorAxisStrategy","elasticToActor","actor17","cameraElasticity","cameraFriction","ElasticToActorStrategy","actor18","radius5","RadiusAroundActorStrategy","limitCameraBounds","box","LimitCameraBoundsStrategy","target30","_cam","_eng","target31","axis6","cam","currentFocus","getFocus","target32","cameraElasticity1","cameraFriction1","focus","cameraVel","stretch","target33","radius6","target34","boundSizeChecked","focusX","focusY","Camera","_cameraStrategies","strategy","_z","az","_posChanged","_cameraMoving","_shakeMagnitudeX","_shakeMagnitudeY","_elapsedShakeTime","_xShake","_yShake","_isZooming","_zoomStart","_zoomEnd","_currentZoomTime","_zoomDuration","_zoomEasing","EaseInOutCubic","_easing","_halfWidth","_halfHeight","val27","value23","_pos","vec6","value24","_follow","value25","value26","value27","ax","value28","ay","value29","duration1","easingFn","pos14","_lerpPromise","_lerpResolve","magnitudeX","magnitudeY","duration2","_isShaking","_shakeDuration","scale4","duration3","easingFn1","_zoomPromise","_zoomResolve","cameraStrategy","cameraStrategy1","engine24","delta23","_engine9","_delta19","engine25","delta24","_engine10","_delta20","_engine11","currentRes","loadingComplete","res","peekResolution","_engine12","eventName13","handler12","eventName14","handler13","eventName15","handler14","delta25","_engine13","dz","newZoom","zoomEasing","lerpPoint","CreateVectorEasingFunction","moveEasing","_isDoneShaking","ctx25","newCanvasWidth","newCanvasHeight","_ctx4","isScreenElement","ScreenElement_ScreenElement","triggerDefaults","Trigger_Trigger","opts","_dispatchAction","ExitTriggerEvent","target35","engine26","ctx26","wp","SystemType1","_entityAddedOrRemoved","data4","isAddedSystemEntity","RemovedEntity","data5","isRemoveSystemEntity","_world","entities","_entityIndex","_entitiesToRemove","_context","elapsed2","removeEntity","findEntitiesForRemoval","message1","queryManager","addEntity","entity25","register","idOrEntity","deferred","unregister","actors","killed","processEntityRemovals","processComponentRemovals","processComponentRemoval","name11","localeCompare","Query","T","_key","buildTypeKey","sort1","_entities","entity26","matches","AddedEntity","entity27","typesOrEntity","type5","QueryManager","_world1","_queries","_addQuery","entityManager","maybeRemoveQuery","query1","entity28","queryType","entity29","component3","contain","entity30","types1","maybeExistingQuery","getQuery","types2","_world2","systems","initialized","systemType","find","addSystem","system","createQuery","priority","initialize","updateSystems","type6","context3","delta26","s5","preupdate","s3","getEntities","Scene","s4","postupdate","removeSystem","context4","EntityManager","systemManager","SystemManager","delta27","Update","updateEntities","type7","entityOrSystem","System","entityOrSystem1","deferred1","transform5","totalAcc","elapsedMs3","elapsedMs4","optionalBody","captureOldTransform","EulerIntegrator","integrate","preSolve","isCanceled","solveVelocity","solvePosition","postSolve","ArcadeSolver","CollisionSolver","contacts1","contacts2","contacts3","contacts4","opposite","velAdj","ContactConstraintPoint","point23","normalImpulse","tangentImpulse","normalMass","tangentMass","aToContact","bToContact","aToContactNormal","bToContactNormal","aToContactTangent","bToContactTangent","getRelativeVelocity","velA","lastFrameContacts","idToContactConstraint","id1","contacts5","CollisionPreSolveEvent","matchAwake","finishedContactIds","contact5","contactPoints","pointIndex","squareDistance","contact6","getContactConstraints","contacts6","updateMotion","contacts7","applyImpulse","contacts8","positionIterations","constraints","FindContactSeparation","maxCorrection","steeringForce","contacts9","velocityIterations","restitution","impulseDelta","maxFriction","newImpulse","point24","_realisticSolver","RealisticSolver","_arcadeSolver","_processor","_lastFrameContacts","_currentFrameContacts","_trackCollider","_untrackCollider","message2","colliderComponent","subscribe","elapsedMs5","enabled","_entities1","colliderComp","broadphase","narrowphase","getSolver","solve","ex18","ContactStartEvent","id2","c2","ContactEndEvent","AnimationDirection1","AnimationDirection","AnimationStrategy","EmitterType","AnimationStrategy1","options25","Loop","frameDuration","timeScale","_firstTick","_currentFrame","_done","_playing","_reversed","totalDuration","goToFrame","Animation","spriteSheet2","frameIndices","durationPerFrameMs","invalidIndices","engine27","animation2","legacySprites","Freeze","currentFrameIndex","isPlaying","Backward","Forward","frameNumber","maybeFrame","PingPong","elapsedMilliseconds","idempotencyToken2","_nextFrame","ctx27","x41","y36","_LOGGER","GraphicsGroup","options26","members","_isAnimationOrGroup","graphic4","elapsedMilliseconds1","idempotencyToken3","member","maybeAnimation","ex19","x33","y37","ex20","x34","y38","EmitterType1","ParticleImpl","emitterOrConfig","life","opacity4","beginColor","endColor","velocity","acceleration","startSize","endSize","particleRotationalVelocity","currentRotation","focusAccel","fadeFlag","_rRate","_gRate","_bRate","_aRate","emitter","particleSize","particleSprite","sizeRate","elapsedMultiplier","ParticleEmitter","tmpColor","removeParticle","_engine14","delta28","accel","ctx35","Particle","emitterOrConfig1","life1","opacity5","beginColor1","endColor1","position2","velocity1","acceleration1","startSize1","endSize1","config2","_particlesToEmit","numParticles","isEmitting","particles","deadParticles","minVel","minAngle","particleLife","minSize","maxSize","_og","emitterType","maxVel","maxAngle","emitRate","randomRotation","opacity6","val28","particle","particleCount","_createParticle","world","clearParticles","ranX","ranY","engine28","delta29","emitParticles","ctx29","ctx30","Draw","scene1","_graphicsContext","graphicsContext","a7","b5","delta30","_clearScreen","entityOffscreen","_isOffscreen","_pushCameraTransform","_applyTransform","particleOpacity","_drawGraphicsComponent","_popCameraTransform","flush","drawnImages","drawCalls","transform6","graphics1","graphicsComponent","isDebug","showBounds","boundsColor","entity31","ancestors","ancestor","scene2","b4","a6","entities1","delta31","canvasdraw","offscreen","entity32","transform9","transform10","scene3","_collisionSystem","CollisionSystem","entities2","_delta21","filterSettings","entitySettings","txSettings","motionSettings","colliderSettings","physicsSettings","graphicsSettings","bodySettings","cameraSettings","useFilter","ids","nameQuery","lineHeight","showAll","showPosition","positionColor","drawText","showId","showName","showRotation","fromAngle","rotationColor","toDegrees","showScale","scaleColor","showCollisionGroup","showAcceleration","accelerationColor","showGeometry","geometryColor","collider13","showOwner","showBroadphaseSpacePartitionDebug","showCollisionContacts","showCollisionNormals","collisionContactColor","point25","collisionNormalColor","showFocus","focusColor","showZoom","entity33","transform11","transform12","entities3","delta32","Scene_decorate","_timers","_cancelQueue","ActionsSystem","MotionSystem","CanvasDrawingSystem","GraphicsSystem","DebugSystem","tileMaps","TileMap","handler15","eventName16","eventName17","handler16","handler17","eventName18","_engine15","_newScene","_oldScene1","_newScene1","_engine16","_delta22","_engine17","_delta23","_ctx6","_delta24","_delta25","engine29","newScene1","onActivate","oldScene1","oldScene2","newScene2","delta33","_engine18","delta34","_engine19","_delta26","_ctx8","_delta27","_ctx9","delta35","engine30","removeTimer","timer","_collectActorStats","dispatchPointerEvents","delta36","ctx31","ctx32","PreDebugDrawEvent","PostDebugDrawEvent","actor24","entity34","entity35","actor20","actor21","tileMap","removeTileMap","tileMap1","timer1","timer2","timer3","isCurrentScene","engine31","screenElements","_ui","ui","alive","ColorBlindness1","ColorBlindness","engine32","simulate","colorMode","Protanope","_vertexShader","_internalCanvas","_program","_getShader","_getFragmentShaderByMode","vertextShader","colorMode1","Deuteranope","Tritanope","_fragmentShader","x35","y39","width13","height13","STATIC_DRAW","type8","compileShader","image8","out","texCoordLocation","texCoordBuffer","bindBuffer","bufferData","pixelStorei","UNPACK_FLIP_Y_WEBGL","resolutionLocation","uniform2f","positionBuffer","positionLocation","pixelData","Uint8Array","readPixels","engine33","correct","colorBlindness","postProcessors","ColorBlindCorrector","colorBlindness1","engine34","FrameStats","showVelocity","velocityColor","showSleeping","showMotion","showMass","colorBlindMode","ColorBlindFlags","remaining","total","_physicsStats","PhysicsStats","_graphicsStats","otherStats","fps","$6b1f265fecc08040$export$202e0172ed3c7be0","$6b1f265fecc08040$var$__webpack_exports__","Bhw","$5ba171b4a505aeb2$var$game","$6b1f265fecc08040$export$2c3b404bf3a77a1f","$5ba171b4a505aeb2$var$paddle","$6b1f265fecc08040$export$f73d3eb6fd876d80","$6b1f265fecc08040$export$892596cec99bc70e","$6b1f265fecc08040$export$ddb2ed749236e720","primary","$5ba171b4a505aeb2$var$ball","$5ba171b4a505aeb2$var$brickColor","$5ba171b4a505aeb2$var$brickWidth","$5ba171b4a505aeb2$var$padding","$5ba171b4a505aeb2$var$bricks","brick","alert"],"version":3,"file":"index.0c379131.js.map"}